From 89708479fa37425446be5dd3978f6165871f23c6 Mon Sep 17 00:00:00 2001
From: denglei <denglei@eswincomputing.com>
Date: Tue, 23 Jul 2024 16:10:17 +0800
Subject: [PATCH 114/223] feat:linux-6.6 add npu & dsp driver.

Changelogs:
	linux-6.6 add npu & dsp driver.

Signed-off-by: denglei <denglei@eswincomputing.com>
---
 drivers/soc/eswin/Kconfig                     |     2 +
 drivers/soc/eswin/Makefile                    |     3 +-
 drivers/soc/eswin/ai_driver/Kconfig           |    11 +
 drivers/soc/eswin/ai_driver/Makefile          |     2 +
 drivers/soc/eswin/ai_driver/dsp/Makefile      |    50 +
 .../soc/eswin/ai_driver/dsp/dsp_firmware.c    |   234 +
 .../soc/eswin/ai_driver/dsp/dsp_firmware.h    |    28 +
 drivers/soc/eswin/ai_driver/dsp/dsp_hw.h      |   186 +
 drivers/soc/eswin/ai_driver/dsp/dsp_hw_if.h   |    39 +
 drivers/soc/eswin/ai_driver/dsp/dsp_ioctl.c   |  1126 ++
 drivers/soc/eswin/ai_driver/dsp/dsp_ioctl.h   |    51 +
 .../soc/eswin/ai_driver/dsp/dsp_ioctl_if.h    |    85 +
 drivers/soc/eswin/ai_driver/dsp/dsp_log.c     |    25 +
 drivers/soc/eswin/ai_driver/dsp/dsp_log.h     |    32 +
 drivers/soc/eswin/ai_driver/dsp/dsp_mailbox.h |    44 +
 drivers/soc/eswin/ai_driver/dsp/dsp_main.c    |  1155 ++
 drivers/soc/eswin/ai_driver/dsp/dsp_main.h    |   215 +
 drivers/soc/eswin/ai_driver/dsp/dsp_perf.h    |    61 +
 .../soc/eswin/ai_driver/dsp/dsp_platform.c    |  1254 ++
 .../soc/eswin/ai_driver/dsp/dsp_platform.h    |    59 +
 .../eswin/ai_driver/dsp/dsp_platform_sim.c    |   529 +
 drivers/soc/eswin/ai_driver/dsp/dsp_proc.c    |   400 +
 drivers/soc/eswin/ai_driver/dsp/dsp_proc.h    |    13 +
 drivers/soc/eswin/ai_driver/dsp/dsp_sram.c    |    98 +
 .../ai_driver/dsp/mloader/core-const16w.inc   |   113 +
 .../ai_driver/dsp/mloader/dsp_load_operator.c |   269 +
 .../soc/eswin/ai_driver/dsp/mloader/xt_elf.h  |   342 +
 .../ai_driver/dsp/mloader/xt_mld_loader.c     |  1149 ++
 .../ai_driver/dsp/mloader/xt_mld_loader.h     |   259 +
 .../ai_driver/dsp/mloader/xt_mld_relocate.c   |   498 +
 .../soc/eswin/ai_driver/include/cdma_regs.h   |   245 +
 .../soc/eswin/ai_driver/include/conv_regs.h   |   234 +
 .../eswin/ai_driver/include/dla_interface.h   |   865 +
 .../soc/eswin/ai_driver/include/edma_regs.h   |    68 +
 .../eswin/ai_driver/include/es_dsp_internal.h |   183 +
 .../eswin/ai_driver/include/es_dsp_op_types.h |    53 +
 .../eswin/ai_driver/include/es_dsp_types.h    |   151 +
 .../eswin/ai_driver/include/es_nn_common.h    |   269 +
 drivers/soc/eswin/ai_driver/include/es_type.h |    75 +
 .../soc/eswin/ai_driver/include/hetero_arch.h |   206 +
 .../eswin/ai_driver/include/hetero_common.h   |   917 +
 .../soc/eswin/ai_driver/include/hetero_env.h  |    17 +
 .../soc/eswin/ai_driver/include/hetero_host.h |   615 +
 .../eswin/ai_driver/include/hetero_ioctl.h    |   311 +
 .../soc/eswin/ai_driver/include/hetero_ipc.h  |   506 +
 .../soc/eswin/ai_driver/include/hetero_perf.h |    98 +
 .../ai_driver/include/hetero_processor.h      |    48 +
 .../eswin/ai_driver/include/hetero_types.h    |    54 +
 .../eswin/ai_driver/include/mailbox_regs.h    |   199 +
 drivers/soc/eswin/ai_driver/include/md5.h     |    68 +
 .../eswin/ai_driver/include/npu_base_regs.h   |   382 +
 .../soc/eswin/ai_driver/include/pdp_regs.h    |   136 +
 .../soc/eswin/ai_driver/include/rubik_regs.h  |    65 +
 .../soc/eswin/ai_driver/include/sdp_regs.h    |   207 +
 .../soc/eswin/ai_driver/include/sys_regs.h    |    30 +
 drivers/soc/eswin/ai_driver/npu/Makefile      |    54 +
 drivers/soc/eswin/ai_driver/npu/common.c      |   123 +
 drivers/soc/eswin/ai_driver/npu/common.h      |    22 +
 drivers/soc/eswin/ai_driver/npu/conv.c        |   495 +
 drivers/soc/eswin/ai_driver/npu/conv.h        |    34 +
 drivers/soc/eswin/ai_driver/npu/debug.c       |  1131 ++
 drivers/soc/eswin/ai_driver/npu/debug.h       |    37 +
 drivers/soc/eswin/ai_driver/npu/dla_buffer.c  |   402 +
 drivers/soc/eswin/ai_driver/npu/dla_buffer.h  |    59 +
 drivers/soc/eswin/ai_driver/npu/dla_driver.c  |    14 +
 drivers/soc/eswin/ai_driver/npu/dla_driver.h  |    73 +
 .../eswin/ai_driver/npu/dla_engine_internal.h |   176 +
 drivers/soc/eswin/ai_driver/npu/dla_log.c     |   169 +
 drivers/soc/eswin/ai_driver/npu/dla_log.h     |    53 +
 drivers/soc/eswin/ai_driver/npu/dsp.c         |   865 +
 drivers/soc/eswin/ai_driver/npu/dsp.h         |    17 +
 drivers/soc/eswin/ai_driver/npu/edma.c        |   954 +
 drivers/soc/eswin/ai_driver/npu/edma.h        |   370 +
 drivers/soc/eswin/ai_driver/npu/engine.c      |   957 +
 drivers/soc/eswin/ai_driver/npu/event.c       |   104 +
 .../eswin/ai_driver/npu/include/dla_engine.h  |    94 +
 .../soc/eswin/ai_driver/npu/include/dla_err.h |    50 +
 .../eswin/ai_driver/npu/include/dla_sched.h   |    61 +
 .../eswin/ai_driver/npu/include/npu_top_csr.h |    51 +
 .../ai_driver/npu/include/nvdla_interface.h   |   113 +
 .../eswin/ai_driver/npu/include/nvdla_linux.h |    46 +
 .../soc/eswin/ai_driver/npu/include/opendla.h |    40 +
 .../ai_driver/npu/include/opendla_initial.h   | 15426 ++++++++++++++++
 .../eswin/ai_driver/npu/internal_interface.h  |   567 +
 drivers/soc/eswin/ai_driver/npu/npu_e31.c     |   170 +
 drivers/soc/eswin/ai_driver/npu/npu_frame.c   |   409 +
 drivers/soc/eswin/ai_driver/npu/npu_main.c    |   724 +
 drivers/soc/eswin/ai_driver/npu/npu_spram.c   |   220 +
 drivers/soc/eswin/ai_driver/npu/npu_spram.h   |    17 +
 drivers/soc/eswin/ai_driver/npu/nvdla_hw.c    |  1022 +
 .../soc/eswin/ai_driver/npu/nvdla_lowlevel.h  |    40 +
 drivers/soc/eswin/ai_driver/npu/nvdla_proc.c  |   369 +
 drivers/soc/eswin/ai_driver/npu/nvdla_proc.h  |    16 +
 drivers/soc/eswin/ai_driver/npu/nvdla_sim.c   |   590 +
 drivers/soc/eswin/ai_driver/npu/parse_dep.c   |   461 +
 drivers/soc/eswin/ai_driver/npu/pdp.c         |   583 +
 drivers/soc/eswin/ai_driver/npu/post_drp.h    |    58 +
 drivers/soc/eswin/ai_driver/npu/rubik.c       |   301 +
 drivers/soc/eswin/ai_driver/npu/scheduler.c   |   301 +
 drivers/soc/eswin/ai_driver/npu/sdp.c         |  1058 ++
 drivers/soc/eswin/ai_driver/npu/sdp.h         |    98 +
 .../soc/eswin/ai_driver/npu/user_context.c    |  1203 ++
 102 files changed, 44529 insertions(+), 2 deletions(-)
 create mode 100644 drivers/soc/eswin/ai_driver/Kconfig
 create mode 100644 drivers/soc/eswin/ai_driver/Makefile
 create mode 100755 drivers/soc/eswin/ai_driver/dsp/Makefile
 create mode 100644 drivers/soc/eswin/ai_driver/dsp/dsp_firmware.c
 create mode 100755 drivers/soc/eswin/ai_driver/dsp/dsp_firmware.h
 create mode 100644 drivers/soc/eswin/ai_driver/dsp/dsp_hw.h
 create mode 100644 drivers/soc/eswin/ai_driver/dsp/dsp_hw_if.h
 create mode 100644 drivers/soc/eswin/ai_driver/dsp/dsp_ioctl.c
 create mode 100644 drivers/soc/eswin/ai_driver/dsp/dsp_ioctl.h
 create mode 100644 drivers/soc/eswin/ai_driver/dsp/dsp_ioctl_if.h
 create mode 100644 drivers/soc/eswin/ai_driver/dsp/dsp_log.c
 create mode 100644 drivers/soc/eswin/ai_driver/dsp/dsp_log.h
 create mode 100644 drivers/soc/eswin/ai_driver/dsp/dsp_mailbox.h
 create mode 100644 drivers/soc/eswin/ai_driver/dsp/dsp_main.c
 create mode 100644 drivers/soc/eswin/ai_driver/dsp/dsp_main.h
 create mode 100644 drivers/soc/eswin/ai_driver/dsp/dsp_perf.h
 create mode 100644 drivers/soc/eswin/ai_driver/dsp/dsp_platform.c
 create mode 100644 drivers/soc/eswin/ai_driver/dsp/dsp_platform.h
 create mode 100644 drivers/soc/eswin/ai_driver/dsp/dsp_platform_sim.c
 create mode 100644 drivers/soc/eswin/ai_driver/dsp/dsp_proc.c
 create mode 100644 drivers/soc/eswin/ai_driver/dsp/dsp_proc.h
 create mode 100644 drivers/soc/eswin/ai_driver/dsp/dsp_sram.c
 create mode 100644 drivers/soc/eswin/ai_driver/dsp/mloader/core-const16w.inc
 create mode 100644 drivers/soc/eswin/ai_driver/dsp/mloader/dsp_load_operator.c
 create mode 100644 drivers/soc/eswin/ai_driver/dsp/mloader/xt_elf.h
 create mode 100644 drivers/soc/eswin/ai_driver/dsp/mloader/xt_mld_loader.c
 create mode 100644 drivers/soc/eswin/ai_driver/dsp/mloader/xt_mld_loader.h
 create mode 100644 drivers/soc/eswin/ai_driver/dsp/mloader/xt_mld_relocate.c
 create mode 100644 drivers/soc/eswin/ai_driver/include/cdma_regs.h
 create mode 100644 drivers/soc/eswin/ai_driver/include/conv_regs.h
 create mode 100644 drivers/soc/eswin/ai_driver/include/dla_interface.h
 create mode 100644 drivers/soc/eswin/ai_driver/include/edma_regs.h
 create mode 100644 drivers/soc/eswin/ai_driver/include/es_dsp_internal.h
 create mode 100644 drivers/soc/eswin/ai_driver/include/es_dsp_op_types.h
 create mode 100644 drivers/soc/eswin/ai_driver/include/es_dsp_types.h
 create mode 100644 drivers/soc/eswin/ai_driver/include/es_nn_common.h
 create mode 100644 drivers/soc/eswin/ai_driver/include/es_type.h
 create mode 100644 drivers/soc/eswin/ai_driver/include/hetero_arch.h
 create mode 100644 drivers/soc/eswin/ai_driver/include/hetero_common.h
 create mode 100644 drivers/soc/eswin/ai_driver/include/hetero_env.h
 create mode 100644 drivers/soc/eswin/ai_driver/include/hetero_host.h
 create mode 100644 drivers/soc/eswin/ai_driver/include/hetero_ioctl.h
 create mode 100644 drivers/soc/eswin/ai_driver/include/hetero_ipc.h
 create mode 100644 drivers/soc/eswin/ai_driver/include/hetero_perf.h
 create mode 100644 drivers/soc/eswin/ai_driver/include/hetero_processor.h
 create mode 100644 drivers/soc/eswin/ai_driver/include/hetero_types.h
 create mode 100644 drivers/soc/eswin/ai_driver/include/mailbox_regs.h
 create mode 100644 drivers/soc/eswin/ai_driver/include/md5.h
 create mode 100644 drivers/soc/eswin/ai_driver/include/npu_base_regs.h
 create mode 100644 drivers/soc/eswin/ai_driver/include/pdp_regs.h
 create mode 100644 drivers/soc/eswin/ai_driver/include/rubik_regs.h
 create mode 100644 drivers/soc/eswin/ai_driver/include/sdp_regs.h
 create mode 100644 drivers/soc/eswin/ai_driver/include/sys_regs.h
 create mode 100644 drivers/soc/eswin/ai_driver/npu/Makefile
 create mode 100644 drivers/soc/eswin/ai_driver/npu/common.c
 create mode 100644 drivers/soc/eswin/ai_driver/npu/common.h
 create mode 100644 drivers/soc/eswin/ai_driver/npu/conv.c
 create mode 100644 drivers/soc/eswin/ai_driver/npu/conv.h
 create mode 100644 drivers/soc/eswin/ai_driver/npu/debug.c
 create mode 100644 drivers/soc/eswin/ai_driver/npu/debug.h
 create mode 100644 drivers/soc/eswin/ai_driver/npu/dla_buffer.c
 create mode 100644 drivers/soc/eswin/ai_driver/npu/dla_buffer.h
 create mode 100644 drivers/soc/eswin/ai_driver/npu/dla_driver.c
 create mode 100644 drivers/soc/eswin/ai_driver/npu/dla_driver.h
 create mode 100644 drivers/soc/eswin/ai_driver/npu/dla_engine_internal.h
 create mode 100644 drivers/soc/eswin/ai_driver/npu/dla_log.c
 create mode 100644 drivers/soc/eswin/ai_driver/npu/dla_log.h
 create mode 100644 drivers/soc/eswin/ai_driver/npu/dsp.c
 create mode 100644 drivers/soc/eswin/ai_driver/npu/dsp.h
 create mode 100644 drivers/soc/eswin/ai_driver/npu/edma.c
 create mode 100644 drivers/soc/eswin/ai_driver/npu/edma.h
 create mode 100644 drivers/soc/eswin/ai_driver/npu/engine.c
 create mode 100644 drivers/soc/eswin/ai_driver/npu/event.c
 create mode 100644 drivers/soc/eswin/ai_driver/npu/include/dla_engine.h
 create mode 100644 drivers/soc/eswin/ai_driver/npu/include/dla_err.h
 create mode 100644 drivers/soc/eswin/ai_driver/npu/include/dla_sched.h
 create mode 100644 drivers/soc/eswin/ai_driver/npu/include/npu_top_csr.h
 create mode 100644 drivers/soc/eswin/ai_driver/npu/include/nvdla_interface.h
 create mode 100644 drivers/soc/eswin/ai_driver/npu/include/nvdla_linux.h
 create mode 100644 drivers/soc/eswin/ai_driver/npu/include/opendla.h
 create mode 100644 drivers/soc/eswin/ai_driver/npu/include/opendla_initial.h
 create mode 100644 drivers/soc/eswin/ai_driver/npu/internal_interface.h
 create mode 100644 drivers/soc/eswin/ai_driver/npu/npu_e31.c
 create mode 100644 drivers/soc/eswin/ai_driver/npu/npu_frame.c
 create mode 100644 drivers/soc/eswin/ai_driver/npu/npu_main.c
 create mode 100644 drivers/soc/eswin/ai_driver/npu/npu_spram.c
 create mode 100644 drivers/soc/eswin/ai_driver/npu/npu_spram.h
 create mode 100644 drivers/soc/eswin/ai_driver/npu/nvdla_hw.c
 create mode 100644 drivers/soc/eswin/ai_driver/npu/nvdla_lowlevel.h
 create mode 100644 drivers/soc/eswin/ai_driver/npu/nvdla_proc.c
 create mode 100644 drivers/soc/eswin/ai_driver/npu/nvdla_proc.h
 create mode 100644 drivers/soc/eswin/ai_driver/npu/nvdla_sim.c
 create mode 100644 drivers/soc/eswin/ai_driver/npu/parse_dep.c
 create mode 100644 drivers/soc/eswin/ai_driver/npu/pdp.c
 create mode 100644 drivers/soc/eswin/ai_driver/npu/post_drp.h
 create mode 100644 drivers/soc/eswin/ai_driver/npu/rubik.c
 create mode 100644 drivers/soc/eswin/ai_driver/npu/scheduler.c
 create mode 100644 drivers/soc/eswin/ai_driver/npu/sdp.c
 create mode 100644 drivers/soc/eswin/ai_driver/npu/sdp.h
 create mode 100644 drivers/soc/eswin/ai_driver/npu/user_context.c

diff --git a/drivers/soc/eswin/Kconfig b/drivers/soc/eswin/Kconfig
index 54179b920cc8..256bfa5d85eb 100644
--- a/drivers/soc/eswin/Kconfig
+++ b/drivers/soc/eswin/Kconfig
@@ -1,3 +1,5 @@
+source "drivers/soc/eswin/ai_driver/Kconfig"
+
 if SOC_SIFIVE || SOC_STARFIVE
 
 config ESWIN_KHANDLE
diff --git a/drivers/soc/eswin/Makefile b/drivers/soc/eswin/Makefile
index 290bd185817f..bc4e41370dc1 100644
--- a/drivers/soc/eswin/Makefile
+++ b/drivers/soc/eswin/Makefile
@@ -1,4 +1,3 @@
 obj-$(CONFIG_ESWIN_KHANDLE) += eswin-khandle.o
 obj-$(CONFIG_ESWIN_DSP_SUBSYS) += dsp_subsys.o
-
-
+obj-y += ai_driver/
\ No newline at end of file
diff --git a/drivers/soc/eswin/ai_driver/Kconfig b/drivers/soc/eswin/ai_driver/Kconfig
new file mode 100644
index 000000000000..84a135ee3d69
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/Kconfig
@@ -0,0 +1,11 @@
+config ESWIN_DSP
+    tristate "Eswin DSP"
+    default n
+
+config ESWIN_NPU
+    tristate "Eswin NPU"
+    default n
+    depends on ESWIN_DSP
+    select ESWIN_DEV_DMA_BUF
+    select ESWIN_IOMMU_RSV
+    select ESWIN_RSVMEM_HEAP
diff --git a/drivers/soc/eswin/ai_driver/Makefile b/drivers/soc/eswin/ai_driver/Makefile
new file mode 100644
index 000000000000..3763ea444940
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_ESWIN_DSP) += dsp/
+obj-$(CONFIG_ESWIN_NPU) += npu/
diff --git a/drivers/soc/eswin/ai_driver/dsp/Makefile b/drivers/soc/eswin/ai_driver/dsp/Makefile
new file mode 100755
index 000000000000..465f11f3e688
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/dsp/Makefile
@@ -0,0 +1,50 @@
+#
+# Copyright (c) 2017 Cadence Design Systems Inc.
+#
+# Permission is hereby granted, free of charge, to any person obtaining
+# a copy of this software and associated documentation files (the
+# "Software"), to deal in the Software without restriction, including
+# without limitation the rights to use, copy, modify, merge, publish,
+# distribute, sublicense, and/or sell copies of the Software, and to
+# permit persons to whom the Software is furnished to do so, subject to
+# the following conditions:
+#
+# The above copyright notice and this permission notice shall be included
+# in all copies or substantial portions of the Software.
+#
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+#
+# Alternatively you can use and distribute this file under the terms of
+# the GNU General Public License version 2 or later.
+#
+
+BUILD_RELEASE ?= 1
+DEBUG_LEVEL ?= 0
+
+ccflags-y := -I$(src)/
+ccflags-y += -I$(srctree)/drivers/soc/eswin
+ccflags-y += -I$(srctree)/$(src)/../include
+
+obj-$(CONFIG_ESWIN_DSP) += eic7700_dsp.o
+
+eic7700_dsp-y += dsp_main.o dsp_ioctl.o dsp_proc.o dsp_log.o
+
+ifeq ($(DSP_ENV_SIM), 1)
+eic7700_dsp-y += dsp_platform_sim.o
+
+else
+ccflags-y +=-I
+eic7700_dsp-y += dsp_platform.o dsp_sram.o dsp_firmware.o \
+				mloader/dsp_load_operator.o \
+				mloader/xt_mld_loader.o \
+				mloader/xt_mld_relocate.o
+
+endif
+
+ccflags-y += -DDSP_ENV_SIM=${DSP_ENV_SIM} -DBUILD_RELEASE=${BUILD_RELEASE} -DDEBUG_LEVEL=${DEBUG_LEVEL} -w
diff --git a/drivers/soc/eswin/ai_driver/dsp/dsp_firmware.c b/drivers/soc/eswin/ai_driver/dsp/dsp_firmware.c
new file mode 100644
index 000000000000..d901a770f566
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/dsp/dsp_firmware.c
@@ -0,0 +1,234 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#include <linux/dma-mapping.h>
+#include <linux/elf.h>
+#include <linux/firmware.h>
+#include <linux/highmem.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include "dsp_main.h"
+#include "dsp_firmware.h"
+
+#ifndef OF_BAD_ADDR
+#define OF_BAD_ADDR (-1ul)
+#endif
+struct es_dsp_hw;
+int es_dsp_load_fw_segment(struct es_dsp_hw *hw, const void *image,
+			   Elf32_Phdr *phdr);
+
+static phys_addr_t dsp_translate_to_cpu(struct es_dsp *dsp, Elf32_Phdr *phdr)
+{
+#if IS_ENABLED(CONFIG_OF)
+	phys_addr_t res;
+	__be32 addr = cpu_to_be32((u32)phdr->p_paddr);
+	struct device_node *node = of_get_next_child(dsp->dev->of_node, NULL);
+
+	if (!node)
+		node = dsp->dev->of_node;
+
+	res = of_translate_address(node, &addr);
+
+	if (node != dsp->dev->of_node)
+		of_node_put(node);
+	return res;
+#else
+	return phdr->p_paddr;
+#endif
+}
+
+static int dsp_load_segment_to_sysmem(struct es_dsp *dsp, Elf32_Phdr *phdr)
+{
+	phys_addr_t pa = dsp_translate_to_cpu(dsp, phdr);
+	struct page *page = pfn_to_page(__phys_to_pfn(pa));
+	size_t page_offs = pa & ~PAGE_MASK;
+	size_t offs;
+
+	for (offs = 0; offs < phdr->p_memsz; ++page) {
+		void *p = kmap(page);
+		size_t sz;
+
+		if (!p)
+			return -ENOMEM;
+
+		page_offs &= ~PAGE_MASK;
+		sz = PAGE_SIZE - page_offs;
+
+		if (offs < phdr->p_filesz) {
+			size_t copy_sz = sz;
+
+			if (phdr->p_filesz - offs < copy_sz)
+				copy_sz = phdr->p_filesz - offs;
+
+			copy_sz = ALIGN(copy_sz, 4);
+			memcpy(p + page_offs,
+			       (void *)dsp->firmware->data + phdr->p_offset +
+				       offs,
+			       copy_sz);
+			page_offs += copy_sz;
+			offs += copy_sz;
+			sz -= copy_sz;
+		}
+
+		if (offs < phdr->p_memsz && sz) {
+			if (phdr->p_memsz - offs < sz)
+				sz = phdr->p_memsz - offs;
+
+			sz = ALIGN(sz, 4);
+			memset(p + page_offs, 0, sz);
+			page_offs += sz;
+			offs += sz;
+		}
+		kunmap(page);
+	}
+	dma_sync_single_for_device(dsp->dev, pa, phdr->p_memsz, DMA_TO_DEVICE);
+	return 0;
+}
+
+static int dsp_load_segment_to_iomem(struct es_dsp *dsp, Elf32_Phdr *phdr)
+{
+	phys_addr_t pa = dsp_translate_to_cpu(dsp, phdr);
+	void __iomem *p = ioremap(pa, phdr->p_memsz);
+
+	if (!p) {
+		dev_err(dsp->dev, "couldn't ioremap %pap x 0x%08x\n", &pa,
+			(u32)phdr->p_memsz);
+		return -EINVAL;
+	}
+
+	memcpy_toio(p, (void *)dsp->firmware->data + phdr->p_offset,
+		    ALIGN(phdr->p_filesz, 4));
+
+	memset_io(p + ALIGN(phdr->p_filesz, 4), 0,
+		  ALIGN(phdr->p_memsz - ALIGN(phdr->p_filesz, 4), 4));
+
+	iounmap(p);
+	return 0;
+}
+
+static int dsp_load_segment(struct es_dsp *dsp, Elf32_Phdr *phdr)
+{
+	phys_addr_t pa;
+
+	pa = dsp_translate_to_cpu(dsp, phdr);
+	if (pa == (phys_addr_t)OF_BAD_ADDR) {
+		dev_err(dsp->dev,
+			"device address 0x%08x could not be mapped to host physical address",
+			(u32)phdr->p_paddr);
+		return -EINVAL;
+	}
+	dsp_info("loading segment (device 0x%08x) to physical %pap\n",
+		 (u32)phdr->p_paddr, &pa);
+
+	if (pfn_valid(__phys_to_pfn(pa)))
+		return dsp_load_segment_to_sysmem(dsp, phdr);
+	else
+		return dsp_load_segment_to_iomem(dsp, phdr);
+}
+
+static int dsp_prepare_firmware(struct es_dsp *dsp)
+{
+	Elf32_Ehdr *ehdr = (Elf32_Ehdr *)dsp->firmware->data;
+
+	if (memcmp(ehdr->e_ident, ELFMAG, SELFMAG)) {
+		dev_err(dsp->dev, "bad firmware ELF magic\n");
+		return -EINVAL;
+	}
+
+	if (ehdr->e_type != ET_EXEC) {
+		dev_err(dsp->dev, "bad firmware ELF type\n");
+		return -EINVAL;
+	}
+
+	if (ehdr->e_machine != 94) {
+		dev_err(dsp->dev, "bad firmware ELF machine\n");
+		return -EINVAL;
+	}
+
+	if (ehdr->e_phoff >= dsp->firmware->size ||
+	    ehdr->e_phoff + ehdr->e_phentsize * ehdr->e_phnum >
+		    dsp->firmware->size) {
+		dev_err(dsp->dev, "bad firmware ELF PHDR information\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int dsp_load_firmware(struct es_dsp *dsp)
+{
+	Elf32_Ehdr *ehdr = (Elf32_Ehdr *)dsp->firmware->data;
+	int i;
+	int rc;
+
+	for (i = 0; i < ehdr->e_phnum; ++i) {
+		Elf32_Phdr *phdr = (void *)dsp->firmware->data + ehdr->e_phoff +
+				   i * ehdr->e_phentsize;
+
+		/* Only load non-empty loadable segments, R/W/X */
+		if (!(phdr->p_type == PT_LOAD &&
+		      (phdr->p_flags & (PF_X | PF_R | PF_W)) &&
+		      phdr->p_memsz > 0))
+			continue;
+
+		if (phdr->p_offset >= dsp->firmware->size ||
+		    phdr->p_offset + phdr->p_filesz > dsp->firmware->size) {
+			dev_err(dsp->dev,
+				"bad firmware ELF program header entry %d\n",
+				i);
+			return -EINVAL;
+		}
+
+		dsp_info("%s loading segment %d\n", __func__, i);
+
+		rc = es_dsp_load_fw_segment(
+			dsp->hw_arg, (const void *)dsp->firmware->data, phdr);
+
+		if (rc != 0) {
+			rc = dsp_load_segment(dsp, phdr);
+		}
+
+		if (rc < 0)
+			return rc;
+	}
+	return 0;
+}
+
+void dsp_release_firmware(struct es_dsp *dsp)
+{
+	if (dsp->firmware) {
+		release_firmware(dsp->firmware);
+		dsp->firmware = NULL;
+	}
+}
+
+int dsp_request_firmware(struct es_dsp *dsp)
+{
+	int ret;
+
+	if (!dsp->firmware) {
+		ret = request_firmware(&dsp->firmware, dsp->firmware_name,
+				       dsp->dev);
+		dsp_debug("%s, after request_firmware, ret=%d\n", __func__,
+			  ret);
+		if (ret < 0)
+			return ret;
+
+		ret = dsp_prepare_firmware(dsp);
+		if (ret < 0)
+			goto err;
+	}
+
+	ret = dsp_load_firmware(dsp);
+err:
+	if (ret < 0)
+		dsp_release_firmware(dsp);
+	return ret;
+}
+
+MODULE_LICENSE("GPL");
diff --git a/drivers/soc/eswin/ai_driver/dsp/dsp_firmware.h b/drivers/soc/eswin/ai_driver/dsp/dsp_firmware.h
new file mode 100755
index 000000000000..240ddf0f966d
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/dsp/dsp_firmware.h
@@ -0,0 +1,28 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#ifndef DSP_FIRMWARE_H
+#define DSP_FIRMWARE_H
+
+struct es_dsp;
+
+#if IS_ENABLED(CONFIG_FW_LOADER)
+int dsp_request_firmware(struct es_dsp *dsp);
+void dsp_release_firmware(struct es_dsp *dsp);
+#else
+static inline int dsp_request_firmware(struct es_dsp *dsp)
+{
+	(void)xvp;
+	return -EINVAL;
+}
+
+static inline void dsp_release_firmware(struct es_dsp *dsp)
+{
+}
+#endif
+
+#endif
diff --git a/drivers/soc/eswin/ai_driver/dsp/dsp_hw.h b/drivers/soc/eswin/ai_driver/dsp/dsp_hw.h
new file mode 100644
index 000000000000..302c48a5234d
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/dsp/dsp_hw.h
@@ -0,0 +1,186 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#ifndef __DSP_HW_H__
+#define __DSP_HW_H__
+
+#include <linux/completion.h>
+#include <linux/miscdevice.h>
+#include <linux/mutex.h>
+#include <linux/types.h>
+#include <linux/irqreturn.h>
+#include <linux/dma-buf.h>
+#include "dsp_hw_if.h"
+
+struct device;
+typedef struct dsp_request dsp_request_t;
+typedef void (*cpl_handler_fn)(struct device *, dsp_request_t *);
+
+typedef struct dsp_request {
+	u64 handle;
+	/**
+	*  This structure can be chainned in a linked list and this variable
+	*  specifies the list node.
+	*/
+	struct list_head cpl_list;
+	struct list_head pending_list;
+	int prio;
+	cpl_handler_fn cpl_handler;
+	void *private;
+
+	dma_addr_t dsp_flat1_iova;
+	struct es_dsp_flat1_desc *flat_virt;
+	u32 flat_size;
+	es_dsp_d2h_msg d2h_msg;
+	/**
+	*  If true, then the driver is responsible for host side cache 
+	*  synchronization.
+	*/
+	bool sync_cache;
+	/**
+	*  If true, then DSP framework is allowed to start evaluation function call
+	*  directly after completing prepare call. Otherwise DSP framework should
+	*  wait for further instruction from DSP driver or E31 auxiliary CPU core.
+	*/
+	bool allow_eval;
+	/**
+	*  If true, the DSP framework should expect to communicate with E31
+	*  auxiliary CPU core for starting evaluation and notifying `prepare` and
+	*  `eval` completion events.
+	*/
+	bool poll_mode;
+} __attribute__((aligned(SMP_CACHE_BYTES))) dsp_request_t;
+
+/**
+ * @brief Submit a DSP task to the given DSP device.
+ * 
+ * @param dsp_dev   The device handle to load an operator.
+ * @param req  The task to be delivered. Note if the task has `allow_eval`
+ *             field set to true, then DSP device will execute `prepare`
+ *             and `eval` in order when this task is scheduled to DSP
+ *             device. Otherwise, it will execute `prepare` and wait for
+ *             further notification.
+ *
+ * @return ES_S32 The execution status.
+ */
+int submit_task(struct device *dsp_dev, dsp_request_t *req);
+
+/**
+ * @brief Load a given operator into system. This includes load elf data from
+ * firmware folder into memory and allocate IOVA for executable code.
+ * 
+ * @param dsp_dev   The device handle to load an operator.
+ * @param op_name Authoritative name of the given operator.
+ * @param handle If operator is loaded successfully, the this pointer operator desc address.
+ *
+ * @return ES_S32 The execution status.
+ */
+int load_operator(struct device *dsp_dev, char *op_dir, char *op_name,
+		  u64 *handle);
+/**
+ * @brief Unload the given operator from system. If the operator is not longer
+ * in use, then it will be removed entirely.
+ * 
+ * @param dsp_dev   The device handle to load an operator.
+ * @param op_name Authoritative name of the given operator.
+ *
+ * @return ES_S32 The execution status.
+ */
+int unload_operator(struct device *dsp_dev, u64 handle);
+
+/**
+ * @brief Signal DSP device that the given DSP task is ready for `eval` step.
+ * 
+ * @param dsp_dev   The device handle to load an operator.
+ * @param req  The task to be signaled. Call start_eval only if the task is
+ *             submitted without setting `allow_eval` to true.
+ *
+ * @return ES_S32 The execution status.
+ */
+int start_eval(struct device *dsp_dev, dsp_request_t *req);
+
+/**
+ * @brief DSP unmap dma buf when no need this dma buf
+ * 
+ * @param dsp_file   The process open dsp node file.
+ * @param buf  buf saved dsp mapped dmabufs.
+ * @param count How many dma buf in buf.
+ *
+ * @return 0
+ */
+int dsp_unmap_dmabuf(struct dsp_file *dsp_file, struct dsp_dma_buf **buf, int count);
+
+/**
+ * @brief DSP get dma buf when need mapped dma buf.
+ * 
+ * @param dsp_file   The process open dsp node file.
+ * @param memfd memfd reference dma file.
+ *
+ * @return NULL or pointer that point the dsp dma buf.
+ */
+struct dsp_dma_buf *dsp_get_dma_buf_ex(struct dsp_file *dsp_file, int memfd);
+
+/**
+ * @brief Dsp set flat descriptor prepare and eval func address.
+ * @param flat is a pointer that is alloced by dma alloc.
+ * @param handle is a pointer that point dsp op desc.
+ */
+void dsp_set_flat_func(struct es_dsp_flat1_desc *flat, u64 handle);
+
+/**
+ * @brief get sram iova when buffer comes from SRAM.
+ * @param dev represent dsp device.
+ * @param phy_addr is sram physical address.
+ * @return dsp iova addr or 0(when no iova mapped).
+ */
+u32 dsp_get_sram_iova_by_addr(struct device *dev, u64 phy_addr);
+
+/**
+ * @brief unmap dsp used sram buf.
+ * @param dev is dsp device.
+ * @return 0 is successful, other failed.
+ */
+int dsp_detach_sram_dmabuf(struct device *dev);
+
+
+/**
+ * @brief map sram for dsp.
+ * @param dev is dsp device.
+ * @param dmabuf is sram dma buf.
+ * @return 0 is successful or failed.
+ */
+int dsp_attach_sram_dmabuf(struct device *dev, struct dma_buf *dmabuf);
+
+/**
+ * @brief Subscribe the service of the given DSP core. NPU device can call this
+ * function to bind it to a given DSP core in NPU's probe function. If binding
+ * is successful, then NPU can use the service from this DSP core. Note device
+ * link is added in this function.
+ *
+ * @param die_id    The die ID (0, 1) of the subscriber.
+ * @param dspId    The DSP ID (0, 1, 2, 3) of the subscriber.
+ * @param subscriber The device instance of subscriber.
+ * @param dsp_device Return the DSP device instance if the call returns
+ *             successfully.
+ * @return int  The execution status. Return Linux errorno.
+ */
+int subscribe_dsp_device(u32 die_id, u32 dspId, struct device *subscrib,
+			 struct device **dsp_dev);
+
+/**
+ * @brief Unsubscribe the service of the given DSP core. NPU device can call
+ * this function to unbind it from a given DSP core in NPU's release function.
+ * Note device link is deleted in this function.
+ *
+ * @param subscriber The device instance of subscriber.
+ * @param dsp_device Return the DSP device instance if the call returns
+ *             successfully.
+ * @return int  The execution status. Return Linux errorno.
+ */
+int unsubscribe_dsp_device(struct device *subscrib, struct device *dsp_dev);
+
+#endif
diff --git a/drivers/soc/eswin/ai_driver/dsp/dsp_hw_if.h b/drivers/soc/eswin/ai_driver/dsp/dsp_hw_if.h
new file mode 100644
index 000000000000..27e3313bfb5f
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/dsp/dsp_hw_if.h
@@ -0,0 +1,39 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#ifndef ESWIN_COMMON_DSP_HW_IF_H_
+#define ESWIN_COMMON_DSP_HW_IF_H_
+
+#include "es_dsp_types.h"
+#include "es_nn_common.h"
+#include "es_dsp_internal.h"
+
+#define MAX_DSP_TASKS 4096
+#define DSP_2M_SHIFT 20
+#define DSP_2M_SIZE 0x200000
+
+#if defined DSP_ENV_SIM && DSP_ENV_SIM
+#define DSP_OP_LIB_DIR "./operators"
+#else
+#define DSP_OP_LIB_DIR "/lib/firmware/dsp_kernels"
+#endif
+
+
+typedef struct es_dsp_buffer_group_t {
+    es_dsp_buffer* buffers;
+    ES_U32 bufferCnt;
+} es_dsp_buffer_group;
+
+typedef ES_S32 (*PREPARE_FUNC)(es_dsp_buffer_group* params);
+typedef ES_S32 (*EVAL_FUNC)(es_dsp_buffer_group* params, es_dsp_buffer_group* inputs, es_dsp_buffer_group* outputs);
+
+typedef struct operator_func_t {
+    PREPARE_FUNC prepare_func;
+    EVAL_FUNC eval_func;
+} operator_func;
+
+#endif  // ESWIN_COMMON_DSP_HW_IF_H_
diff --git a/drivers/soc/eswin/ai_driver/dsp/dsp_ioctl.c b/drivers/soc/eswin/ai_driver/dsp/dsp_ioctl.c
new file mode 100644
index 000000000000..dee6ec9d8da0
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/dsp/dsp_ioctl.c
@@ -0,0 +1,1126 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#include <linux/fs.h>
+#include <linux/compat.h>
+#include <linux/pm_runtime.h>
+#include <linux/dma-direct.h>
+#include <linux/slab.h>
+#include "eswin-khandle.h"
+#include <linux/dsp_dma_buf.h>
+#include <linux/list.h>
+#include <linux/poll.h>
+#include "dsp_platform.h"
+#include "dsp_main.h"
+#include "dsp_ioctl.h"
+#include <linux/fdtable.h>
+
+MODULE_IMPORT_NS(DMA_BUF);
+
+static void dsp_user_release_fn(struct khandle *handle)
+{
+	struct dsp_user *user = container_of(handle, struct dsp_user, h);
+	struct dsp_op_desc *op;
+	struct es_dsp *dsp;
+	struct dsp_file *dsp_file;
+
+	dsp_debug("%s, %d.\n", __func__, __LINE__);
+	if (!user) {
+		dsp_err("%s, user is null, error.\n", __func__);
+		return;
+	}
+	op = user->op;
+	dsp = op->dsp;
+	dsp_file = user->dsp_file;
+
+	kfree(user);
+
+	mutex_lock(&dsp->op_list_mutex);
+	kref_put(&op->refcount, dsp_op_release);
+	mutex_unlock(&dsp->op_list_mutex);
+
+	dsp_debug("%s,%d, user release done.\n", __func__, __LINE__);
+	return;
+}
+
+static struct dsp_user *dsp_op_add_user(struct dsp_file *dsp_file,
+					struct dsp_op_desc *op)
+{
+	struct dsp_user *user;
+	int ret;
+
+	user = kmalloc(sizeof(struct dsp_user), GFP_KERNEL);
+	if (!user) {
+		dsp_err("alloc dsp user mem failed.\n");
+		return NULL;
+	}
+
+	ret = init_kernel_handle(&user->h, dsp_user_release_fn,
+				 DSP_USER_HANDLE_MAGIC, &dsp_file->h);
+	if (ret) {
+		dsp_err("init user khandle error.\n");
+		kfree(user);
+		return NULL;
+	}
+	dsp_debug("%s, op refcount=%d.\n", __func__, kref_read(&op->refcount));
+	dsp_debug("%s, user handle addr=0x%px.\n", __func__, &user->h);
+	user->op = op;
+	user->dsp_file = dsp_file;
+	return user;
+}
+
+static long dsp_ioctl_load_op(struct file *flip, dsp_ioctl_load_s __user *arg)
+{
+	struct dsp_file *dsp_file = flip->private_data;
+	struct es_dsp *dsp = dsp_file->dsp;
+	int ret;
+	dsp_ioctl_load_s dsp_load;
+	u64 handle;
+	struct dsp_op_desc *op;
+	struct dsp_user *user;
+	char op_name[OPERATOR_NAME_MAXLEN];
+	char *op_dir = NULL;
+
+	if (copy_from_user(&dsp_load, arg, sizeof(dsp_ioctl_load_s))) {
+		ret = -EFAULT;
+		goto err;
+	}
+
+	if (copy_from_user(op_name, (void *)dsp_load.op_name,
+			   OPERATOR_NAME_MAXLEN)) {
+		ret = -EFAULT;
+		goto err;
+	}
+
+	if (dsp_load.op_lib_dir) {
+		op_dir = kzalloc(OPERATOR_DIR_MAXLEN, GFP_KERNEL);
+		if (!op_dir) {
+			ret = -ENOMEM;
+			goto err;
+		}
+		if (copy_from_user(op_dir, (void *)dsp_load.op_lib_dir,
+				   OPERATOR_DIR_MAXLEN)) {
+			ret = -EFAULT;
+			goto err;
+		}
+		dsp_debug("%s, op_dir=%s.\n", __func__, op_dir);
+	}
+
+	ret = load_operator(dsp->dev, op_dir, op_name, &handle);
+	if (op_dir) {
+		kfree(op_dir);
+	}
+
+	if (ret) {
+		dsp_err("ioctl load oper %s, error.\n", op_name);
+		goto err;
+	}
+	op = (struct dsp_op_desc *)handle;
+	user = dsp_op_add_user(dsp_file, op);
+	if (user == NULL) {
+		ret = -EIO;
+		dsp_err("ioctl add user error.\n");
+		kref_put(&op->refcount, dsp_op_release);
+		return ret;
+	}
+	dsp_load.op_handle = user->h.fd;
+	if (copy_to_user(arg, &dsp_load, sizeof(dsp_ioctl_load_s))) {
+		kernel_handle_release_family(&user->h);
+		kernel_handle_decref(&user->h);
+		dsp_err("ioctl load op copy_from_user err.\n");
+		ret = -EFAULT;
+		return ret;
+	}
+
+	dsp_debug("%s, ok, user fd=%d, refcount=%d.\n\n", __func__,
+		  dsp_load.op_handle, kref_read(&user->h.refcount));
+	kernel_handle_decref(&user->h);
+err:
+	return ret;
+}
+
+static u32 dsp_get_dma_addr(struct es_dsp *dsp, int fd,
+			    struct dsp_dma_buf *map_buf)
+{
+	struct dma_buf *dmabuf;
+	u32 dma_addr;
+
+	dmabuf = dma_buf_get(fd);
+	if (IS_ERR(dmabuf)) {
+		dsp_err("fd = %d,  get dma buf error.\n", fd);
+		return 0;
+	}
+
+	dma_addr = dev_mem_attach(dmabuf, dsp->dev, DMA_BIDIRECTIONAL,
+				  &map_buf->attach);
+	if (!dma_addr) {
+		dsp_err("dev mem attach fd=%d failed.\n", fd);
+		map_buf->attach = NULL;
+		goto err_attach;
+	}
+	map_buf->dma_addr = dma_addr;
+	map_buf->dmabuf = dmabuf;
+	return dma_addr;
+
+err_attach:
+	dma_buf_put(dmabuf);
+	return 0;
+}
+
+static void dsp_put_dma_addr(struct es_dsp *dsp, struct dsp_dma_buf *buf)
+{
+	int ret;
+	struct dma_buf *dmabuf;
+	struct dma_buf_attachment *attach;
+
+	if (!buf || !buf->dmabuf || !buf->attach) {
+		return;
+	}
+	attach = buf->attach;
+	ret = dev_mem_detach(attach, DMA_BIDIRECTIONAL);
+
+	dmabuf = buf->dmabuf;
+	dma_buf_put(dmabuf);
+	buf->dmabuf = NULL;
+	buf->attach = NULL;
+}
+
+int dsp_unmap_dmabuf(struct dsp_file *dsp_file, struct dsp_dma_buf **buf,
+		     int count)
+{
+	int i;
+	struct es_dsp *dsp = dsp_file->dsp;
+	struct dsp_dma_buf_ex *entry;
+
+	for (i = 0; i < count; i++) {
+		if (buf[i] == NULL) {
+			continue;
+		}
+		if (buf[i]->fd == -1) {
+			dsp_put_dma_addr(dsp, buf[i]);
+			kfree(buf[i]);
+			buf[i] = NULL;
+		} else {
+			entry = container_of(buf[i], struct dsp_dma_buf_ex,
+					     buf);
+			dsp_debug("%s, %d, fd=%d, handl cnt=%d.\n", __func__,
+				  __LINE__, buf[i]->fd,
+				  kref_read(&entry->handle.refcount));
+			kernel_handle_decref(&entry->handle);
+		}
+	}
+	return 0;
+}
+EXPORT_SYMBOL(dsp_unmap_dmabuf);
+
+struct dsp_dma_buf *dsp_get_dma_buf_ex(struct dsp_file *dsp_file, int memfd)
+{
+	struct dsp_dma_buf_ex *entry;
+	struct khandle *handle;
+	struct dsp_dma_buf *dma_buf = NULL;
+	struct dsp_dma_buf *dma_entry = NULL;
+	u32 addr = 0;
+
+	mutex_lock(&dsp_file->xrray_lock);
+	entry = xa_load(&dsp_file->buf_xrray, memfd);
+	if (entry) {
+		dsp_debug("%s, %d. entry->fd=%d.\n", __func__, __LINE__,
+			  entry->buf.fd);
+		handle = find_kernel_handle(&dsp_file->h, entry->handle.fd,
+					    DSP_DMABUF_HANDLE_MAGIC);
+		dsp_debug("%s, %d, handle_fd=0x%x, refcount=%d.\n", __func__,
+			  __LINE__, entry->handle.fd,
+			  kref_read(&handle->refcount));
+	}
+	mutex_unlock(&dsp_file->xrray_lock);
+
+	if (!entry || !handle) {
+		dsp_debug("%s, %d, slow path.\n", __func__, __LINE__);
+		dma_entry = kzalloc(sizeof(struct dsp_dma_buf), GFP_KERNEL);
+		if (!dma_entry) {
+			dsp_err("%s, %d. alloc dsp device buf struct err.\n",
+				__func__, __LINE__);
+			goto err;
+		}
+		addr = dsp_get_dma_addr(dsp_file->dsp, memfd, dma_entry);
+		dma_entry->fd = -1;
+	} else {
+		dsp_debug("%s, %d, fast path, dma fd=%d, iova=0x%x.\n",
+			  __func__, __LINE__, entry->buf.fd,
+			  entry->buf.dma_addr);
+		dma_entry = &entry->buf;
+		addr = dma_entry->dma_addr;
+	}
+	if (addr == 0) {
+		dsp_err("%s, %d, addr is err.\n", __func__, __LINE__);
+		goto err;
+	}
+	return dma_entry;
+err:
+	return NULL;
+}
+EXPORT_SYMBOL(dsp_get_dma_buf_ex);
+
+static int dsp_ioctl_set_flat(struct dsp_file *dsp_file, dsp_ioctl_task_s *req,
+			      struct es_dsp_flat1_desc *flat,
+			      struct dsp_dma_buf **dma_entry)
+{
+	int buffer_count;
+	int i;
+	struct es_dsp *dsp = dsp_file->dsp;
+	struct dsp_dma_buf *entry = NULL;
+
+	buffer_count = req->task.bufferCntCfg + req->task.bufferCntInput +
+		       req->task.bufferCntOutput;
+
+	for (i = 0; i < buffer_count; i++) {
+		u32 addr;
+		dsp_debug("%s, i=%d, new fd=%d, offset=0x%x.\n", __func__, i,
+			  (int)req->task.dspBuffers[i].memFd,
+			  req->task.dspBuffers[i].offset);
+
+		entry = dsp_get_dma_buf_ex(dsp_file,
+					   req->task.dspBuffers[i].memFd);
+		if (entry == NULL) {
+			goto err;
+		}
+		dma_entry[i] = entry;
+		flat->buffers[i].addr =
+			entry->dma_addr + req->task.dspBuffers[i].offset;
+		flat->buffers[i].size = req->task.dspBuffers[i].size;
+		dsp_debug("%s, i=%d, addr=0x%x, len=0x%x\n", __func__, i,
+			  flat->buffers[i].addr, flat->buffers[i].size);
+	}
+	return 0;
+err:
+	dsp_unmap_dmabuf(dsp_file, dma_entry, i - 1);
+	return -EINVAL;
+}
+
+static struct dsp_user *dsp_find_user_by_fd(struct dsp_file *dsp_file, int fd)
+{
+	struct khandle *user_handle;
+	struct dsp_user *user;
+
+	user_handle =
+		find_kernel_handle(&dsp_file->h, fd, DSP_USER_HANDLE_MAGIC);
+	if (!user_handle) {
+		dsp_err("cannot find dsp operator for %d.\n", fd);
+		return NULL;
+	}
+
+	user = (struct dsp_user *)container_of(user_handle, struct dsp_user, h);
+	return user;
+}
+
+static int dsp_set_task_req(struct es_dsp *dsp, dsp_request_t *dsp_req,
+			    dsp_ioctl_task_s *task)
+{
+	u32 dma_len;
+	dma_addr_t dma_addr;
+	struct es_dsp_flat1_desc *flat;
+	int ret;
+	u32 buffer_count;
+
+	buffer_count = task->task.bufferCntCfg + task->task.bufferCntInput +
+		       task->task.bufferCntOutput;
+	dma_len = sizeof(struct es_dsp_flat1_desc) +
+		  buffer_count * sizeof(es_dsp_buffer);
+
+	flat = (struct es_dsp_flat1_desc *)dsp_alloc_flat_mem(dsp, dma_len,
+							      &dma_addr);
+	if (!flat) {
+		dsp_err("cannot dma alloc mem for desc.\n");
+		ret = -ENOMEM;
+		return ret;
+	}
+	dsp_req->dsp_flat1_iova = dma_addr;
+
+	dsp_req->sync_cache = true;
+	dsp_req->poll_mode = task->task.pollMode;
+	dsp_req->allow_eval = 1;
+	dsp_req->flat_virt = (void *)flat;
+	dsp_req->prio = task->task.priority;
+	dsp_req->flat_size = dma_len;
+
+	flat->num_buffer = buffer_count;
+
+	flat->input_index = task->task.bufferCntCfg;
+	flat->output_index =
+		task->task.bufferCntCfg + task->task.bufferCntInput;
+	return 0;
+}
+
+static void dsp_user_async_req_complete(struct device *dev, dsp_request_t *req)
+{
+	struct dsp_user_req_async *user_req;
+	struct es_dsp *dsp;
+	struct dsp_file *dsp_file;
+	struct dsp_user *user;
+
+	if (!req) {
+		dsp_err("%s, err, req is NULL.\n", __func__);
+		return;
+	}
+
+	user_req = container_of(req, struct dsp_user_req_async, dsp_req);
+	dsp = dev_get_drvdata(dev);
+	if (!dsp) {
+		dsp_err("%s, request dsp dev is null.\n", __func__);
+		return;
+	}
+	user = user_req->user;
+	dsp_file = user_req->dsp_file;
+	dsp_unmap_dmabuf(dsp_file, user_req->dma_entry,
+			 user_req->dma_buf_count);
+	dsp_free_flat_mem(dsp, req->flat_size, req->flat_virt,
+			  req->dsp_flat1_iova);
+	dsp_debug("%s, %d.\n", __func__, __LINE__);
+	kernel_handle_decref(&user_req->handle);
+	kernel_handle_decref(&user->h);
+
+	dsp_debug("%s, done.\n", __func__);
+}
+
+static void dsp_async_task_release(struct khandle *handle)
+{
+	struct dsp_user_req_async *user_req =
+		container_of(handle, struct dsp_user_req_async, handle);
+	struct dsp_user *user;
+	struct es_dsp *dsp;
+
+	if (!user_req) {
+		dsp_err("%s, user_req is null.\n", __func__);
+		return;
+	}
+	dsp = user_req->es_dsp;
+	user = user_req->user;
+	kfree(user_req);
+	module_put(THIS_MODULE);
+	dsp_debug("%s, done.\n", __func__);
+}
+
+static void dsp_hw_complete_task(struct device *dev, dsp_request_t *req)
+{
+	struct dsp_file *dsp_file;
+	struct dsp_user_req_async *async_task;
+	unsigned long flags;
+	struct es_dsp *dsp;
+	async_task = container_of(req, struct dsp_user_req_async, dsp_req);
+
+	dsp_file = async_task->dsp_file;
+	dsp = dsp_file->dsp;
+
+	spin_lock_irqsave(&dsp_file->async_ll_lock, flags);
+	if (dsp_file->h.fd != INVALID_HANDLE_VALUE) {
+		list_add_tail(&async_task->async_ll,
+			      &dsp_file->async_ll_complete);
+		spin_unlock_irqrestore(&dsp_file->async_ll_lock, flags);
+		wake_up_interruptible(&dsp_file->async_ll_wq);
+	} else {
+		spin_unlock_irqrestore(&dsp_file->async_ll_lock, flags);
+		kernel_handle_decref(&async_task->handle);
+	}
+
+	spin_lock_irqsave(&dsp->complete_lock, flags);
+	list_add_tail(&req->cpl_list, &dsp->complete_list);
+	spin_unlock_irqrestore(&dsp->complete_lock, flags);
+	if (!work_pending(&dsp->task_work)) {
+		schedule_work(&dsp->task_work);
+	}
+}
+
+static long dsp_ioctl_submit_tsk_async(struct file *flip,
+				       dsp_ioctl_task_s __user *arg)
+{
+	struct dsp_file *dsp_file = flip->private_data;
+	struct es_dsp *dsp = dsp_file->dsp;
+	dsp_ioctl_task_s req;
+	dsp_ioctl_task_s *task;
+	dsp_request_t *dsp_req;
+	struct dsp_user_req_async *user_req;
+	int ret;
+	struct dsp_user *user;
+	u32 buffer_count;
+	struct dsp_dma_buf **dma_entry = NULL;
+
+	if (copy_from_user(&req, arg, sizeof(dsp_ioctl_task_s))) {
+		dsp_err("%s, %d, copy_from_user err.\n", __func__, __LINE__);
+		ret = -EINVAL;
+		return ret;
+	}
+	task = &req.task;
+
+	// using reserved for op_idx
+	dsp->op_idx = task->task.reserved;
+	if ((dsp_perf_enable || dsp->perf_enable) &&
+	    dsp->op_idx < MAX_DSP_TASKS) {
+		dsp->op_perf[dsp->op_idx].OpStartCycle =
+			0;  //get_perf_timer_cnt();
+		dsp->op_perf[dsp->op_idx].Die = dsp->numa_id;
+		dsp->op_perf[dsp->op_idx].CoreId = dsp->process_id;
+		dsp->op_perf[dsp->op_idx].OpIndex = dsp->op_idx;
+		dsp->op_perf[dsp->op_idx].OpType =
+			dsp->process_id + 7;  // IDX_DSP0
+	}
+
+	if (!try_module_get(THIS_MODULE)) {
+		dsp_err("%s, %d, cannot get module.\n", __func__, __LINE__);
+		return -ENODEV;
+	}
+
+	user = dsp_find_user_by_fd(dsp_file, task->task.operatorHandle);
+	if (!user) {
+		ret = -EINVAL;
+		module_put(THIS_MODULE);
+		dsp_err("cannot get user.\n");
+		return ret;
+	}
+
+	buffer_count = task->task.bufferCntCfg + task->task.bufferCntInput +
+		       task->task.bufferCntOutput;
+
+	user_req = kmalloc(sizeof(struct dsp_user_req_async) +
+				   sizeof(struct dsp_dma_buf *) * buffer_count,
+			   GFP_KERNEL);
+	if (!user_req) {
+		kernel_handle_decref(&user->h);
+		module_put(THIS_MODULE);
+		dsp_err("kmalloc dsp request struct error.\n");
+		ret = -ENOMEM;
+		return ret;
+	}
+
+	ret = init_kernel_handle(&user_req->handle, dsp_async_task_release,
+				 DSP_REQ_HANDLE_MAGIC, &dsp_file->h);
+	if (ret) {
+		dsp_err("init async task khandle error.\n");
+		kernel_handle_decref(&user->h);
+		kfree(user_req);
+		module_put(THIS_MODULE);
+		ret = -EIO;
+		return ret;
+	}
+
+	user_req->user = user;
+	user_req->es_dsp = dsp;
+	dma_entry = (struct dsp_dma_buf **)(user_req + 1);
+	user_req->dma_entry = dma_entry;
+	user_req->dma_buf_count = buffer_count;
+	user_req->dsp_file = dsp_file;
+	user_req->callback = task->task.callback;
+	user_req->cbarg = task->task.cbArg;
+
+	INIT_LIST_HEAD(&user_req->async_ll);
+
+	dsp_debug("%s, user_req=0x%px.\n", __func__, user_req);
+	dsp_req = &user_req->dsp_req;
+
+	dsp_debug("%s,%d, dsp_req=0x%px.\n", __func__, __LINE__, dsp_req);
+
+	ret = dsp_set_task_req(dsp, dsp_req, task);
+
+	if (ret) {
+		goto err_req;
+	}
+	user_req->req_cpl_handler = dsp_user_async_req_complete;
+	dsp_req->cpl_handler = dsp_hw_complete_task;
+	dsp_req->handle = (u64)(user->op);
+	ret = dsp_ioctl_set_flat(dsp_file, task, dsp_req->flat_virt, dma_entry);
+	if (ret != 0) {
+		ret = -EINVAL;
+		goto err_flat;
+	}
+	kernel_handle_addref(&user_req->handle);
+	req.task.taskHandle = user_req->handle.fd;
+	ret = submit_task(dsp->dev, dsp_req);
+	if (ret) {
+		kernel_handle_decref(&user_req->handle);
+		dsp_err("submit task error.\n");
+		goto err_task;
+	}
+	if (copy_to_user(arg, &req, sizeof(dsp_ioctl_task_s))) {
+		dsp_err("copy to user err.\n");
+		ret = -EINVAL;
+	}
+	dsp_debug("%s, %d, user refcount=%d.\n\n", __func__, __LINE__,
+		  kref_read(&user->h.refcount));
+	return 0;
+err_task:
+	dsp_unmap_dmabuf(dsp_file, dma_entry, buffer_count);
+err_flat:
+	dsp_free_flat_mem(dsp, dsp_req->flat_size, dsp_req->flat_virt,
+			  dsp_req->dsp_flat1_iova);
+err_req:
+	kernel_handle_release_family(&user_req->handle);
+	kernel_handle_decref(&user_req->handle);
+	kernel_handle_decref(&user->h);
+	return ret;
+}
+
+static long
+dsp_ioctl_process_complete_task(struct file *flip,
+				dsp_ioctl_async_process_s __user *arg)
+{
+	struct dsp_file *dsp_file = flip->private_data;
+	struct es_dsp *dsp = dsp_file->dsp;
+	struct dsp_user_req_async *async_req = NULL;
+	long ret;
+	dsp_ioctl_async_process_s query_task;
+	dsp_task_status_s *task = NULL;
+	struct dsp_user_req_async *async_task = NULL;
+	unsigned long flags;
+
+	if (copy_from_user(&query_task, arg,
+			   sizeof(dsp_ioctl_async_process_s))) {
+		ret = -EINVAL;
+		return ret;
+	}
+	if (query_task.task_num <= 0) {
+		dsp_err("parameter task num is invalid.\n");
+		return -EINVAL;
+	}
+	query_task.return_num = 0;
+	task = kzalloc(query_task.task_num * sizeof(dsp_task_status_s),
+		       GFP_KERNEL);
+	if (!task) {
+		dsp_err("alloc memory for dsp_task_status error.\n");
+		return -ENOMEM;
+	}
+
+	spin_lock_irqsave(&dsp_file->async_ll_lock, flags);
+	if (list_empty_careful(&dsp_file->async_ll_complete)) {
+		spin_unlock_irqrestore(&dsp_file->async_ll_lock, flags);
+		if (query_task.timeout < 0) {
+			ret = wait_event_interruptible(
+				dsp_file->async_ll_wq,
+				!list_empty(&dsp_file->async_ll_complete));
+		} else {
+			ret = wait_event_interruptible_timeout(
+				dsp_file->async_ll_wq,
+				!list_empty(&dsp_file->async_ll_complete),
+				msecs_to_jiffies(query_task.timeout));
+		}
+	} else {
+		spin_unlock_irqrestore(&dsp_file->async_ll_lock, flags);
+	}
+
+	if (ret == -ERESTARTSYS) {
+		dsp_debug("interrupt by signal.\n");
+		goto err_int;
+	}
+	spin_lock_irqsave(&dsp_file->async_ll_lock, flags);
+	while (!list_empty_careful(&dsp_file->async_ll_complete)) {
+		if (query_task.return_num >= query_task.task_num) {
+			break;
+		}
+
+		async_req = list_first_entry(&dsp_file->async_ll_complete,
+					     struct dsp_user_req_async,
+					     async_ll);
+		list_del_init(&async_req->async_ll);
+		task[query_task.return_num].callback = async_req->callback;
+		task[query_task.return_num].cbArg = async_req->cbarg;
+		task[query_task.return_num].finish =
+			async_req->dsp_req.d2h_msg.return_value;
+		query_task.return_num++;
+		spin_unlock_irqrestore(&dsp_file->async_ll_lock, flags);
+		kernel_handle_release_family(&async_req->handle);
+		kernel_handle_decref(&async_req->handle);
+		spin_lock_irqsave(&dsp_file->async_ll_lock, flags);
+	}
+	spin_unlock_irqrestore(&dsp_file->async_ll_lock, flags);
+
+	ret = 0;
+	if (query_task.return_num != 0) {
+		if (copy_to_user((void __user *)(query_task.task), task,
+				 sizeof(dsp_task_status_s) *
+					 query_task.return_num)) {
+			ret = -EINVAL;
+			dsp_err("copy to user task status err.\n");
+		}
+	}
+err_int:
+	kfree(task);
+	if (copy_to_user(arg, &query_task, sizeof(dsp_ioctl_async_process_s))) {
+		ret = -EINVAL;
+	}
+	return ret;
+}
+
+static long dsp_query_task(struct file *flip, dsp_ioctl_query_s *query_task)
+{
+	long ret = 0;
+	struct dsp_file *dsp_file = flip->private_data;
+	struct dsp_user_req_async *async_task = NULL;
+	unsigned long flags;
+	struct khandle *task_handle = NULL;
+
+	query_task->finish = -ENODATA;
+	task_handle = find_kernel_handle(&dsp_file->h, query_task->task_handle,
+					 DSP_REQ_HANDLE_MAGIC);
+	if (task_handle == NULL) {
+		return -ENODATA;
+	}
+
+again:
+
+	spin_lock_irqsave(&dsp_file->async_ll_lock, flags);
+	if (list_empty_careful(&dsp_file->async_ll_complete)) {
+		spin_unlock_irqrestore(&dsp_file->async_ll_lock, flags);
+		if (query_task->block != 0) {
+			ret = wait_event_interruptible(
+				dsp_file->async_ll_wq,
+				!list_empty(&dsp_file->async_ll_complete));
+		} else {
+			kernel_handle_decref(task_handle);
+			return 0;
+		}
+	} else {
+		spin_unlock_irqrestore(&dsp_file->async_ll_lock, flags);
+	}
+
+	if (ret == -ERESTARTSYS) {
+		query_task->finish = -EINTR;
+		dsp_debug("interrupt by signal.\n");
+		goto err_int;
+	}
+	async_task =
+		container_of(task_handle, struct dsp_user_req_async, handle);
+	spin_lock_irqsave(&dsp_file->async_ll_lock, flags);
+	if (list_empty(&async_task->async_ll)) {
+		async_task = NULL;
+	} else {
+		list_del_init(&async_task->async_ll);
+	}
+	spin_unlock_irqrestore(&dsp_file->async_ll_lock, flags);
+
+	if (async_task != NULL) {
+		ret = 0;
+		query_task->finish = async_task->dsp_req.d2h_msg.return_value;
+		kernel_handle_release_family(&async_task->handle);
+		kernel_handle_decref(&async_task->handle);
+	} else if (query_task->block != 0) {
+		goto again;
+	}
+
+err_int:
+	kernel_handle_decref(task_handle);
+	return ret;
+}
+
+static long dsp_ioctl_query_tsk(struct file *flip,
+				dsp_ioctl_query_s __user *arg)
+{
+	int ret;
+	dsp_ioctl_query_s query_task;
+
+	if (copy_from_user(&query_task, arg, sizeof(dsp_ioctl_query_s))) {
+		ret = -EINVAL;
+		return ret;
+	}
+	ret = dsp_query_task(flip, &query_task);
+	if (copy_to_user(arg, &query_task, sizeof(dsp_ioctl_query_s))) {
+		ret = -EINVAL;
+	}
+	return ret;
+}
+
+static void dsp_release_user_completed_task(struct dsp_file *dsp_file)
+{
+	struct dsp_user_req_async *tmp = NULL, *async_task = NULL;
+	unsigned long flags;
+	struct list_head *tmp_list;
+	spin_lock_irqsave(&dsp_file->async_ll_lock, flags);
+	list_for_each_entry_safe(async_task, tmp, &dsp_file->async_ll_complete,
+				 async_ll) {
+		spin_unlock_irqrestore(&dsp_file->async_ll_lock, flags);
+		list_del_init(&async_task->async_ll);
+		kernel_handle_decref(&async_task->handle);
+		spin_lock_irqsave(&dsp_file->async_ll_lock, flags);
+	}
+	spin_unlock_irqrestore(&dsp_file->async_ll_lock, flags);
+}
+
+static long dsp_ioctl_unload_op(struct file *flip, void *arg)
+{
+	int fd;
+	struct dsp_file *dsp_file = (struct dsp_file *)flip->private_data;
+	struct dsp_user *user;
+
+	if (copy_from_user(&fd, arg, sizeof(fd))) {
+		dsp_err("%s, %d, copy_from_user err.\n", __func__, __LINE__);
+		return -EINVAL;
+	}
+	dsp_debug("", __func__, __LINE__);
+	user = dsp_find_user_by_fd(dsp_file, fd);
+	if (user == NULL) {
+		dsp_debug("%s, %d, cannot find user fd=%d.\n", __func__,
+			  __LINE__, fd);
+		return -EINVAL;
+	}
+	kernel_handle_release_family(&user->h);
+	kernel_handle_decref(&user->h);
+	dsp_debug("%s, %d, done.\n", __func__, __LINE__);
+	return 0;
+}
+
+static void dsp_dma_buf_release(struct khandle *h)
+{
+	struct dsp_dma_buf_ex *entry =
+		container_of(h, struct dsp_dma_buf_ex, handle);
+	struct dsp_file *dsp_file = entry->buf.dsp_file;
+	struct es_dsp *dsp = dsp_file->dsp;
+
+	dsp_put_dma_addr(dsp, &entry->buf);
+	dsp_debug("%s, %d, fd=0x%x, iova=0x%x.\n", __func__, __LINE__,
+		  entry->buf.fd, entry->buf.dma_addr);
+	kfree(entry);
+}
+
+static long dsp_ioctl_prepare_dma(struct file *flip, dsp_ioctl_pre_dma_s *arg)
+{
+	struct dsp_file *dsp_file = (struct dsp_file *)flip->private_data;
+	struct es_dsp *dsp = dsp_file->dsp;
+	dsp_ioctl_pre_dma_s buf;
+	struct dsp_dma_buf_ex *entry, *tmp;
+	struct khandle *khandle;
+	u32 addr;
+	int ret;
+
+	if (copy_from_user(&buf, arg, sizeof(buf))) {
+		dsp_err("%s, %d, copy from user err.\n", __func__, __LINE__);
+		return -EINVAL;
+	}
+	mutex_lock(&dsp_file->xrray_lock);
+	entry = xa_load(&dsp_file->buf_xrray, (int)buf.desc.memFd);
+	if (entry) {
+		khandle = find_kernel_handle(&dsp_file->h, entry->handle.fd,
+					     DSP_DMABUF_HANDLE_MAGIC);
+		BUG_ON(khandle == NULL);
+		dsp_debug("%s, %d, find %d entry, handle fd=%d.\n", __func__,
+			  __LINE__, entry->buf.fd, entry->handle.fd);
+		entry->count++;
+		kernel_handle_decref(khandle);
+		mutex_unlock(&dsp_file->xrray_lock);
+		return 0;
+	}
+
+	entry = kzalloc(sizeof(struct dsp_dma_buf_ex), GFP_KERNEL);
+	if (!entry) {
+		dsp_err("%s, %d, alloc memory for device dma buf err.\n",
+			__func__, __LINE__);
+		mutex_unlock(&dsp_file->xrray_lock);
+		return -ENOMEM;
+	}
+
+	ret = init_kernel_handle(&entry->handle, dsp_dma_buf_release,
+				 DSP_DMABUF_HANDLE_MAGIC, &dsp_file->h);
+	if (ret) {
+		dsp_err("%s, %d, init kernel handle err.\n", __func__,
+			__LINE__);
+		kfree(entry);
+		mutex_unlock(&dsp_file->xrray_lock);
+		return ret;
+	}
+
+	dsp_debug("%s, %d, handle_fd=%d.\n", __func__, __LINE__,
+		  entry->handle.fd);
+	addr = dsp_get_dma_addr(dsp, (int)buf.desc.memFd, &entry->buf);
+	if (addr == 0) {
+		dsp_err("%s, %d, addr err.\n", __func__, __LINE__);
+		ret = -ENODEV;
+		goto err;
+	}
+	entry->offset = buf.desc.offset;
+	entry->buf.dsp_file = dsp_file;
+	entry->buf.fd = (int)buf.desc.memFd;
+	xa_store(&dsp_file->buf_xrray, (int)buf.desc.memFd, entry, GFP_KERNEL);
+
+	kernel_handle_decref(&entry->handle);
+	entry->count = 1;
+	mutex_unlock(&dsp_file->xrray_lock);
+
+	dsp_debug("%s,%d, fd=0x%x, buf_desc_fd=%d,  dma_addr=0x%x.\n", __func__,
+		  __LINE__, entry->buf.fd, buf.desc.memFd, entry->buf.dma_addr);
+
+	return 0;
+err:
+	kernel_handle_release_family(&entry->handle);
+	kernel_handle_decref(&entry->handle);
+	mutex_unlock(&dsp_file->xrray_lock);
+
+	return ret;
+}
+static long dsp_ioctl_unprepare_dma(struct file *flip, u32 *arg)
+{
+	u32 fd;
+	struct dsp_file *dsp_file = (struct dsp_file *)flip->private_data;
+	struct dsp_dma_buf_ex *entry;
+	struct khandle *khandle;
+	dsp_debug("%s, %d.\n", __func__, __LINE__);
+
+	if (copy_from_user(&fd, arg, sizeof(fd))) {
+		dsp_err("%s, %d, copy from user err.\n", __func__, __LINE__);
+		return -EINVAL;
+	}
+	mutex_lock(&dsp_file->xrray_lock);
+	entry = xa_load(&dsp_file->buf_xrray, fd);
+	if (!entry) {
+		dsp_err("%s,%d, cannot find %d dmabuf entry.\n", __func__,
+			__LINE__, fd);
+		mutex_unlock(&dsp_file->xrray_lock);
+		return -EINVAL;
+	}
+	BUG_ON(entry->count <= 0);
+	entry->count--;
+	if (entry->count) {
+		mutex_unlock(&dsp_file->xrray_lock);
+		return 0;
+	}
+	dsp_debug("%s, %d, entry->fd=%d.\n\n", __func__, __LINE__,
+		  entry->buf.fd);
+	khandle = find_kernel_handle(&dsp_file->h, entry->handle.fd,
+				     DSP_DMABUF_HANDLE_MAGIC);
+
+	BUG_ON(!khandle);
+	xa_erase(&dsp_file->buf_xrray, entry->buf.fd);
+	kernel_handle_release_family(khandle);
+	kernel_handle_decref(khandle);
+	mutex_unlock(&dsp_file->xrray_lock);
+	return 0;
+}
+
+static long dsp_ioctl_enable_perf(struct file *flip, u32 *arg)
+{
+	struct dsp_file *dsp_file = flip->private_data;
+	struct es_dsp *dsp = dsp_file->dsp;
+
+	if (copy_from_user(&dsp->perf_enable, arg, sizeof(dsp->perf_enable))) {
+		dsp_err("%s, %d, copy from user err.\n", __func__, __LINE__);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static long dsp_ioctl_get_perf_data(struct file *flip, dsp_kmd_perf_t *data)
+{
+	int ret = 0;
+
+	struct dsp_file *dsp_file = flip->private_data;
+	struct es_dsp *dsp = dsp_file->dsp;
+
+	if (copy_to_user(data, dsp->op_perf,
+			 sizeof(dsp_kmd_perf_t) * MAX_DSP_TASKS)) {
+		dsp_err("copy perf data to user err.\n");
+		ret = -EINVAL;
+	}
+	dsp_debug("get dsp kmd perf data done.\n");
+
+	return ret;
+}
+
+extern void get_dsp_perf_info(es_dsp_perf_info *perf_info, int die_num,
+			      int dsp_num);
+
+static long dsp_ioctl_get_fw_perf_data(struct file *flip, dsp_fw_perf_t *data)
+{
+	int ret = 0;
+
+	struct dsp_file *dsp_file = flip->private_data;
+	struct es_dsp *dsp = dsp_file->dsp;
+	es_dsp_perf_info perf_info;
+
+	get_dsp_perf_info(&perf_info, 0, 0);
+
+	dsp->op_fw_perf[0].Die = 0;
+	dsp->op_fw_perf[0].CoreId = perf_info.core_id;
+	dsp->op_fw_perf[0].OpIndex = perf_info.op_index;
+	dsp->op_fw_perf[0].OpType = perf_info.op_type;
+	// dsp->op_fw_perf[0].OpName = "";
+	dsp->op_fw_perf[0].OpStartCycle = perf_info.flat1_start_time;
+	dsp->op_fw_perf[0].OpPrepareStartCycle = perf_info.prepare_start_time;
+	dsp->op_fw_perf[0].OpPrepareEndCycle = perf_info.prepare_end_time;
+	dsp->op_fw_perf[0].OpEvalStartCycle = perf_info.eval_start_time;
+	dsp->op_fw_perf[0].OpEvalEndCycle = perf_info.eval_end_time;
+	dsp->op_fw_perf[0].OpNotifyStartCycle = perf_info.notify_start_time;
+	dsp->op_fw_perf[0].OpEndCycle = perf_info.flat1_end_time;
+
+	if (copy_to_user(data, dsp->op_fw_perf,
+			 sizeof(dsp_fw_perf_t) * MAX_DSP_TASKS)) {
+		dsp_err("copy perf data to user err.\n");
+		ret = -EINVAL;
+	}
+	dsp_debug("get dsp%u hardware perf data done.\n", perf_info.op_index);
+
+	return ret;
+}
+
+static long dsp_ioctl(struct file *flip, unsigned int cmd, unsigned long arg)
+{
+	long retval;
+
+	switch (cmd) {
+	case DSP_IOCTL_LOAD_OP:
+		retval = dsp_ioctl_load_op(flip, (dsp_ioctl_load_s *)arg);
+		break;
+	case DSP_IOCTL_UNLOAD_OP:
+		retval = dsp_ioctl_unload_op(flip, arg);
+		break;
+	case DSP_IOCTL_SUBMIT_TSK_ASYNC:
+		retval = dsp_ioctl_submit_tsk_async(
+			flip, (dsp_ioctl_task_s __user *)arg);
+		break;
+	case DSP_IOCTL_PROCESS_REPORT:
+		retval = dsp_ioctl_process_complete_task(
+			flip, (dsp_ioctl_async_process_s __user *)arg);
+		break;
+	case DSP_IOCTL_QUERY_TASK:
+		retval = dsp_ioctl_query_tsk(flip,
+					     (dsp_ioctl_query_s __user *)arg);
+		break;
+	case DSP_IOCTL_PREPARE_DMA:
+		retval = dsp_ioctl_prepare_dma(
+			flip, (dsp_ioctl_pre_dma_s __user *)arg);
+		break;
+	case DSP_IOCTL_UNPREPARE_DMA:
+		retval = dsp_ioctl_unprepare_dma(flip, (u32 __user *)arg);
+		break;
+	case DSP_IOCTL_ENABLE_PERF:
+		retval = dsp_ioctl_enable_perf(flip, (u32 __user *)arg);
+		break;
+	case DSP_IOCTL_GET_PERF_DATA:
+		retval = dsp_ioctl_get_perf_data(flip,
+						 (dsp_kmd_perf_t __user *)arg);
+		break;
+	case DSP_IOCTL_GET_FW_PERF_DATA:
+		retval = dsp_ioctl_get_fw_perf_data(
+			flip, (dsp_fw_perf_t __user *)arg);
+		break;
+	default:
+		retval = es_dsp_hw_ioctl(flip, cmd, arg);
+		break;
+	}
+	return retval;
+}
+
+static void dsp_file_release(struct khandle *handle)
+{
+	struct dsp_file *dsp_file = container_of(handle, struct dsp_file, h);
+	struct es_dsp *dsp;
+
+	if (!dsp_file) {
+		return;
+	}
+
+	dsp = dsp_file->dsp;
+	devm_kfree(dsp->dev, dsp_file);
+	es_dsp_pm_put_sync(dsp);
+	dsp_debug("release dsp_file done.\n");
+}
+
+static int dsp_open(struct inode *inode, struct file *flip)
+{
+	struct es_dsp *dsp =
+		container_of(flip->private_data, struct es_dsp, miscdev);
+	struct dsp_file *dsp_file;
+	int ret;
+
+	dsp_info("%s %d, pid %d\n", __func__, __LINE__, current->pid);
+
+	ret = es_dsp_pm_get_sync(dsp);
+	if (ret < 0) {
+		dsp_err("%s, %d, pm get sync err, ret=%d.\n", __func__, __LINE__, ret);
+		return ret;
+	}
+	dsp_file = devm_kzalloc(dsp->dev, sizeof(*dsp_file), GFP_KERNEL);
+	if (!dsp_file) {
+		es_dsp_pm_put_sync(dsp);
+		return -ENOMEM;
+	}
+
+	ret = init_kernel_handle(&dsp_file->h, dsp_file_release,
+				 DSP_FILE_HANDLE_MAGIC, NULL);
+	if (ret != 0) {
+		dsp_err("%s, init kernel handle error.\n", __func__);
+		devm_kfree(dsp->dev, dsp_file);
+		es_dsp_pm_put_sync(dsp->dev);
+		return ret;
+	}
+	INIT_LIST_HEAD(&dsp_file->async_ll_complete);
+	spin_lock_init(&dsp_file->async_ll_lock);
+	init_waitqueue_head(&dsp_file->async_ll_wq);
+	mutex_init(&dsp_file->xrray_lock);
+	xa_init(&dsp_file->buf_xrray);
+
+	dsp_file->dsp = dsp;
+	flip->private_data = dsp_file;
+	kernel_handle_decref(&dsp_file->h);
+	return 0;
+}
+
+static int dsp_close(struct inode *inode, struct file *flip)
+{
+	struct dsp_file *dsp_file = flip->private_data;
+	struct es_dsp *dsp;
+
+	if (!dsp_file) {
+		return 0;
+	}
+
+	dsp = dsp_file->dsp;
+	dsp_info("%s %d, pid %d\n", __func__, __LINE__, current->pid);
+	mutex_lock(&dsp_file->xrray_lock);
+	xa_destroy(&dsp_file->buf_xrray);
+	mutex_unlock(&dsp_file->xrray_lock);
+
+	kernel_handle_addref(&dsp_file->h);
+	kernel_handle_release_family(&dsp_file->h);
+	dsp_release_user_completed_task(dsp_file);
+	kernel_handle_decref(&dsp_file->h);
+
+	flip->private_data = NULL;
+	dsp_info("%s, close done.\n", __func__);
+	return 0;
+}
+
+#ifdef CONFIG_COMPAT
+static long dsp_ioctl_compat(struct file *flip, unsigned int cmd,
+			     unsigned long arg)
+{
+	return dsp_ioctl(flip, cmd, (unsigned long)compat_ptr(arg));
+}
+#endif
+
+static unsigned int dsp_poll(struct file *flip, poll_table *wait)
+{
+	struct dsp_file *dsp_file = flip->private_data;
+
+	if (!dsp_file) {
+		return EPOLLERR;
+	}
+
+	poll_wait(flip, &dsp_file->async_ll_wq, wait);
+
+	if (!list_empty_careful(&dsp_file->async_ll_complete)) {
+		return EPOLLIN;
+	}
+	return 0;
+}
+
+const struct file_operations dsp_fops = {
+	.owner = THIS_MODULE,
+	.llseek = no_llseek,
+	.unlocked_ioctl = dsp_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl = dsp_ioctl_compat,
+#endif
+	.poll = dsp_poll,
+	.open = dsp_open,
+	.release = dsp_close,
+};
diff --git a/drivers/soc/eswin/ai_driver/dsp/dsp_ioctl.h b/drivers/soc/eswin/ai_driver/dsp/dsp_ioctl.h
new file mode 100644
index 000000000000..59a21dcd13ce
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/dsp/dsp_ioctl.h
@@ -0,0 +1,51 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#ifndef _DSP_IOCTL_DEFS_H
+#define _DSP_IOCTL_DEFS_H
+
+#include "eswin-khandle.h"
+#include "dsp_ioctl_if.h"
+#include "dsp_hw_if.h"
+struct es_dsp;
+
+#define OPERATOR_DIR_MAXLEN 512
+
+struct dsp_ioctl_alloc {
+	u32 size;
+	u32 align;
+	u64 addr;
+	u64 dev_addr;
+	u64 dbuf_fd;
+	u64 dbuf_phys;
+};
+
+struct dsp_ioctl_task {
+	es_dsp_h2d_msg msg;
+	u32 flat_size;
+} __attribute__((packed));
+
+struct dsp_file {
+	struct es_dsp *dsp;
+	/* async_ll_complete and async_ll_lock can only for low level interface*/
+	struct list_head async_ll_complete;
+	spinlock_t async_ll_lock;
+	wait_queue_head_t async_ll_wq;
+	struct dsp_ioctl_alloc *ioctl_alloc;
+	struct mutex xrray_lock;
+	struct xarray buf_xrray;
+	struct khandle h;
+};
+
+enum {
+	DSP_FLAG_READ = 0x1,
+	DSP_FLAG_WRITE = 0x2,
+	DSP_FLAG_READ_WRITE = 0x3,
+};
+
+extern const struct file_operations dsp_fops;
+#endif
diff --git a/drivers/soc/eswin/ai_driver/dsp/dsp_ioctl_if.h b/drivers/soc/eswin/ai_driver/dsp/dsp_ioctl_if.h
new file mode 100644
index 000000000000..76a88f2399dc
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/dsp/dsp_ioctl_if.h
@@ -0,0 +1,85 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#ifndef ESWIN_COMMON_DSP_IOCTL_IF_H_
+#define ESWIN_COMMON_DSP_IOCTL_IF_H_
+
+#include "es_type.h"
+#include "es_dsp_types.h"
+
+#define ES_DSP_IOCTL_MAGIC 'e'
+#define DSP_IOCTL_ALLOC _IO(ES_DSP_IOCTL_MAGIC, 1)
+#define DSP_IOCTL_FREE _IO(ES_DSP_IOCTL_MAGIC, 2)
+#define DSP_IOCTL_QUEUE _IO(ES_DSP_IOCTL_MAGIC, 3)
+#define DSP_IOCTL_QUEUE_NS _IO(ES_DSP_IOCTL_MAGIC, 4)
+#define DSP_IOCTL_IMPORT _IO(ES_DSP_IOCTL_MAGIC, 5)
+#define DSP_IOCTL_ALLOC_COHERENT _IO(ES_DSP_IOCTL_MAGIC, 6)
+#define DSP_IOCTL_FREE_COHERENT _IO(ES_DSP_IOCTL_MAGIC, 7)
+#define DSP_IOCTL_REG_TASK _IO(ES_DSP_IOCTL_MAGIC, 8)
+#define DSP_IOCTL_TEST_INFO _IO(ES_DSP_IOCTL_MAGIC, 9)
+#define DSP_IOCTL_DMA_TEST _IO(ES_DSP_IOCTL_MAGIC, 10)
+#define DSP_IOCTL_LOAD_OP _IO(ES_DSP_IOCTL_MAGIC, 11)
+#define DSP_IOCTL_UNLOAD_OP _IO(ES_DSP_IOCTL_MAGIC, 12)
+#define DSP_IOCTL_SUBMIT_TSK _IO(ES_DSP_IOCTL_MAGIC, 13)
+#define DSP_IOCTL_WAIT_IRQ _IO(ES_DSP_IOCTL_MAGIC, 14)
+#define DSP_IOCTL_SEND_ACK _IO(ES_DSP_IOCTL_MAGIC, 15)
+#define DSP_IOCTL_QUERY_TASK _IO(ES_DSP_IOCTL_MAGIC, 16)
+#define DSP_IOCTL_SUBMIT_TSK_ASYNC _IO(ES_DSP_IOCTL_MAGIC, 17)
+#define DSP_IOCTL_GET_CMA_INFO _IO(ES_DSP_IOCTL_MAGIC, 18)
+#define DSP_IOCTL_PROCESS_REPORT _IO(ES_DSP_IOCTL_MAGIC, 19)
+#define DSP_IOCTL_PREPARE_DMA _IO(ES_DSP_IOCTL_MAGIC, 20)
+#define DSP_IOCTL_UNPREPARE_DMA _IO(ES_DSP_IOCTL_MAGIC, 21)
+#define DSP_IOCTL_ENABLE_PERF _IO(ES_DSP_IOCTL_MAGIC, 22)
+#define DSP_IOCTL_GET_PERF_DATA _IO(ES_DSP_IOCTL_MAGIC, 23)
+#define DSP_IOCTL_GET_FW_PERF_DATA _IO(ES_DSP_IOCTL_MAGIC, 24)
+
+typedef struct dsp_ioctl_pre_dma_t {
+    ES_DEV_BUF_S desc;
+} __attribute__((packed)) dsp_ioctl_pre_dma_s;
+
+typedef struct dsp_ioctl_load_t {
+    ES_S32 dspId;
+    ES_U64 op_name;
+    ES_U64 op_lib_dir;
+    ES_DSP_HANDLE op_handle;
+} __attribute__((packed)) dsp_ioctl_load_s;
+
+typedef struct dsp_ioctl_unload_t {
+    ES_S32 dspId;
+    ES_DSP_HANDLE op_handle;
+} __attribute__((packed)) dsp_ioctl_unload_s;
+
+typedef struct dsp_ioctl_task_t {
+    ES_DSP_TASK_S task;
+    ES_S32 result;
+} __attribute__((packed)) dsp_ioctl_task_s;
+
+typedef struct dsp_ioctl_query_t {
+    ES_S32 dspId;
+    ES_S32 finish;
+    ES_BOOL block;
+    ES_DSP_HANDLE task_handle;
+} __attribute__((packed)) dsp_ioctl_query_s;
+
+typedef struct dsp_task_status {
+    ES_U64 callback;
+    ES_U64 cbArg;
+    ES_S32 finish;
+} __attribute__((packed)) dsp_task_status_s;
+
+struct dsp_cma_info {
+    ES_U64 base;
+    ES_U32 size;
+} __attribute__((packed));
+
+typedef struct dsp_ioctl_async_process_t {
+    ES_S32 timeout;
+    ES_U32 task_num;
+    ES_U32 return_num;
+    ES_U64 task;
+} __attribute__((packed)) dsp_ioctl_async_process_s;
+#endif  // ESWIN_COMMON_DSP_IOCTL_IF_H_
diff --git a/drivers/soc/eswin/ai_driver/dsp/dsp_log.c b/drivers/soc/eswin/ai_driver/dsp/dsp_log.c
new file mode 100644
index 000000000000..4ade1bc6d6db
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/dsp/dsp_log.c
@@ -0,0 +1,25 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#include <linux/module.h>
+#include "dsp_log.h"
+
+#if BUILD_RELEASE == 1
+int dsp_log_level = LOG_ERROR;
+#else
+#if DEBUG_LEVEL == 1
+int dsp_log_level = LOG_ERROR;
+#elif DEBUG_LEVEL == 2
+int dsp_log_level = LOG_INFO;
+#else
+int dsp_log_level = LOG_DEBUG;
+#endif
+#endif
+
+module_param(dsp_log_level, int, 0644);
+MODULE_PARM_DESC(dsp_log_level,
+		 "Log level (0:DISABLE 1: ERROR, 2: INFO, 3: DEBUG)");
diff --git a/drivers/soc/eswin/ai_driver/dsp/dsp_log.h b/drivers/soc/eswin/ai_driver/dsp/dsp_log.h
new file mode 100644
index 000000000000..ba9dd92d26f8
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/dsp/dsp_log.h
@@ -0,0 +1,32 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+
+#define LOG_ERROR 1
+#define LOG_WARNING 2
+#define LOG_INFO 3
+#define LOG_DEBUG 4
+
+extern int dsp_log_level;
+
+#define dsp_log(level, fmt, ...)                                          \
+	do {                                                              \
+		if (level <= dsp_log_level)                               \
+			printk(KERN_INFO "[DSP][Driver][%s](%s:%d) " fmt, \
+			       level == LOG_ERROR   ? "ERROR" :           \
+			       level == LOG_WARNING ? "WARNING" :         \
+			       level == LOG_INFO    ? "INFO" :            \
+							    "DEBUG",               \
+			       __func__, __LINE__, ##__VA_ARGS__);        \
+	} while (0)
+
+#define dsp_err(fmt, ...) dsp_log(LOG_ERROR, fmt, ##__VA_ARGS__)
+#define dsp_warning(fmt, ...) dsp_log(LOG_WARNING, fmt, ##__VA_ARGS__)
+#define dsp_info(fmt, ...) dsp_log(LOG_INFO, fmt, ##__VA_ARGS__)
+#define dsp_debug(fmt, ...) dsp_log(LOG_DEBUG, fmt, ##__VA_ARGS__)
diff --git a/drivers/soc/eswin/ai_driver/dsp/dsp_mailbox.h b/drivers/soc/eswin/ai_driver/dsp/dsp_mailbox.h
new file mode 100644
index 000000000000..6694b8b52ce3
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/dsp/dsp_mailbox.h
@@ -0,0 +1,44 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#ifndef ESWIN_DSP_COMMON_MAILBOX_H_
+#define ESWIN_DSP_COMMON_MAILBOX_H_
+
+#define ESWIN_MAILBOX_DSP_TO_E31_REG_BASE 0xfffb9000 /*mailbox 4*/
+#define ESWIN_MAILBOX_U84_TO_DSP_REG_BASE 0xfffd0000 /*mailbox 8*/
+#define ESWIN_MAILBOX_DSP_TO_U84_REG_BASE 0xfffe0000 /*mailbox 9*/
+
+#define ESWIN_MAILBOX_DSP_TO_E31_BIT_BASE 4
+#define ESWIN_MAILBOX_DSP_TO_U84_BIT_BASE 5
+
+#define BIT0 (1 << 0)
+#define BIT1 (1 << 1)
+#define BIT2 (1 << 2)
+#define BIT3 (1 << 3)
+#define BIT4 (1 << 4)
+#define BIT5 (1 << 5)
+#define BIT6 (1 << 6)
+#define BIT7 (1 << 7)
+#define BIT8 (1 << 8)
+#define BIT9 (1 << 9)
+#define BIT10 (1 << 10)
+#define BIT11 (1 << 11)
+#define BIT12 (1 << 12)
+#define BIT13 (1 << 13)
+#define BIT14 (1 << 14)
+#define BIT31 ((uint32_t)1 << 31)
+
+#define ESWIN_MBOX_WR_DATA0 0x00
+#define ESWIN_MBOX_WR_DATA1 0x04
+#define ESWIN_MBOX_RD_DATA0 0x08
+#define ESWIN_MBOX_RD_DATA1 0x0C
+#define ESWIN_MBOX_FIFO_STATUS 0x10
+#define ESWIN_MBOX_MB_ERR 0x14
+#define ESWIN_MBOX_INT_CTRL 0x18
+#define ESWIN_MBOX_WR_LOCK 0x1C
+
+#endif  // ESWIN_DSP_COMMON_MAILBOX_H_
diff --git a/drivers/soc/eswin/ai_driver/dsp/dsp_main.c b/drivers/soc/eswin/ai_driver/dsp/dsp_main.c
new file mode 100644
index 000000000000..1fa928df25c2
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/dsp/dsp_main.c
@@ -0,0 +1,1155 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#include <linux/version.h>
+#include <linux/atomic.h>
+#include <linux/acpi.h>
+#include <linux/completion.h>
+#include <linux/delay.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0)
+#include <linux/dma-mapping.h>
+#else
+#include <linux/dma-direct.h>
+#endif
+#include <linux/firmware.h>
+#include <linux/fs.h>
+#include <linux/idr.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/mman.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 12, 0)
+#include <linux/of_reserved_mem.h>
+#endif
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/property.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/sort.h>
+#include <asm/mman.h>
+#include <asm/uaccess.h>
+#include <asm/current.h>
+#include <linux/dmapool.h>
+#include <linux/debugfs.h>
+#include <uapi/asm-generic/siginfo.h>
+#include <linux/mailbox/eswin-mailbox.h>
+#include <linux/dma-mapping.h>
+#include "eswin-khandle.h"
+
+#include "dsp_main.h"
+#include "dsp_hw.h"
+#include "dsp_ioctl.h"
+#include "dsp_platform.h"
+#include "dsp_proc.h"
+
+#define MAX_NUM_PER_DIE 4
+#define DRIVER_NAME "eswin-dsp"
+#define DSP_SUBSYS_HILOAD_CLK 1040000000
+#define DSP_SUBSYS_LOWLOAD_CLK 5200000
+
+#define ES_DSP_DEFAULT_TIMEOUT (100 * 2)
+
+#ifdef DEBUG
+#pragma GCC optimize("O0")
+#endif
+
+int dsp_boot_firmware(struct es_dsp *dsp);
+
+static int fw_timeout = ES_DSP_DEFAULT_TIMEOUT;
+module_param(fw_timeout, int, 0644);
+MODULE_PARM_DESC(fw_timeout, "Firmware command timeout in seconds.");
+
+enum {
+	LOOPBACK_NORMAL, /* normal work mode */
+	LOOPBACK_NOIO, /* don't communicate with FW, but still load it and control DSP */
+	LOOPBACK_NOMMIO, /* don't comminicate with FW or use DSP MMIO, but still load the FW */
+	LOOPBACK_NOFIRMWARE, /* don't communicate with FW or use DSP MMIO, don't load the FW */
+};
+static int loopback = LOOPBACK_NORMAL;
+module_param(loopback, int, 0644);
+MODULE_PARM_DESC(loopback, "Don't use actual DSP, perform everything locally.");
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 13, 0)
+#define devm_kmalloc devm_kzalloc
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 15, 0)
+#define devm_kstrdup dsp_devm_kstrdup
+static char *dsp_devm_kstrdup(struct device *dev, const char *s, gfp_t gfp)
+{
+	size_t size;
+	char *buf;
+
+	if (!s)
+		return NULL;
+
+	size = strlen(s) + 1;
+	buf = devm_kmalloc(dev, size, gfp);
+	if (buf)
+		memcpy(buf, s, size);
+	return buf;
+}
+#endif
+
+int es_dsp_exec_cmd_timeout(void)
+{
+	return fw_timeout;
+}
+
+static void __dsp_enqueue_task(struct es_dsp *dsp, dsp_request_t *req)
+{
+	struct prio_array *array = &dsp->array;
+	unsigned long flags;
+
+	list_add_tail(&req->pending_list, &array->queue[req->prio]);
+	set_bit(req->prio, array->bitmap);
+	dsp->wait_running++;
+	array->queue_task_num[req->prio]++;
+}
+
+static void __dsp_dequeue_task(struct es_dsp *dsp)
+{
+	struct prio_array *array = &dsp->array;
+	int idx;
+	struct list_head *queue;
+	dsp_request_t *req;
+
+	BUG_ON(dsp->current_task != NULL);
+	idx = sched_find_first_bit(array->bitmap);
+	if (idx >= DSP_MAX_PRIO) {
+		return;
+	}
+	queue = &array->queue[idx];
+	req = list_entry(queue->next, dsp_request_t, pending_list);
+	dsp->wait_running--;
+	if (--array->queue_task_num[idx] == 0) {
+		clear_bit(idx, array->bitmap);
+	}
+	list_del(&req->pending_list);
+	dsp->current_task = req;
+	/* Reset retry count. */
+	dsp->task_reboot_cnt = 0;
+}
+
+static void __dsp_send_task(struct es_dsp *dsp)
+{
+	struct dsp_op_desc *opdesc;
+	dsp_request_t *req;
+
+	dsp_debug("%s.\n", __func__);
+
+	req = dsp->current_task;
+	BUG_ON(req == NULL);
+	opdesc = (struct dsp_op_desc *)req->handle;
+	strcpy(dsp->stats->last_op_name, opdesc->name);
+	dsp->send_time = ktime_get_real_ns();
+	dsp->stats->send_to_dsp_cnt++;
+
+	if ((dsp_perf_enable || dsp->perf_enable) &&
+	    dsp->op_idx < MAX_DSP_TASKS) {
+		strcpy(dsp->op_perf[dsp->op_idx].OpName, opdesc->name);
+	}
+
+	if (req->allow_eval) {
+		dsp->task_timer.expires = jiffies + fw_timeout * HZ;
+		BUG_ON(timer_pending(&dsp->task_timer));
+		add_timer(&dsp->task_timer);
+	}
+
+	if ((dsp_perf_enable || dsp->perf_enable) &&
+	    dsp->op_idx < MAX_DSP_TASKS) {
+		dsp->op_perf[dsp->op_idx].OpSendTaskCycle =
+			0;  //get_perf_timer_cnt();
+		dsp_debug("op_idx=%u OpSendTaskCycle=%u\n", dsp->op_idx,
+			  dsp->op_perf[dsp->op_idx].OpSendTaskCycle);
+	}
+	es_dsp_send_irq(dsp->hw_arg, (void *)req);
+}
+
+static void dsp_schedule_task(struct es_dsp *dsp)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&dsp->send_lock, flags);
+	if (dsp->current_task == NULL) {
+		__dsp_dequeue_task(dsp);
+		if (dsp->current_task != NULL) {
+			__dsp_send_task(dsp);
+		}
+	}
+	spin_unlock_irqrestore(&dsp->send_lock, flags);
+}
+
+void dsp_complete_work(struct es_dsp *dsp, dsp_request_t *req)
+{
+	unsigned long flags;
+
+	if (req->d2h_msg.status != 0) {
+		dsp->stats->total_failed_cnt++;
+	} else {
+		dsp->stats->total_ok_cnt++;
+	}
+	if (req->cpl_handler != NULL) {
+		req->cpl_handler(dsp->dev, req);
+	}
+
+	if ((dsp_perf_enable || dsp->perf_enable) &&
+	    dsp->op_idx < MAX_DSP_TASKS) {
+		dsp->op_perf[dsp->op_idx].OpEndCycle =
+			0;  //get_perf_timer_cnt();
+	}
+}
+
+static void es_dsp_drop_pending_task(struct es_dsp *dsp)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&dsp->send_lock, flags);
+	while (true) {
+		dsp_request_t *req;
+		if (dsp->current_task == NULL) {
+			spin_unlock_irqrestore(&dsp->send_lock, flags);
+			break;
+		}
+		req = dsp->current_task;
+		spin_unlock_irqrestore(&dsp->send_lock, flags);
+		req->d2h_msg.status = -EIO;
+		req->d2h_msg.return_value = -ENXIO;
+		dsp_complete_work(dsp, req);
+		spin_lock_irqsave(&dsp->send_lock, flags);
+		dsp->current_task = NULL;
+		__dsp_dequeue_task(dsp);
+	}
+}
+
+static void dsp_process_expire_work(struct work_struct *work)
+{
+	struct es_dsp *dsp = container_of(work, struct es_dsp, expire_work);
+	dsp_request_t *req;
+	unsigned long flags;
+	int ret;
+
+	dsp_err("%s, %d, task timeout.\n", __func__, __LINE__);
+	ret = es_dsp_reboot_core(dsp->hw_arg);
+	if (ret < 0) {
+		dsp_err("reboot dsp core failed.\n");
+		atomic_set(&dsp->reboot_cycle, 0);
+		dsp->off = true;
+	} else {
+		ret = dsp_boot_firmware(dsp);
+		if (ret < 0) {
+			dsp_err("restarting load firmware failed.\n");
+			atomic_set(&dsp->reboot_cycle, 0);
+			dsp->off = true;
+		}
+	}
+
+	if (dsp->off) {
+		es_dsp_drop_pending_task(dsp);
+		return;
+	}
+
+	spin_lock_irqsave(&dsp->send_lock, flags);
+	req = dsp->current_task;
+	BUG_ON(req == NULL);
+	if (dsp->task_reboot_cnt == 3) {
+		dsp->current_task = NULL;
+		spin_unlock_irqrestore(&dsp->send_lock, flags);
+		req->d2h_msg.status = -EIO;
+		req->d2h_msg.return_value = -ENXIO;
+		dsp_err("dsp task timeout 3 times, so cannot do dsp this request work.\n");
+		dsp_complete_work(dsp, req);
+		dsp_schedule_task(dsp);
+	} else {
+		dsp->task_reboot_cnt++;
+		__dsp_send_task(dsp);
+		spin_unlock_irqrestore(&dsp->send_lock, flags);
+	}
+}
+
+static void dsp_task_timer(struct timer_list *timer)
+{
+	struct es_dsp *dsp = container_of(timer, struct es_dsp, task_timer);
+
+	dsp->stats->task_timeout_cnt++;
+	schedule_work(&dsp->expire_work);
+}
+
+irqreturn_t dsp_irq_handler(void *msg_data, struct es_dsp *dsp)
+{
+	dsp_request_t *req;
+	es_dsp_d2h_msg *msg = (es_dsp_d2h_msg *)msg_data;
+	unsigned long flags;
+	struct dsp_file *dsp_file = NULL;
+	int ret = 1;
+
+	dsp->stats->total_int_cnt++;
+	if (msg->status == 0 && msg->return_value == DSP_CMD_READY) {
+		dsp->off = false;
+		wake_up_interruptible_nr(&dsp->hd_ready_wait, 1);
+		dsp_info("%s, this is hardware sync.\n", __func__);
+		return IRQ_HANDLED;
+	}
+
+	spin_lock_irqsave(&dsp->send_lock, flags);
+	req = dsp->current_task;
+	if (req == NULL) {
+		spin_unlock_irqrestore(&dsp->send_lock, flags);
+		dsp_err("error, this irq have no task request.\n");
+		return IRQ_NONE;
+	}
+
+	if (req->allow_eval) {
+		ret = del_timer(&dsp->task_timer);
+		if (!ret) {
+			dsp_err("%s, %d, task is now processing in timer.\n",
+				__func__, __LINE__);
+			spin_unlock_irqrestore(&dsp->send_lock, flags);
+			return IRQ_NONE;
+		}
+	}
+
+	dsp->current_task = NULL;
+	spin_unlock_irqrestore(&dsp->send_lock, flags);
+	BUG_ON(timer_pending(&dsp->task_timer));
+
+	dsp->done_time = ktime_get_real_ns();
+	dsp->stats->last_task_time = dsp->done_time - dsp->send_time;
+
+	req->d2h_msg = *msg;
+	dsp_complete_work(dsp, req);
+
+	dsp_debug("%s, current task req = 0x%px.\n", __func__, req);
+	dsp_info("op name:%s take time:%lld\n", dsp->stats->last_op_name,
+		 dsp->stats->last_task_time);
+
+	dsp_schedule_task(dsp);
+	return IRQ_HANDLED;
+}
+EXPORT_SYMBOL(dsp_irq_handler);
+
+static struct dsp_op_desc *load_oper_to_mem(struct es_dsp *dsp, char *op_dir,
+					    char *op_name)
+{
+	struct dsp_op_desc *op;
+	int len;
+	int ret;
+
+	len = strlen(op_name) + 1;
+	op = kzalloc(sizeof(struct dsp_op_desc) + len, GFP_KERNEL);
+	if (!op) {
+		dsp_err("error alloc operator mem.\n");
+		return NULL;
+	}
+	op->name = (char *)(op + 1);
+	strcpy(op->name, op_name);
+
+	op->dsp = dsp;
+	op->op_dir = op_dir;
+
+	ret = es_dsp_load_op(dsp->hw_arg, (void *)op);
+	if (ret) {
+		dsp_err("error op firmware.\n");
+		goto err_load_firm;
+	}
+	dsp_send_invalid_code_seg(dsp->hw_arg, op);
+	kref_init(&op->refcount);
+	list_add(&op->entry, &dsp->all_op_list);
+	dsp_debug("%s, done.\n", __func__);
+	return op;
+err_load_firm:
+	kfree((void *)op);
+	return NULL;
+}
+
+static struct dsp_op_desc *check_op_list(struct es_dsp *dsp, char *op_name)
+{
+	struct dsp_op_desc *op;
+
+	list_for_each_entry(op, &dsp->all_op_list, entry) {
+		if (strcmp(op->name, op_name) == 0) {
+			dsp_debug("op %s have loaded into memory.\n", op_name);
+			return op;
+		}
+	}
+	return NULL;
+}
+
+static struct dsp_op_desc *dsp_get_op(struct es_dsp *dsp, char *op_dir,
+				      char *op_name)
+{
+	struct dsp_op_desc *op;
+
+	mutex_lock(&dsp->op_list_mutex);
+	op = check_op_list(dsp, op_name);
+	if (op) {
+		kref_get(&op->refcount);
+	} else {
+		dsp_debug("op %s don't have load into mem.\n", op_name);
+		op = load_oper_to_mem(dsp, op_dir, op_name);
+		if (!op) {
+			dsp_err("load operator %s, failed.\n", op_name);
+		}
+	}
+	mutex_unlock(&dsp->op_list_mutex);
+	return op;
+}
+
+int load_operator(struct device *dsp_dev, char *op_dir, char *op_name,
+		  u64 *handle)
+{
+	struct dsp_op_desc *op;
+	struct es_dsp *dsp = dev_get_drvdata(dsp_dev);
+
+	if (!dsp) {
+		dsp_err("load op, dsp device cannot find.\n");
+		return -EIO;
+	}
+
+	op = dsp_get_op(dsp, op_dir, op_name);
+	if (op == NULL) {
+		return -EINVAL;
+	}
+	if (handle) {
+		*handle = (u64)op;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(load_operator);
+
+void dsp_op_release(struct kref *kref)
+{
+	struct dsp_op_desc *op =
+		container_of(kref, struct dsp_op_desc, refcount);
+	struct es_dsp *dsp;
+	if (!op) {
+		dsp_err("%s, op is null, error.\n", __func__);
+		return;
+	}
+	dsp = op->dsp;
+
+	dsp_debug("%s, opname=%s, refcount=%d.\n", __func__, op->name,
+		  kref_read(kref));
+
+	list_del(&op->entry);
+	if (op->op_shared_seg_ptr) {
+		dma_free_coherent(dsp->dev, op->op_shared_seg_size,
+				  op->op_shared_seg_ptr, op->iova_base);
+		op->op_shared_seg_ptr = NULL;
+	}
+
+	kfree((void *)op);
+	dsp_debug("%s, free mem ok.\n", __func__);
+	return;
+}
+
+int unload_operator(struct device *dsp_dev, u64 handle)
+{
+	struct es_dsp *dsp = dev_get_drvdata(dsp_dev);
+	struct dsp_op_desc *op;
+
+	mutex_lock(&dsp->op_list_mutex);
+	op = (struct dsp_op_desc *)handle;
+	kref_put(&op->refcount, dsp_op_release);
+	mutex_unlock(&dsp->op_list_mutex);
+	return 0;
+}
+EXPORT_SYMBOL(unload_operator);
+
+static void dsp_task_work(struct work_struct *work)
+{
+	struct es_dsp *dsp = container_of(work, struct es_dsp, task_work);
+	unsigned long flags;
+
+	while (true) {
+		dsp_request_t *req;
+		struct dsp_user_req_async *user_req;
+		spin_lock_irqsave(&dsp->complete_lock, flags);
+		if (list_empty(&dsp->complete_list)) {
+			break;
+		}
+		req = list_first_entry(&dsp->complete_list, dsp_request_t,
+				       cpl_list);
+		list_del(&req->cpl_list);
+		spin_unlock_irqrestore(&dsp->complete_lock, flags);
+		user_req =
+			container_of(req, struct dsp_user_req_async, dsp_req);
+		if (user_req->req_cpl_handler) {
+			user_req->req_cpl_handler(dsp->dev, req);
+		}
+	}
+	spin_unlock_irqrestore(&dsp->complete_lock, flags);
+}
+
+/* 1. 如果任务已经执行过了prepare，那么就给dsp发送一个消息，去执行eval;
+ * 2. 如果任务没有执行，那么就发送消息，让dsp core去执行prepare和eval，中间prepare执行后，不用等待。
+ */
+
+int start_eval(struct device *dsp_dev, dsp_request_t *req)
+{
+	return 0;
+}
+EXPORT_SYMBOL(start_eval);
+
+void dsp_set_flat_func(struct es_dsp_flat1_desc *flat, u64 handle)
+{
+	struct dsp_op_desc *op;
+
+	op = (struct dsp_op_desc *)handle;
+	memcpy((void *)&flat->funcs, (void *)&op->funcs, sizeof(op->funcs));
+}
+EXPORT_SYMBOL(dsp_set_flat_func);
+/* 把任务提交到dsp的任务队列上排队;
+ * 1. 如果没有任务在运行，那么就运行该任务的prepare，并且告诉dsp core，需要在prepare进行等待，但是prepare不需要发送通知。
+ * 2. 如果有任务在运行，那么就是挂接。
+ */
+
+int submit_task(struct device *dsp_dev, dsp_request_t *req)
+{
+	struct es_dsp *dsp = dev_get_drvdata(dsp_dev);
+	struct dsp_op_desc *op;
+	unsigned long flags;
+
+	if (req->prio >= DSP_MAX_PRIO) {
+		dsp_err("%s, dsp request prio = %d great max prio %d, error.\n",
+			__func__, req->prio, DSP_MAX_PRIO);
+		return -EINVAL;
+	}
+
+	op = (struct dsp_op_desc *)req->handle;
+	if (!op) {
+		dsp_err("%s, handle=0x%llx is invalid.\n", __func__,
+			req->handle);
+		return -EINVAL;
+	}
+	dsp_set_flat_func(req->flat_virt, req->handle);
+	spin_lock_irqsave(&dsp->send_lock, flags);
+	if (dsp->off) {
+		spin_unlock_irqrestore(&dsp->send_lock, flags);
+		dsp_err("es dsp off.\n");
+		return -ENODEV;
+	}
+	__dsp_enqueue_task(dsp, req);
+	spin_unlock_irqrestore(&dsp->send_lock, flags);
+
+	dsp_schedule_task(dsp);
+	dsp_debug("%s, done.\n", __func__);
+	return 0;
+}
+EXPORT_SYMBOL(submit_task);
+
+static struct es_dsp *g_es_dsp[2][4];
+
+struct es_dsp *es_proc_get_dsp(int dieid, int dspid)
+{
+	if (dspid >= 4 || dieid >= 2) {
+		return NULL;
+	}
+
+	return g_es_dsp[dieid][dspid];
+}
+
+/*
+ * input: die_id, dspId, subscrib.
+ * output: dsp_dev.
+ * 注意: 很可能是, npu调用这个接口的时候, 我们的dsp驱动的probe还没有调用.这是可能的.
+ * 所以需要返回EPROBE_DEFED.
+ * */
+
+static int check_device_node_status(u32 die_id, u32 dspid)
+{
+	int ret;
+	struct device_node *node;
+	u32 numa_id, pro_id;
+
+	for_each_compatible_node(node, NULL, "eswin-dsp") {
+		if (of_property_read_u32(node, "numa-node-id", &numa_id)) {
+			dsp_err("%s, failed to get 'numa_id' property.\n",
+				__func__);
+			return -ENODEV;
+		}
+		if (numa_id != die_id) {
+			continue;
+		}
+
+		if (of_property_read_u32(node, "process-id", &pro_id)) {
+			dsp_err("%s, failed to get 'process-id' property\n",
+				__func__);
+			return -ENODEV;
+		}
+
+		if (pro_id != dspid) {
+			continue;
+		}
+
+		if (of_device_is_available(node) == false) {
+			printk("die%d, dsp core %d status is disabled.\n",
+			       die_id, dspid);
+			return -ENODEV;
+		}
+
+		return 0;
+	}
+
+	return -EIO;
+}
+
+int subscribe_dsp_device(u32 die_id, u32 dspId, struct device *subscrib,
+			 struct device **dsp_dev)
+{
+	struct es_dsp *dsp;
+	int ret;
+
+	if (dspId >= 4 || die_id >= 2) {
+		return -EINVAL;
+	}
+	if (!subscrib || !dsp_dev) {
+		return -EINVAL;
+	}
+
+	ret = check_device_node_status(die_id, dspId);
+	if (ret) {
+		return -ENODEV;
+	}
+
+	if (g_es_dsp[die_id][dspId] == NULL) {
+		dsp_err("%s, dsp die %d, dsp_core %d have not register.\n",
+			__func__, die_id, dspId);
+		return -EPROBE_DEFER;
+	}
+	dsp = g_es_dsp[die_id][dspId];
+
+	*dsp_dev = dsp->dev;
+	return 0;
+}
+EXPORT_SYMBOL(subscribe_dsp_device);
+
+int unsubscribe_dsp_device(struct device *subscrib, struct device *dsp_dev)
+{
+	return 0;
+}
+EXPORT_SYMBOL(unsubscribe_dsp_device);
+
+static inline void dsp_reset(struct es_dsp *dsp)
+{
+	es_dsp_reset(dsp->hw_arg);
+}
+
+static inline void dsp_halt(struct es_dsp *dsp)
+{
+	es_dsp_halt(dsp->hw_arg);
+}
+
+static inline void dsp_release(struct es_dsp *dsp)
+{
+	es_dsp_release(dsp->hw_arg);
+}
+
+static inline int dsp_set_rate(struct es_dsp *dsp, unsigned long rate)
+{
+	return es_dsp_set_rate(dsp->hw_arg, rate);
+}
+
+static int dsp_synchronize(struct es_dsp *dsp)
+{
+	return es_dsp_sync(dsp);
+}
+
+int dsp_boot_firmware(struct es_dsp *dsp)
+{
+	int ret;
+
+	dsp_halt(dsp);
+	dsp_reset(dsp);
+	reset_uart_mutex((struct es_dsp_hw *)dsp->hw_arg);
+	dsp->off = true;
+
+	if (dsp->firmware_name) {
+		if (loopback < LOOPBACK_NOFIRMWARE) {
+			ret = dsp_request_firmware(dsp);
+			if (ret < 0)
+				return ret;
+		}
+	}
+	dsp_release(dsp);
+	if (loopback < LOOPBACK_NOIO) {
+		ret = dsp_synchronize(dsp);
+		if (ret < 0) {
+			dsp_halt(dsp);
+			dev_err(dsp->dev,
+				"%s: couldn't synchronize with the DSP core\n",
+				__func__);
+			dsp_err("es dsp device will not use the DSP until the driver is rebound to this device\n");
+			dsp->off = true;
+			return ret;
+		}
+	}
+	return 0;
+}
+
+int dsp_suspend(struct device *dev)
+{
+	struct es_dsp *dsp = dev_get_drvdata(dev);
+	int ret;
+	dev_dbg(dsp->dev, "dsp generic suspend...\n");
+
+	ret = es_dsp_pm_get_sync(dsp);
+	if (ret < 0) {
+		return ret;
+	}
+	es_dsp_hw_uninit(dsp);
+
+	dsp_release_firmware(dsp);
+	dsp_disable_irq(dsp);
+	dsp_halt(dsp);
+
+	pm_runtime_mark_last_busy(dsp->dev);
+	pm_runtime_put_noidle(dsp->dev);
+	win2030_tbu_power(dsp->dev, false);
+	es_dsp_core_clk_disable(dsp);
+	dsp_disable_mbox_clock(dsp);
+	dsp_debug("%s, %d, dsp core%d generic suspend done.\n", __func__, __LINE__, dsp->process_id);
+	return 0;
+}
+
+int dsp_resume(struct device *dev)
+{
+	struct es_dsp *dsp = dev_get_drvdata(dev);
+	int ret;
+	if (dsp->off)
+		goto out;
+
+	dsp_debug("%s, dsp core%d generic resuming..\n\n", __func__,
+		  dsp->process_id);
+
+	ret = dsp_enable_mbox_clock(dsp);
+	if (ret) {
+		dsp_err("dsp resume mbox clock err.\n");
+		return ret;
+	}
+	ret = es_dsp_core_clk_enable(dsp);
+	if (ret < 0) {
+		dev_err(dsp->dev, "couldn't enable DSP\n");
+		goto out;
+	}
+
+	pm_runtime_get_noresume(dsp->dev);
+
+	ret = win2030_tbu_power(dsp->dev, true);
+	if (ret) {
+		dsp_err("%s, %d, tbu power failed.\n", __func__, __LINE__, ret);
+		goto err_tbu_power;
+	}
+	dsp_enable_irq(dsp);
+	ret = es_dsp_hw_init(dsp);
+	if (ret)
+		goto err_hw_init;
+	ret = dsp_boot_firmware(dsp);
+	if (ret < 0) {
+		dsp_err("load firmware failed, ret=%d.\n", ret);
+		goto err_firm;
+	}
+
+	pm_runtime_mark_last_busy(dsp->dev);
+	pm_runtime_put_autosuspend(dsp->dev);
+	dsp_debug("dsp_core%d Generic resume ok, dsp->off=%d.\n", dsp->process_id, dsp->off);
+	return 0;
+err_firm:
+	es_dsp_hw_uninit(dsp);
+err_hw_init:
+	win2030_tbu_power(dsp->dev, false);
+err_tbu_power:
+	es_dsp_core_clk_disable(dsp);
+out:
+	dsp_disable_mbox_clock(dsp);
+	return ret;
+}
+
+int dsp_runtime_suspend(struct device *dev)
+{
+	struct es_dsp *dsp = dev_get_drvdata(dev);
+	dsp_debug("%s, dsp core%d runtime suspend.\n", __func__, dsp->process_id);
+	es_dsp_core_clk_disable(dsp);
+	return 0;
+}
+EXPORT_SYMBOL(dsp_runtime_suspend);
+
+int dsp_runtime_resume(struct device *dev)
+{
+	struct es_dsp *dsp = dev_get_drvdata(dev);
+	int ret = 0;
+
+	if (dsp->off)
+		goto out;
+
+	dsp_debug("%s, dsp core%d runtime resumng.....\n\n", __func__,
+		  dsp->process_id);
+
+	ret = es_dsp_core_clk_enable(dsp);
+	if (ret < 0) {
+		dev_err(dsp->dev, "couldn't enable DSP\n");
+		goto out;
+	}
+	dsp_debug("dsp core%d, runtime resume ok.\n", dsp->process_id);
+out:
+	return ret;
+}
+EXPORT_SYMBOL(dsp_runtime_resume);
+
+/**
+ * Called when opening rate file
+ * @param inode
+ * @param file
+ * @return
+ */
+static int dsp_rate_open(struct inode *inode, struct file *file)
+{
+	file->private_data = inode->i_private;
+	return 0;
+}
+
+/**
+ * Called when reading rate file
+ */
+static ssize_t dsp_rate_read(struct file *flip, char __user *ubuf, size_t cnt,
+			     loff_t *ppos)
+{
+#define RUN_STR_SIZE 11
+	struct es_dsp *dsp = flip->private_data;
+	char buf[RUN_STR_SIZE];
+	int r;
+
+	r = snprintf(buf, RUN_STR_SIZE, "%ld\n", dsp->rate);
+
+	return simple_read_from_buffer(ubuf, cnt, ppos, buf, r);
+}
+/**
+ * Called when writing rate file
+ */
+static ssize_t dsp_rate_write(struct file *flip, const char __user *ubuf,
+			      size_t cnt, loff_t *ppos)
+{
+#define SIZE_SMALL_BUF 256
+	struct es_dsp *dsp = flip->private_data;
+	char buf[SIZE_SMALL_BUF] = { 0 };
+	unsigned ret;
+
+	if (cnt > SIZE_SMALL_BUF)
+		cnt = SIZE_SMALL_BUF - 1;
+
+	if (copy_from_user(&buf, ubuf, cnt))
+		return -EFAULT;
+
+	if (0 == strncmp(buf, "5200000", strlen("5200000"))) {
+		dsp->rate = DSP_SUBSYS_LOWLOAD_CLK; /* FIXME spinlock? */
+	} else if (0 == strncmp(buf, "1040000000", strlen("1040000000"))) {
+		dsp->rate = DSP_SUBSYS_HILOAD_CLK;
+	} else {
+		dev_err(dsp->dev, "invalid rate para %s\n", buf);
+		return -EFAULT;
+	}
+	ret = dsp_set_rate(dsp, dsp->rate);
+	if (0 != ret) {
+		dev_err(dsp->dev, "failed to set rate to %ldHZ", dsp->rate);
+	} else {
+		dev_info(dsp->dev, "set rate to %ldHZ", dsp->rate);
+	}
+	*ppos += cnt;
+
+	return cnt;
+}
+
+static const struct file_operations dsp_rate_fops = {
+	.open = dsp_rate_open,
+	.read = dsp_rate_read,
+	.write = dsp_rate_write,
+	.llseek = generic_file_llseek,
+};
+static int dsp_debug_init(struct es_dsp *dsp)
+{
+	struct dentry *dir, *d;
+	char name[32];
+
+	scnprintf(name, ARRAY_SIZE(name), "dsp_%d", dsp->nodeid);
+
+	dir = debugfs_create_dir(name, NULL);
+	if (IS_ERR(dir))
+		return PTR_ERR(dir);
+
+	d = debugfs_create_file("rate", S_IRUGO | S_IWUSR, dir, dsp,
+				&dsp_rate_fops);
+	if (IS_ERR(d))
+		return PTR_ERR(d);
+
+	dsp->debug_dentry = dir;
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id es_dsp_hw_match[] = {
+	{
+		.compatible = "eswin-dsp",
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, es_dsp_hw_match);
+#endif
+
+static void dsp_init_prio_array(struct es_dsp *dsp)
+{
+	struct prio_array *array = &dsp->array;
+	int i;
+
+	dsp->current_task = NULL;
+	for (i = 0; i < DSP_MAX_PRIO; i++) {
+		INIT_LIST_HEAD(&array->queue[i]);
+		clear_bit(i, array->bitmap);
+		array->queue_task_num[i] = 0;
+	}
+	set_bit(DSP_MAX_PRIO, array->bitmap);
+}
+
+static int es_dsp_hw_probe(struct platform_device *pdev)
+{
+	int ret;
+	char nodename[sizeof("es-dsp") + 3 * sizeof(int)];
+	struct es_dsp *dsp;
+
+	dsp = devm_kzalloc(&pdev->dev,
+			   sizeof(*dsp) + sizeof(struct es_dsp_stats) +
+				   OPERATOR_NAME_MAXLEN,
+			   GFP_KERNEL);
+	if (!dsp) {
+		ret = -ENOMEM;
+		return ret;
+	}
+	dsp->stats = (struct es_dsp_stats *)(dsp + 1);
+	dsp->stats->last_op_name = (char *)((void *)dsp + sizeof(*dsp) +
+					    sizeof(struct es_dsp_stats));
+	dsp->dev = &pdev->dev;
+	dsp->rate = DSP_SUBSYS_HILOAD_CLK;
+	mutex_init(&dsp->lock);
+
+	ret = dsp_alloc_hw(pdev, dsp);
+	if (ret) {
+		return ret;
+	}
+	platform_set_drvdata(pdev, dsp);
+	ret = es_dsp_get_subsys(pdev, dsp);
+	if (ret) {
+		dsp_err("%s, %d, get subsys err, ret=%d.\n", __func__, __LINE__,
+			ret);
+		dsp_free_hw(dsp);
+		return -ENXIO;
+	}
+	ret = dsp_get_resource(pdev, dsp);
+	if (ret) {
+		dsp_err("dsp clock init error.\n");
+		goto err_clk_init;
+	}
+
+	/* setting for DMA check */
+	ret = dma_set_mask(dsp->dev, DMA_BIT_MASK(32));
+	if (ret) {
+		WARN_ON_ONCE(!dsp->dev->dma_mask);
+		goto err_dev;
+	}
+
+	ret = es_dsp_map_resource(dsp);
+	if (ret < 0) {
+		dsp_err("%s, %d, dsp map resource err, ret=%d.\n", __func__, __LINE__, ret);
+		goto err_map_res;
+	}
+	init_waitqueue_head(&dsp->hd_ready_wait);
+	INIT_WORK(&dsp->task_work, dsp_task_work);
+	timer_setup(&dsp->task_timer, dsp_task_timer, 0);
+	dsp->task_timer.expires = 0;
+	spin_lock_init(&dsp->send_lock);
+	dsp_init_prio_array(dsp);
+
+	INIT_LIST_HEAD(&dsp->complete_list);
+	INIT_LIST_HEAD(&dsp->all_op_list);
+	mutex_init(&dsp->op_list_mutex);
+	INIT_WORK(&dsp->expire_work, dsp_process_expire_work);
+	spin_lock_init(&dsp->complete_lock);
+
+	ret = dsp_enable_mbox_clock(dsp);
+	if (ret < 0) {
+		dsp_err("%s, %d, enable mbox clock err, ret = %d.\n", __func__, __LINE__, ret);
+		goto err_mbox_clk;
+	}
+	ret = es_dsp_clk_enable(dsp);
+	if (ret) {
+		dsp_err("%s, %d, clock enbale error.\n", __func__, __LINE__,
+			ret);
+		goto err_dsp_clk;
+	}
+	ret = win2030_tbu_power(dsp->dev, true);
+	if (ret) {
+		dsp_err("%s, %d, tbu power failed.\n", __func__, __LINE__, ret);
+		goto err_tbu_power;
+	}
+
+	ret = es_dsp_hw_init(dsp);
+	if (ret)
+		goto err_hw_init;
+
+	pm_runtime_set_autosuspend_delay(dsp->dev, 5000);
+	pm_runtime_use_autosuspend(dsp->dev);
+	pm_runtime_set_active(dsp->dev);
+	pm_runtime_enable(dsp->dev);
+	pm_runtime_get_noresume(dsp->dev);
+	ret = dsp_boot_firmware(dsp);
+	if (ret < 0) {
+		dsp_err("load firmware failed, ret=%d.\n", ret);
+		goto err_firm;
+	}
+
+	dsp->nodeid = dsp->process_id + dsp->numa_id * MAX_NUM_PER_DIE;
+	sprintf(nodename, "es-dsp%u", dsp->nodeid);
+
+	dsp->miscdev = (struct miscdevice){
+		.minor = MISC_DYNAMIC_MINOR,
+		.name = devm_kstrdup(&pdev->dev, nodename, GFP_KERNEL),
+		.nodename = devm_kstrdup(&pdev->dev, nodename, GFP_KERNEL),
+		.fops = &dsp_fops,
+	};
+
+	ret = misc_register(&dsp->miscdev);
+	if (ret < 0)
+		goto err_pm_disable;
+
+	g_es_dsp[dsp->numa_id][dsp->process_id] = dsp;
+
+	dsp_debug_init(dsp);
+	pm_runtime_mark_last_busy(dsp->dev);
+	pm_runtime_put_autosuspend(dsp->dev);
+
+	dsp_info("%s, probe successful.\n", __func__);
+	return 0;
+
+err_pm_disable:
+err_firm:
+	pm_runtime_put_noidle(dsp->dev);
+	pm_runtime_disable(dsp->dev);
+	pm_runtime_set_suspended(dsp->dev);
+	pm_runtime_dont_use_autosuspend(dsp->dev);
+	es_dsp_hw_uninit(dsp);
+err_hw_init:
+	win2030_tbu_power(dsp->dev, false);
+err_tbu_power:
+	es_dsp_clk_disable(dsp);
+err_dsp_clk:
+	dsp_disable_mbox_clock(dsp);
+err_mbox_clk:
+	es_dsp_unmap_resource(dsp);
+err_map_res:
+	dsp_put_resource(dsp);
+err_dev:
+err_mbx:
+err_clk_init:
+	es_dsp_put_subsys(dsp);
+	dsp_free_hw(dsp);
+	dev_err(&pdev->dev, "%s: ret = %d\n", __func__, ret);
+	return ret;
+}
+
+static int es_dsp_hw_remove(struct platform_device *pdev)
+{
+	struct es_dsp *dsp = platform_get_drvdata(pdev);
+	int ret;
+
+	if (!dsp)
+		return 0;
+	dsp->off = true;
+	debugfs_remove_recursive(dsp->debug_dentry);
+
+	g_es_dsp[dsp->numa_id][dsp->process_id] = NULL;
+
+	if (NULL != dsp->miscdev.this_device) {
+		misc_deregister(&dsp->miscdev);
+	}
+	es_dsp_hw_uninit(dsp);
+
+	pm_runtime_disable(dsp->dev);
+	pm_runtime_set_suspended(dsp->dev);
+	pm_runtime_dont_use_autosuspend(dsp->dev);
+	dsp_release_firmware(dsp);
+
+	dsp_halt(dsp);
+
+	win2030_tbu_power(dsp->dev, false);
+
+	es_dsp_clk_disable(dsp);
+	dsp_disable_mbox_clock(dsp);
+	es_dsp_unmap_resource(dsp);
+	dsp_put_resource(dsp);
+	es_dsp_put_subsys(dsp);
+	dsp_free_hw(dsp);
+	return 0;
+}
+
+
+static const struct dev_pm_ops es_dsp_hw_pm_ops = {
+	SYSTEM_SLEEP_PM_OPS(dsp_suspend, dsp_resume)
+	SET_RUNTIME_PM_OPS(dsp_runtime_suspend, dsp_runtime_resume, NULL) };
+
+static struct platform_driver es_dsp_hw_driver = {
+	.probe   = es_dsp_hw_probe,
+	.remove  = es_dsp_hw_remove,
+	.driver  = {
+		.name = DRIVER_NAME,
+		.of_match_table = of_match_ptr(es_dsp_hw_match),
+		.pm = &es_dsp_hw_pm_ops,
+	},
+};
+
+static int __init es_dsp_module_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&es_dsp_hw_driver);
+	if (ret) {
+		dsp_err("cannot register platform drv\n");
+		return ret;
+	}
+
+	ret = es_dsp_platform_init();
+	if (ret) {
+		dsp_err("es dsp platform init error.\n");
+		platform_driver_unregister(&es_dsp_hw_driver);
+		return ret;
+	}
+
+	es_dsp_init_proc();
+	dsp_info("%s, ok.\n", __func__);
+	return 0;
+}
+
+static void __exit es_dsp_module_exit(void)
+{
+	int ret;
+
+	es_dsp_remove_proc();
+
+	ret = es_dsp_platform_uninit();
+	if (ret) {
+		dsp_err("es dsp platform uninit error.\n");
+		return;
+	}
+	platform_driver_unregister(&es_dsp_hw_driver);
+}
+module_init(es_dsp_module_init);
+module_exit(es_dsp_module_exit);
+
+MODULE_AUTHOR("Takayuki Sugawara");
+MODULE_AUTHOR("Max Filippov");
+MODULE_LICENSE("Dual MIT/GPL");
diff --git a/drivers/soc/eswin/ai_driver/dsp/dsp_main.h b/drivers/soc/eswin/ai_driver/dsp/dsp_main.h
new file mode 100644
index 000000000000..7d2b9e77ee57
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/dsp/dsp_main.h
@@ -0,0 +1,215 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#ifndef __DSP_MAIN_H__
+#define __DSP_MAIN_H__
+
+#include <linux/completion.h>
+#include <linux/miscdevice.h>
+#include <linux/mutex.h>
+#include <linux/types.h>
+#include <linux/irqreturn.h>
+#include <linux/dma-buf.h>
+#include "eswin-khandle.h"
+
+#include "es_dsp_internal.h"
+#include "dsp_hw_if.h"
+#include "dsp_hw.h"
+#include "dsp_log.h"
+#include "dsp_perf.h"
+#include "dsp_mailbox.h"
+
+#if DSP_ENV_SIM
+static inline ES_U32 get_perf_timer_cnt()
+{
+	return 0;
+}
+#else
+#include "eswin_timer.h"
+#endif
+
+extern int dsp_perf_enable;
+
+#define DSP_MAX_PRIO 20
+#define BITMAP_SIZE \
+	((((DSP_MAX_PRIO + 1 + 7) / 8) + sizeof(long) - 1) / sizeof(long))
+
+struct device;
+struct firmware;
+struct dsp_hw_ops;
+struct dsp_allocation_pool;
+
+struct es_dsp;
+
+enum {
+	DSP_FILE_HANDLE_MAGIC = 1,
+	DSP_USER_HANDLE_MAGIC,
+	DSP_REQ_HANDLE_MAGIC,
+	DSP_DMABUF_HANDLE_MAGIC,
+};
+/**
+*	This represent a operator in kernel. Every operator have one struct dsp_op_desc.
+*/
+struct dsp_op_desc {
+	char *name;
+	char *op_dir;
+	struct list_head entry;
+	u32 op_shared_seg_size;
+	phys_addr_t op_shared_seg_addr;
+	void *op_shared_seg_ptr;
+	struct kref refcount;
+	struct es_dsp *dsp;
+
+	struct operator_funcs funcs;
+	dma_addr_t iova_base;
+};
+
+struct dsp_user {
+	struct dsp_op_desc *op;
+	struct dsp_file *dsp_file;
+	struct khandle h;
+};
+
+struct dsp_user_req_async {
+	struct es_dsp *es_dsp;
+	dsp_request_t dsp_req;
+	struct dsp_dma_buf **dma_entry;
+	u32 dma_buf_count;
+	struct dsp_user *user;
+	struct khandle handle;
+	cpl_handler_fn req_cpl_handler;
+	/* async_ll, cbarg, callback and dsp_file Can Only use for Lowlevel interface*/
+	struct list_head async_ll;
+	struct dsp_file *dsp_file;
+	u64 cbarg;
+	u64 callback;
+};
+
+struct prio_array {
+	unsigned int nr_active;
+	unsigned long bitmap[BITMAP_SIZE];
+	struct list_head queue[DSP_MAX_PRIO];
+	unsigned long queue_task_num[DSP_MAX_PRIO];
+};
+
+struct es_dsp_stats {
+	char *last_op_name;
+	int total_ok_cnt;
+	int total_failed_cnt;
+	int total_int_cnt;
+	int send_to_dsp_cnt;
+	int task_timeout_cnt;
+	u64 last_task_time;
+};
+
+struct es_dsp {
+	struct device *dev;
+	const char *firmware_name;
+	const struct firmware *firmware;
+	struct miscdevice miscdev;
+	void *hw_arg;
+	u32 process_id;
+	u32 numa_id;
+	struct prio_array array;
+	spinlock_t send_lock;
+	int wait_running;
+	dsp_request_t *current_task;
+	int task_reboot_cnt;
+
+	u64 sram_phy_addr;
+	u32 sram_dma_addr;
+	struct dma_buf_attachment *sram_attach;
+
+	wait_queue_head_t hd_ready_wait;
+	struct work_struct task_work;
+
+	struct es_dsp_stats *stats;
+
+	struct timer_list task_timer;
+	struct work_struct expire_work;
+
+	struct platform_device *mbox_pdev;
+	struct clk *mbox_pclk;
+	struct clk *mbox_pclk_device;
+	struct reset_control *mbox_rst;
+	struct reset_control *mbox_rst_device;
+	void __iomem *mbox_rx_base;
+	void __iomem *mbox_tx_base;
+	int mbox_lock_bit;
+	int mbox_irq_bit;
+	int mbox_irq;
+	spinlock_t mbox_lock;
+	u32 device_uart;
+	struct resource *mbox_tx_res;
+	struct resource *mbox_rx_res;
+
+
+	u64 send_time;
+	u64 done_time;
+
+	struct mutex op_list_mutex;
+	struct list_head all_op_list;
+
+	spinlock_t complete_lock;
+	struct list_head complete_list;
+	atomic_t reboot_cycle;
+
+	bool off;
+	int nodeid;
+	void *firmware_addr;
+	dma_addr_t firmware_dev_addr;
+	void __iomem *uart_mutex_base;
+
+	struct mutex lock;
+	unsigned long rate;
+	struct dentry *debug_dentry;
+
+	u32 perf_enable;
+	int op_idx;
+	dsp_kmd_perf_t op_perf[MAX_DSP_TASKS];
+	dsp_fw_perf_t op_fw_perf[MAX_DSP_TASKS];
+};
+
+#define DSP_FIRMWARE_IOVA 0xfe000000
+#define DSP_FIRMWARE_IOVA_SIZE 0x400000
+
+/* 0xFF9B_0000 -- 0xFFFB_0000 for SPAD */
+#define DSP_IDDR_IOVA 0xff9b0000
+#define DSP_IDDR_IOVA_SIZE 0x400000
+
+#define DSP_DEVICE_AUX_E31_IOVA 0xfffb0000  // unused iova
+#define DSP_DEVICE_AUX_E31_IOVA_SIZE 0x1000
+
+#define DSP_PTS_IOVA 0xfffb1000
+#define DSP_PTS_IOVA_SIZE 0x8000
+
+#define DSP_DEVICE_U84_TO_MCU_MBX ESWIN_MAILBOX_DSP_TO_E31_REG_BASE
+#define U84_TO_MCU_IOVA_SIZE 0x1000
+
+#define DSP_DEVICE_IOVA 0xfffba000
+#define DSP_DEVICE_IOVA_SIZE (0xfffe0000 - DSP_DEVICE_IOVA)
+
+/*0xfffe_0000 - */
+#define DSP_DEVICE_UART_IOVA 0xffff0000
+#define DSP_DEVICE_UART_MUTEX_IOVA 0xffffa000
+#define DSP_DEVICE_MBX_TX_IOVA ESWIN_MAILBOX_DSP_TO_U84_REG_BASE
+#define DSP_DEVICE_MBX_RX_IOVA ESWIN_MAILBOX_U84_TO_DSP_REG_BASE
+#define DSP_DEVICE_EACH_IOVA_SIZE 0x10000
+#define DSP_DEVICE_UART_IOVA_SIZE 0xa000
+#define DSP_DEVICE_UART_MUTEX_IOVA_SIZE 0x1000
+
+#define UART_MUTEX_BASE_ADDR 0x51820000
+#define UART_MUTEX_UNIT_OFFSET 4
+
+irqreturn_t dsp_irq_handler(void *, struct es_dsp *dsp);
+int dsp_runtime_suspend(struct device *dev);
+int dsp_runtime_resume(struct device *dev);
+void dsp_op_release(struct kref *kref);
+
+int es_dsp_exec_cmd_timeout(void);
+struct es_dsp *es_proc_get_dsp(int dieid, int dspid);
+#endif
diff --git a/drivers/soc/eswin/ai_driver/dsp/dsp_perf.h b/drivers/soc/eswin/ai_driver/dsp/dsp_perf.h
new file mode 100644
index 000000000000..eb1988839543
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/dsp/dsp_perf.h
@@ -0,0 +1,61 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#ifndef __ESWIN_DSP_PERF_H__
+#define __ESWIN_DSP_PERF_H__
+
+#include "es_dsp_types.h"
+#include "es_dsp_op_types.h"
+
+#define OP_NAME_MAXLEN 128
+
+// dsp driver perf info
+typedef struct _dsp_kmd_perf {
+    ES_U32 Die;
+    ES_U32 CoreId;
+    ES_U32 OpIndex;
+    ES_U32 OpType;
+    ES_CHAR OpName[OP_NAME_MAXLEN];
+    ES_U32 OpStartCycle;
+    ES_U32 OpSendTaskCycle;
+    ES_U32 OpEndCycle;
+} dsp_kmd_perf_t;
+
+typedef struct _dsp_fw_perf {
+    ES_U32 Die;
+    ES_U32 CoreId;
+    ES_U32 OpIndex;
+    ES_U32 OpType;
+    char OpName[OPERATOR_NAME_MAXLEN];
+    ES_U32 OpStartCycle;
+    ES_U32 OpPrepareStartCycle;
+    ES_U32 OpPrepareEndCycle;
+    ES_U32 OpEvalStartCycle;
+    ES_U32 OpEvalEndCycle;
+    ES_U32 OpNotifyStartCycle;
+    ES_U32 OpEndCycle;
+} dsp_fw_perf_t;
+
+// dsp hardware perf info
+typedef struct {
+    volatile ES_U32 core_id;
+    volatile ES_U32 op_index;
+    volatile ES_U32 op_type;
+    volatile ES_U32 flat1_start_time;
+    volatile ES_U32 prepare_start_time;
+    volatile ES_U32 prepare_end_time;
+    volatile ES_U32 eval_start_time;
+    volatile ES_U32 eval_end_time;
+    volatile ES_U32 notify_start_time;
+    volatile ES_U32 flat1_end_time;
+    volatile ES_U32 task_cnt;
+    volatile ES_U32 send_prepare_to_npu;
+    volatile ES_U32 send_eval_to_npu;
+    volatile ES_U32 invalid_cmd_cnt;
+} es_dsp_perf_info;
+
+#endif
diff --git a/drivers/soc/eswin/ai_driver/dsp/dsp_platform.c b/drivers/soc/eswin/ai_driver/dsp/dsp_platform.c
new file mode 100644
index 000000000000..998538a44f46
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/dsp/dsp_platform.c
@@ -0,0 +1,1254 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/firmware.h>
+#include <linux/mailbox_client.h>
+#include <linux/mailbox_controller.h>
+#include <linux/mailbox/eswin-mailbox.h>
+#include <asm/cacheflush.h>
+#include <linux/regmap.h>
+#include <linux/pm_runtime.h>
+#include <linux/eswin-win2030-sid-cfg.h>
+#include <dt-bindings/memory/eswin-win2030-sid.h>
+#include <linux/clk.h>
+#include <linux/slab.h>
+#include <linux/iommu.h>
+#include <linux/es_iommu_rsv.h>
+#include "eswin-dsp-subsys.h"
+
+#include "dsp_platform.h"
+#include "dsp_firmware.h"
+#include "dsp_ioctl.h"
+#include "dsp_main.h"
+
+#define DRIVER_NAME "eswin-dsp"
+
+/*
+	dsp subsys registers
+*/
+
+#define REG_OFFSET_DSP_START 0x00
+#define REG_OFFSET_DSP_STAT 0x04
+#define REG_OFFSET_DSP_PRID 0x08
+#define REG_OFFSET_DSP_RESET 0x18
+#define REG_OFFSET_DSP_DYARID 0x504
+#define REG_OFFSET_DSP_DYAWID 0x508
+#define REG_OFFSET_USR_CONF0 0x1c
+
+// bit definitions for REG_OFFSET_DSP_STAT
+#define DSP_STAT_REG_BIT_STAT_VECTOR_SEL BIT_ULL(0)
+#define DSP_STAT_REG_BIT_ARID_DYNM_EN BIT_ULL(4)
+#define DSP_STAT_REG_BITS_ARMMUSID_MASK GENMASK(23, 16)
+
+// bit definitions for REG_OFFSET_DSP_PRID
+#define DSP_PRID_REG_BIT_PRID_MASK GENMASK(15, 0)
+
+// bit definitions for REG_OFFSET_DSP_RESET
+#define DSP_RESET_REG_BIT_RUNSTALL_ON_RESET BIT_ULL(0)
+#define DSP_RESET_REG_BIT_CORE_RESET BIT_ULL(1)
+#define DSP_RESET_REG_BIT_DEBUG_RESET BIT_ULL(2)
+
+// bit definitions for REG_OFFSET_DSP_DYAWID
+#define DSP_DYAWID_REG_BITS_ARMMUSID_MASK GENMASK(23, 16)
+#define DSP_DYAWID_REG_BITS_AWMMUSID_MASK GENMASK(23, 16)
+
+#define REG_DEFAULT_SIZE 0x10000
+#define REG_OFFSET_SIZE 0x20
+#define REG_OFFSET_SIZE_8 0x8
+
+#define REG_OFFSET(reg, pro_id) (reg + (REG_OFFSET_SIZE * pro_id))
+
+#define REG_OFFSET_8(reg, pro_id) (reg + (REG_OFFSET_SIZE_8 * pro_id))
+
+/*
+	aon syscon registers
+*/
+#define REG_OFFSET_SYSCON_DSP_CFG 0x330
+
+// bit definitions for REG_OFFSET_SYSCON_DSP_CFG
+#define SCU_DSPT_DIV_SEL BIT_ULL(19)
+#define SCU_DSPT_DIV_EN BIT_ULL(23)
+
+enum dsp_irq_mode {
+	DSP_IRQ_NONE,
+	DSP_IRQ_LEVEL,
+	DSP_IRQ_MAX,
+};
+
+struct es_dsp_hw {
+	struct es_dsp *es_dsp;
+	void __iomem *dbg_reg_base;
+	struct regmap *map;
+	struct regmap *con_map;
+	struct clk *aclk;
+	struct es_dsp_subsys *subsys;
+	struct dma_pool *flat_dma_pool;
+
+	dma_addr_t pts_iova;
+	u32 pts_iova_size;
+	u32 pts_phys_base;
+
+	dma_addr_t iddr_iova;
+	u32 iddr_size;
+	void *iddr_ptr;
+
+	struct platform_device *pdev;
+	/* how IRQ is used to notify the device of incoming data */
+	enum dsp_irq_mode device_irq_mode;
+	/*
+	 * device IRQ#
+	 * dsp tx mailbox reg base
+	 * dsp tx mailbox wr lock
+	 * dsp rx mailbox reg base
+	 * dsp tx mailbox int bit
+	 * dsp send to mcu tx mailbox reg base
+	 */
+	u32 device_irq[6];
+	enum dsp_irq_mode host_irq_mode;
+	dma_addr_t device_uart_base;
+	dma_addr_t device_uart_mutex_base;
+	dma_addr_t mailbox_tx_reg_base;
+	dma_addr_t mailbox_rx_reg_base;
+	dma_addr_t mailbox_mcu_reg_base;
+
+	void __iomem *uart_mutex_base;
+};
+
+int es_dsp_core_clk_enable(struct es_dsp *dsp)
+{
+	int ret;
+	u32 val;
+	struct es_dsp_hw *hw = (struct es_dsp_hw *)dsp->hw_arg;
+
+	regmap_read(hw->map, REG_OFFSET_USR_CONF0, &val);
+	dsp_debug("%s, %d, original usr conf0 val=0x%x.\n", __func__, __LINE__,
+		  val);
+
+	val |= (3 << (dsp->process_id * 2));
+	ret = regmap_write(hw->map, REG_OFFSET_USR_CONF0, val);
+	regmap_read(hw->map, REG_OFFSET_USR_CONF0, &val);
+	dsp_debug("%s, %d, val=0x%x.\n", __func__, __LINE__, val);
+	return ret;
+}
+
+int es_dsp_core_clk_disable(struct es_dsp *dsp)
+{
+	int ret;
+	u32 val;
+	struct es_dsp_hw *hw = (struct es_dsp_hw *)dsp->hw_arg;
+
+	regmap_read(hw->map, REG_OFFSET_USR_CONF0, &val);
+	dsp_debug("%s, %d, original val=0x%x.\n", __func__, __LINE__, val);
+
+	val &= ~(3 << (dsp->process_id * 2));
+	ret = regmap_write(hw->map, REG_OFFSET_USR_CONF0, val);
+	regmap_read(hw->map, REG_OFFSET_USR_CONF0, &val);
+	dsp_debug("%s, %d, val=0x%x.\n", __func__, __LINE__, val);
+	return ret;
+}
+
+void es_dsp_reset(struct es_dsp_hw *hw)
+{
+	struct es_dsp *dsp = hw->es_dsp;
+	int ret;
+
+	if (NULL == dsp) {
+		dsp_err("%s %d: failed to reset device\n", __func__, __LINE__);
+	} else {
+		ret = regmap_set_bits(hw->map,
+				      REG_OFFSET(REG_OFFSET_DSP_RESET,
+						 dsp->process_id),
+				      DSP_RESET_REG_BIT_DEBUG_RESET);
+		WARN_ON(0 != ret);
+
+		ret = regmap_set_bits(hw->map,
+				      REG_OFFSET(REG_OFFSET_DSP_RESET,
+						 dsp->process_id),
+				      DSP_RESET_REG_BIT_CORE_RESET);
+		WARN_ON(0 != ret);
+		mdelay(20);
+
+		/* set processor id */
+		ret = regmap_write_bits(
+			hw->map,
+			REG_OFFSET(REG_OFFSET_DSP_PRID, dsp->process_id),
+			DSP_PRID_REG_BIT_PRID_MASK, dsp->process_id);
+		WARN_ON(0 != ret);
+
+		/* set reset vector */
+		ret = regmap_write(hw->map,
+				   REG_OFFSET(REG_OFFSET_DSP_START,
+					      dsp->process_id),
+				   dsp->firmware_dev_addr);
+		WARN_ON(0 != ret);
+		ret = regmap_set_bits(hw->map,
+				      REG_OFFSET(REG_OFFSET_DSP_STAT,
+						 dsp->process_id),
+				      DSP_STAT_REG_BIT_STAT_VECTOR_SEL);
+		WARN_ON(0 != ret);
+
+		/* dereset dsp core */
+		ret = regmap_clear_bits(hw->map,
+					REG_OFFSET(REG_OFFSET_DSP_RESET,
+						   dsp->process_id),
+					DSP_RESET_REG_BIT_CORE_RESET);
+		WARN_ON(0 != ret);
+
+		/* set smmu id */
+		ret = regmap_write_bits(
+			hw->map,
+			REG_OFFSET_8(REG_OFFSET_DSP_DYAWID, dsp->process_id),
+			DSP_DYAWID_REG_BITS_AWMMUSID_MASK,
+			(WIN2030_SID_DSP_0 + dsp->process_id) << 16);
+		WARN_ON(0 != ret);
+
+		ret = regmap_write_bits(
+			hw->map,
+			REG_OFFSET_8(REG_OFFSET_DSP_DYARID, dsp->process_id),
+			DSP_DYAWID_REG_BITS_ARMMUSID_MASK,
+			(WIN2030_SID_DSP_0 + dsp->process_id) << 16);
+		WARN_ON(0 != ret);
+
+		ret = win2030_dynm_sid_enable(dev_to_node(dsp->dev));
+		WARN_ON(0 != ret);
+
+		ret = regmap_write(hw->con_map, 0x330, 0xF0F0);
+		WARN_ON(0 != ret);
+
+		/* dereset dsp debug */
+		ret = regmap_clear_bits(hw->map,
+					REG_OFFSET(REG_OFFSET_DSP_RESET,
+						   dsp->process_id),
+					DSP_RESET_REG_BIT_DEBUG_RESET);
+		WARN_ON(0 != ret);
+
+		dev_info(dsp->dev, "reset device, ret %d\n", ret);
+	}
+	return;
+}
+
+int es_dsp_clk_disable(struct es_dsp *dsp)
+{
+	int ret;
+	struct es_dsp_hw *hw = (struct es_dsp_hw *)dsp->hw_arg;
+	ret = es_dsp_core_clk_disable(dsp);
+	if (ret) {
+		dsp_debug("%s, %d, dsp core clk disable err, ret=%d.\n",
+			  __func__, __LINE__, ret);
+		return ret;
+	}
+
+	//clk_disable_unprepare(hw->aclk);
+	dsp_debug("%s, %d, done.\n", __func__, __LINE__);
+	return ret;
+}
+int es_dsp_clk_enable(struct es_dsp *dsp)
+{
+	struct es_dsp_hw *hw = (struct es_dsp_hw *)dsp->hw_arg;
+	int ret;
+	if (!__clk_is_enabled(hw->aclk)) {
+		ret = clk_prepare_enable(hw->aclk);
+		if (ret) {
+			dev_err(dsp->dev, "failed to enable aclk: %d\n", ret);
+			return ret;
+		}
+	}
+	ret = es_dsp_core_clk_enable(dsp);
+	if (ret) {
+		clk_disable_unprepare(hw->aclk);
+		return ret;
+	}
+
+	dsp_debug("enable dsp clock ok.\n");
+	return 0;
+}
+
+int es_dsp_set_rate(struct es_dsp_hw *hw, unsigned long rate)
+{
+	struct es_dsp *dsp = hw->es_dsp;
+	int ret;
+
+	if (NULL == dsp) {
+		dsp_err("%s %d: failed to get device\n", __func__, __LINE__);
+		return -ENXIO;
+	}
+	rate = clk_round_rate(hw->aclk, rate);
+	if (rate > 0) {
+		ret = clk_set_rate(hw->aclk, rate);
+		if (ret) {
+			dev_err(dsp->dev, "failed to set aclk: %d\n", ret);
+			return ret;
+		}
+	}
+	dev_info(dsp->dev, "set device rate to %ldHZ\n", rate);
+	return 0;
+}
+
+void es_dsp_halt(struct es_dsp_hw *hw)
+{
+	struct es_dsp *dsp = hw->es_dsp;
+	int ret;
+
+	if (NULL == dsp) {
+		dsp_err("%s %d: failed to halt device\n", __func__, __LINE__);
+	} else {
+		ret = regmap_set_bits(hw->map,
+				      REG_OFFSET(REG_OFFSET_DSP_RESET,
+						 dsp->process_id),
+				      DSP_RESET_REG_BIT_RUNSTALL_ON_RESET);
+		WARN_ON(0 != ret);
+
+		dev_info(dsp->dev, "halt device, ret %d\n", ret);
+	}
+	return;
+}
+
+void es_dsp_release(struct es_dsp_hw *hw)
+{
+	struct es_dsp *dsp = hw->es_dsp;
+	int ret;
+	unsigned int val;
+
+	if (NULL == dsp) {
+		dsp_err("%s %d: failed to release device\n", __func__,
+			__LINE__);
+	} else {
+		ret = regmap_clear_bits(hw->map,
+					REG_OFFSET(REG_OFFSET_DSP_RESET,
+						   dsp->process_id),
+					DSP_RESET_REG_BIT_RUNSTALL_ON_RESET);
+		WARN_ON(0 != ret);
+		regmap_read(hw->map,
+			    REG_OFFSET(REG_OFFSET_DSP_RESET, dsp->process_id),
+			    &val);
+
+		dev_info(dsp->dev, "release device, ret %d, val=0x%x\n", ret,
+			 val);
+	}
+
+	return;
+}
+
+static int dsp_send_msg_by_mbx(struct es_dsp *dsp, void *data)
+{
+	unsigned long flags;
+	u32 tmp_data;
+	int count = 0;
+	struct eswin_mbox_msg *msg = (struct eswin_mbox_msg *)data;
+
+	spin_lock_irqsave(&dsp->mbox_lock, flags);
+	// TX FIFO FULL?
+	while (true) {
+		if (count > 3) {
+			spin_unlock_irqrestore(&dsp->mbox_lock, flags);
+			return -EBUSY;
+		}
+		writel(dsp->mbox_lock_bit,
+		       dsp->mbox_tx_base + ESWIN_MBOX_WR_LOCK);
+		if (!(readl(dsp->mbox_tx_base + ESWIN_MBOX_WR_LOCK) &
+		      dsp->mbox_lock_bit) ||
+		    (readl(dsp->mbox_tx_base + ESWIN_MBOX_FIFO_STATUS) &
+		     BIT_ULL(0))) {
+			udelay(10);
+			count++;
+			continue;
+		}
+		break;
+	}
+
+	tmp_data = (u32)msg->data;
+	writel(tmp_data, dsp->mbox_tx_base + ESWIN_MBOX_WR_DATA0);
+
+	tmp_data = (u32)(msg->data >> 32) | BIT(31);
+	writel(tmp_data, dsp->mbox_tx_base + ESWIN_MBOX_WR_DATA1);
+	// 写中断enable bit.
+
+	writel(dsp->mbox_irq_bit, dsp->mbox_tx_base + ESWIN_MBOX_INT_CTRL);
+
+	writel(0x0, dsp->mbox_tx_base + ESWIN_MBOX_WR_LOCK);
+	spin_unlock_irqrestore(&dsp->mbox_lock, flags);
+	return 0;
+}
+
+void dsp_send_invalid_code_seg(struct es_dsp_hw *hw, struct dsp_op_desc *op)
+{
+	es_dsp_h2d_msg h2d_msg;
+	int ret;
+
+	dsp_debug("request dsp invalid code seg addr:%x,size:%d\n",
+		  op->iova_base, op->op_shared_seg_size);
+	h2d_msg.command = DSP_CMD_INVALID_ICACHE;
+	h2d_msg.size = op->op_shared_seg_size >> DSP_2M_SHIFT;
+	h2d_msg.iova_ptr = op->iova_base;
+
+	ret = dsp_send_msg_by_mbx(hw->es_dsp, (void *)&h2d_msg);
+	if (ret < 0)
+		dev_err(NULL, "Failed to send message via mailbox\n");
+	return;
+}
+
+void es_dsp_send_irq(struct es_dsp_hw *hw, dsp_request_t *req)
+{
+	es_dsp_h2d_msg h2d_msg;
+	int ret;
+	h2d_msg.command = DSP_CMD_FLAT1;
+	h2d_msg.allow_eval = req->allow_eval;
+	h2d_msg.poll_mode = req->poll_mode;
+	h2d_msg.sync_cache = req->sync_cache;
+	h2d_msg.iova_ptr = req->dsp_flat1_iova;
+
+	ret = dsp_send_msg_by_mbx(hw->es_dsp, (void *)&h2d_msg);
+	if (ret < 0)
+		dev_err(NULL, "Failed to send message via mailbox\n");
+	return;
+}
+
+/*
+	获取elf段对应的cpu虚拟地址
+*/
+static void *translate_to_cpu_va(struct es_dsp *dsp, Elf32_Phdr *phdr)
+{
+	if ((long)dsp->firmware_addr > (long)dsp->firmware_dev_addr) {
+		return (void *)((long)phdr->p_paddr + (long)dsp->firmware_addr -
+				(long)dsp->firmware_dev_addr);
+	} else {
+		return (void *)((long)phdr->p_paddr -
+				((long)dsp->firmware_dev_addr -
+				 (long)dsp->firmware_addr));
+	}
+}
+
+static phys_addr_t translate_to_cpu_pa(struct es_dsp *dsp, Elf32_Phdr *phdr)
+{
+#if IS_ENABLED(CONFIG_OF)
+	phys_addr_t res;
+	__be32 addr = cpu_to_be32((u32)phdr->p_paddr);
+	struct device_node *node = of_get_next_child(dsp->dev->of_node, NULL);
+
+	if (!node)
+		node = dsp->dev->of_node;
+
+	res = of_translate_address(node, &addr);
+
+	if (node != dsp->dev->of_node)
+		of_node_put(node);
+	return res;
+#else
+	return phdr->p_paddr;
+#endif
+}
+
+/*
+	将elf段加载到DDR
+*/
+static int load_segment_to_sysmem(struct es_dsp *dsp, Elf32_Phdr *phdr)
+{
+	void *va = translate_to_cpu_va(dsp, phdr);
+
+	memcpy(va, (void *)dsp->firmware->data + phdr->p_offset, phdr->p_memsz);
+	return 0;
+}
+
+/*
+ * 将elf段加载到DSP local memory
+ *
+ */
+static int load_segment_to_iomem(struct es_dsp *dsp, Elf32_Phdr *phdr)
+{
+	phys_addr_t pa = translate_to_cpu_pa(dsp, phdr);
+	void __iomem *p = ioremap(pa, phdr->p_memsz);
+
+	if (!p) {
+		dev_err(dsp->dev, "couldn't ioremap %pap x 0x%08x\n", &pa,
+			(u32)phdr->p_memsz);
+		return -EINVAL;
+	}
+	// writel_relaxed(0x8000, hw->dbg_reg_base + 0x668);
+
+	memcpy_toio(p, (void *)dsp->firmware->data + phdr->p_offset,
+		    ALIGN(phdr->p_filesz, 4));
+
+	memset_io(p + ALIGN(phdr->p_filesz, 4), 0,
+		  ALIGN(phdr->p_memsz - ALIGN(phdr->p_filesz, 4), 4));
+	iounmap(p);
+	return 0;
+}
+
+int es_dsp_load_fw_segment(struct es_dsp_hw *hw, const void *image,
+			   Elf32_Phdr *phdr)
+{
+	void *va = NULL;
+	phys_addr_t pa = 0;
+	struct es_dsp *dsp = hw->es_dsp;
+
+	if ((long)phdr->p_paddr >= (long)dsp->firmware_dev_addr) {
+		va = translate_to_cpu_va(dsp, phdr);
+		if (IS_ERR(va)) {
+			dev_err(dsp->dev,
+				"device smmu address 0x%08x could not be "
+				"mapped to host virtual address",
+				(u32)phdr->p_paddr);
+			return -EINVAL;
+		}
+		dsp_info(
+			"esdsp, loading segment (device 0x%08x) to virtual 0x%px\n",
+			(u32)phdr->p_paddr, va);
+		return load_segment_to_sysmem(dsp, phdr);
+	} else {
+		pa = translate_to_cpu_pa(dsp, phdr);
+		if (pa == (phys_addr_t)OF_BAD_ADDR) {
+			dev_err(dsp->dev,
+				"device address 0x%08x could not be "
+				"mapped to host physical address, pa 0x%llx",
+				(u32)phdr->p_paddr, pa);
+			return -EINVAL;
+		}
+
+		dsp_info(
+			"esdsp,loading segment (device 0x%08x) to phy address 0x%llx\n",
+			(u32)phdr->p_paddr, pa);
+		return load_segment_to_iomem(dsp, phdr);
+	}
+}
+
+int es_dsp_reboot_core(struct es_dsp_hw *hw)
+{
+	int ret;
+	struct es_dsp_subsys *subsys = hw->subsys;
+
+	if (!subsys || !subsys->dsp_subsys_status) {
+		return -EINVAL;
+	}
+
+	ret = subsys->dsp_subsys_status();
+	if (ret <= 0) {
+		dsp_err("dsp subsys keep busing in 3 seconds, fail to restarting firmware.\n");
+		ret = -EIO;
+		return ret;
+	}
+
+	return 0;
+}
+
+int es_dsp_load_op(struct es_dsp_hw *hw, void *op_ptr)
+{
+	struct dsp_op_desc *op = (struct dsp_op_desc *)op_ptr;
+	if (!op_ptr || !hw->es_dsp) {
+		dsp_err("invalid parameter for load op");
+		return -ENOMEM;
+	}
+	return dsp_load_op_file(hw->es_dsp, op);
+}
+
+int es_dsp_sync(struct es_dsp *dsp)
+{
+	int ret;
+
+	msleep(1);
+	ret = wait_event_timeout(dsp->hd_ready_wait, dsp->off != true,
+				 msecs_to_jiffies(3000));
+	if (!ret) {
+		dsp_err("DSP cannot deliver ready cmd during sync.\n");
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+static irqreturn_t dsp_mbox_irq(int irq, void *dev_id)
+{
+	u32 data0, data1;
+	u64 message;
+	struct es_dsp *dsp = (struct es_dsp *)dev_id;
+	int ret;
+
+	while (true) {
+		data0 = readl(dsp->mbox_rx_base + ESWIN_MBOX_RD_DATA0);
+		data1 = readl(dsp->mbox_rx_base + ESWIN_MBOX_RD_DATA1);
+		if (!data1) {
+			break;
+		}
+		message = ((u64)data1 << 32 | data0);
+		writel(0x0, dsp->mbox_rx_base + ESWIN_MBOX_RD_DATA1);
+
+		ret = dsp_irq_handler((void *)&message, dsp);
+	}
+	return IRQ_HANDLED;
+}
+
+void reset_uart_mutex(struct es_dsp_hw *hw)
+{
+	if (hw->uart_mutex_base) {
+		writel(0, hw->uart_mutex_base + UART_MUTEX_UNIT_OFFSET);
+	} else {
+		dev_err(&hw->pdev->dev, "uart mutex addr is NULL\n");
+	}
+}
+
+static void hw_uart_uninit(struct es_dsp *dsp)
+{
+	struct es_dsp_hw *hw = (struct es_dsp_hw *)dsp->hw_arg;
+
+	if (hw->device_uart_base != 0) {
+		iommu_unmap_rsv_iova(dsp->dev, NULL, hw->device_uart_base,
+				     DSP_DEVICE_UART_IOVA_SIZE);
+		hw->device_uart_base = 0;
+	}
+
+	if (hw->device_uart_mutex_base != 0) {
+		iommu_unmap_rsv_iova(dsp->dev, NULL, hw->device_uart_mutex_base,
+				     DSP_DEVICE_UART_MUTEX_IOVA_SIZE);
+		hw->device_uart_mutex_base = 0;
+	}
+}
+
+static inline int init_hw_uart(struct es_dsp_hw *hw)
+{
+	int ret;
+	struct es_dsp *dsp = hw->es_dsp;
+
+	ret = iommu_map_rsv_iova_with_phys(dsp->dev,
+					   (dma_addr_t)DSP_DEVICE_UART_IOVA,
+					   DSP_DEVICE_UART_IOVA_SIZE,
+					   dsp->device_uart, IOMMU_MMIO);
+	if (ret != 0) {
+		dev_err(dsp->dev, "uart iommu map error\n");
+		return ret;
+	}
+	hw->device_uart_base = DSP_DEVICE_UART_IOVA;
+
+	ret = iommu_map_rsv_iova_with_phys(
+		dsp->dev, (dma_addr_t)DSP_DEVICE_UART_MUTEX_IOVA,
+		DSP_DEVICE_UART_MUTEX_IOVA_SIZE, UART_MUTEX_BASE_ADDR,
+		IOMMU_MMIO);
+	if (ret != 0) {
+		dev_err(dsp->dev, "uart mutex iommu map error\n");
+		goto err_mutex;
+	}
+	hw->device_uart_mutex_base = DSP_DEVICE_UART_MUTEX_IOVA;
+
+
+	return ret;
+err_iomap:
+	iommu_unmap_rsv_iova(dsp->dev, NULL, hw->device_uart_mutex_base,
+			     DSP_DEVICE_UART_MUTEX_IOVA_SIZE);
+	hw->device_uart_mutex_base = 0;
+err_mutex:
+	iommu_unmap_rsv_iova(dsp->dev, NULL, hw->device_uart_base,
+			     DSP_DEVICE_UART_IOVA_SIZE);
+	hw->device_uart_base = 0;
+err:
+	return ret;
+}
+
+void dsp_uninit_mbox(struct es_dsp *dsp)
+{
+	struct es_dsp_hw *hw = (struct es_dsp_hw *)dsp->hw_arg;
+
+	if (hw->mailbox_tx_reg_base != 0) {
+		iommu_unmap_rsv_iova(dsp->dev, NULL, hw->mailbox_tx_reg_base,
+				     DSP_DEVICE_EACH_IOVA_SIZE);
+		hw->mailbox_tx_reg_base = 0;
+	}
+
+	if (hw->mailbox_rx_reg_base != 0) {
+		iommu_unmap_rsv_iova(dsp->dev, NULL, hw->mailbox_rx_reg_base,
+				     DSP_DEVICE_EACH_IOVA_SIZE);
+		hw->mailbox_rx_reg_base = 0;
+	}
+
+	if (hw->mailbox_mcu_reg_base != 0) {
+		iommu_unmap_rsv_iova(dsp->dev, NULL, hw->mailbox_mcu_reg_base,
+				     U84_TO_MCU_IOVA_SIZE);
+		hw->mailbox_mcu_reg_base = 0;
+	}
+}
+
+int dsp_enable_mbox_clock(struct es_dsp *dsp)
+{
+	int ret;
+	ret = clk_prepare_enable(dsp->mbox_pclk);
+	if (ret) {
+		dev_err(dsp->dev, "failed to enable host mailbox pclk: %d\n",
+			ret);
+		goto err_pclk;
+	}
+	ret = clk_prepare_enable(dsp->mbox_pclk_device);
+	if (ret) {
+		dev_err(dsp->dev,
+			"failed to enable device mailbox pclk: %d\n", ret);
+		goto err_pd_clock;
+	}
+	return 0;
+err_pd_clock:
+	clk_disable_unprepare(dsp->mbox_pclk);
+err_pclk:
+return ret;
+}
+
+void dsp_disable_mbox_clock(struct es_dsp *dsp)
+{
+	clk_disable_unprepare(dsp->mbox_pclk_device);
+	clk_disable_unprepare(dsp->mbox_pclk);
+}
+static inline int init_hw_mailbox(struct es_dsp_hw *hw)
+{
+	int ret = 0;
+	struct es_dsp *dsp = hw->es_dsp;
+
+	reset_control_reset(dsp->mbox_rst);
+	reset_control_reset(dsp->mbox_rst_device);
+	spin_lock_init(&dsp->mbox_lock);
+
+	dsp_info("%s: dev: irq num %d, tx phy base 0x%08x, tx wr lock 0x%08x,"
+		 " rx phy base 0x%08x, irq bit 0x%08x\n",
+		 __func__, hw->device_irq[0], hw->device_irq[1],
+		 hw->device_irq[2], hw->device_irq[3], hw->device_irq[4]);
+
+	ret = iommu_map_rsv_iova_with_phys(dsp->dev,
+					   (dma_addr_t)DSP_DEVICE_MBX_TX_IOVA,
+					   DSP_DEVICE_EACH_IOVA_SIZE,
+					   hw->device_irq[1], IOMMU_MMIO);
+	if (ret != 0) {
+		hw->mailbox_tx_reg_base = 0;
+		dsp_err("%s, mbox tx failed.\n", __func__);
+		return ret;
+	}
+
+	hw->mailbox_tx_reg_base = DSP_DEVICE_MBX_TX_IOVA;
+
+	ret = iommu_map_rsv_iova_with_phys(dsp->dev,
+					   (dma_addr_t)DSP_DEVICE_MBX_RX_IOVA,
+					   DSP_DEVICE_EACH_IOVA_SIZE,
+					   hw->device_irq[3], IOMMU_MMIO);
+	if (ret != 0) {
+		hw->mailbox_rx_reg_base = 0;
+		goto err_mbx_rx;
+	}
+
+	hw->mailbox_rx_reg_base = DSP_DEVICE_MBX_RX_IOVA;
+	writel(dsp->mbox_irq_bit, dsp->mbox_tx_base + ESWIN_MBOX_INT_CTRL);
+
+	ret = iommu_map_rsv_iova_with_phys(
+		dsp->dev, (dma_addr_t)DSP_DEVICE_U84_TO_MCU_MBX,
+		U84_TO_MCU_IOVA_SIZE, hw->device_irq[5], IOMMU_MMIO);
+	if (ret != 0) {
+		hw->mailbox_mcu_reg_base = 0;
+		goto err_mbx_mcu;
+	}
+	hw->mailbox_mcu_reg_base = DSP_DEVICE_U84_TO_MCU_MBX;
+	return 0;
+
+err_mbx_mcu:
+	iommu_unmap_rsv_iova(dsp->dev, NULL, hw->mailbox_rx_reg_base,
+			     DSP_DEVICE_EACH_IOVA_SIZE);
+	hw->mailbox_rx_reg_base = 0;
+err_mbx_rx:
+	iommu_unmap_rsv_iova(dsp->dev, NULL, hw->mailbox_tx_reg_base,
+			     DSP_DEVICE_EACH_IOVA_SIZE);
+	hw->mailbox_tx_reg_base = 0;
+	return ret;
+}
+
+int dsp_get_mbx_node(struct platform_device *pdev)
+{
+	struct device_node *dsp_mbox = NULL;
+	struct platform_device *mbox_pdev = NULL;
+	struct es_dsp *dsp = platform_get_drvdata(pdev);
+	int ret;
+	struct es_dsp_hw *hw = (struct es_dsp_hw *)dsp->hw_arg;
+
+	dsp_mbox = of_parse_phandle(pdev->dev.of_node, "dsp_mbox", 0);
+	if (dsp_mbox == NULL) {
+		dev_err(&pdev->dev, "dsp node have not mailbox node, err.\n");
+		return -EINVAL;
+	}
+
+	mbox_pdev = of_find_device_by_node(dsp_mbox);
+	if (mbox_pdev == NULL) {
+		dev_err(&pdev->dev, "cannot find dsp mbox platform dev, err\n");
+		return -EINVAL;
+	}
+	of_node_put(dsp_mbox);
+	dsp->mbox_pdev = mbox_pdev;
+
+	if (of_property_read_u32(mbox_pdev->dev.of_node, "lock-bit",
+				 &dsp->mbox_lock_bit)) {
+		dev_err(&pdev->dev, "failed to get lock_bit: %d\n", ret);
+		return -ENXIO;
+	}
+
+	if (of_property_read_u32(mbox_pdev->dev.of_node, "irq-bit",
+				 &dsp->mbox_irq_bit)) {
+		dev_err(&pdev->dev, "failed to get irq_bit: %d\n", ret);
+		return -ENXIO;
+	}
+	dsp->mbox_tx_res = platform_get_resource(mbox_pdev, IORESOURCE_MEM, 0);
+	if (!dsp->mbox_tx_res) {
+		dsp_err("error get dsp mbox tx mem.\n");
+		return -ENOMEM;
+	}
+
+	dsp->mbox_rx_res = platform_get_resource(mbox_pdev, IORESOURCE_MEM, 1);
+	if (!dsp->mbox_rx_res) {
+		return -ENODEV;
+	}
+
+	dsp->mbox_pclk = devm_clk_get(&mbox_pdev->dev, "pclk_mailbox_host");
+	if (IS_ERR(dsp->mbox_pclk)) {
+		ret = PTR_ERR(dsp->mbox_pclk);
+		dev_err(&pdev->dev, "failed to get host mailbox clock: %d\n",
+			ret);
+		return -ENODEV;
+	}
+
+	platform_set_drvdata(mbox_pdev, dsp);
+	dsp->mbox_pclk_device = devm_clk_get(&mbox_pdev->dev, "pclk_mailbox_device");
+	if (IS_ERR(dsp->mbox_pclk_device)) {
+		ret = PTR_ERR(dsp->mbox_pclk_device);
+		dev_err(&pdev->dev, "failed to get device mailbox clock: %d\n",
+			ret);
+		return ret;
+	}
+	dsp->mbox_rst = devm_reset_control_get_optional_exclusive(&mbox_pdev->dev, "rst");
+	if (IS_ERR(dsp->mbox_rst)) {
+		ret = PTR_ERR(dsp->mbox_rst);
+		dev_err(&pdev->dev, "failed to get rst controller.\n");
+		return ret;;
+	}
+	dsp->mbox_rst_device = devm_reset_control_get_optional_exclusive(&mbox_pdev->dev,
+							       "rst_device");
+	if (IS_ERR(dsp->mbox_rst_device)) {
+		ret = PTR_ERR(dsp->mbox_rst_device);
+		dev_err(&pdev->dev, "failed to get rst_device controller.\n");
+		return ret;
+	}
+	dsp->mbox_irq = platform_get_irq(mbox_pdev, 0);
+	if (dsp->mbox_irq < 0) {
+		return dsp->mbox_irq;
+	}
+
+	ret = devm_request_threaded_irq(&mbox_pdev->dev, dsp->mbox_irq, dsp_mbox_irq,
+					NULL, IRQF_ONESHOT,
+					dev_name(&mbox_pdev->dev), dsp);
+	if (ret < 0) {
+		return ret;
+	}
+
+	ret = device_property_read_u32_array(&pdev->dev, "device-irq",
+					     hw->device_irq,
+					     ARRAY_SIZE(hw->device_irq));
+	return 0;
+}
+
+int dsp_put_resource(struct es_dsp *dsp)
+{
+	if (dsp == NULL) {
+		return -EINVAL;
+	}
+	clk_put(dsp->mbox_pclk);
+	clk_put(dsp->mbox_pclk_device);
+	reset_control_put(dsp->mbox_rst);
+	reset_control_put(dsp->mbox_rst_device);
+	free_irq(dsp->mbox_irq, dsp);
+	dev_set_drvdata(&dsp->mbox_pdev->dev, NULL);
+	dsp->mbox_pdev = NULL;
+	return 0;
+}
+
+int dsp_get_resource(struct platform_device *pdev, struct es_dsp *dsp)
+{
+	struct es_dsp_hw *hw = (struct es_dsp_hw *)dsp->hw_arg;
+	int ret;
+
+	ret = dsp_get_mbx_node(pdev);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "get dsb mailbox node err.\n");
+		return ret;
+	}
+	ret = device_property_read_u32(&pdev->dev, "process-id",
+				       &(dsp->process_id));
+	if (0 != ret) {
+		dev_err(&pdev->dev, "failed to init process id\n");
+		return ret;
+	}
+	dev_dbg(&pdev->dev, "dsp processor id=%d.\n", dsp->process_id);
+	ret = device_property_read_u32(&pdev->dev, "numa-node-id",
+				       &(dsp->numa_id));
+	if (0 != ret) {
+		dev_err(&pdev->dev, "failed to get numa node id\n");
+		return ret;
+	}
+	dev_dbg(&pdev->dev, "dsp numa_id = %d.\n", dsp->numa_id);
+	/* get aclk */
+	hw->aclk = devm_clk_get(&pdev->dev, "aclk");
+	if (IS_ERR(hw->aclk)) {
+		ret = PTR_ERR(hw->aclk);
+		dev_err(&pdev->dev, "failed to get aclk: %ld\n", ret);
+		return ret;
+	}
+
+	ret = device_property_read_string(dsp->dev, "firmware-name",
+					  &dsp->firmware_name);
+	if (ret == -EINVAL || ret == -ENODATA) {
+		dev_dbg(dsp->dev,
+			"no firmware-name property, not loading firmware");
+	} else if (ret < 0) {
+		dev_err(dsp->dev, "invalid firmware name (%d)", ret);
+		return ret;
+	}
+
+	/* get uart reg base */
+	ret = device_property_read_u32(&pdev->dev, "device-uart", &dsp->device_uart);
+	if (0 != ret) {
+		dev_err(&hw->pdev->dev, "Failed to get uart reg base\n");
+		return ret;
+	}
+	return ret;
+}
+
+static long eswin_dsp_init_hw(struct es_dsp_hw *hw, int mem_idx)
+{
+	long ret = 0;
+	struct es_dsp *dsp = hw->es_dsp;
+
+	/* init uart */
+	ret = init_hw_uart(hw);
+	if (0 != ret) {
+		dev_err(dsp->dev, "failed to init uart\n");
+		goto err_uart;
+	}
+	/* init mailbox */
+	ret = init_hw_mailbox(hw);
+	if (0 != ret) {
+		dev_err(dsp->dev, "failed to init mailbox\n");
+		goto err_mb;
+	}
+
+	dev_dbg(dsp->dev,
+		"host_irq_mode %d, proid=%d, numa_id=%d. "
+		"uart base 0x%llx, mbox_tx_base 0x%llx, mbox_rx_base 0x%llx\n",
+		hw->host_irq_mode, dsp->process_id, dsp->numa_id,
+		hw->device_uart_base, hw->mailbox_tx_reg_base,
+		hw->mailbox_rx_reg_base);
+
+	return 0;
+err_mb:
+	hw_uart_uninit(dsp);
+err_uart:
+	return ret;
+}
+
+int es_dsp_pm_get_sync(struct es_dsp *dsp)
+{
+	int rc;
+
+	rc = pm_runtime_resume_and_get(dsp->dev);
+	if (rc < 0)
+		return rc;
+
+	return 0;
+}
+
+void es_dsp_pm_put_sync(struct es_dsp *dsp)
+{
+	pm_runtime_mark_last_busy(dsp->dev);
+	pm_runtime_put_autosuspend(dsp->dev);
+	return;
+}
+
+long es_dsp_hw_ioctl(struct file *flip, unsigned int cmd, unsigned long arg)
+{
+	return -EINVAL;
+}
+
+static void es_dsp_low_level_uninit(struct es_dsp *dsp)
+{
+	struct es_dsp_hw *hw = (struct es_dsp_hw *)dsp->hw_arg;
+
+	reset_uart_mutex((struct es_dsp_hw *)dsp->hw_arg);
+
+	if (dsp->mbox_pdev) {
+		dsp_uninit_mbox(dsp);
+	}
+
+	hw_uart_uninit(dsp);
+
+}
+
+void dsp_free_flat_mem(struct es_dsp *dsp, u32 size, void *cpu,
+		       dma_addr_t dma_addr)
+{
+	struct es_dsp_hw *hw = dsp->hw_arg;
+	dma_pool_free(hw->flat_dma_pool, cpu, dma_addr);
+}
+
+void *dsp_alloc_flat_mem(struct es_dsp *dsp, u32 dma_len, dma_addr_t *dma_addr)
+{
+	struct es_dsp_hw *hw = dsp->hw_arg;
+	void *flat = NULL;
+	flat = dma_pool_alloc(hw->flat_dma_pool, GFP_KERNEL, dma_addr);
+	return flat;
+}
+
+void es_dsp_put_subsys(struct es_dsp *dsp)
+{
+	struct es_dsp_subsys *subsys;
+	struct es_dsp_hw *hw = (struct es_dsp_hw *)dsp->hw_arg;
+
+	if (!hw) {
+		dsp_err("%s, %d, hw is null, err.\n", __func__, __LINE__);
+		return;
+	}
+	subsys = hw->subsys;
+	put_device(&subsys->pdev->dev);
+	module_put(subsys->pdev->dev.driver->owner);
+	return;
+}
+
+int es_dsp_get_subsys(struct platform_device *pdev, struct es_dsp *dsp)
+{
+	struct device *parent;
+	struct es_dsp_subsys *subsys;
+	struct es_dsp_hw *hw = (struct es_dsp_hw *)dsp->hw_arg;
+
+	parent = pdev->dev.parent;
+	subsys = dev_get_drvdata(parent);
+	if (IS_ERR_OR_NULL(subsys)) {
+		return -EPROBE_DEFER;
+	}
+	if (!try_module_get(subsys->pdev->dev.driver->owner)) {
+		dsp_err("error try get dsp subsys module.\n");
+		return -EIO;
+	}
+
+	get_device(&subsys->pdev->dev);
+
+	hw->map = subsys->map;
+	hw->con_map = subsys->con_map;
+	hw->dbg_reg_base = subsys->con_reg_base;
+	hw->subsys = subsys;
+	return 0;
+}
+
+
+
+int es_dsp_map_resource(struct es_dsp *dsp)
+{
+	struct es_dsp_hw *hw = (struct es_dsp_hw *)dsp->hw_arg;
+	int ret;
+
+	hw->flat_dma_pool = dma_pool_create("dsp_flat_dma", dsp->dev,
+					    sizeof(struct es_dsp_flat1_desc) +
+						    sizeof(es_dsp_buffer) *
+							    BUFFER_CNT_MAXSIZE,
+					    64, 0);
+	if (!hw->flat_dma_pool) {
+		dsp_err("cat not create flat dma pool.\n");
+		ret = -ENOMEM;
+		return ret;
+	}
+
+	dsp->mbox_tx_base =
+		devm_ioremap(&dsp->mbox_pdev->dev, dsp->mbox_tx_res->start, resource_size(dsp->mbox_tx_res));
+	if (IS_ERR(dsp->mbox_tx_base)) {
+		dsp_err("ioremap for dsp mbox tx register.\n");
+		return -EIO;
+	}
+
+	dsp->mbox_rx_base =
+		devm_ioremap(&dsp->mbox_pdev->dev, dsp->mbox_rx_res->start, resource_size(dsp->mbox_rx_res));
+	if (IS_ERR(dsp->mbox_rx_base)) {
+		return -EIO;
+	}
+
+	hw->uart_mutex_base =
+		ioremap(UART_MUTEX_BASE_ADDR, DSP_DEVICE_UART_MUTEX_IOVA_SIZE);
+	if (!hw->uart_mutex_base) {
+		dev_err(&hw->pdev->dev, "ioremap error\n");
+		ret = -ENOMEM;
+		return ret;
+	}
+	return 0;
+}
+
+int es_dsp_unmap_resource(struct es_dsp *dsp)
+{
+	struct es_dsp_hw *hw = (struct es_dsp_hw *)dsp->hw_arg;
+
+	if (hw->flat_dma_pool != NULL) {
+		dma_pool_destroy(hw->flat_dma_pool);
+		hw->flat_dma_pool = NULL;
+	}
+
+	if (dsp->mbox_rx_base != NULL) {
+		devm_iounmap(&dsp->mbox_pdev->dev, dsp->mbox_rx_base);
+		dsp->mbox_rx_base = NULL;
+	}
+	if (dsp->mbox_tx_base != NULL) {
+		devm_iounmap(&dsp->mbox_pdev->dev, dsp->mbox_tx_base);
+		dsp->mbox_tx_base = NULL;
+	}
+	if (hw->uart_mutex_base != NULL) {
+
+		iounmap(hw->uart_mutex_base);
+		hw->uart_mutex_base = NULL;
+	}
+	return 0;
+}
+
+int es_dsp_hw_init(struct es_dsp *dsp)
+{
+	int ret;
+	struct device *parent;
+	struct es_dsp_subsys *subsys;
+	struct es_dsp_hw *hw = (struct es_dsp_hw *)dsp->hw_arg;
+
+	dev_info(dsp->dev, "\n\ndsp hw init begin\n");
+
+	if (!hw)
+		return -ENOMEM;
+
+	hw->iddr_iova = DSP_IDDR_IOVA;
+	hw->iddr_size = DSP_IDDR_IOVA_SIZE;
+	hw->iddr_ptr = iommu_map_rsv_iova(dsp->dev, hw->iddr_iova,
+					  hw->iddr_size, GFP_KERNEL, 0);
+	if (!hw->iddr_ptr) {
+		dsp_err("Err, map iddr iova.\n");
+		ret = -ENOMEM;
+		goto err_iddr;
+	}
+
+	ret = eswin_dsp_init_hw(hw, 0);
+	if (ret < 0) {
+		dsp_err("%s, eswin_dsp_init_hw failed, ret=%d.\n", __func__,
+			ret);
+		goto err_init_hw;
+	}
+
+	dsp->firmware_dev_addr = DSP_FIRMWARE_IOVA;
+	dsp->firmware_addr =
+		iommu_map_rsv_iova(dsp->dev, (dma_addr_t)dsp->firmware_dev_addr,
+				   DSP_FIRMWARE_IOVA_SIZE, GFP_KERNEL, 0);
+
+	if (IS_ERR_OR_NULL(dsp->firmware_addr)) {
+		dsp_err("failed to alloc firmware memory\n");
+		ret = -ENOMEM;
+		goto err_map_firm;
+	}
+
+	hw->pts_iova = DSP_PTS_IOVA;
+	hw->pts_iova_size = DSP_PTS_IOVA_SIZE;
+	hw->pts_phys_base = 0x51840000;
+	ret = iommu_map_rsv_iova_with_phys(dsp->dev, (dma_addr_t)DSP_PTS_IOVA,
+					   DSP_PTS_IOVA_SIZE, 0x51840000,
+					   IOMMU_MMIO);
+	if (ret != 0) {
+		dev_err(dsp->dev, "iommu map dsp pts phy error.\n");
+		hw->pts_iova = 0;
+		goto err;
+	}
+	es_dsp_set_rate(hw, dsp->rate);
+	dev_dbg(dsp->dev, "firmware-name:%s.\n", dsp->firmware_name);
+	return 0;
+err:
+	iommu_unmap_rsv_iova(dsp->dev, dsp->firmware_addr,
+			     dsp->firmware_dev_addr, DSP_FIRMWARE_IOVA_SIZE);
+	dsp->firmware_addr = NULL;
+
+err_map_firm:
+	es_dsp_low_level_uninit(dsp);
+err_init_hw:
+	iommu_unmap_rsv_iova(dsp->dev, hw->iddr_ptr, hw->iddr_iova,
+			     hw->iddr_size);
+	hw->iddr_ptr = NULL;
+err_iddr:
+	return ret;
+}
+
+void dsp_disable_irq(struct es_dsp *dsp)
+{
+	if (dsp->mbox_irq) {
+		disable_irq(dsp->mbox_irq);
+	}
+}
+
+int dsp_enable_irq(struct es_dsp *dsp)
+{
+	if (dsp->mbox_irq) {
+		enable_irq(dsp->mbox_irq);
+	}
+}
+
+void es_dsp_hw_uninit(struct es_dsp *dsp)
+{
+	struct es_dsp_hw *hw = (struct es_dsp_hw *)dsp->hw_arg;
+	struct es_dsp_subsys *subsys = hw->subsys;
+
+	if (hw->iddr_ptr != NULL) {
+		iommu_unmap_rsv_iova(dsp->dev, hw->iddr_ptr, hw->iddr_iova,
+				     hw->iddr_size);
+		hw->iddr_ptr = NULL;
+	}
+
+	if (dsp->firmware_addr != NULL) {
+		iommu_unmap_rsv_iova(dsp->dev, dsp->firmware_addr,
+				     dsp->firmware_dev_addr,
+				     DSP_FIRMWARE_IOVA_SIZE);
+	}
+
+	es_dsp_low_level_uninit(dsp);
+
+	if (hw->pts_iova != 0) {
+		iommu_unmap_rsv_iova(dsp->dev, NULL, hw->pts_iova,
+				     hw->pts_iova_size);
+		hw->pts_iova = 0;
+	}
+}
+
+void dsp_free_hw(struct es_dsp *dsp)
+{
+	struct es_dsp_hw *hw = (struct es_dsp_hw *)dsp->hw_arg;
+	if (!hw) {
+		return;
+	}
+
+	devm_kfree(dsp->dev, hw);
+	dsp->hw_arg = NULL;
+	return;
+}
+
+int dsp_alloc_hw(struct platform_device *pdev, struct es_dsp *dsp)
+{
+	struct es_dsp_hw *hw =
+		devm_kzalloc(&pdev->dev, sizeof(*hw), GFP_KERNEL);
+	if (!hw) {
+		dsp_err("%s, %d, alloc hw err.\n", __func__, __LINE__);
+		return -ENOMEM;
+	}
+
+	dsp->hw_arg = hw;
+	hw->pdev = pdev;
+	hw->es_dsp = dsp;
+	return 0;
+}
+
+int es_dsp_platform_init(void)
+{
+	return 0;
+}
+
+int es_dsp_platform_uninit(void)
+{
+	return 0;
+}
diff --git a/drivers/soc/eswin/ai_driver/dsp/dsp_platform.h b/drivers/soc/eswin/ai_driver/dsp/dsp_platform.h
new file mode 100644
index 000000000000..82343e910bc2
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/dsp/dsp_platform.h
@@ -0,0 +1,59 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#ifndef __DSP_PLATFORM_INTF_H_
+#define __DSP_PLATFORM_INTF_H_
+
+#include <linux/platform_device.h>
+#include "dsp_main.h"
+struct es_dsp_hw;
+void es_dsp_send_irq(struct es_dsp_hw *, dsp_request_t *);
+int es_dsp_reboot_core(struct es_dsp_hw *);
+int es_dsp_enable(struct es_dsp_hw *);
+void es_dsp_disable(struct es_dsp_hw *);
+int es_dsp_set_rate(struct es_dsp_hw *, unsigned long rate);
+void es_dsp_reset(struct es_dsp_hw *);
+void es_dsp_halt(struct es_dsp_hw *);
+void es_dsp_release(struct es_dsp_hw *);
+int es_dsp_sync(struct es_dsp *dsp);
+int es_dsp_load_op(struct es_dsp_hw *, void *op_ptr);
+
+int es_dsp_platform_init(void);
+int es_dsp_platform_uninit(void);
+int es_dsp_hw_init(struct es_dsp *dsp);
+void es_dsp_hw_uninit(struct es_dsp *dsp);
+void reset_uart_mutex(struct es_dsp_hw *hw);
+
+int es_dsp_pm_get_sync(struct es_dsp *dsp);
+void es_dsp_pm_put_sync(struct es_dsp *dsp);
+
+int dsp_request_firmware(struct es_dsp *dsp);
+void dsp_release_firmware(struct es_dsp *dsp);
+
+long es_dsp_hw_ioctl(struct file *flip, unsigned int cmd, unsigned long arg);
+void dsp_send_invalid_code_seg(struct es_dsp_hw *hw, struct dsp_op_desc *op);
+int dsp_load_op_file(struct es_dsp *dsp, struct dsp_op_desc *op);
+void dsp_free_flat_mem(struct es_dsp *dsp, u32 size, void *cpu,
+		       dma_addr_t dma_addr);
+void *dsp_alloc_flat_mem(struct es_dsp *dsp, u32 dma_len, dma_addr_t *dma_addr);
+int es_dsp_clk_enable(struct es_dsp *);
+int es_dsp_clk_disable(struct es_dsp *dsp);
+int es_dsp_core_clk_enable(struct es_dsp *dsp);
+int es_dsp_core_clk_disable(struct es_dsp *dsp);
+
+int dsp_get_resource(struct platform_device *pdev, struct es_dsp *dsp);
+int dsp_put_resource(struct es_dsp *dsp);
+
+int es_dsp_get_subsys(struct platform_device *pdev, struct es_dsp *dsp);
+void dsp_free_hw(struct es_dsp *dsp);
+int dsp_alloc_hw(struct platform_device *pdev, struct es_dsp *dsp);
+int dsp_enable_irq(struct es_dsp *dsp);
+void dsp_disable_irq(struct es_dsp *dsp);
+void dsp_disable_mbox_clock(struct es_dsp *dsp);
+int dsp_enable_mbox_clock(struct es_dsp *dsp);
+
+#endif
diff --git a/drivers/soc/eswin/ai_driver/dsp/dsp_platform_sim.c b/drivers/soc/eswin/ai_driver/dsp/dsp_platform_sim.c
new file mode 100644
index 000000000000..fd2edd5fa926
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/dsp/dsp_platform_sim.c
@@ -0,0 +1,529 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/firmware.h>
+#include <linux/mailbox_client.h>
+#include <linux/mailbox/eswin-mailbox.h>
+#include <asm/cacheflush.h>
+#include <linux/regmap.h>
+#include <linux/pm_runtime.h>
+#include <linux/eswin-win2030-sid-cfg.h>
+#include <dt-bindings/memory/eswin-win2030-sid.h>
+#include <linux/clk.h>
+#include <linux/slab.h>
+
+#include "dsp_ioctl.h"
+#include "dsp_main.h"
+
+#define DRIVER_NAME "eswin-dsp"
+#define FIRMWARE_SIZE_MAX (1024 * 1024 * 4)
+
+enum dsp_irq_mode {
+	DSP_IRQ_NONE,
+	DSP_IRQ_LEVEL,
+	DSP_IRQ_MAX,
+};
+
+struct es_dsp_resource {
+	u32 process_id;
+	u32 numa_id;
+	char *firmware_name;
+};
+
+struct es_dsp_hw {
+	struct es_dsp *es_dsp;
+	struct platform_device *pdev;
+	spinlock_t send_lock;
+	dsp_request_t *emu_irq_task;
+	wait_queue_head_t emu_irq_wait;
+	atomic_t emu_task_count;
+	es_dsp_h2d_msg msg;
+};
+
+void dsp_send_invalid_code_seg(struct es_dsp_hw *hw, struct dsp_op_desc *op)
+{
+}
+
+void es_dsp_send_irq(struct es_dsp_hw *hw, dsp_request_t *req)
+{
+	es_dsp_h2d_msg msg;
+
+	msg.command = DSP_CMD_FLAT1;
+	msg.allow_eval = req->allow_eval;
+	msg.poll_mode = req->poll_mode;
+	msg.sync_cache = req->sync_cache;
+	msg.iova_ptr = req->dsp_flat1_iova;
+
+	if (hw->emu_irq_task == NULL && atomic_read(&hw->emu_task_count) == 0) {
+		dsp_debug("%s, wake up emu_irq_wait.\n", __func__);
+		hw->emu_irq_task = req;
+		hw->msg = msg;
+
+		atomic_add(1, &hw->emu_task_count);
+		wake_up_interruptible_nr(&hw->emu_irq_wait, 1);
+	}
+}
+
+int es_dsp_reboot_core(struct es_dsp_hw *hw)
+{
+	struct task_struct *task;
+	struct es_dsp *dsp = hw->es_dsp;
+
+	hw->emu_irq_task = NULL;
+	atomic_set(&hw->emu_task_count, 0);
+	dsp->off = true;
+	for_each_process(task) {
+		if (strcmp(task->comm, "eic7700_dsp_fw") == 0) {
+			send_sig(SIGKILL, task, 1);
+		}
+	}
+	return -1;
+}
+
+int es_dsp_load_op(struct es_dsp_hw *hw, void *op_ptr)
+{
+	struct dsp_op_desc *op = (struct dsp_op_desc *)op_ptr;
+
+	dsp_debug("this is x86 emu.\n");
+	op->op_shared_seg_ptr = NULL;
+	strcpy(op->funcs.op_name, op->name);
+	return 0;
+}
+
+static long dsp_ioctl_wait_irq(struct file *flip,
+			       struct dsp_ioctl_task __user *arg)
+{
+	struct dsp_file *dsp_file = flip->private_data;
+	struct es_dsp *dsp = dsp_file->dsp;
+	struct es_dsp_hw *hw = dsp->hw_arg;
+	unsigned long flags;
+	struct es_dsp_flat1_desc *flat_desc;
+	struct dsp_ioctl_task task;
+	es_dsp_h2d_msg msg;
+
+	spin_lock_irqsave(&hw->send_lock, flags);
+
+	while (hw->emu_irq_task == NULL) {
+		spin_unlock_irqrestore(&hw->send_lock, flags);
+
+		if (wait_event_interruptible(hw->emu_irq_wait,
+					     hw->emu_irq_task != NULL)) {
+			dsp_debug(
+				"wait event wake up from interrupt, pls restart, pending=0x%x\n",
+				signal_pending(current));
+			return -ERESTARTSYS;
+		}
+
+		spin_lock_irqsave(&hw->send_lock, flags);
+	}
+	dsp_debug("%s, arg:%px\n", __func__, arg);
+	flat_desc = hw->emu_irq_task->flat_virt;
+	task.msg = hw->msg;
+	dsp_debug("%s, emu_task addr=%px\n", __func__, hw->emu_irq_task);
+	dsp_debug("%s, get oper name=%s.\n", __func__,
+		  flat_desc->funcs.op_name);
+
+	task.msg.iova_ptr = virt_to_phys((void *)flat_desc);
+	task.flat_size = hw->emu_irq_task->flat_size;
+
+	dsp_debug("%s, task flat phys=0x%x, size=0x%x\n", __func__,
+		  task.msg.iova_ptr, task.flat_size);
+	hw->emu_irq_task = NULL;
+	if (copy_to_user((void __user *)arg, (void *)&task,
+			 sizeof(struct dsp_ioctl_task))) {
+		spin_unlock_irqrestore(&hw->send_lock, flags);
+		dsp_err("copy to user failed.\n");
+		return -EFAULT;
+	}
+	spin_unlock_irqrestore(&hw->send_lock, flags);
+	return 0;
+}
+
+static long dsp_ioctl_send_ack(struct file *flip, unsigned long arg)
+{
+	struct dsp_file *dsp_file = flip->private_data;
+	struct es_dsp *dsp = dsp_file->dsp;
+	struct es_dsp_hw *hw = dsp->hw_arg;
+	struct eswin_mbox_msg msg;
+	unsigned long flags;
+	int ret;
+
+	dsp_debug("send ack to.\n");
+	if (copy_from_user((void *)&msg, (void *)arg,
+			   sizeof(struct eswin_mbox_msg))) {
+		return -EFAULT;
+	}
+
+	atomic_dec_if_positive(&hw->emu_task_count);
+	ret = dsp_irq_handler(&msg, dsp);
+	return (ret == IRQ_HANDLED) ? 0 : ret;
+}
+
+static int dsp_cma_check(struct cma *cma, void *data)
+{
+	struct dsp_cma_info *tmp;
+	if (data == NULL) {
+		dsp_err("data is null.\n");
+		return 0;
+	}
+
+	tmp = (struct dsp_cma_info *)data;
+	if (cma != NULL) {
+		if (strcmp(cma_get_name(cma), "reserved") != 0) {
+			return 0;
+		}
+
+		tmp->base = cma_get_base(cma);
+		tmp->size = cma_get_size(cma);
+		return 1;
+	}
+	return 0;
+}
+
+static long dsp_ioctl_get_cma_info(struct file *flip, unsigned long arg)
+{
+	struct dsp_cma_info info;
+	int ret;
+
+	ret = cma_for_each_area(dsp_cma_check, &info);
+	if (!ret) {
+		dsp_err("cannot find cma info.\n");
+		return -ENODEV;
+	}
+
+	if (copy_to_user((void __user *)arg, &info, sizeof(info))) {
+		dsp_err("%s, copy to user, err.\n", __func__);
+		return -EFAULT;
+	}
+	return 0;
+}
+
+long es_dsp_hw_ioctl(struct file *flip, unsigned int cmd, unsigned long arg)
+{
+	long retval;
+
+	switch (cmd) {
+	case DSP_IOCTL_WAIT_IRQ:
+		retval = dsp_ioctl_wait_irq(
+			flip, (struct dsp_ioctl_task __user *)arg);
+		break;
+	case DSP_IOCTL_SEND_ACK:
+		retval = dsp_ioctl_send_ack(flip, arg);
+		break;
+	case DSP_IOCTL_GET_CMA_INFO:
+		retval = dsp_ioctl_get_cma_info(flip, arg);
+		break;
+	default:
+		dsp_err("%s, error cmd = 0x%x.\n", __func__, cmd);
+		retval = -EINVAL;
+		break;
+	}
+	return retval;
+}
+
+int es_dsp_enable(struct es_dsp_hw *hw)
+{
+	return 0;
+}
+void es_dsp_disable(struct es_dsp_hw *hw)
+{
+}
+void es_dsp_reset(struct es_dsp_hw *hw)
+{
+}
+void es_dsp_halt(struct es_dsp_hw *hw)
+{
+}
+void es_dsp_release(struct es_dsp_hw *hw)
+{
+}
+long es_dsp_set_rate(struct es_dsp_hw *hw, unsigned long rate)
+{
+	return 0;
+}
+int es_dsp_sync(struct es_dsp *dsp)
+{
+	dsp->off = false;
+	return 0;
+}
+
+int es_dsp_load_fw_segment(struct es_dsp_hw *hw, const void *image,
+			   Elf32_Phdr *phdr)
+{
+	return 0;
+}
+int dsp_request_firmware(struct es_dsp *dsp)
+{
+	return 0;
+}
+void dsp_release_firmware(struct es_dsp *dsp)
+{
+	return;
+}
+
+int es_dsp_pm_get_sync(struct es_dsp *dsp)
+{
+	return 0;
+}
+
+void es_dsp_pm_put_sync(struct es_dsp *dsp)
+{
+	return;
+}
+static int es_dsp_unload_op(struct es_dsp_hw *hw, void *op)
+{
+}
+
+void dsp_free_flat_mem(struct es_dsp *dsp, u32 size, void *cpu,
+		       dma_addr_t dma_addr)
+{
+	dma_free_coherent(dsp->dev, size, cpu, dma_addr);
+}
+
+void *dsp_alloc_flat_mem(struct es_dsp *dsp, u32 dma_len, dma_addr_t *dma_addr)
+{
+	void *flat = NULL;
+	flat = dma_alloc_coherent(dsp->dev, dma_len, dma_addr, GFP_KERNEL);
+	return flat;
+}
+
+int es_dsp_core_clk_enable(struct es_dsp_hw *hw)
+{
+	return 0;
+}
+int es_dsp_core_clk_disable(struct es_dsp_hw *hw)
+{
+	return 0;
+}
+
+int es_dsp_clk_enable(struct es_dsp *dsp)
+{
+	return 0;
+}
+void es_dsp_clk_disable(struct es_dsp *dsp)
+{
+	return;
+}
+
+void reset_uart_mutex(struct es_dsp_hw *hw)
+{
+}
+
+int dsp_enable_irq(struct es_dsp *dsp)
+{
+	return 0;
+}
+
+void dsp_disable_irq(struct es_dsp *dsp)
+{
+
+}
+
+void dsp_disable_mbox_clock(struct es_dsp *dsp)
+{
+
+}
+
+int dsp_enable_mbox_clock(struct es_dsp *dsp)
+{
+	return 0;
+}
+
+int es_dsp_core_clk_enable(struct es_dsp *dsp)
+{
+	return 0;
+}
+int es_dsp_core_clk_disable(struct es_dsp *dsp)
+{
+	return 0;
+}
+
+void dsp_put_resource(struct es_dsp *dsp)
+{
+	return;
+}
+int dsp_get_resource(struct platform_device *pdev, struct es_dsp *dsp)
+{
+	struct es_dsp_hw *hw = (struct es_dsp_hw *)dsp->hw_arg;
+	struct es_dsp_resource *res;
+
+	res = (struct es_dsp_resource *)dev_get_platdata(&pdev->dev);
+	dsp->firmware_name =
+		res->firmware_name;  //(char *)dev_get_platdata(&pdev->dev);
+	dsp->process_id = res->process_id;
+	dsp->numa_id = res->numa_id;
+	dsp_info("the firmware name=%s.\n", dsp->firmware_name);
+	dsp_info("%s, process_id=%d, numa_id=%d.\n", __func__, dsp->process_id,
+		 dsp->numa_id);
+
+	return 0;
+}
+
+int es_dsp_get_subsys(struct platform_device *pdev, struct es_dsp *dsp)
+{
+	struct es_dsp_hw *hw = (struct es_dsp_hw *)dsp->hw_arg;
+	hw->pdev = pdev;
+	hw->es_dsp = dsp;
+	return 0;
+}
+int es_dsp_hw_init(struct platform_device *pdev, struct es_dsp *dsp)
+{
+	struct es_dsp_hw *hw = (struct es_dsp_hw *)dsp->hw_arg;
+
+	if (!hw) {
+		return -ENOMEM;
+	}
+
+	init_waitqueue_head(&hw->emu_irq_wait);
+	atomic_set(&hw->emu_task_count, 0);
+	spin_lock_init(&hw->send_lock);
+
+	dsp->firmware_addr = dma_alloc_coherent(dsp->dev, FIRMWARE_SIZE_MAX,
+						&dsp->firmware_dev_addr,
+						GFP_KERNEL);
+	if (IS_ERR_OR_NULL(dsp->firmware_addr)) {
+		dev_err(dsp->dev, "failed to alloc firmware memory\n");
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+int dsp_get_mbx_node(struct platform_device *pdev)
+{
+	return 0;
+}
+
+void es_dsp_hw_uninit(struct es_dsp *dsp)
+{
+	if (dsp->firmware_addr != NULL)
+		dma_free_coherent(dsp->dev, FIRMWARE_SIZE_MAX,
+				  dsp->firmware_addr, dsp->firmware_dev_addr);
+
+	return;
+}
+
+#define MAX_DSP_NUM 2
+#define FIRM_NAME_MAX 30
+
+static struct platform_device *es_dsp_hw_pdev[MAX_DSP_NUM];
+
+int es_dsp_platform_init(void)
+{
+	int ret;
+	int i;
+	char *firm_name[MAX_DSP_NUM];
+	struct es_dsp_resource res;
+
+	for (i = 0; i < MAX_DSP_NUM; i++) {
+		es_dsp_hw_pdev[i] = platform_device_alloc(DRIVER_NAME, i);
+		if (!es_dsp_hw_pdev[i]) {
+			i--;
+			while (i >= 0) {
+				platform_device_put(es_dsp_hw_pdev[i--]);
+			}
+			ret = -EIO;
+			goto err_dev_alloc;
+		}
+		es_dsp_hw_pdev[i]->dev.coherent_dma_mask = DMA_BIT_MASK(32);
+	}
+
+	for (i = 0; i < MAX_DSP_NUM; i++) {
+		res.process_id = i;
+		res.numa_id = 0;
+		dsp_info("%s, proces_id=%d.\n", __func__, res.process_id);
+		firm_name[i] = kzalloc(FIRM_NAME_MAX, GFP_KERNEL);
+		if (!firm_name[i]) {
+			ret = -ENOMEM;
+			goto err_add_pdata;
+		}
+		snprintf(firm_name[i], FIRM_NAME_MAX, "DSP_%d.exe", i);
+
+		res.firmware_name = firm_name[i];
+		ret = platform_device_add_data(es_dsp_hw_pdev[i], (void *)&res,
+					       sizeof(res));
+		if (ret) {
+			goto err_add_pdata;
+		}
+	}
+
+	for (i = 0; i < MAX_DSP_NUM; i++) {
+		ret = platform_device_add(es_dsp_hw_pdev[i]);
+		if (ret < 0) {
+			i--;
+			while (i >= 0) {
+				platform_device_del(es_dsp_hw_pdev[i]);
+			}
+			goto err_add_dev;
+		}
+	}
+	dsp_info("%s, successfully new arch\n", __func__);
+	return 0;
+
+err_add_dev:
+err_add_pdata:
+	for (i = 0; i < MAX_DSP_NUM; i++) {
+		kfree(firm_name[i]);
+	}
+
+	for (i = 0; i < MAX_DSP_NUM; i++) {
+		platform_device_put(es_dsp_hw_pdev[i]);
+	}
+err_dev_alloc:
+	return ret;
+}
+
+int dsp_alloc_hw(struct platform_device *pdev, struct es_dsp *dsp)
+{
+	struct es_dsp_hw *hw =
+		devm_kzalloc(&pdev->dev, sizeof(*hw), GFP_KERNEL);
+	if (!hw) {
+		dsp_err("%s, %d, alloc hw err.\n", __func__, __LINE__);
+		return -ENOMEM;
+	}
+
+	dsp->hw_arg = hw;
+	hw->pdev = pdev;
+	hw->es_dsp = dsp;
+	return 0;
+}
+
+void dsp_free_hw(struct es_dsp *dsp)
+{
+	struct es_dsp_hw *hw = (struct es_dsp_hw *)dsp->hw_arg;
+	if (!hw) {
+		return;
+	}
+
+	devm_free(dsp->dev, hw);
+	dsp->hw_arg = NULL;
+	return;
+}
+
+int es_dsp_platform_uninit(void)
+{
+	int i;
+	struct es_dsp_resource *res;
+
+	for (i = 0; i < MAX_DSP_NUM; i++) {
+		res = (struct es_dsp_resource *)dev_get_platdata(
+			&es_dsp_hw_pdev[i]->dev);
+		if (es_dsp_hw_pdev[i]) {
+			platform_device_del(es_dsp_hw_pdev[i]);
+			es_dsp_hw_pdev[i] = NULL;
+		}
+		kfree((void *)res->firmware_name);
+	}
+	dsp_info("%s, ok.\n", __func__);
+	return 0;
+}
diff --git a/drivers/soc/eswin/ai_driver/dsp/dsp_proc.c b/drivers/soc/eswin/ai_driver/dsp/dsp_proc.c
new file mode 100644
index 000000000000..b12258767c43
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/dsp/dsp_proc.c
@@ -0,0 +1,400 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#include <linux/fs.h>
+#include <linux/proc_fs.h>
+#include <linux/kernel.h>
+#include <linux/seq_file.h>
+#include "dsp_main.h"
+
+static struct proc_dir_entry *proc_es_dsp;
+extern int dsp_log_level;
+int dsp_perf_enable = 0;
+
+// from eswin/dsp/framework/lsp/memmap.xmm .dram1.perfdata(0x2813ffc0)
+#define DSP_PERF_START_ADDR 0x5b13ffc0
+#define DIE_BASE_INTERVAL 0x20000000
+#define DSP_CORE_INTERVAL 0x40000
+
+void get_dsp_perf_info(es_dsp_perf_info *perf_info, int die_num, int dsp_num)
+{
+	struct es_dsp *dsp = NULL;
+	void *iomem = NULL;
+	unsigned long phys;
+
+	memset((void *)perf_info, 0, sizeof(es_dsp_perf_info));
+	dsp = es_proc_get_dsp(die_num, dsp_num);
+	if (!dsp) {
+		return;
+	}
+
+	phys = DSP_PERF_START_ADDR + die_num * DIE_BASE_INTERVAL +
+	       DSP_CORE_INTERVAL * dsp_num;
+	iomem = ioremap(phys, sizeof(es_dsp_perf_info));
+	if (!iomem) {
+		return;
+	}
+	memcpy((void *)perf_info, iomem, sizeof(es_dsp_perf_info));
+
+	iounmap(iomem);
+}
+
+static int stats_show(struct seq_file *m, void *p)
+{
+	struct es_dsp *dsp;
+	int i, j;
+	dsp_request_t req;
+	struct timespec64 ts;
+	const int die_cnt = 2;
+	const int dsp_cnt = 4;
+	es_dsp_perf_info perf_info;
+	int k;
+
+	seq_printf(
+		m,
+		"--------------------------------DSP PARAM INFO----------------------------------\n");
+	seq_printf(m, "    DieId    CoreId     Enable   CmdTOut(s)\n");
+	for (j = 0; j < die_cnt; j++) {
+		for (i = 0; i < dsp_cnt; i++) {
+			dsp = es_proc_get_dsp(j, i);
+			if (dsp == NULL) {
+				seq_printf(
+					m,
+					"    %5d       %5d       %s        %5d\n",
+					j, i, "NO", 0);
+			} else {
+				seq_printf(
+					m,
+					"    %5d       %5d       %s        %5d\n",
+					j, i, "Yes", es_dsp_exec_cmd_timeout());
+			}
+		}
+	}
+
+	seq_printf(m, "\n");
+	seq_printf(
+		m,
+		"--------------------------------DSP RUNTIME INFO------------------------------------\n");
+	seq_printf(
+		m,
+		"\t%-8s\t %-8s\t %-13s\t %-13s\t %-16s\t %-15s\t %-15s\t %-20s\t %-15s\n",
+		"DieId", "CoreId", "TotalIntCnt", "SendToDspCnt",
+		"FinishedTaskCnt", "FailedTaskCnt", "TimeOutTaskCnt",
+		"PendingTaskCnt", "LTaskRunTm");
+	for (j = 0; j < die_cnt; j++) {
+		for (i = 0; i < dsp_cnt; i++) {
+			struct es_dsp_stats *stats;
+			dsp = es_proc_get_dsp(j, i);
+			if (dsp == NULL) {
+				seq_printf(
+					m,
+					"\t%-8d\t %-8d\t %-13d\t %-13d\t %-16d\t %-15d\t %-15d\t %-20d\t %-15d\n",
+					j, i, 0, 0, 0, 0, 0, 0, 0);
+				continue;
+			}
+			stats = dsp->stats;
+			ts = ns_to_timespec64(stats->last_task_time);
+			seq_printf(
+				m,
+				"\t%-8d\t %-8d\t %-13d\t %-13d\t %-16d\t %-15d\t %-15d\t %-20d\t %lldms%ldns\n",
+				j, i, stats->total_int_cnt,
+				stats->send_to_dsp_cnt, stats->total_ok_cnt,
+				stats->total_failed_cnt,
+				stats->task_timeout_cnt, dsp->wait_running,
+				ts.tv_sec * 1000, ts.tv_nsec);
+		}
+	}
+
+	seq_printf(m, "\n");
+	seq_printf(
+		m,
+		"--------------------------------DSP TASK INFO------------------------------------\n");
+	seq_printf(m, "\t%-8s\t %-8s\t %-8s\t %-8s\t %-12s\t %-12s\n", "DieId",
+		   "CoreId", "TaskCnt", "InvaldCmdCnt", "SendPrepareNpu",
+		   "SendEvalToNpu");
+	for (j = 0; j < die_cnt; j++) {
+		for (i = 0; i < dsp_cnt; i++) {
+			get_dsp_perf_info(&perf_info, j, i);
+			dsp = es_proc_get_dsp(j, i);
+
+			if (dsp == NULL) {
+				seq_printf(
+					m,
+					"\t%-8d\t %-8d\t %-8d\t %-8d\t %-12d\t %-12d\n",
+					j, i, 0, 0, 0, 0);
+			} else {
+				seq_printf(
+					m,
+					"\t%-8d\t %-8d\t %-8d\t %-8d\t %-12d\t %-12d\n",
+					j, i, perf_info.task_cnt,
+					perf_info.invalid_cmd_cnt,
+					perf_info.send_prepare_to_npu,
+					perf_info.send_eval_to_npu);
+			}
+		}
+	}
+
+#if BUILD_RELEASE > 1
+	seq_printf(m, "\n");
+	seq_printf(
+		m,
+		"--------------------------------DSP HW PERF INFO------------------------------------\n");
+	seq_printf(
+		m,
+		"\t%-8s\t %-8s\t %-10s\t %-10s\t %-10s\t %-10s\t %-10s\t %-8s\t %-8s\t %-8s\n",
+		"DieId", "CoreId", "TaskName", "StartTm", "PrepSTm", "PrepETm",
+		"EvalSTm", "EvalETm", "IPCSTm", "EndTm");
+	for (j = 0; j < die_cnt; j++) {
+		for (i = 0; i < dsp_cnt; i++) {
+			get_dsp_perf_info(&perf_info, j, i);
+			dsp = es_proc_get_dsp(j, i);
+			if (dsp == NULL) {
+				seq_printf(
+					m,
+					"\t%-8d\t %-8d\t %-10s\t %-10u\t %-10u\t %-10u\t %-10u\t %-8u\t %-8u\t %-8u\n",
+					j, i, "NULL", 0, 0, 0, 0, 0, 0, 0);
+				continue;
+			} else {
+				seq_printf(
+					m,
+					"\t%-8d\t %-8d\t %-10s\t %-10u\t %-10u\t %-10u\t %-10u\t %-8u\t %-8u\t %-8u\n",
+					j, i, dsp->stats->last_op_name,
+					perf_info.flat1_start_time,
+					perf_info.prepare_start_time,
+					perf_info.prepare_end_time,
+					perf_info.eval_start_time,
+					perf_info.eval_end_time,
+					perf_info.notify_start_time,
+					perf_info.flat1_end_time);
+			}
+		}
+	}
+#endif
+
+	seq_printf(m, "\n");
+	seq_printf(
+		m,
+		"--------------------------------DSP INVOKE INFO------------------------------------\n");
+	seq_printf(m, "\t%-8s\t %-8s\t %-8s\t %-15s\t %-10s\t %-8s\t %-10s\n",
+		   "DieId", "CoreId", "Pri", "TaskName", "TaskHnd", "TaskStat",
+		   "TaskRunTm");
+	for (j = 0; j < die_cnt; j++) {
+		for (i = 0; i < dsp_cnt; i++) {
+			dsp = es_proc_get_dsp(j, i);
+			if (dsp == NULL) {
+				seq_printf(
+					m,
+					"\t%-8d\t %-8d\t %-8d\t %-15s\t %-10d\t %-8s\t %-10d\n",
+					j, i, 0, "NULL", 0, "NULL", 0);
+				continue;
+			}
+
+			if (dsp->current_task == NULL) {
+				seq_printf(
+					m,
+					"\t%-8d\t %-8d\t %-8d\t %-15s\t %-10d\t %-8s\t %-10d\n",
+					j, i, 0, "NULL", 0, "NULL", 0);
+				continue;
+			}
+			memcpy(&req, dsp->current_task, sizeof(req));
+			ts = ns_to_timespec64(ktime_get_real_ns() -
+					      dsp->send_time);
+			seq_printf(
+				m,
+				"\t%-8d\t %-8d\t %-8d\t %-15s\t %-10llx\t %-8s\t %lldms%ldns\n",
+				j, i, req.prio, dsp->stats->last_op_name,
+				req.handle, "eval", ts.tv_sec * 1000,
+				ts.tv_nsec);
+		}
+	}
+	seq_printf(m, "\n");
+	return 0;
+}
+
+static int proc_stats_release(struct inode *inode, struct file *file)
+{
+	const int die_cnt = 2;
+	const int dsp_cnt = 4;
+	int i, j;
+	struct es_dsp *dsp;
+
+	for (j = 0; j < die_cnt; j++) {
+		for (i = 0; i < dsp_cnt; i++) {
+			dsp = es_proc_get_dsp(j, i);
+			if (dsp == NULL) {
+				continue;
+			}
+			es_dsp_pm_put_sync(dsp);
+		}
+	}
+	return 0;
+}
+
+static int proc_stats_open(struct inode *inode, struct file *file)
+{
+	int ret;
+	const int die_cnt = 2;
+	const int dsp_cnt = 4;
+	int i, j;
+	struct es_dsp *dsp;
+
+	for (j = 0; j < die_cnt; j++) {
+		for (i = 0; i < dsp_cnt; i++) {
+			dsp = es_proc_get_dsp(j, i);
+			if (dsp == NULL) {
+				continue;
+			}
+			ret = es_dsp_pm_get_sync(dsp);
+			if (ret < 0) {
+				dsp_err("%s, %d, get dsp die = %d, core = %d pm err.\n",
+					__func__, __LINE__, j, i);
+				goto err;
+			}
+		}
+	}
+	return single_open(file, stats_show, NULL);
+
+err:
+	for (j; j >= 0; j--) {
+		for (i -= 1; i >= 0; i--) {
+			dsp = es_proc_get_dsp(j, i);
+			if (dsp == NULL) {
+				continue;
+			}
+			es_dsp_pm_put_sync(dsp);
+		}
+	}
+	return ret;
+}
+
+static int debug_show(struct seq_file *m, void *p)
+{
+	seq_printf(m, "\n");
+	seq_printf(
+		m,
+		"--------------------DSP DRIVER DEBUG INFO--------------------\n");
+	seq_printf(m, "Debug    Value\n");
+	seq_printf(m, "%s        %d\n", dsp_log_level ? "ON" : "OFF",
+		   dsp_log_level);
+	seq_printf(m, "\n");
+
+	return 0;
+}
+
+static int debug_open(struct inode *inode, struct file *flip)
+{
+	return single_open(flip, debug_show, NULL);
+}
+
+static ssize_t debug_write(struct file *flip, const char __user *buf,
+			   size_t size, loff_t *pos)
+{
+	u16 value;
+
+	if (size > 2) {
+		return -EINVAL;
+	}
+
+	if (copy_from_user(&value, buf, size)) {
+		return -EFAULT;
+	}
+
+	dsp_log_level = (value - '0') & 0xf;
+	printk("set dsp driver debug as value(%d) to %d\n", value,
+	       dsp_log_level);
+
+	return size;
+}
+
+static int perf_show(struct seq_file *m, void *p)
+{
+	seq_printf(m, "\n");
+	seq_printf(
+		m,
+		"--------------------DSP DRIVER PERF INFO--------------------\n");
+	seq_printf(m, "Perf    Value\n");
+	seq_printf(m, "%s        %d\n", dsp_perf_enable ? "ON" : "OFF",
+		   dsp_perf_enable);
+	seq_printf(m, "\n");
+
+	return 0;
+}
+
+static int perf_open(struct inode *inode, struct file *flip)
+{
+	return single_open(flip, perf_show, NULL);
+}
+
+static ssize_t perf_write(struct file *flip, const char __user *buf,
+			  size_t size, loff_t *pos)
+{
+	u16 value;
+
+	if (size > 2) {
+		return -EINVAL;
+	}
+
+	if (copy_from_user(&value, buf, size)) {
+		return -EFAULT;
+	}
+
+	dsp_perf_enable = (value - '0') & 0xf;
+	printk("set dsp driver perf as value(%d) to %d\n", value,
+	       dsp_perf_enable);
+
+	return size;
+}
+
+static struct proc_ops proc_stats_fops = {
+	.proc_open = proc_stats_open,
+	.proc_read = seq_read,
+	.proc_release = proc_stats_release,
+};
+
+static struct proc_ops proc_debug_fops = {
+	.proc_open = debug_open,
+	.proc_read = seq_read,
+	.proc_release = single_release,
+	.proc_write = debug_write,
+};
+
+static struct proc_ops proc_perf_fops = {
+	.proc_open = perf_open,
+	.proc_read = seq_read,
+	.proc_release = single_release,
+	.proc_write = perf_write,
+};
+
+int es_dsp_init_proc(void)
+{
+	proc_es_dsp = proc_mkdir("esdsp", NULL);
+	if (proc_es_dsp == NULL) {
+		dsp_err("proc mkdir esdsp dir err.\n");
+		return -ENOMEM;
+	}
+	if (!proc_create("info", 0644, proc_es_dsp, &proc_stats_fops)) {
+		goto err;
+	}
+	if (!proc_create("debug", 0644, proc_es_dsp, &proc_debug_fops)) {
+		dsp_err("error create proc dsp debug file.\n");
+		goto err;
+	}
+	if (!proc_create("perf", 0644, proc_es_dsp, &proc_perf_fops)) {
+		dsp_err("error create proc dsp perf file.\n");
+		goto err;
+	}
+	return 0;
+
+err:
+	remove_proc_subtree("esdsp", NULL);
+	return -1;
+}
+
+void es_dsp_remove_proc(void)
+{
+	remove_proc_subtree("esdsp", NULL);
+}
diff --git a/drivers/soc/eswin/ai_driver/dsp/dsp_proc.h b/drivers/soc/eswin/ai_driver/dsp/dsp_proc.h
new file mode 100644
index 000000000000..5fd60ec9e009
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/dsp/dsp_proc.h
@@ -0,0 +1,13 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#ifndef __DSP_PROC_H_
+#define __DSP_PROC_H_
+
+int es_dsp_init_proc(void);
+void es_dsp_remove_proc(void);
+#endif
diff --git a/drivers/soc/eswin/ai_driver/dsp/dsp_sram.c b/drivers/soc/eswin/ai_driver/dsp/dsp_sram.c
new file mode 100644
index 000000000000..1639727bb118
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/dsp/dsp_sram.c
@@ -0,0 +1,98 @@
+// Copyright © 2024 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#include <linux/dma-buf.h>
+#include <linux/dsp_dma_buf.h>
+#include <linux/device.h>
+#include "dsp_main.h"
+
+int dsp_attach_sram_dmabuf(struct device *dev, struct dma_buf *dmabuf)
+{
+	int ret;
+	struct attach;
+	struct es_dsp *dsp;
+	dma_addr_t dma_addr = 0;
+
+	if (dev == NULL) {
+		dsp_err("%s, %d, device is null, err.\n", __func__, __LINE__);
+		return -EINVAL;
+	}
+
+	if (dmabuf == NULL) {
+		dsp_err("%s, %d, param dmabuf is null, err.\n", __func__,
+			__LINE__);
+		return -EINVAL;
+	}
+	get_dma_buf(dmabuf);
+	dsp = dev_get_drvdata(dev);
+
+	dma_addr = dev_mem_attach(dmabuf, dev, DMA_BIDIRECTIONAL,
+				  &dsp->sram_attach);
+	if (dma_addr == 0) {
+		dsp_err("err:dev_mem_attach failed!\n");
+		dsp->sram_dma_addr = 0;
+		dsp->sram_phy_addr = 0;
+		return -ENOMEM;
+	}
+	dsp->sram_phy_addr = sg_phys(dsp->sram_attach->sgt->sgl);
+	dsp->sram_dma_addr = dma_addr;
+	return 0;
+}
+EXPORT_SYMBOL(dsp_attach_sram_dmabuf);
+
+int dsp_detach_sram_dmabuf(struct device *dev)
+{
+	struct es_dsp *dsp;
+	struct dma_buf *dmabuf;
+
+	if (dev == NULL) {
+		return -EINVAL;
+	}
+
+	dsp = dev_get_drvdata(dev);
+	if (dsp == NULL) {
+		dsp_err("dsp device is null.\n");
+		return -EINVAL;
+	}
+
+	if (!dsp->sram_attach) {
+		return -EINVAL;
+	}
+	dmabuf = dsp->sram_attach->dmabuf;
+	if (dmabuf == NULL) {
+		return -EINVAL;
+	}
+	dev_mem_detach(dsp->sram_attach, DMA_BIDIRECTIONAL);
+	dma_buf_put(dmabuf);
+	dsp->sram_attach = NULL;
+	dsp->sram_phy_addr = 0;
+	dsp->sram_dma_addr = 0;
+	return 0;
+}
+EXPORT_SYMBOL(dsp_detach_sram_dmabuf);
+
+u32 dsp_get_sram_iova_by_addr(struct device *dev, u64 phy_addr)
+{
+	struct es_dsp *dsp;
+
+	if (dev == NULL) {
+		return 0;
+	}
+
+	dsp = dev_get_drvdata(dev);
+	if (dsp == NULL) {
+		dsp_err("dsp device is null.\n");
+		return 0;
+	}
+	if (dsp->sram_phy_addr == 0) {
+		dsp_err("dsp sram addr is not map, error.\n");
+		return 0;
+	}
+
+	return (phy_addr - dsp->sram_phy_addr + dsp->sram_dma_addr);
+}
+EXPORT_SYMBOL(dsp_get_sram_iova_by_addr);
diff --git a/drivers/soc/eswin/ai_driver/dsp/mloader/core-const16w.inc b/drivers/soc/eswin/ai_driver/dsp/mloader/core-const16w.inc
new file mode 100644
index 000000000000..cb67d5f9210a
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/dsp/mloader/core-const16w.inc
@@ -0,0 +1,113 @@
+/*
+ * Functions for setting immediate field of CONST16 instruction.
+ */
+
+
+/* Maximum format size in bits for formats containing CONST16. */
+#define XTIMM_MAX_FORMAT_LENGTH 128
+
+/* format length from first byte, only formats containing CONST16 are recognized. */
+static uint32_t
+xtimm_get_format_length (uint32_t insn0)
+{
+  if ((insn0 & 0x8) == 0)
+    return 24;
+  if ((insn0 & 0x100000f) == 0xf)
+    return 128;
+  if ((insn0 & 0x100000f) == 0xf)
+    return 128;
+  if ((insn0 & 0x100000f) == 0xf)
+    return 128;
+  if ((insn0 & 0x100000f) == 0xf)
+    return 128;
+  if ((insn0 & 0xf) == 0xe)
+    return 128;
+  if ((insn0 & 0x100000f) == 0xf)
+    return 128;
+  if ((insn0 & 0x100000f) == 0xf)
+    return 128;
+  if ((insn0 & 0x100000f) == 0xf)
+    return 128;
+  if ((insn0 & 0x300000f) == 0x100000f)
+    return 64;
+  if ((insn0 & 0x300000f) == 0x100000f)
+    return 64;
+  if ((insn0 & 0x300000f) == 0x100000f)
+    return 64;
+  return 0;
+}
+
+/* xtimm_*_immediate_field_set sets immediate field of CONST16 instruction
+   in insn buffer at slot. Only checks necessary for figuring out which format
+   this is are performed. The small version sets CONST16 immediate field in
+   formats up to 32 bits in size. Large version operates only on formats larger
+   than 32 bit. */
+
+static uint32_t
+xtimm_fmt_small_immediate_field_set (uint32_t *insn, int slot, uint32_t value)
+{
+      insn[0] = ((value << 16) >> 8) | (insn[0] & ~0xFFFF00);
+      return 1;
+}
+
+static uint32_t
+xtimm_fmt_large_immediate_field_set (uint32_t *insn, int slot, uint32_t value)
+{
+  if ((insn[0] & 0x100000f) == 0xf && (insn[3] & 0x410c0000) == 0x41000000) { /* F0 */
+      insn[0] = ((value << 24) >> 16) | (((value << 23) >> 31) << 26) | (insn[0] & ~0x400FF00);
+      insn[1] = (((value << 21) >> 31) << 29) | (insn[1] & ~0x20000000);
+      insn[2] = (((value << 18) >> 31) << 16) | (((value << 19) >> 30) << 17) | (((value << 17) >> 31) << 19) | (((value << 22) >> 31) << 20) | (((value << 16) >> 31) << 22) | (insn[2] & ~0x5F0000);
+      return 1;
+  } else if ((insn[0] & 0x100000f) == 0xf && (insn[3] & 0x40000000) == 0) { /* F11 */
+      insn[0] = ((value << 24) >> 16) | (insn[0] & ~0xFF00);
+      insn[1] = (((value << 21) >> 29) << 25) | (((value << 20) >> 31) << 29) | (insn[1] & ~0x2E000000);
+      insn[2] = (((value << 19) >> 31) << 13) | (((value << 17) >> 30) << 17) | (((value << 16) >> 31) << 30) | (insn[2] & ~0x40062000);
+      return 1;
+  } else if ((insn[0] & 0x100000f) == 0xf && (insn[3] & 0x410e0000) == 0x41040000) { /* F1 */
+      insn[0] = ((value << 24) >> 16) | (((value << 23) >> 31) << 26) | (insn[0] & ~0x400FF00);
+      insn[1] = (((value << 22) >> 31) << 3) | (((value << 21) >> 31) << 29) | (insn[1] & ~0x20000008);
+      insn[2] = (((value << 16) >> 27) << 15) | (insn[2] & ~0xF8000);
+      return 1;
+  } else if ((insn[0] & 0x100000f) == 0xf && (insn[3] & 0x410e8000) == 0x41080000) { /* F2 */
+      insn[0] = ((value << 24) >> 16) | (insn[0] & ~0xFF00);
+      insn[1] = (((value << 17) >> 30) << 29) | (insn[1] & ~0x60000000);
+      insn[2] = (((value << 19) >> 28) << 15) | (((value << 16) >> 31) << 19) | (((value << 23) >> 31) << 20) | (insn[2] & ~0x1F8000);
+      return 1;
+  } else if ((insn[0] & 0xf) == 0xe) { /* F3 */
+      insn[0] = ((value << 24) >> 16) | (((value << 23) >> 31) << 26) | (insn[0] & ~0x400FF00);
+      insn[1] = (((value << 21) >> 31) << 29) | (insn[1] & ~0x20000000);
+      insn[2] = (((value << 22) >> 31) << 14) | (((value << 19) >> 30) << 17) | ((value >> 13) << 30) | (insn[2] & ~0xC0064000);
+      insn[3] = ((value << 16) >> 31) | (insn[3] & ~0x1);
+      return 1;
+  } else if ((insn[0] & 0x100000f) == 0xf && (insn[3] & 0x41000000) == 0x40000000) { /* F4 */
+      insn[0] = ((value << 24) >> 16) | (((value << 22) >> 31) << 26) | (insn[0] & ~0x400FF00);
+      insn[1] = (((value << 21) >> 31) << 29) | (insn[1] & ~0x20000000);
+      insn[2] = (((value << 23) >> 31) << 14) | (insn[2] & ~0x4000);
+      insn[3] = ((value << 16) >> 27) | (insn[3] & ~0x1F);
+      return 1;
+  } else if ((insn[0] & 0x100000f) == 0xf && (insn[3] & 0x410e8000) == 0x41088000) { /* F6 */
+      insn[0] = ((value << 24) >> 16) | (insn[0] & ~0xFF00);
+      insn[1] = (((value << 17) >> 30) << 29) | (insn[1] & ~0x60000000);
+      insn[2] = (((value << 16) >> 31) << 7) | (((value << 19) >> 28) << 15) | (((value << 23) >> 31) << 20) | (insn[2] & ~0x178080);
+      return 1;
+  } else if ((insn[0] & 0x100000f) == 0xf && (insn[3] & 0x410e0000) == 0x41060000) { /* F7 */
+      insn[0] = ((value << 24) >> 16) | (((value << 23) >> 31) << 26) | (insn[0] & ~0x400FF00);
+      insn[1] = (((value << 22) >> 31) << 3) | (((value << 21) >> 31) << 29) | (insn[1] & ~0x20000008);
+      insn[2] = (((value << 17) >> 30) << 15) | (((value << 19) >> 30) << 17) | (((value << 16) >> 31) << 19) | (insn[2] & ~0xF8000);
+      return 1;
+  } else if ((insn[0] & 0x300000f) == 0x100000f && (insn[1] & 0x42000000) == 0x40000000) { /* N1 */
+      insn[0] = ((value << 23) >> 15) | (insn[0] & ~0x1FF00);
+      insn[1] = (((value << 21) >> 30) << 1) | (((value << 19) >> 30) << 5) | (((value << 16) >> 29) << 9) | (insn[1] & ~0xE66);
+      return 1;
+  } else if ((insn[0] & 0x300000f) == 0x100000f && (insn[1] & 0x42000000) == 0x42000000) { /* N2 */
+      insn[0] = ((value << 24) >> 16) | (((value << 23) >> 31) << 26) | (insn[0] & ~0x400FF00);
+      insn[1] = (((value << 19) >> 30) << 1) | (((value << 21) >> 30) << 3) | (((value << 17) >> 30) << 5) | (((value << 16) >> 31) << 8) | (insn[1] & ~0x17E);
+      return 1;
+  } else if ((insn[0] & 0x300000f) == 0x100000f && (insn[1] & 0x40000000) == 0) { /* N0 */
+      insn[0] = ((value << 23) >> 15) | (insn[0] & ~0x1FF00);
+      insn[1] = (((value << 21) >> 30) << 1) | (((value << 16) >> 27) << 18) | (insn[1] & ~0x7C0006);
+      return 1;
+  }
+  return 0;
+}
+
diff --git a/drivers/soc/eswin/ai_driver/dsp/mloader/dsp_load_operator.c b/drivers/soc/eswin/ai_driver/dsp/mloader/dsp_load_operator.c
new file mode 100644
index 000000000000..34ce44f0aeae
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/dsp/mloader/dsp_load_operator.c
@@ -0,0 +1,269 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+#include <linux/namei.h>
+#include "dsp_main.h"
+#include "xt_mld_loader.h"
+#include "xt_elf.h"
+
+#define DSP_CACHE_LINE_SIZE 64
+
+static int load_op_file(char *file_path, char *buff, int size)
+{
+	struct file *file = NULL;
+	loff_t pos = 0;
+	int ret = 0;
+
+	file = filp_open(file_path, O_RDONLY, 0664);
+
+	if (IS_ERR(file)) {
+		dsp_err("\nfile_read: filp_open fail!\n");
+		return -EEXIST;
+	}
+
+	ret = kernel_read(file, buff, size, &pos);
+	filp_close(file, NULL);
+	return 0;
+}
+
+static int get_file_size(const char *file_path)
+{
+	struct path p;
+	struct kstat ks;
+	if (kern_path(file_path, 0, &p) == 0 &&
+	    vfs_getattr(&p, &ks, 0, 0) == 0) {
+		return ks.size;
+	} else {
+		dsp_err("invalid file:%s\n", file_path);
+	}
+	return 0;
+}
+
+static int load_op_funcs(const void *buf, xtmld_state_t *lib_info,
+			 struct dsp_op_desc *op)
+{
+	Elf32_Ehdr *elf = (Elf32_Ehdr *)buf;
+	void *shoff = (void *)elf + elf->e_shoff;
+	Elf32_Shdr *shstrtab =
+		(Elf32_Shdr *)(shoff + elf->e_shstrndx * elf->e_shentsize);
+	void *shoff0 = (void *)elf + elf->e_shoff;
+	char *symstr = NULL;
+
+	int ret = 0;
+	int i, k, t;
+	uint32_t real_addr;
+	char *shstr = vmalloc(shstrtab->sh_size);
+	if (shstr == NULL) {
+		return -ENOMEM;
+	}
+
+	memcpy(shstr, ((void *)elf) + shstrtab->sh_offset, shstrtab->sh_size);
+
+	for (k = 0; k < elf->e_shnum; k++, shoff0 += elf->e_shentsize) {
+		Elf32_Shdr *sh = (Elf32_Shdr *)shoff0;
+		if (SHT_STRTAB == sh->sh_type) {
+			if (strcmp(".strtab", shstr + sh->sh_name))
+				continue;
+			symstr = vmalloc(sh->sh_size);
+			if (symstr == NULL) {
+				ret = -ENOMEM;
+				goto failed;
+			}
+			memcpy(symstr, ((void *)elf) + sh->sh_offset,
+			       sh->sh_size);
+			break;
+		}
+	}
+
+	for (k = 0; k < elf->e_shnum; k++, shoff += elf->e_shentsize) {
+		Elf32_Shdr *sh = (Elf32_Shdr *)shoff;
+		if (SHT_STRTAB == sh->sh_type) {
+		} else if (SHT_SYMTAB == sh->sh_type) {
+			Elf32_Sym *symtab =
+				(Elf32_Sym *)(((void *)elf) + sh->sh_offset);
+			int sym_num = sh->sh_size / sizeof(Elf32_Sym);
+			for (i = 0; i < sym_num; i++) {
+				if (ELF32_ST_TYPE(symtab->st_info) !=
+				    STT_FUNC) {
+					symtab++;
+					continue;
+				}
+
+				for (t = 0; t < lib_info->num_sections; t++) {
+					if (symtab->st_value >=
+						    lib_info->src_offs[t] &&
+					    symtab->st_value <
+						    (lib_info->src_offs[t] +
+						     lib_info->size[t])) {
+						real_addr =
+							op->iova_base +
+							(symtab->st_value -
+							 lib_info->src_offs[t]);
+						break;
+					}
+				}
+
+				if (strcmp("_start",
+					   symstr + symtab->st_name) == 0) {
+					// nothing
+				} else if (strcmp("prepare",
+						  symstr + symtab->st_name) ==
+					   0) {
+					op->funcs.dsp_prepare_fn = real_addr;
+				} else if (strcmp("eval",
+						  symstr + symtab->st_name) ==
+					   0) {
+					op->funcs.dsp_eval_fn = real_addr;
+				}
+				symtab++;
+			}
+		}
+	}
+	if (!op->funcs.dsp_eval_fn) {
+		dsp_err("func eval not found,[%0x,%0x] ", op->funcs.dsp_eval_fn);
+		ret = -1;
+	}
+
+	if (symstr) {
+		vfree(symstr);
+	}
+failed:
+	if (shstr) {
+		vfree(shstr);
+	}
+	return ret;
+}
+
+int mloader_load_operator(char *buff, struct es_dsp *dsp,
+			  struct dsp_op_desc *op)
+{
+	xtmld_library_info_t info;
+	xtmld_result_code_t ret_code;
+	xtmld_state_t loader_state = { 0 };
+	void *p_start;
+	int i;
+	int code_size = 0;
+	int dram_size = 0;
+	int data_size = 0;
+	void *current_addr;
+	void *code_memory[XTMLD_MAX_CODE_SECTIONS];
+	void *data_memory[XTMLD_MAX_DATA_SECTIONS];
+	void *data_addr = (void *)DSP_IDDR_IOVA;
+	void *dram_addr = (void *)XTMLD_DATARAM0_ADDR;
+
+	xtmld_packaged_lib_t *p_mld_lib = (xtmld_packaged_lib_t *)buff;
+	if ((ret_code = xtmld_library_info(p_mld_lib, &info)) !=
+	    xtmld_success) {
+		dsp_err("xtmld_library_info failed\n");
+		return -1;
+	}
+	for (i = 0; i < info.number_of_code_sections; i++) {
+		code_size += info.code_section_size[i];
+	}
+	code_size += DSP_CACHE_LINE_SIZE * 2;
+	dsp_debug("op library text size:0x%x\n", code_size);
+	op->op_shared_seg_size = round_up(code_size, DSP_2M_SIZE);
+
+	op->op_shared_seg_ptr = dma_alloc_coherent(
+		dsp->dev, op->op_shared_seg_size, &op->iova_base, GFP_KERNEL);
+	if (!op->op_shared_seg_ptr) {
+		dsp_err("dma map iova failed.\n");
+		goto map_failed;
+	}
+	current_addr = op->op_shared_seg_ptr;
+	dsp_debug("op->iova_base=0x%x size:0x%x\n", op->iova_base,
+		  op->op_shared_seg_size);
+	for (i = 0; i < info.number_of_code_sections; i++) {
+		if (info.code_section_size[i]) {
+			code_memory[i] = current_addr;
+			current_addr += info.code_section_size[i];
+			loader_state.text_addr[i] =
+				(void *)(op->iova_base +
+					 (code_memory[i] -
+					  op->op_shared_seg_ptr));
+		} else {
+			code_memory[i] = 0;
+			loader_state.text_addr[i] = NULL;
+		}
+	}
+
+	for (i = 0; i < info.number_of_data_sections; i++) {
+		if (info.data_section_mem_req[i] == xtmld_load_require_dram0 ||
+		    info.data_section_mem_req[i] == xtmld_load_require_dram1) {
+			dram_size += info.data_section_size[i];
+			data_memory[i] = dram_addr;
+			dram_addr += info.data_section_size[i];
+		} else {
+			data_size += info.data_section_size[i];
+			data_memory[i] = data_addr;
+			data_addr += info.data_section_size[i];
+		}
+	}
+
+	ret_code = xtmld_load(p_mld_lib, code_memory, data_memory,
+			      &loader_state, &p_start);
+	if ((ret_code == xtmld_success) && (p_start != NULL)) {
+		dsp_debug("xtmld_load() succeeded, start_fn = 0x%px\n",
+			  p_start);
+	} else {
+		dsp_err("xtmld_load() failed: %s\n",
+			xtmld_error_string(ret_code));
+		goto load_failed;
+	}
+
+	if (load_op_funcs(buff, &loader_state, op) == 0) {
+		return 0;
+	}
+
+load_failed:
+	dma_free_coherent(dsp->dev, op->op_shared_seg_size,
+			  op->op_shared_seg_ptr, op->iova_base);
+	op->iova_base = 0;
+map_failed:
+	op->op_shared_seg_addr = 0;
+	op->op_shared_seg_ptr = NULL;
+	return -1;
+}
+
+int dsp_load_op_file(struct es_dsp *dsp, struct dsp_op_desc *op)
+{
+	char op_path[256] = { 0 };
+	char *lib_buff;
+	int file_size;
+	int ret = 0;
+	char *op_dir = NULL;
+
+	if (strlen(op->name) > 200) {
+		dsp_err("dsp operator name %s length is over 200, error.\n",
+			op->name);
+		return -EINVAL;
+	}
+	if (op->op_dir) {
+		op_dir = op->op_dir;
+	} else {
+		op_dir = DSP_OP_LIB_DIR;
+	}
+
+	sprintf(op_path, "%s%s%s%s", op_dir, "/es_", op->name, ".pkg.lib");
+	dsp_debug("start load operator path:%s\n", op_path);
+	file_size = get_file_size(op_path);
+	if (file_size <= 0) {
+		return -EEXIST;
+	}
+	lib_buff = vmalloc(file_size);
+	if (lib_buff == NULL) {
+		return -ENOMEM;
+	}
+	ret = load_op_file(op_path, lib_buff, file_size);
+	if (ret == 0) {
+		ret = mloader_load_operator(lib_buff, dsp, op);
+	}
+	vfree(lib_buff);
+	return ret;
+}
diff --git a/drivers/soc/eswin/ai_driver/dsp/mloader/xt_elf.h b/drivers/soc/eswin/ai_driver/dsp/mloader/xt_elf.h
new file mode 100644
index 000000000000..c91d110065fc
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/dsp/mloader/xt_elf.h
@@ -0,0 +1,342 @@
+/*
+ * Copyright (c) 2012 by Tensilica Inc. ALL RIGHTS RESERVED.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+/* Low-level ELF data structures and other definitions. */
+
+#ifndef XT_ELF_H_
+#define XT_ELF_H_
+
+#ifndef _UAPI_LINUX_ELF_H
+
+#if ____xtensa__
+#define Elf_Addr unsigned int
+#else
+#define Elf_Addr uint64_t
+#endif
+#define Elf32_Addr unsigned int
+#define Elf32_Half int16_t
+#define Elf32_Off unsigned int
+#define Elf32_Sword signed int
+#define Elf32_Word unsigned int
+#define Elf32_Byte unsigned char
+
+#define EI_NIDENT 16
+
+/* The header is always present in an elf file and will always be first */
+typedef struct {
+	Elf32_Byte e_ident[EI_NIDENT]; /* Identifier block. see below */
+	Elf32_Half e_type; /* object file type */
+	Elf32_Half e_machine; /* machine type */
+	Elf32_Word e_version; /* elf version */
+	Elf32_Addr e_entry; /* entry point ( _start ) */
+	Elf32_Off e_phoff; /* program header offset in bytes */
+	Elf32_Off e_shoff; /* section header offset in bytes */
+	Elf32_Word e_flags; /* processor specific flags */
+	Elf32_Half e_ehsize; /* header size in bytes */
+	Elf32_Half e_phentsize; /* program header entry size */
+	Elf32_Half e_phnum; /* program header entry count */
+	Elf32_Half e_shentsize; /* section header entry size */
+	Elf32_Half e_shnum; /* section header entry count */
+	Elf32_Half e_shstrndx; /* index of section name string table */
+} Elf32_Ehdr;
+
+/* object file identification */
+/* indices into e_ident */
+#define EI_MAG0 0 /* 0-3 are magic '0x7f' */
+#define EI_MAG1 1 /* 'E' */
+#define EI_MAG2 2 /* 'L' */
+#define EI_MAG3 3 /* 'F' */
+#define EI_CLASS 4 /* file class */
+#define EI_DATA 5 /* data encoding */
+#define EI_VERSION 6 /* file version */
+#define EI_OSABI 7 /* OS/ABI id */
+#define EI_ABIVERSION 8
+#define EI_PAD 9 /* start of padding bytes */
+
+/* file class */
+#define ELFCLASSNONE 0 /* invalid class */
+#define ELFCLASS32 1 /* 32 bit objects */
+#define ELFCLASS64 2 /* 64 bit objects */
+
+/* encoding */
+#define ELFDATANONE 0 /* invalid encoding */
+#define ELFDATA2LSB 1 /* little endian */
+#define ELFDATA2MSB 2 /* big endian */
+
+/* object file type */
+#define ET_NONE 0 /* no file type */
+#define ET_REL 1 /* relocatable file */
+#define ET_EXEC 2 /* executable file */
+#define ET_DYN 3 /* shared object file */
+#define ET_CORE 4 /* core file */
+#define ET_LOPROC 0xff00 /* processor specific */
+#define ET_HIPROC 0xffff /* processor specific */
+
+/* machine types */
+#define EM_NONE 0 /* no type */
+/* other machines are defined but are not included here since this
+   reader is only intended for xtensa elf */
+#define EM_SPARC 2
+#define EM_386 3
+#define EM_SPARC32PLUS 18
+#define EM_XTENSA 94
+#define EM_XTENSA_DEPRECATED 0xabc7
+
+/* version */
+#define EV_NONE 0 /* invalid version */
+#define EV_CURRENT 1 /* current version */
+
+/*** Sections ***/
+
+/* special section indices for reserved sections */
+#define SHN_UNDEF 0
+#define SHN_LORESERVE 0xff00
+#define SHN_LOPROC 0xff00
+#define SHN_HIPROC 0xff1f
+#define SHN_ABS 0xfff1
+#define SHN_COMMON 0xfff2
+#define SHN_HIRESERVE 0xffff
+
+typedef struct {
+	Elf32_Word
+		sh_name; /* index into string table for the name of the section */
+	Elf32_Word sh_type; /* section semantics */
+	Elf32_Word sh_flags; /* misc attributes */
+	Elf32_Addr sh_addr; /* first byte address of a memory image */
+	Elf32_Off sh_offset; /* offset to section from beginning of file */
+	Elf32_Word sh_size; /* section size in bytes */
+	Elf32_Word sh_link; /* table index link */
+	Elf32_Word sh_info; /* contextual information */
+	Elf32_Word sh_addralign; /* section will be sh_addr % sh_addralign == 0 */
+	Elf32_Word sh_entsize; /* size of entry for fixed size sections */
+} Elf32_Shdr;
+
+#define SHT_NULL 0 /* inactive section header */
+#define SHT_PROGBITS 1 /* contents defined by program */
+#define SHT_SYMTAB 2 /* symbol table */
+#define SHT_STRTAB 3 /* string table */
+#define SHT_RELA 4 /* relocation section with explicit addends */
+#define SHT_HASH 5 /* symbol hash table */
+#define SHT_DYNAMIC 6 /* dynamic link info */
+#define SHT_NOTE 7 /* comment section */
+#define SHT_NOBITS 8 /* section occupies no space */
+#define SHT_REL 9 /* relocation section with no explicit addends */
+#define SHT_SHLIB 10 /* reserved with unknown semantics */
+#define SHT_DYNSYM 11 /* symbol table */
+#define SHT_INIT_ARRAY 14 /* initialization functions */
+#define SHT_FINI_ARRAY 15 /* termination functions */
+#define SHT_PREINIT_ARRAY 16 /* preinitialization functions */
+#define SHT_GROUP 17 /* grouping section */
+#define SHT_SYMTAB_SHNDX 18 /* special symbol table index */
+
+#define SHT_LOOS 0x60000000 /* OS specific semantics */
+#define SHT_HIOS 0x6fffffff
+#define SHT_LOPROC 0x70000000 /* processor specific semantics */
+#define SHT_HIPROC 0x7fffffff
+#define SHT_LOUSER 0x80000000 /* lower bound of reserved indices for apps */
+#define SHT_HIUSER 0xffffffff /* upper bound of same */
+
+#define SHT_XTENSA_AUTOTIE 0x7f000000 /* AutoTIE analysis information. */
+
+/* flags */
+#define SHF_WRITE 0x1 /* writable section */
+#define SHF_ALLOC 0x2 /* will reside in the memory image of the process */
+#define SHF_EXECINSTR 0x4 /* executable section */
+#define SHF_MASKPROC 0xf0000000 /* processor specific semantics */
+
+/* symbol tables */
+typedef struct {
+	Elf32_Word st_name; /* string table index to name of symbol */
+	Elf32_Addr st_value; /* symbol value */
+	Elf32_Word st_size; /* size of data object */
+	Elf32_Byte st_info; /* symbol type and binding attributes */
+	Elf32_Byte st_other; /* not currently defined by ELF */
+	Elf32_Half st_shndx; /* section index for the symbol */
+} Elf32_Sym;
+
+/* use these macros to extract information from st_info */
+#define ELF32_ST_BIND(i) ((i) >> 4)
+#define ELF32_ST_TYPE(i) ((i)&0xf)
+#define ELF32_ST_INFO(b, t) (((b) << 4) + ((t)&0xf))
+
+/* symbol bindings */
+#define STB_LOCAL 0 /* visible only in current object file */
+#define STB_GLOBAL 1 /* visible to all object files */
+#define STB_WEAK 2 /* global, but may be redefined by later symbol */
+#define STB_LOPROC 13 /* reserved for processor specific semantics */
+#define STB_HIPROC 15
+
+/* symbol type */
+#define STT_NOTYPE 0 /* no type specified */
+#define STT_OBJECT 1 /* data object, e.g. variable, array */
+#define STT_FUNC 2 /* executable code */
+#define STT_SECTION 3 /* assoc. with a section ( used for relocation ) */
+#define STT_FILE 4 /* symbol is name of source file */
+#define STT_LOPROC 13 /* reserved for processor specific semantics */
+#define STT_HIPROC 15
+
+/* Special symbol table index to indicate the end of a hash table
+ * chain.
+ */
+#define STN_UNDEF 0
+
+/*** relocation ***/
+
+typedef struct {
+	Elf32_Addr r_offset;
+	Elf32_Word r_info;
+} Elf32_Rel;
+
+typedef struct {
+	Elf32_Addr r_offset;
+	Elf32_Word r_info;
+	Elf32_Sword r_addend;
+} Elf32_Rela;
+
+#define ELF32_R_SYM(i) ((i) >> 8)
+#define ELF32_R_TYPE(i) ((Elf32_Byte)(i))
+#define ELF32_R_INFO(s, t) (((s) << 8) + (Elf32_Byte)(t))
+
+/*** program header ***/
+
+typedef struct {
+	Elf32_Word p_type; /* type of segment */
+	Elf32_Off p_offset; /* offset from beginning of file to segment */
+	Elf32_Addr p_vaddr; /* virtual address of first byte */
+	Elf32_Addr p_paddr; /* physical address ( if relevant ) */
+	Elf32_Word p_filesz; /* number of bytes in the file image for segment */
+	Elf32_Word p_memsz; /* number of bytes in the memory image "  "   */
+	Elf32_Word p_flags; /* segment flags */
+	Elf32_Word p_align; /* power of 2 alignment constant */
+} Elf32_Phdr;
+
+#define PT_NULL 0 /* unused entry */
+#define PT_LOAD 1 /* loadable segment */
+#define PT_DYNAMIC 2 /* dynamic linking info */
+#define PT_INTERP 3 /* pointer to path to interpreter */
+#define PT_NOTE 4 /* auxiliary information */
+#define PT_SHLIB 5 /* reserved */
+#define PT_PHDR 6 /* pointer to program header */
+#define PT_LOPROC 0x70000000 /* reserved */
+#define PT_HIPROC 0x7fffffff
+
+/* flag values */
+#define PF_X 0x1 /* Execute */
+#define PF_W 0x2 /* Write */
+#define PF_R 0x4 /* Read */
+#define PF_MASKOS 0x0ff00000 /* Unspecified */
+#define PF_MASKPROC 0xf0000000 /* Unspecified */
+
+/* dynamic section entries */
+
+typedef struct {
+	Elf32_Sword d_tag;
+	union {
+		Elf32_Word d_val;
+		Elf32_Addr d_ptr;
+	} d_un;
+} Elf32_Dyn;
+
+#define DT_NULL 0
+#define DT_NEEDED 1
+#define DT_PLTRELSZ 2
+#define DT_PLTGOT 3
+#define DT_HASH 4
+#define DT_STRTAB 5
+#define DT_SYMTAB 6
+#define DT_RELA 7
+#define DT_RELASZ 8
+#define DT_RELAENT 9
+#define DT_STRSZ 10
+#define DT_SYMENT 11
+#define DT_INIT 12
+#define DT_FINI 13
+#define DT_SONAME 14
+#define DT_RPATH 15
+#define DT_SYMBOLIC 16
+#define DT_REL 17
+#define DT_RELSZ 18
+#define DT_RELENT 19
+#define DT_PLTREL 20
+#define DT_DEBUG 21
+#define DT_TEXTREL 22
+#define DT_JMPREL 23
+#define DT_LOPROC 0x70000000
+#define DT_HIPROC 0x7fffffff
+
+#endif
+
+// List of xtensa relocations. See bintutils/bfd/relocs.c for an
+// explanation of each of these.
+
+typedef enum xtensa_relocations {
+	R_XTENSA_NONE = 0,
+	R_XTENSA_32 = 1,
+	R_XTENSA_RTLD = 2,
+	R_XTENSA_GLOB_DAT = 3,
+	R_XTENSA_JMP_SLOT = 4,
+	R_XTENSA_RELATIVE = 5,
+	R_XTENSA_PLT = 6,
+	R_XTENSA_OP0 = 8,
+	R_XTENSA_OP1 = 9,
+	R_XTENSA_OP2 = 10,
+	R_XTENSA_ASM_EXPAND = 11,
+	R_XTENSA_ASM_SIMPLIFY = 12,
+	R_XTENSA_32_PCREL = 14,
+	R_XTENSA_GNU_VTINHERIT = 15,
+	R_XTENSA_GNU_VTENTRY = 16,
+	R_XTENSA_DIFF8 = 17,
+	R_XTENSA_DIFF16 = 18,
+	R_XTENSA_DIFF32 = 19,
+	R_XTENSA_SLOT0_OP = 20,
+	R_XTENSA_SLOT1_OP = 21,
+	R_XTENSA_SLOT2_OP = 22,
+	R_XTENSA_SLOT3_OP = 23,
+	R_XTENSA_SLOT4_OP = 24,
+	R_XTENSA_SLOT5_OP = 25,
+	R_XTENSA_SLOT6_OP = 26,
+	R_XTENSA_SLOT7_OP = 27,
+	R_XTENSA_SLOT8_OP = 28,
+	R_XTENSA_SLOT9_OP = 29,
+	R_XTENSA_SLOT10_OP = 30,
+	R_XTENSA_SLOT11_OP = 31,
+	R_XTENSA_SLOT12_OP = 32,
+	R_XTENSA_SLOT13_OP = 33,
+	R_XTENSA_SLOT14_OP = 34,
+	R_XTENSA_SLOT0_ALT = 35,
+	R_XTENSA_SLOT1_ALT = 36,
+	R_XTENSA_SLOT2_ALT = 37,
+	R_XTENSA_SLOT3_ALT = 38,
+	R_XTENSA_SLOT4_ALT = 39,
+	R_XTENSA_SLOT5_ALT = 40,
+	R_XTENSA_SLOT6_ALT = 41,
+	R_XTENSA_SLOT7_ALT = 42,
+	R_XTENSA_SLOT8_ALT = 43,
+	R_XTENSA_SLOT9_ALT = 44,
+	R_XTENSA_SLOT10_ALT = 45,
+	R_XTENSA_SLOT11_ALT = 46,
+	R_XTENSA_SLOT12_ALT = 47,
+	R_XTENSA_SLOT13_ALT = 48,
+	R_XTENSA_SLOT14_ALT = 49
+} xtensa_relocations;
+
+#endif
diff --git a/drivers/soc/eswin/ai_driver/dsp/mloader/xt_mld_loader.c b/drivers/soc/eswin/ai_driver/dsp/mloader/xt_mld_loader.c
new file mode 100644
index 000000000000..e5967e94da47
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/dsp/mloader/xt_mld_loader.c
@@ -0,0 +1,1149 @@
+/*
+ * Copyright (c) 2019 by Tensilica Inc. ALL RIGHTS RESERVED.
+
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+#include <linux/string.h>
+#include <linux/kernel.h>
+
+#if __xtensa__
+#include <xtensa/config/core.h>
+#include <xtensa/config/defs.h>
+#else
+#define xthal_memcpy memcpy
+#endif
+
+#include "xt_mld_loader.h"
+#include "xt_elf.h"
+
+#if defined(XCHAL_DCACHE_LINESIZE)
+#define DCACHE_LINESIZE XCHAL_DCACHE_LINESIZE
+#else
+#define DCACHE_LINESIZE 1
+#endif
+
+#define ADDR64_HI 0xffffffff00000000
+
+xtmld_state_t *xtmld_loaded_lib_info = 0;
+/*
+ * This function exists only for the debugger to detect when a library
+ * has been unloaded (by setting a breakpoint on it.
+ *
+ * Therefore, if any changes are made to the signature, then the
+ * debug module needs a corresponding update.
+ *
+ * Also, it is critical that this function (and calls to it) not be
+ * optimized away.
+ */
+static void xtmld_unloaded(xtmld_state_t *state)
+{
+	/* this is not necessary for the operation of the library but it defeats
+     * optimization that might break the debug flow.*/
+	memset(state, 0, sizeof(xtmld_state_t));
+}
+
+typedef struct {
+	xtmld_result_code_t status;
+	uint32_t number_sections;
+	int32_t scratch_section_found;
+	uint32_t scratch_section_index;
+	Elf32_Phdr *section[XTMLD_MAX_SECTIONS];
+} xtmld_validate_t;
+
+#ifndef DISABLE_EXPENSIVE_CHECKS
+/*
+ These functions are used in checking that sections that require local memory
+ are placed correctly.  Impossible to reliably check on architectures with
+ address translation so we just return true if there is any local memory.
+ */
+static int maybe_in_iram(void *addr, uint32_t size)
+{
+#if XCHAL_NUM_INSTRAM > 0
+#if !XCHAL_HAVE_IDENTITY_MAP
+	return 1;
+#else
+	uint32_t x = (uint32_t)addr;
+	if ((x >= XCHAL_INSTRAM0_VADDR) &&
+	    ((x + size) < (XCHAL_INSTRAM0_VADDR + XCHAL_INSTRAM0_SIZE)))
+		return 1;
+#if XCHAL_NUM_INSTRAM > 1
+	if ((x >= XCHAL_INSTRAM1_VADDR) &&
+	    ((x + size) < (XCHAL_INSTRAM1_VADDR + XCHAL_INSTRAM1_SIZE)))
+		return 1;
+#endif
+#endif
+#endif
+	return 0;
+}
+
+#if XCHAL_NUM_DATARAM > 0
+static int maybe_in_dram(void *addr, uint32_t size)
+{
+#if XCHAL_NUM_DATARAM > 0
+#if !XCHAL_HAVE_IDENTITY_MAP
+	return 1;
+#else
+	uint32_t x = (uint32_t)addr;
+	if ((x >= XCHAL_DATARAM0_VADDR) &&
+	    ((x + size) < (XCHAL_DATARAM0_VADDR + XCHAL_DATARAM0_SIZE)))
+		return 1;
+#if XCHAL_NUM_DATARAM > 1
+	if ((x >= XCHAL_DATARAM1_VADDR) &&
+	    ((x + size) < (XCHAL_DATARAM1_VADDR + XCHAL_DATARAM1_SIZE)))
+		return 1;
+#endif
+#endif
+#endif
+	return 0;
+}
+
+static int maybe_in_dram0(void *addr, uint32_t size)
+{
+#if XCHAL_HAVE_DATARAM0
+#if !XCHAL_HAVE_IDENTITY_MAP
+	return 1;
+#else
+	uint32_t x = (uint32_t)addr;
+
+	if ((x >= XCHAL_DATARAM0_VADDR) &&
+	    ((x + size) < (XCHAL_DATARAM0_VADDR + XCHAL_DATARAM0_SIZE))) {
+		return 1;
+	}
+#endif
+#endif
+	return 0;
+}
+
+static int maybe_in_dram1(void *addr, uint32_t size)
+{
+#if XCHAL_HAVE_DATARAM1
+#if !XCHAL_HAVE_IDENTITY_MAP
+	return 1;
+#else
+	uint32_t x = (uint32_t)addr;
+
+	if ((x >= XCHAL_DATARAM1_VADDR) &&
+	    ((x + size) < (XCHAL_DATARAM1_VADDR + XCHAL_DATARAM1_SIZE))) {
+		return 1;
+	}
+#endif
+#endif
+	return 0;
+}
+#endif
+#endif
+
+/*
+ * host_half and host_word are intended to isolate any endian differences
+ * between the host processor (the one doing the load) and the target
+ * processor (the one executing the loaded library code).
+ *
+ * Note that host loading is not currently supported or tested.
+ */
+static Elf32_Half host_half(Elf32_Half v)
+{
+	return (XTENSA_HOST_BYTE_SWAP) ? (v >> 8) | (v << 8) : v;
+}
+
+static Elf32_Word host_word(Elf32_Word v)
+{
+	if (XTENSA_HOST_BYTE_SWAP) {
+		v = ((v & 0x00FF00FF) << 8) | ((v & 0xFF00FF00) >> 8);
+		v = (v >> 16) | (v << 16);
+	}
+	return v;
+}
+
+static int verify_magic(Elf32_Ehdr *header)
+{
+	Elf32_Byte magic_no;
+
+	magic_no = header->e_ident[EI_MAG0];
+	if (magic_no != 0x7f) {
+		return -1;
+	}
+
+	magic_no = header->e_ident[EI_MAG1];
+	if (magic_no != 'E') {
+		return -1;
+	}
+
+	magic_no = header->e_ident[EI_MAG2];
+	if (magic_no != 'L') {
+		return -1;
+	}
+
+	magic_no = header->e_ident[EI_MAG3];
+	if (magic_no != 'F') {
+		return -1;
+	}
+
+	if (header->e_ident[EI_CLASS] != ELFCLASS32)
+		return -1;
+
+	return 0;
+}
+
+static xtmld_ptr align_ptr(xtmld_ptr ptr, uint32_t t_align, uint32_t t_paddr)
+{
+	uint32_t align = host_word(t_align);
+
+	// A segment may not start at desired alignment boundary, so calculate the
+	// offset from the alignment boundary.
+	uint32_t offset = host_word(t_paddr) & (align - 1);
+
+	// To align an address to the boundary, the starting address needs some
+	// adjustment before it can be aligned to the desired boundary.
+	uint32_t align_adj = align - offset - 1;
+	xtmld_ptr ret = ((((uint32_t)ptr + align_adj) & ~(align - 1)) + offset);
+#ifndef __XTENSA__
+	xtmld_ptr ret_hi = (uint64_t)ptr & ADDR64_HI;
+	ret = (xtmld_ptr)((uint64_t)ret_hi | (uint64_t)ret);
+#endif
+	return ret;
+}
+
+static xtmld_result_code_t validate_dynamic(Elf32_Ehdr *header)
+{
+	if (verify_magic(header) != 0) {
+		return xtmld_invalid_library;
+	}
+
+	if (host_half(header->e_type) != ET_DYN) {
+		return xtmld_invalid_library;
+	}
+
+	return xtmld_success;
+}
+
+static xtmld_ptr xt_ptr_offs(xtmld_ptr base, Elf32_Word offs)
+{
+	// return (xtmld_ptr) host_word((uint32_t) base + host_word(offs));
+	return (xtmld_ptr)((uint64_t)base + offs);
+}
+
+static int32_t is_data_section(Elf32_Phdr *phi)
+{
+	return (host_word(phi->p_flags) & (PF_X | PF_R | PF_W)) ==
+	       (PF_W | PF_R | PF_X);
+}
+
+static int32_t is_code_section(Elf32_Phdr *phi)
+{
+	return ((host_word(phi->p_flags) & (PF_W | PF_R | PF_X)) ==
+		(PF_R | PF_X));
+}
+
+static int32_t is_scratch_section(Elf32_Phdr *phi)
+{
+	return ((host_word(phi->p_flags) & (PF_W | PF_R | PF_X)) ==
+		(PF_W | PF_X));
+}
+
+/* .rodata section is the ELF image we want in a packed library */
+xtmld_result_code_t xt_mld_get_packaged_lib(void *packaged_img,
+					    xtmld_packaged_lib_t **lib)
+{
+	Elf32_Ehdr *eheader = (Elf32_Ehdr *)packaged_img;
+	Elf32_Shdr *sheader;
+	Elf32_Shdr *shi;
+	int i;
+	char *string_table;
+
+	if (!packaged_img || !lib)
+		return xtmld_null_ptr;
+
+	*lib = NULL;
+
+	/* We don't want to deal with unaligned access; ELF image must be 4-byte aligned */
+	if ((uint32_t)eheader & 0x3) {
+		return xtmld_image_not_aligned;
+	}
+
+	/* Is this an ELF? */
+	if (verify_magic(eheader) != 0) {
+		return xtmld_invalid_library;
+	}
+
+	/* Check size of section header entry */
+	if (host_half(eheader->e_shentsize) != sizeof(Elf32_Shdr)) {
+		return xtmld_invalid_library;
+	}
+
+	/* Locate section headers */
+	sheader = (Elf32_Shdr *)((char *)eheader + host_word(eheader->e_shoff));
+
+	/* Locate section containing section names */
+	shi = sheader + host_half(eheader->e_shstrndx);
+
+	/* Locate section name string table */
+	string_table = (char *)eheader + host_word(shi->sh_offset);
+
+	/* Looking for .rodata section */
+	for (i = 0; i < host_half(eheader->e_shnum); i++) {
+		shi = &sheader[i];
+
+		if (0 ==
+		    strcmp(string_table + host_word(shi->sh_name), ".rodata")) {
+			*lib = (xtmld_packaged_lib_t *)((char *)eheader +
+							host_word(
+								shi->sh_offset));
+			if (host_word(shi->sh_addralign) != 0 &&
+			    (uint32_t)*lib % host_word(shi->sh_addralign) !=
+				    0) {
+				*lib = NULL;
+				return xtmld_image_not_aligned;
+			}
+
+			return xtmld_success;
+		}
+	}
+
+	/* Can't find .rodata */
+	return xtmld_invalid_library;
+}
+
+static xtmld_validate_t validate_dynamic_multload(Elf32_Ehdr *header)
+{
+	Elf32_Phdr *pheader;
+	xtmld_validate_t rv;
+	memset(&rv, 0, sizeof(rv));
+
+	rv.status = validate_dynamic(header);
+
+	if (rv.status != xtmld_success)
+		return rv;
+
+	/* make sure it's split load pi library, expecting three headers,
+     code, data and dynamic, for example:
+
+     LOAD off    0x00000094 vaddr 0x00000000 paddr 0x00000000 align 2**0
+     filesz 0x00000081 memsz 0x00000081 flags r-x
+     LOAD off    0x00000124 vaddr 0x00000084 paddr 0x00000084 align 2**0
+     filesz 0x000001ab memsz 0x000011bc flags rwx
+     DYNAMIC off    0x00000124 vaddr 0x00000084 paddr 0x00000084 align 2**2
+     filesz 0x000000a0 memsz 0x000000a0 flags rw-
+
+     */
+
+	int dynamic = 0;
+
+	/* minimum segment count is 3, Segments for .text section, dynamic data and
+    reloaction data.  Segments with PT_NULL type don't count.  */
+	if (host_half(header->e_phnum) < 3) {
+		rv.status = xtmld_invalid_library;
+		return rv;
+	}
+
+	pheader = (Elf32_Phdr *)((char *)header + host_word(header->e_phoff));
+
+	int i;
+	uint32_t number_code_sections = 0;
+	uint32_t number_data_sections = 0;
+	for (i = 0; i < header->e_phnum; i++) {
+		Elf32_Phdr *phi = &pheader[i];
+		/* LOAD R-X */
+		Dprintf("%d %x %x\n", i, phi->p_flags, phi->p_memsz);
+
+		if (host_word(phi->p_type) == PT_LOAD && (phi->p_memsz > 0) &&
+		    (host_word(phi->p_flags) & (PF_R | PF_W | PF_X)) ==
+			    (PF_R | PF_X)) {
+			number_code_sections++;
+			if (number_code_sections <= XTMLD_MAX_CODE_SECTIONS) {
+				rv.section[rv.number_sections++] = phi;
+			} else {
+				break;
+			}
+		}
+
+		/* LOAD RWX */
+		if (host_word(phi->p_type) == PT_LOAD && (phi->p_memsz > 0) &&
+		    (host_word(phi->p_flags) & (PF_R | PF_W | PF_X)) ==
+			    (PF_R | PF_W | PF_X)) {
+			number_data_sections++;
+			if (number_data_sections <= XTMLD_MAX_DATA_SECTIONS) {
+				rv.section[rv.number_sections++] = phi;
+			} else {
+				break;
+			}
+		}
+
+		/* LOAD RWX */
+		if (host_word(phi->p_type) == PT_LOAD && (phi->p_memsz > 0) &&
+		    is_scratch_section(phi)) {
+			if (!rv.scratch_section_found) {
+				rv.scratch_section_found = 1;
+				rv.scratch_section_index = rv.number_sections;
+				Dprintf("scratch section found\n");
+				rv.section[rv.number_sections++] = phi;
+			} else {
+				break;
+			}
+		}
+
+		/* DYNAMIC RW- */
+		if (host_word(phi->p_type) == PT_DYNAMIC &&
+		    (host_word(phi->p_flags) & (PF_R | PF_W | PF_X)) ==
+			    (PF_R | PF_W)) {
+			dynamic++;
+		}
+	}
+	Dprintf("number of data sections %d\n", number_data_sections);
+	if (dynamic && (number_data_sections > 0) &&
+	    (number_data_sections <= XTMLD_MAX_DATA_SECTIONS) &&
+	    (number_code_sections > 0) &&
+	    (number_code_sections <= XTMLD_MAX_CODE_SECTIONS))
+		rv.status = xtmld_success;
+	else
+		rv.status = xtmld_invalid_library;
+	return rv;
+}
+
+static Elf32_Dyn *find_dynamic_info(Elf32_Ehdr *eheader, uint32_t *size)
+{
+	char *base_addr = (char *)eheader;
+
+	Elf32_Phdr *pheader =
+		(Elf32_Phdr *)(base_addr + host_word(eheader->e_phoff));
+
+	int seg = 0;
+	int num = host_half(eheader->e_phnum);
+
+	while (seg < num) {
+		if (host_word(pheader[seg].p_type) == PT_DYNAMIC) {
+			*size = host_word(pheader[seg].p_memsz);
+			return (Elf32_Dyn *)(base_addr +
+					     host_word(pheader[seg].p_offset));
+		}
+		seg++;
+	}
+	return 0;
+}
+
+/*
+ * This function finds the memory requirements data for the code
+ * and data sections which is embedded into the dynamic section
+ * of the packaged library elf file.
+ */
+static xtmld_result_code_t get_mem_perf(Elf32_Ehdr *eheader,
+					xtmld_mem_require_t *data_performance,
+					xtmld_mem_require_t *code_performance)
+{
+	int i;
+	int count = 0;
+	int data_found = 0;
+	int code_found = 0;
+	uint32_t *ptr;
+	uint32_t size;
+	Elf32_Dyn *dyn_entry = find_dynamic_info(eheader, &size);
+
+	if (dyn_entry == 0) {
+		return xtmld_invalid_library;
+	}
+
+	while (dyn_entry->d_tag != DT_NULL) {
+		dyn_entry++;
+	}
+
+	ptr = (uint32_t *)dyn_entry;
+
+	while (count++ < size / sizeof(uint32_t)) {
+		if (*(ptr++) == 0x70000002) {
+			int dcount;
+			for (dcount = 0;
+			     dcount + count < size / sizeof(uint32_t); dcount++)
+				if (*(ptr + dcount) == XTMLD_DATA_MARKER) {
+					for (i = 0; i < XTMLD_MAX_DATA_SECTIONS;
+					     i++)
+						data_performance[i] =
+							*(ptr + dcount + i + 1);
+					data_found = 1;
+					break;
+				}
+			for (dcount = 0;
+			     dcount + count < size / sizeof(uint32_t); dcount++)
+				if (*(ptr + dcount) == XTMLD_CODE_MARKER) {
+					for (i = 0; i < XTMLD_MAX_CODE_SECTIONS;
+					     i++)
+						code_performance[i] =
+							*(ptr + dcount + i + 1);
+					code_found = 1;
+					break;
+				}
+			break;
+		}
+	}
+	{
+		/* If either .dram0.data or .dram1.data sections exist, force the corresponding
+           requirements to require dataram0 or dataram1.
+         */
+		/* Locate section headers */
+		Elf32_Shdr *shdr = (Elf32_Shdr *)((char *)eheader +
+						  host_word(eheader->e_shoff));
+		/* Locate section containing section names */
+		Elf32_Shdr *sstr = shdr + host_half(eheader->e_shstrndx);
+		/* Locate name string table */
+		char *name_table = (char *)eheader + host_word(sstr->sh_offset);
+		/* Locate segment headers */
+		Elf32_Phdr *phdr = (Elf32_Phdr *)((char *)eheader +
+						  host_word(eheader->e_phoff));
+		uint32_t ndx = 0;
+
+		/* Iterate over all the program segment headers */
+		for (i = 0; i < eheader->e_phnum; i++) {
+			if ((host_word(phdr[i].p_type) == PT_LOAD) &&
+			    (phdr[i].p_memsz > 0)) {
+				if ((host_word(phdr[i].p_flags) &
+				     (PF_R | PF_W | PF_X)) ==
+				    (PF_R | PF_W | PF_X)) {
+					/* Found a data segment, now find first section in segment */
+					/* .dram0.data and .dram1.data will be first and only section in segment */
+					int32_t j;
+
+					for (j = 0;
+					     j < host_half(eheader->e_shnum);
+					     j++) {
+						/* First section's vaddr should match program segment vaddr */
+						if (shdr[j].sh_addr ==
+						    phdr[i].p_vaddr) {
+							if (strcmp(name_table +
+									   host_word(
+										   shdr[j].sh_name),
+								   ".dram0.data") ==
+							    0) {
+								data_performance[ndx] =
+									xtmld_load_require_dram0;
+							} else if (
+								strcmp(name_table +
+									       host_word(
+										       shdr[j].sh_name),
+								       ".dram1.data") ==
+								0) {
+								data_performance[ndx] =
+									xtmld_load_require_dram1;
+							}
+						}
+					}
+					ndx++;
+				}
+			}
+		}
+
+		return xtmld_success;
+	}
+
+	return xtmld_mem_require_not_found;
+}
+
+/*
+    This function searches the dynamic info section for the library name
+    (used for debugging purposes).  If no library name is found then a default
+    name is created.
+ */
+static void get_libname(Elf32_Ehdr *eheader, xtmld_state_t *state)
+{
+	const char *default_name = "loadable_lib_";
+	static int libcount = 0;
+	int count = 0;
+	char *ptr;
+	uint32_t size;
+	const char *prefix = "xtensalibname:";
+	uint32_t prefix_len = strlen(prefix);
+	Elf32_Dyn *dyn_entry = find_dynamic_info(eheader, &size);
+
+	while (dyn_entry->d_tag != DT_NULL) {
+		dyn_entry++;
+	}
+
+	ptr = (char *)dyn_entry;
+
+	while (count++ < size) {
+		if (!strncmp(ptr, prefix, prefix_len)) {
+			char *str = ptr + prefix_len;
+			strncpy(state->libname, str,
+				sizeof(state->libname) - 1);
+			return;
+		}
+		ptr++;
+	}
+	snprintf(state->libname, sizeof(state->libname) - 1, "%s",
+		 default_name);
+	state->libname[strlen(default_name)] = 'a' + libcount++;
+}
+
+static xtmld_result_code_t get_dyn_info(Elf32_Ehdr *eheader,
+					xtmld_validate_t *val,
+					xtmld_ptr *dest_addr,
+					xtmld_state_t *state)
+{
+	unsigned int jmprel = 0;
+	unsigned int pltrelsz = 0;
+	uint32_t size;
+	Elf32_Dyn *dyn_entry = find_dynamic_info(eheader, &size);
+
+	if (dyn_entry == 0) {
+		return xtmld_invalid_library;
+	}
+
+	int i;
+	int j;
+	state->scratch_section_found = val->scratch_section_found;
+	// Initialize the state structure and find the _start symbol in the
+	// library
+	for (i = 0; i < val->number_sections; i++) {
+		state->dst_addr[i] = dest_addr[i];
+		state->src_offs[i] = host_word(val->section[i]->p_paddr);
+		state->size[i] = val->section[i]->p_memsz;
+		if (is_code_section(val->section[i]) &&
+		    (eheader->e_entry >= val->section[i]->p_paddr) &&
+		    (eheader->e_entry <
+		     val->section[i]->p_paddr + val->section[i]->p_memsz)) {
+			state->start_sym =
+				(xtmld_start_fn_ptr)(eheader->e_entry +
+						     (uint32_t)state
+							     ->dst_addr[i] -
+						     val->section[i]->p_paddr);
+		}
+	}
+
+	state->num_sections = val->number_sections;
+
+	Dprintf("get_dyn_info: start address = %p\n", state->start_sym);
+
+	while (dyn_entry->d_tag != DT_NULL) {
+		switch ((Elf32_Sword)host_word((Elf32_Word)dyn_entry->d_tag)) {
+		case DT_RELA:
+			Dprintf("in case DT_RELA with offset = %d and ptr = %0x\n",
+				val->section[0]->p_offset,
+				dyn_entry->d_un.d_ptr);
+			if (val->scratch_section_found) {
+				int32_t si = val->scratch_section_index;
+				state->rel = xt_ptr_offs(
+					eheader,
+					val->section[si]->p_offset +
+						dyn_entry->d_un.d_ptr -
+						val->section[si]->p_vaddr);
+			} else {
+				/* d_un.ptr is offset from the the first section (always section[0] */
+				state->rel = xt_ptr_offs(
+					eheader, val->section[0]->p_offset +
+							 dyn_entry->d_un.d_ptr);
+			}
+			break;
+		case DT_RELASZ:
+			state->rela_count =
+				host_word(host_word(dyn_entry->d_un.d_val) /
+					  sizeof(Elf32_Rela));
+			break;
+		case DT_INIT:
+			for (i = 0; i < val->number_sections; i++)
+				if (is_code_section(val->section[i]) &&
+				    (val->section[i]->p_paddr <=
+				     dyn_entry->d_un.d_ptr) &&
+				    (dyn_entry->d_un.d_ptr <
+				     val->section[i]->p_paddr +
+					     val->section[i]->p_memsz)) {
+					state->init = xt_ptr_offs(
+						state->dst_addr[i] -
+							val->section[i]->p_paddr,
+						dyn_entry->d_un.d_ptr);
+					Dprintf("init function found = %p\n",
+						state->init);
+					break;
+				}
+			break;
+		case DT_FINI:
+			if (is_code_section(val->section[i]) &&
+			    (val->section[i]->p_paddr <=
+			     dyn_entry->d_un.d_ptr) &&
+			    (dyn_entry->d_un.d_ptr <
+			     val->section[i]->p_paddr +
+				     val->section[i]->p_memsz)) {
+				state->fini = xt_ptr_offs(
+					state->dst_addr[i] -
+						val->section[i]->p_paddr,
+					dyn_entry->d_un.d_ptr);
+				Dprintf("fini function found = %p\n",
+					state->fini);
+				break;
+			}
+			break;
+		case DT_HASH:
+			for (i = 0, j = 0; i < val->number_sections; i++)
+				if (is_data_section(val->section[i]))
+					state->hash[j++] = xt_ptr_offs(
+						state->dst_addr[i] -
+							val->section[i]->p_paddr,
+						dyn_entry->d_un.d_ptr);
+			break;
+		case DT_SYMTAB:
+			break;
+		case DT_STRTAB:
+			break;
+		case DT_JMPREL:
+			jmprel = dyn_entry->d_un.d_val;
+			break;
+		case DT_PLTRELSZ:
+			pltrelsz = dyn_entry->d_un.d_val;
+			break;
+		case DT_LOPROC + 2:
+			for (i = 0, j = 0; i < val->number_sections; i++) {
+				state->text_addr[j++] = xt_ptr_offs(
+					state->dst_addr[i] -
+						val->section[i]->p_paddr,
+					dyn_entry->d_un.d_ptr);
+				pr_debug("DT_LOPROC dyn text_addr:%0x",
+					 (uint32_t)state->text_addr[j]);
+			}
+			break;
+
+		default:
+			/* do nothing */
+			break;
+		}
+		dyn_entry++;
+	}
+	return xtmld_success;
+}
+
+static void xtmld_sync(void)
+{
+	/* Synchronize caches and memory. We've just loaded code and possibly
+     patched some of it. All changes need to be flushed out of dcache
+     and the corresponding sections need to be invalidated in icache.
+     */
+#ifdef __XTENSA__
+	/* we don't know exactly how much to writeback and/or invalidate
+     so do all. Possible optimization later.
+     */
+	xthal_dcache_all_writeback();
+	xthal_icache_all_invalidate();
+	xthal_clear_regcached_code();
+#endif
+}
+
+static xtmld_result_code_t xtmld_target_init_library(xtmld_state_t *lib_info)
+{
+	xtmld_result_code_t rv = xtmld_relocate_library(lib_info);
+	if (rv != xtmld_success) {
+		return rv;
+	}
+
+	xtmld_sync();
+#ifdef __XTENSA__
+	((void (*)(void))(lib_info->init))();
+#endif
+	return xtmld_success;
+}
+
+/*
+ * load_section does the work of actually loading each section into memory.
+ */
+static void load_section(Elf32_Phdr *pheader, xtmld_ptr src_addr,
+			 xtmld_ptr dst_addr, memcpy_func_ex mcpy,
+			 memset_func_ex mset, void *user)
+{
+	Elf32_Word bytes_to_copy = host_word(pheader->p_filesz);
+	Elf32_Word bytes_to_zero = host_word(pheader->p_memsz) - bytes_to_copy;
+
+	xtmld_ptr zero_addr = dst_addr + bytes_to_copy;
+	if (bytes_to_copy > 0) {
+		memcpy(dst_addr, src_addr, bytes_to_copy);
+	}
+	/* this zeros the bss area */
+	if (bytes_to_zero > 0) {
+		memset(zero_addr, 0, bytes_to_zero);
+	}
+	/* The dcache needs to be written back and the icache needs to
+     be invalidated, but that happens in xtmld_sync() so we don't
+     need to do it here.
+     */
+}
+
+/*
+ * xtmld_load_sections() does the loading of a library into memory.
+ */
+static xtmld_result_code_t
+xtmld_load_sections(xtmld_packaged_lib_t *library, xtmld_state_t *lib_info,
+		    int32_t num, Elf32_Phdr **ph, xtmld_ptr *dest_addr,
+		    memcpy_func_ex mcpy_fn, memset_func_ex mset_fn, void *user)
+{
+	int32_t i;
+	for (i = 0; i < num; i++) {
+		Elf32_Phdr *phi = ph[i];
+		if (is_code_section(phi) /* || is_data_section(phi)*/)
+			load_section(phi,
+				     (uint8_t *)library +
+					     host_word(phi->p_offset),
+				     dest_addr[i], mcpy_fn, mset_fn, user);
+	}
+	return xtmld_success;
+}
+
+/*
+ *
+ * This function is used by the debug component, so if you change its signature
+ * then corresponding changes need to be made to the debug module.
+ */
+static xtmld_result_code_t
+xtmld_load_mlib_break(xtmld_packaged_lib_t *library, xtmld_state_t *lib_info,
+		      int32_t num, Elf32_Phdr **ph, xtmld_ptr *dest_addr,
+		      memcpy_func_ex mcpy_fn, memset_func_ex mset_fn,
+		      void *user)
+{
+	return xtmld_success;
+}
+
+/*
+ * xtmld_load_common is the common root between xtmld_load and
+ * xtmld_load_custom_fn.
+ *
+ * 1) It aligns the section addresses,
+ * 2) checks for
+ *              a) overlapping sections
+ *              b) code sections out of the 1-GB range
+ *              c) sections that require local memory but are being loaded into
+ *                      system memory.
+ * 3) loads the library sections into memory
+ */
+
+static xtmld_result_code_t
+xtmld_load_common(xtmld_packaged_lib_t *library,
+		  xtmld_code_ptr *destination_code_address,
+		  xtmld_data_ptr *destination_data_address,
+		  xtmld_state_t *state, memcpy_func_ex mcpy_fn,
+		  memset_func_ex mset_fn, void *user, xtmld_start_fn_ptr *start)
+{
+	if (!library || !destination_code_address ||
+	    !destination_data_address || !state || !mcpy_fn || !mset_fn ||
+	    !start) {
+		return xtmld_null_ptr;
+	}
+
+	{
+		int32_t i;
+		int32_t j = 0;
+		Elf32_Ehdr *header = (Elf32_Ehdr *)library;
+		xtmld_library_info_t info;
+
+		xtmld_result_code_t status;
+		xtmld_ptr addr[XTMLD_MAX_SECTIONS];
+
+		xtmld_validate_t val = validate_dynamic_multload(header);
+		if (val.status != xtmld_success)
+			return val.status;
+		status = xtmld_library_info(library, &info);
+		if (status != xtmld_success)
+			return status;
+		for (i = 0; i < info.number_of_code_sections; i++)
+			addr[j++] = align_ptr(destination_code_address[i],
+					      val.section[i]->p_align,
+					      val.section[i]->p_paddr);
+		for (i = 0; i < info.number_of_data_sections; i++)
+			addr[j++] = align_ptr(
+				destination_data_address[i],
+				val.section[i + info.number_of_code_sections]
+					->p_align,
+				val.section[i + info.number_of_code_sections]
+					->p_paddr);
+/*
+ * Doubtful that these checks are very expensive in practice, but
+ * they are set up to be easily disabled.
+ */
+#ifndef DISABLE_EXPENSIVE_CHECKS
+		{
+			int j;
+			uint32_t size[XTMLD_MAX_CODE_SECTIONS +
+				      XTMLD_MAX_DATA_SECTIONS];
+
+			/* Check that any section requiring local memory is actually in
+             * local memory
+             */
+			for (i = 0; i < info.number_of_code_sections; i++) {
+				size[i] = info.code_section_size[i];
+				if ((info.code_section_mem_req[i] ==
+				     xtmld_load_require_localmem) &&
+				    !(maybe_in_iram(destination_code_address[i],
+						    info.code_section_size[i])))
+					return xtmld_local_memory_required;
+			}
+			for (i = 0; i < info.number_of_data_sections; i++) {
+				size[i + info.number_of_code_sections] =
+					info.data_section_size[i];
+#if (XCHAL_NUM_DATARAM > 0)
+				if ((info.data_section_mem_req[i] ==
+				     xtmld_load_require_localmem) &&
+				    !(maybe_in_dram(
+					    destination_data_address[i],
+					    info.data_section_size[i]))) {
+					return xtmld_local_memory_required;
+				} else if ((info.data_section_mem_req[i] ==
+					    xtmld_load_require_dram0) &&
+					   !(maybe_in_dram0(
+						   destination_data_address[i],
+						   info.data_section_size[i]))) {
+					return xtmld_local_memory_required;
+				} else if ((info.data_section_mem_req[i] ==
+					    xtmld_load_require_dram1) &&
+					   !(maybe_in_dram1(
+						   destination_data_address[i],
+						   info.data_section_size[i]))) {
+					return xtmld_local_memory_required;
+				}
+#endif
+			}
+#if !(XCHAL_HAVE_XEA3 || defined(__XTENSA_CALL0_ABI__))
+			/*
+             * Check that code sections all start in the same 1-GB range
+             */
+			/*           {
+                           void* base = &xtmld_load_common;
+                           uint32_t gig_addr_start = ((uint32_t) base) & 0xc0000000;
+                           for (i = 0; i < info.number_of_code_sections; i++)
+                               if (((((uint32_t) destination_code_address[i]) & 0xc0000000)
+                                       != gig_addr_start) && info.code_section_size[i])
+                                   return xtmld_code_must_be_in_1gig_region;
+                       }*/
+#endif
+			/* Check that none of the sections overlap */
+			for (i = 1; i < info.number_of_code_sections +
+						info.number_of_data_sections;
+			     i++)
+				for (j = 0; j < 1; j++)
+					if (((addr[i] <= addr[j]) &&
+					     (addr[i] +
+						      size[i] /
+							      sizeof(xtmld_ptr) >=
+					      addr[j])) ||
+					    ((addr[j] <= addr[i]) &&
+					     (addr[j] +
+						      size[j] /
+							      sizeof(xtmld_ptr) >=
+					      addr[i])))
+						return xtmld_sections_overlap;
+		}
+#endif
+
+		status = xtmld_load_sections(library, state,
+					     val.number_sections, val.section,
+					     addr, mcpy_fn, mset_fn, user);
+		if (status != xtmld_success)
+			return status;
+
+		status = get_dyn_info(header, &val, addr, state);
+		if (status != xtmld_success)
+			return status;
+
+		state->num_text_sections = info.number_of_code_sections;
+
+		get_libname(header, state);
+
+		state->next = xtmld_loaded_lib_info;
+		xtmld_loaded_lib_info = state;
+
+		if (status != xtmld_success)
+			return status;
+
+		*start = (xtmld_start_fn_ptr)host_word(
+			(Elf32_Word)state->start_sym);
+		Dprintf("code loaded ... start = %p\n", *start);
+
+		status = xtmld_load_mlib_break(library, state,
+					       val.number_sections, val.section,
+					       addr, mcpy_fn, mset_fn, user);
+
+		return xtmld_success;
+	}
+}
+
+/*
+ * The function xtmld_library_info() populates the info argument with the
+ * numbers, sizes, and load requirements for the library
+ *
+ */
+xtmld_result_code_t xtmld_library_info(xtmld_packaged_lib_t *library,
+				       xtmld_library_info_t *info)
+{
+	Elf32_Phdr *pheader;
+	Elf32_Ehdr *header = (Elf32_Ehdr *)library;
+	xtmld_result_code_t status;
+	xtmld_validate_t val;
+
+	int align;
+	int i;
+
+	if ((library == 0) || (info == 0))
+		return xtmld_null_ptr;
+
+	val = validate_dynamic_multload(header);
+
+	if (val.status != xtmld_success) {
+		return val.status;
+	}
+
+	pheader =
+		(Elf32_Phdr *)((uint8_t *)library + host_word(header->e_phoff));
+
+	memset(info, 0, sizeof(*info));
+
+	status = get_mem_perf(header, info->data_section_mem_req,
+			      info->code_section_mem_req);
+
+	if (status != xtmld_success)
+		return status;
+	/*
+     the size calculation assumes the starting address of destination buffer may
+     not be aligned to the required alignment, so extra space is needed in order to
+     maintain the same alignment as the source data.  Besides this, the source data
+     may not start at the alignment boundary, so another extra space is needed.  At the
+     end of the buffer, some padding may also necessary if the buffer is not ended at
+     the alignment boundary, in order to safe guard the write operation.
+     So, the total size is in multiple of alignment.
+     */
+	for (i = 0; i < val.number_sections; i++) {
+		align = host_word(val.section[i]->p_align);
+		if (is_code_section(val.section[i])) {
+			info->code_section_size[info->number_of_code_sections] =
+				(align + host_word(val.section[i]->p_memsz) +
+				 align - 1) &
+				(~(align - 1));
+			//      info->code_section_alignment[info->number_of_code_sections] =
+			//             align;
+
+			info->number_of_code_sections++;
+		} else if (is_data_section(val.section[i])) {
+			align = DCACHE_LINESIZE > align ? DCACHE_LINESIZE :
+								align;
+			info->data_section_size[info->number_of_data_sections] =
+				(align + host_word(val.section[i]->p_memsz) +
+				 align - 1) &
+				(~(align - 1));
+			//         info->data_section_alignment[info->number_of_data_sections] =
+			//            align;
+			info->number_of_data_sections++;
+		}
+	}
+	return xtmld_success;
+}
+
+/*
+ * The function xtmld_load() loads the library into the sections
+ * supplied, call the library init function (C++ constructors
+ * for static objects), and sets the start function point to point
+ * to the _start function() of the supplied library.
+ */
+xtmld_result_code_t xtmld_load(xtmld_packaged_lib_t *lib,
+			       xtmld_code_ptr *code_section_la,
+			       xtmld_data_ptr *data_section_la,
+			       xtmld_state_t *state, xtmld_start_fn_ptr *start)
+{
+	return xtmld_load_custom_fn(lib, code_section_la, data_section_la,
+				    state, (memcpy_func_ex)xthal_memcpy,
+				    (memset_func_ex)memset, 0, start);
+}
+
+/*
+ * xtmld_load_custom_fn is the same as xtmld_load except that it has
+ * additional arguments for custom memory copy and set functions. The
+ * parameter user, is passed to the custom functions.
+ */
+xtmld_result_code_t xtmld_load_custom_fn(
+	xtmld_packaged_lib_t *library, xtmld_code_ptr *destination_code_address,
+	xtmld_data_ptr *destination_data_address, xtmld_state_t *lib_info,
+	memcpy_func_ex mcpy_fn, memset_func_ex mset_fn, void *user,
+	xtmld_start_fn_ptr *start)
+{
+	xtmld_result_code_t result;
+
+	result = xtmld_load_common(library, destination_code_address,
+				   destination_data_address, lib_info, mcpy_fn,
+				   mset_fn, user, start);
+
+	if (result == xtmld_success)
+		return xtmld_target_init_library(lib_info);
+	else
+		return result;
+}
+
+/*
+ * This function unloads a library.  The state argument must be the
+ * same as passed to the load function.
+ */
+xtmld_result_code_t xtmld_unload(xtmld_state_t *state)
+{
+	int found = 0;
+	if (!state)
+		return xtmld_null_ptr;
+	if (state == xtmld_loaded_lib_info) {
+		xtmld_loaded_lib_info = state->next;
+		found = 1;
+	} else {
+		xtmld_state_t *pptr = xtmld_loaded_lib_info;
+		xtmld_state_t *ptr = pptr->next;
+		while (ptr) {
+			if (state == ptr) {
+				pptr->next = ptr->next;
+				found = 1;
+				break;
+			} else {
+				pptr = ptr;
+				ptr = pptr->next;
+			}
+		}
+	}
+	if (!found)
+		return xtmld_invalid_library;
+#ifdef __XTENSA__
+	((void (*)(void))(state->fini))();
+#endif
+	xtmld_unloaded(state);
+	return xtmld_success;
+}
+
+/*
+ * This function writes information about the packaged library into
+ * the info structure.
+ */
+const char *xtmld_error_string(xtmld_result_code_t x)
+{
+	switch (x) {
+	case xtmld_success:
+		return "No Error.";
+	case xtmld_null_ptr:
+		return "Function improperly called with NULL pointer.";
+	case xtmld_invalid_library:
+		return "Invalid library format.";
+	case xtmld_internal_error:
+		return "Internal error.";
+	case xtmld_local_memory_required:
+		return "Local memory was required for some library sections, but it was not provided.";
+	case xtmld_mem_require_not_found:
+		return "Memory requirements not found. Use XTMLD_CODE_MEM_REQ and XTMLD_DATA_MEM_REQ macros to specify "
+		       "memory requirements for library.";
+	case xtmld_code_must_be_in_1gig_region:
+		return "Attempt to load code outside 1-gig range.";
+	case xtmld_sections_overlap:
+		return "Section addresses overlap.";
+	case xtmld_image_not_aligned:
+		return "Library is not properly aligned.";
+	default:
+		return "Unknown error.";
+	}
+}
diff --git a/drivers/soc/eswin/ai_driver/dsp/mloader/xt_mld_loader.h b/drivers/soc/eswin/ai_driver/dsp/mloader/xt_mld_loader.h
new file mode 100644
index 000000000000..4036e17e16e3
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/dsp/mloader/xt_mld_loader.h
@@ -0,0 +1,259 @@
+/*
+ * Copyright (c) 2019 by Tensilica Inc. ALL RIGHTS RESERVED.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+#ifndef XT_MLD_LOADER_H_
+#define XT_MLD_LOADER_H_
+
+#include <linux/string.h>
+
+typedef void *xtmld_code_ptr;
+typedef void *xtmld_data_ptr;
+typedef void *xtmld_ptr;
+typedef void *xtmld_start_fn_ptr;
+
+typedef int int32_t;
+typedef unsigned int uint32_t;
+typedef unsigned char uint8_t;
+
+#define xthal_memcpy memcpy
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if defined(XTMLIB_DEBUG) && XTMLIB_DEBUG
+#include <stdio.h>
+#define Dprintf(args...) printf("%s", args)
+#else
+#define Dprintf(args...)
+#endif
+
+/* this is the type for the memory copy function that is passed to
+ * xtmld_load_library_custom_fn().  Note that the signature is the
+ * same as the standard library function memcpy() except for the user pointer.
+ */
+typedef xtmld_ptr (*memcpy_func_ex)(xtmld_ptr dest, const xtmld_ptr src,
+				    unsigned int n, void *user);
+
+/* this is the type for the memset function that is passed to
+ * xtmld_load_library_custom_fn().  Note that the signature is the
+ * same as the standard library function memset() except for the user pointer.
+ */
+typedef xtmld_ptr (*memset_func_ex)(xtmld_ptr s, int c, unsigned int n,
+				    void *user);
+
+/* Constants for the maximum number of supported code and data segments.  If
+ * these values are changed, then the linker script needs to be updated
+ * as well.
+ */
+#define XTMLD_MAX_CODE_SECTIONS 4
+#define XTMLD_MAX_DATA_SECTIONS 4
+#define XTMLD_MAX_SECTIONS \
+	(XTMLD_MAX_CODE_SECTIONS + XTMLD_MAX_DATA_SECTIONS + 1)
+
+/*
+ * XTENSA_HOST_BYTE_SWAP should be defined to 1 only if the libraries are
+ * being loaded on a core with a different endianness than the target where
+ * the library code will be executed.
+ */
+#ifndef XTENSA_HOST_BYTE_SWAP
+#define XTENSA_HOST_BYTE_SWAP 0
+#endif
+
+#define XTMLD_DATA_MARKER ((xtmld_mem_require_t)0x70000003)
+#define XTMLD_CODE_MARKER ((xtmld_mem_require_t)0x70000004)
+#define XTMLD_MAX_LIB_NAME_LENGTH 32  // default name
+
+#define XTMLD_DATARAM0_ADDR 0x28100000
+/* IMPORTANT: Do not change the numerical values of these enums. Doing so will
+ * impact compatibility with libraries built with earlier versions of the SDK.
+ */
+typedef enum xtmld_mem_require {
+	xtmld_load_normal = 1,
+	xtmld_load_prefer_localmem = 2,
+	xtmld_load_require_localmem = 3,
+	xtmld_load_require_dram0 = 4,
+	xtmld_load_require_dram1 = 5,
+	xtmld_load_prefer_l2mem = 6,
+} xtmld_mem_require_t;
+
+/* The XTMLD_CODE_MEM_REQ() and XTMLD_DATA_MEM_REQ() macros must be included
+ * in each multiple section loadable library.  The macros specify the memory
+ * needed for each section.  Typical usage:
+ *
+ * Suppose, .data contains bulk data that isn't performance critical
+ *          .1.data and .2.data contain performance critical data.
+ *          .3.data contains an iDMA buffer which MUST be in local memory
+ *
+ * XTMLD_DATA_MEM_REQ(xtmld_load_normal, xtmld_load_prefer_localmem,
+ *                    xtmld_prefer_local_memory, and xtmld_require_local_mem)
+ */
+#define XTMLD_CODE_MEM_REQ(sec1, sec2, sec3, sec4)                          \
+	__attribute__((section(".dyninfo")))                                \
+	xtmld_mem_require_t xtmld_text[] = { XTMLD_CODE_MARKER, sec1, sec2, \
+					     sec3, sec4 };
+
+#define XTMLD_DATA_MEM_REQ(sec1, sec2, sec3, sec4)                          \
+	__attribute__((section(".dyninfo")))                                \
+	xtmld_mem_require_t xtmld_data[] = { XTMLD_DATA_MARKER, sec1, sec2, \
+					     sec3, sec4 };
+
+#define XTMLD_LIBRARY_NAME(lname)                                   \
+	__attribute__((section(".dyninfo"))) char xtmld_libname[] = \
+		"xtensalibname:" #lname;
+
+/*
+ * A structure of type xtmld_library_info_t is by xtmld_library_info to
+ * return the number and sizes of the sections.
+ */
+typedef struct {
+	uint32_t number_of_code_sections;
+	uint32_t number_of_data_sections;
+	uint32_t code_section_size[XTMLD_MAX_CODE_SECTIONS];
+	uint32_t data_section_size[XTMLD_MAX_DATA_SECTIONS];
+	xtmld_mem_require_t code_section_mem_req[XTMLD_MAX_CODE_SECTIONS];
+	xtmld_mem_require_t data_section_mem_req[XTMLD_MAX_DATA_SECTIONS];
+} xtmld_library_info_t;
+
+/*
+ * All functions return a result code of type xtmld_result_code.
+ */
+typedef enum {
+	/* Function executed as expected */
+	xtmld_success = 0,
+	/* a NULL ptr was passed to function */
+	xtmld_null_ptr,
+	/* The in memory library format was invalid. Verify that the correct
+     * linker script was used to build the library.  Also verify the
+     * correct command was used to package the library.
+     */
+	xtmld_invalid_library,
+	/* An error internal to implementation was found.*/
+	xtmld_internal_error,
+	/* Make sure that XTMLD_DATA_MEM_REQ and XTMLD_CODE_MEM_REQ macros are
+     * in library.
+     */
+	xtmld_mem_require_not_found,
+	/*
+     * A section that requires local memory was placed in a non-local
+     * memory region.
+     */
+	xtmld_local_memory_required,
+	/*
+     * One or more code sections were not placed within the same 1GB range.
+     */
+	xtmld_code_must_be_in_1gig_region,
+	/*
+     * One or more of the section load areas (supplied to xtmld_load)
+     * overlapped.
+     */
+	xtmld_sections_overlap,
+	/*
+     * Packed library is not properly aligned.
+     */
+	xtmld_image_not_aligned
+} xtmld_result_code_t;
+
+/*
+ * xtmld_state_t is an internal structure used during library loading
+ * and unloading.
+ */
+typedef struct xtmld_state_t {
+	uint32_t num_sections;
+	uint32_t num_text_sections;
+	xtmld_ptr dst_addr[XTMLD_MAX_SECTIONS];
+	uint32_t src_offs[XTMLD_MAX_SECTIONS];
+	uint32_t size[XTMLD_MAX_SECTIONS];
+	xtmld_start_fn_ptr start_sym;
+	xtmld_ptr text_addr[XTMLD_MAX_CODE_SECTIONS];
+	xtmld_ptr init;
+	xtmld_ptr fini;
+	xtmld_ptr rel;
+	uint32_t rela_count;
+	xtmld_ptr hash[XTMLD_MAX_DATA_SECTIONS];
+	struct xtmld_state_t *next;
+	char libname[XTMLD_MAX_LIB_NAME_LENGTH];
+	int32_t scratch_section_found;
+} xtmld_state_t;
+
+typedef void *xtmld_packaged_lib_t;
+
+extern xtmld_state_t *xtmld_loaded_lib_info;
+
+/*
+ * This function locates the .rodata section of the packaged library.
+ * So, the packaged library has no need to be linked with main module
+ * and it can be loaded on the fly.  The returned result in lib can
+ * be used in xtmld_library_info() and xtmld_load().
+ */
+xtmld_result_code_t xt_mld_get_packaged_lib(void *packaged_img,
+					    xtmld_packaged_lib_t **lib);
+
+/*
+ * This function converts the result code from one of the
+ * other xtmld functions into a descriptive string.
+ */
+extern const char *xtmld_error_string(xtmld_result_code_t);
+
+/*
+ * This function writes information about the packaged library into
+ * the info structure.
+ */
+extern xtmld_result_code_t xtmld_library_info(xtmld_packaged_lib_t *lib,
+					      xtmld_library_info_t *info);
+
+/*
+ * The function xtmld_load() loads the library into the sections
+ * supplied, call the library init function (C++ constructors
+ * for static objects), and sets the start function point to point
+ * to the _start function() of the supplied library.
+ */
+extern xtmld_result_code_t xtmld_load(xtmld_packaged_lib_t *lib,
+				      xtmld_code_ptr *code_section_la,
+				      xtmld_data_ptr *data_section_la,
+				      xtmld_state_t *state,
+				      xtmld_start_fn_ptr *start);
+
+/*
+ * xtmld_load_custom_fn is the same as xtmld_load except that it has
+ * additional arguments for custom memory copy and set functions. The
+ * parameter user, is passed to the custom functions.
+ */
+extern xtmld_result_code_t xtmld_load_custom_fn(
+	xtmld_packaged_lib_t *library, xtmld_code_ptr *destination_code_address,
+	xtmld_data_ptr *destination_data_address, xtmld_state_t *lib_info,
+	memcpy_func_ex mcpy_fn, memset_func_ex mset_fn, void *user,
+	xtmld_start_fn_ptr *start);
+
+/*
+ * This function unloads a library.  The state argument must be the
+ * same as passed to the load function.
+ */
+extern xtmld_result_code_t xtmld_unload(xtmld_state_t *state);
+
+extern xtmld_result_code_t xtmld_relocate_library(xtmld_state_t *state);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/drivers/soc/eswin/ai_driver/dsp/mloader/xt_mld_relocate.c b/drivers/soc/eswin/ai_driver/dsp/mloader/xt_mld_relocate.c
new file mode 100644
index 000000000000..75e18557c879
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/dsp/mloader/xt_mld_relocate.c
@@ -0,0 +1,498 @@
+/*
+ Copyright (c) 2019 Cadence Design Systems Inc.
+
+ Permission is hereby granted, free of charge, to any person obtaining
+ a copy of this software and associated documentation files (the
+ "Software"), to deal in the Software without restriction, including
+ without limitation the rights to use, copy, modify, merge, publish,
+ distribute, sublicense, and/or sell copies of the Software, and to
+ permit persons to whom the Software is furnished to do so, subject to
+ the following conditions:
+
+ The above copyright notice and this permission notice shall be included
+ in all copies or substantial portions of the Software.
+
+ THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <linux/kernel.h>
+#include "xt_elf.h"
+#include "xt_mld_loader.h"
+#include "core-const16w.inc"
+
+#define BPW (8 * sizeof(Elf32_Word))
+#define DIV_ROUNDUP(a, b) (((a) + (b)-1) / (b))
+
+/* Define the minimum separation between segments.  This must be > than
+ * the largest indirect with L32I.
+ */
+#define MIN_SEPARATION 0x400
+
+static unsigned int XT_SSA8L(unsigned int s)
+{
+	return ((((s) << 3) & 0x18U));
+}
+
+static unsigned int XT_SSA8B(unsigned int s)
+{
+	return ((0x20U) - ((((s) << 3) & 0x18U))) & 0x3fU;
+}
+
+static unsigned int XT_SRC(unsigned int s, unsigned int t, unsigned int SAR)
+{
+	unsigned int r__out = 0;
+
+	unsigned int tn0__o0;
+	unsigned int tn4__o0[2];
+	unsigned int tn4__i0[2];
+	tn0__o0 = SAR;
+	tn4__i0[0] = ((t));
+	tn4__i0[1] = ((s));
+	{
+		unsigned bit__shift = tn0__o0 & 0x1fU;
+		unsigned word__shift = tn0__o0 >> 5;
+		if (bit__shift == 0) {
+			tn4__o0[0] = (tn4__i0[word__shift]);
+		} else {
+			unsigned int rshift__ = 32 - bit__shift;
+			unsigned int tmp__;
+			unsigned int prev__;
+			prev__ = (word__shift > 0) ? 0 : tn4__i0[1];
+			tmp__ = tn4__i0[word__shift];
+			tn4__o0[0] =
+				((tmp__ >> bit__shift) | (prev__ << rshift__));
+		}
+	}
+	r__out = ((tn4__o0[0]));
+	return r__out;
+}
+static inline uint32_t load_32(xtmld_ptr addr)
+{
+	uint32_t *paddr = (uint32_t *)addr;
+	return (uint32_t)*paddr;
+}
+
+static inline void store_32(xtmld_ptr addr, uint32_t value)
+{
+	uint32_t *paddr = (uint32_t *)addr;
+	*paddr = value;
+}
+
+/* Extract word from {lo, hi} pair at byte offset 'ofs'. This is equivalent
+ of unaligned load from aligned memory region {lo, hi}. */
+
+static inline uint32_t extract(uint32_t lo, uint32_t hi, int32_t ofs)
+{
+#ifdef __XTENSA_EB__
+	unsigned int SAR = XT_SSA8B(ofs);
+	return XT_SRC(lo, hi, SAR);
+#else
+	unsigned int SAR = XT_SSA8L(ofs);
+	return XT_SRC(hi, lo, SAR);
+#endif
+}
+
+/* Sets word at byte offset 'ofs' in the pair {lo, hi} to 'value'. This is equivalent
+ of unaligned store into aligned memory region {lo, hi}. */
+
+static inline void combine(uint32_t *lo, uint32_t *hi, uint32_t value,
+			   int32_t ofs)
+{
+	uint32_t x0, x1;
+#ifdef __XTENSA_EB__
+	unsigned int SAR = XT_SSA8B(ofs);
+	x0 = XT_SRC(*lo, *lo, SAR);
+	x1 = XT_SRC(*hi, *hi, SAR);
+	SAR = XT_SSA8L(ofs);
+	*lo = XT_SRC(x0, value, SAR);
+	*hi = XT_SRC(value, x1, SAR);
+#else
+	unsigned int SAR = XT_SSA8L(ofs);
+	x0 = XT_SRC(*lo, *lo, SAR);
+	x1 = XT_SRC(*hi, *hi, SAR);
+	SAR = XT_SSA8B(ofs);
+	*lo = XT_SRC(value, x0, SAR);
+	*hi = XT_SRC(x1, value, SAR);
+#endif
+}
+
+/* Helper functions for copying instructions between IRAM and word aligned buffer.
+ */
+
+/* copy_in copies 'bits' number of bits starting from word aligned pointer 'src' at
+ byte offset 'src_ofs' into word-aligned buffer 'buf'.
+ The actual number of bytes copied is higher, this helps to write this buffer back
+ without need to read data from IRAM again. The actual 'src':'src_pos' data starts
+ from word dst[1]. Th word dst[0] holds data from the start of 'src' up to 'src_pos'
+ byte.
+ */
+static inline void copy_in(Elf32_Word *dst, Elf32_Word *src, int src_ofs,
+			   int32_t bits)
+{
+	Elf32_Word copied;
+	Elf32_Word count = DIV_ROUNDUP(bits + 8 * src_ofs, BPW);
+	unsigned int SAR = 0;
+
+	if (src_ofs == 0) { /* special case - source is word-aligned */
+		dst++;
+		for (copied = 0; copied < count; copied++)
+			*dst++ = load_32(src++);
+	} else {
+		Elf32_Word last = 0;
+		Elf32_Word curr;
+#ifdef __XTENSA_EB__
+		SAR = XT_SSA8B(src_ofs);
+		for (copied = 0; copied < count; copied++) {
+			*dst++ = XT_SRC(last, (curr = load_32(src++), SAR));
+			last = curr;
+		}
+#else
+		SAR = XT_SSA8L(src_ofs);
+		for (copied = 0; copied < count; copied++) {
+			*dst++ = XT_SRC((curr = load_32(src++)), last, SAR);
+			last = curr;
+		}
+#endif
+		*dst = XT_SRC(last, last, SAR);
+	}
+}
+
+/* copy_out writes data buffered using copy_in back to IRAM.
+ 'src_ofs' and 'bits' has to be the same as in copy_in call
+ but 'dst' now is the 'src' from copy_in and 'src' in copy_out
+ is the 'dst' from copy_in. */
+
+static inline void copy_out(Elf32_Word *dst, Elf32_Word *src, int32_t src_ofs,
+			    int32_t bits)
+{
+	Elf32_Word copied;
+	Elf32_Word count = DIV_ROUNDUP(bits + 8 * src_ofs, BPW);
+	unsigned int SAR = 0;
+
+	if (src_ofs == 0) { /* special case - desctionation is word-aligned */
+		src++;
+		for (copied = 0; copied < count; copied++)
+			store_32(dst++, *src++);
+	} else {
+		Elf32_Word last = *src++;
+		Elf32_Word curr;
+#ifdef __XTENSA_EB__
+		SAR = XT_SSA8L(src_ofs);
+		for (copied = 0; copied < count; copied++) {
+			store_32(dst++, XT_SRC(last, (curr = *src++), SAR));
+			last = curr;
+		}
+#else
+		SAR = XT_SSA8B(src_ofs);
+		for (copied = 0; copied < count; copied++) {
+			store_32(dst++, XT_SRC((curr = *src++), last, SAR));
+			last = curr;
+		}
+#endif
+	}
+}
+
+static xtmld_result_code_t relocate_op(char *ptr, int slot, Elf32_Word value)
+{
+	Elf32_Word format_length, a_ofs, mem_lo, mem_hi, insn;
+	uint32_t *a_ptr;
+
+	// To decode the instruction length we need to read up to 4 bytes
+	// of the instruction from memory. We cannot pass "ptr" as is to
+	// the decode function because it may be unaligned, and iram will
+	// not allow unaligned access. So we will read two words aligned
+	// and then merge them to get the first 4 bytes (if the insn is
+	// less than 4 bytes we get some garbage at the end but it does
+	// not matter.
+
+	a_ofs = (uint32_t)ptr % sizeof(uint32_t);
+#ifdef __XTENSA__
+	a_ptr = (uint32_t *)((uint32_t)ptr - a_ofs);
+#else
+	a_ptr = (uint32_t *)((uint64_t)ptr - a_ofs);
+#endif
+
+	mem_lo = load_32(a_ptr);
+	mem_hi = load_32(a_ptr + 1);
+#ifdef __XTENSA_EB__
+	switch (a_ofs) {
+	case 0:
+		insn = mem_lo;
+		break;
+	case 1:
+		insn = (mem_lo << 8) | (mem_hi >> 24);
+		break;
+	case 2:
+		insn = (mem_lo << 16) | (mem_hi >> 16);
+		break;
+	case 3:
+		insn = (mem_lo << 24) | (mem_hi >> 8);
+		break;
+	default:
+		return xtmld_internal_error;
+	}
+#else
+	switch (a_ofs) {
+	case 0:
+		insn = mem_lo;
+		break;
+	case 1:
+		insn = (mem_lo >> 8) | (mem_hi << 24);
+		break;
+	case 2:
+		insn = (mem_lo >> 16) | (mem_hi << 16);
+		break;
+	case 3:
+		insn = (mem_lo >> 24) | (mem_hi << 8);
+		break;
+	default:
+		return xtmld_internal_error;
+	}
+#endif
+
+	format_length = xtimm_get_format_length(insn);
+	if (format_length == 0)
+		return xtmld_internal_error;
+
+	if (format_length <= 32) {
+		if (format_length + 8 * a_ofs <= 32) {
+			if (!xtimm_fmt_small_immediate_field_set(&insn, slot,
+								 value))
+				return xtmld_internal_error;
+			combine(&mem_lo, &mem_hi, insn, a_ofs);
+			store_32(a_ptr, mem_lo);
+		} else {
+			mem_hi = load_32(a_ptr + 1);
+			insn = extract(mem_lo, mem_hi, a_ofs);
+			if (!xtimm_fmt_small_immediate_field_set(&insn, slot,
+								 value))
+				return xtmld_internal_error;
+			combine(&mem_lo, &mem_hi, insn, a_ofs);
+			store_32(a_ptr, mem_lo);
+			store_32(a_ptr + 1, mem_hi);
+		}
+	} else {
+		Elf32_Word buf[DIV_ROUNDUP(XTIMM_MAX_FORMAT_LENGTH, BPW) + 2];
+		copy_in(buf, a_ptr, a_ofs, format_length);
+		if (!xtimm_fmt_large_immediate_field_set(&buf[1], slot, value))
+			return xtmld_internal_error;
+		copy_out(a_ptr, buf, a_ofs, format_length);
+	}
+	return xtmld_success;
+}
+
+static xtmld_result_code_t reloc_addr(const xtmld_state_t *lib_info,
+				      Elf32_Addr addr, xtmld_ptr *relocation)
+{
+	int i;
+	uint32_t sep = lib_info->scratch_section_found ? MIN_SEPARATION : 0;
+	for (i = 0; i < lib_info->num_sections; i++) {
+		if ((addr + sep >= lib_info->src_offs[i]) &&
+		    (addr < lib_info->src_offs[i] + lib_info->size[i] + sep)) {
+			*relocation =
+				(xtmld_ptr)((Elf_Addr)lib_info->dst_addr[i]) -
+				lib_info->src_offs[i] + addr;
+			return xtmld_success;
+		}
+	}
+	Dprintf("Failed to find relocation\n");
+	return xtmld_internal_error;
+}
+
+static xtmld_result_code_t reloc_addr_value(const xtmld_state_t *lib_info,
+					    Elf32_Addr addr,
+					    Elf32_Addr *relocation)
+{
+	int i;
+	uint32_t sep = lib_info->scratch_section_found ? MIN_SEPARATION : 0;
+	for (i = 0; i < lib_info->num_sections; i++) {
+		if ((addr + sep >= lib_info->src_offs[i]) &&
+		    (addr < lib_info->src_offs[i] + lib_info->size[i] + sep)) {
+			if (i <
+			    lib_info->num_text_sections) {  // addr located in text segment
+				*relocation =
+					((Elf32_Addr)lib_info->text_addr[i]) -
+					lib_info->src_offs[i] + addr;
+			} else {
+				*relocation =
+					((Elf32_Addr)lib_info->dst_addr[i]) -
+					lib_info->src_offs[i] + addr;
+			}
+			return xtmld_success;
+		}
+	}
+	Dprintf("Failed to find relocation\n");
+	return xtmld_internal_error;
+}
+
+static xtmld_result_code_t relocate_relative(xtmld_state_t *lib_info,
+					     Elf32_Rela *rela)
+{
+	xtmld_ptr addr;
+	xtmld_result_code_t status;
+	status = reloc_addr(lib_info, rela->r_offset, &addr);
+	if (status != xtmld_success)
+		return status;
+	Elf32_Word a_ofs = (Elf32_Word)addr % 4;
+	// check if it's 4 byte aligned, C++ exception tables may have
+	// unaligned relocations
+	if (a_ofs == 0) {
+		xtmld_ptr raddr;
+		status = reloc_addr(lib_info, load_32(addr) + rela->r_addend,
+				    &raddr);
+		if (status != xtmld_success)
+			return status;
+		store_32(addr, (uint32_t)raddr);
+	} else {
+		Elf32_Word hi, lo, val;
+		xtmld_ptr a_ptr = (addr - a_ofs);
+		lo = load_32(a_ptr);
+		hi = load_32((uint32_t *)a_ptr + 1);
+		val = extract(lo, hi, a_ofs);
+		status = reloc_addr(lib_info, val + rela->r_addend,
+				    ((xtmld_ptr *)&val));
+		if (status != xtmld_success)
+			return status;
+		combine(&lo, &hi, val, a_ofs);
+		store_32(a_ptr, lo);
+		store_32(((uint32_t *)a_ptr + 1), hi);
+	}
+	return xtmld_success;
+}
+
+static xtmld_result_code_t relocate_32_pcrel(xtmld_state_t *lib_info,
+					     Elf32_Rela *rela)
+{
+	xtmld_ptr addr;
+	xtmld_ptr raddr;
+	xtmld_result_code_t status;
+	// r_offset is the location of source in PIL, which has data to be relocated
+	// get loaded address of source
+	status = reloc_addr(lib_info, rela->r_offset, &addr);
+	if (status != xtmld_success)
+		return status;
+	Elf32_Word a_ofs = (Elf32_Word)addr % 4;
+	// r_addend is the location of target in PIL
+	// get loaded address of target
+	status = reloc_addr(lib_info, rela->r_addend, &raddr);
+	if (status != xtmld_success)
+		return status;
+	// check if it's 4 byte aligned, C++ exception tables may have
+	// unaligned relocations
+	if (a_ofs == 0) {
+		// write offset between target and source to source address
+		store_32(addr, (uint32_t)raddr - (uint32_t)addr);
+	} else {
+		Elf32_Word hi, lo;
+		xtmld_ptr a_ptr = (addr - a_ofs);
+
+		// unaligned access; read the original to keep partial data
+		lo = load_32(a_ptr);
+		hi = load_32((uint32_t *)a_ptr + 1);
+		// split the offset between source and target into 2 words
+		combine(&lo, &hi, (uint32_t)raddr - (uint32_t)addr, a_ofs);
+
+		// write offset between target and source to source address
+		store_32(a_ptr, lo);
+		store_32((uint32_t *)a_ptr + 1, hi);
+	}
+	return xtmld_success;
+}
+
+int is_data_segment(xtmld_state_t *lib_info, Elf32_Addr addr)
+{
+	int i;
+	uint32_t sep = lib_info->scratch_section_found ? MIN_SEPARATION : 0;
+	for (i = 0; i < lib_info->num_sections; i++) {
+		if ((addr + sep >= lib_info->src_offs[i]) &&
+		    (addr < lib_info->src_offs[i] + lib_info->size[i] + sep)) {
+			if (i <
+			    lib_info->num_text_sections) {  // addr located in text segment
+				return 0;
+			} else {
+				return 1;
+			}
+		}
+	}
+	return 0;
+}
+
+xtmld_result_code_t xtmld_relocate_library(xtmld_state_t *lib_info)
+{
+	int i;
+	xtmld_result_code_t status;
+	Elf32_Rela *relocations = (Elf32_Rela *)lib_info->rel;
+	for (i = 0; i < lib_info->rela_count; i++) {
+		Elf32_Rela *rela = &relocations[i];
+		Elf32_Word r_type;
+
+		if (is_data_segment(lib_info, rela->r_offset)) {
+			continue;  // data segment cannot relocate
+		}
+
+		if (ELF32_R_SYM(rela->r_info) != STN_UNDEF)
+			return xtmld_internal_error;
+
+		r_type = ELF32_R_TYPE(rela->r_info);
+		/* instruction specific relocation, at the moment only const16 expected  */
+		if (r_type >= R_XTENSA_SLOT0_OP &&
+		    r_type <= R_XTENSA_SLOT14_OP) {
+			Elf_Addr r_addr;
+			Elf32_Addr r_addr_value;
+			status = reloc_addr(lib_info, rela->r_offset,
+					    (xtmld_ptr *)&r_addr);
+			if (status != xtmld_success)
+				return status;
+			status = reloc_addr_value(lib_info, rela->r_addend,
+						  &r_addr_value);
+			if (status != xtmld_success)
+				return status;
+
+			status = relocate_op((xtmld_ptr)r_addr,
+					     (r_type - R_XTENSA_SLOT0_OP),
+					     r_addr_value);
+			if (status != xtmld_success)
+				return status;
+		} else if (r_type >= R_XTENSA_SLOT0_ALT &&
+			   r_type <= R_XTENSA_SLOT14_ALT) {
+			Elf_Addr r_addr;
+			Elf32_Addr r_addr_value;
+			status = reloc_addr(lib_info, rela->r_offset,
+					    (xtmld_ptr *)&r_addr);
+			if (status != xtmld_success)
+				return status;
+			status = reloc_addr_value(lib_info, rela->r_addend,
+						  &r_addr_value);
+			if (status != xtmld_success)
+				return status;
+
+			status = relocate_op((xtmld_ptr)r_addr,
+					     (r_type - R_XTENSA_SLOT0_ALT),
+					     r_addr_value >> 16);
+			if (status != xtmld_success) {
+				return status;
+			}
+		} else if (r_type == R_XTENSA_RELATIVE) {
+			status = relocate_relative(lib_info, rela);
+			if (status != xtmld_success)
+				return status;
+		} else if (r_type == R_XTENSA_32_PCREL) {
+			/* this is used with symbol@pcrel relocation for PIC code and
+               std non-PIC code in .eh_frame sections*/
+			status = relocate_32_pcrel(lib_info, rela);
+			if (status != xtmld_success)
+				return status;
+		} else if (r_type != R_XTENSA_NONE) {
+			return xtmld_internal_error;
+		}
+	}
+	return xtmld_success;
+}
+
+/* end relocate code */
diff --git a/drivers/soc/eswin/ai_driver/include/cdma_regs.h b/drivers/soc/eswin/ai_driver/include/cdma_regs.h
new file mode 100644
index 000000000000..331d0b00d920
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/include/cdma_regs.h
@@ -0,0 +1,245 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#ifndef __CDMA_REGS_H__
+#define __CDMA_REGS_H__
+
+/**
+ * @brief NPU configuration DMA related register offsets. Refer to
+ * https://ekm.eswincomputing.com/preview.html?fileid=1267313
+ *
+ */
+
+/**
+ * @brief NPU configuration DMA major size register.
+ * This is a 32 bits register. Total bits are divided equally into 4 groups and each 8 bits belong to a group. Each 8
+ * bits map to a transfer size (In 4 bytes unit) of a given Master node. Total 4 groups correspond to Master node 0 ~ 3.
+ *
+ */
+#define NPU_CDMA_MJLX_SZ_OFFSET 0x0
+
+/**
+ * @brief NPU configuration DMA major size register.
+ * This is a 32 bits register. Total bits are divided equally into 4 groups and each 8 bits belong to a group. Each 8
+ * bits map to a transfer size (In 4 bytes unit) of a given Master node. Total 4 groups correspond to Master node 4 ~ 7.
+ *
+ */
+#define NPU_CDMA_MJHX_SZ_OFFSET 0x4
+
+/**
+ * @brief NPU configuration DMA miscellaneous configuration register.
+ * See npu_cdma_misc_cfg0_t for a detailed explanation.
+ *
+ */
+#define NPU_CDMA_MISC_CFG0_OFFSET 0x8
+
+/**
+ * @brief NPU configuration DMA source address register.
+ * This is a 32 bits wide register corresponding to the 0~31 bits of source address. Source address should be aligned to
+ * 4 bytes boundary.
+ *
+ */
+#define NPU_CDMA_SRC_ADD_OFFSET 0xC
+
+/**
+ * @brief NPU configuration DMA miscellaneous configuration register.
+ * See npu_cdma_misc_cfg1_t for a detailed explanation.
+ *
+ */
+#define NPU_CDMA_MISC_CFG1_OFFSET 0x10
+
+/**
+ * @brief NPU configuration DMA miscellaneous control register.
+ * See npu_cdma_misc_ctl_t for a detailed explanation.
+ *
+ */
+#define NPU_CDMA_MISC_CTL_OFFSET 0x14
+
+/**
+ * @brief NPU configuration DMA miscellaneous control register.
+ * .See npu_cdma_err_intr_clr_t for a detailed explanation.
+ *
+ */
+#define NPU_CDMA_ERR_INT_CLEAR_OFFSET 0x1c
+
+/**
+ * @brief This is a bitmap. Each bit in 0~9 specifies if common information data should be sent to the given node if
+ * this bit is 1.
+ *
+ */
+#define NPU_CDMA_COM_BITMAP 0x28
+
+/**
+ * @brief NPU configuration DMA miscellaneous configuration register 0.
+ *
+ */
+union npu_cdma_misc_cfg0_t {
+    struct {
+        /**
+         * @brief Master node DMA transfer size (In 4 bytes unit).
+         *
+         */
+        u32 master_size : 8;
+
+        /**
+         * @brief Auxiliary node DMA transfer size (In 4 bytes unit).
+         *
+         */
+        u32 aux_size : 8;
+
+        /**
+         * @brief Major nodes destination address offset (In 4 bytes unit) relative to DTim start.
+         *
+         */
+        u32 major_des_addr : 8;
+
+        /**
+         * @brief Auxiliary node destination address offset (In 4 bytes unit) relative to DTim start.
+         *
+         */
+        u32 aux_des_addr : 8;
+    };
+
+    /**
+     * @brief DWord register value.
+     *
+     */
+    u32 dw;
+};
+
+/**
+ * @brief NPU configuration DMA miscellaneous configuration register 1.
+ *
+ */
+union npu_cdma_misc_cfg1_t {
+    struct {
+        /**
+         * @brief  Corresponds to the 32~47 bits of source address.
+         *
+         */
+        u32 src_addr_hi : 16;
+
+        /**
+         * @brief Common DMA transfer size (In 4 bytes unit).
+         *
+         */
+        u32 com_size : 8;
+
+        /**
+         * @brief Master nodes destination address offset (In 4 bytes unit) relative to DTim start.
+         *
+         */
+        u32 master_des_addr : 8;
+    };
+
+    /**
+     * @brief DWord register value.
+     *
+     */
+    u32 dw;
+};
+
+/**
+ * @brief NPU configuration DMA miscellaneous control register.
+ *
+ */
+union npu_cdma_misc_ctl_t {
+    struct {
+        /**
+         * @brief Write this register with setting 1 to this bit triggers DMA transfer. Write this register with setting
+         * 0 to this bit if DMA is outstanding is undefined behavior. Read this register and this bit reflects if there
+         * is outstanding DMA.
+         *
+         */
+        u32 dma_en : 1;
+
+        /**
+         * @brief Enable DMA completion interrupt.
+         *
+         */
+        u32 int_en : 1;
+
+        /**
+         * @brief Indicates the status of last DMA transfer.
+         *
+         */
+        u32 dma_status : 6;
+
+        /**
+         * @brief Specifies the AXI maximum burst length. This value should
+         * satisfy 2 ** n - 1 where n is a natural number.
+         *
+         */
+        u32 burst_len : 6;
+
+        u32 : 2;
+
+        /**
+         * @brief Specifies the total length (In 4-bytes unit) of the data to be read from source address.
+         *
+         */
+        u32 total_len : 16;
+    };
+
+    /**
+     * @brief DWord register value.
+     *
+     */
+    u32 dw;
+};
+
+union npu_cdma_err_intr_clr_t {
+    struct {
+        /**
+         * @brief Normal interrupt clear(include success interrupt and total size zero interruput)
+         *
+         */
+        u32 normal_clear : 1;
+
+        /**
+         * @brief Enable cfg error clear
+         *
+         */
+        u32 dma_cfg_err_clear : 1;
+
+        /**
+         * @brief Enable axi slave error clear
+         *
+         */
+        u32 dma_axi_slv_err_clear : 1;
+
+        /**
+         * @brief Enable axi decode error clear
+         *
+         */
+        u32 dma_axi_dec_err_clear : 1;
+
+        /**
+         * @brief Enable the hardware automatically clears the interrupt and error status
+         *
+         */
+        u32 hw_int_ctrl : 1;
+
+        u32 : 11;
+
+        /**
+         * @brief Retry error clear
+         * [0] for for master, [1] for aux, [9:2] for major 0~7
+         */
+        u32 retry_error_clear : 10;
+
+        u32 : 6;
+    };
+
+    /**
+     * @brief DWord register value.
+     *
+     */
+    u32 dw;
+};
+
+#endif
\ No newline at end of file
diff --git a/drivers/soc/eswin/ai_driver/include/conv_regs.h b/drivers/soc/eswin/ai_driver/include/conv_regs.h
new file mode 100644
index 000000000000..f72902ce1ac3
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/include/conv_regs.h
@@ -0,0 +1,234 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#ifndef __CONV_REGS_H__
+#define __CONV_REGS_H__
+
+/**
+ * @brief Declear miscellaneous interrupts in NPU module.
+ *
+ */
+#define IRQ_NPU_PEC_PING 5
+#define IRQ_NPU_PEC_PONG 6
+#define IRQ_NPU_PEC_ERROR 7
+#define IRQ_NPU_PREDRP_PING 8
+#define IRQ_NPU_PREDRP_PONG 9
+#define IRQ_NPU_PREDRP_ERROR 10
+#define IRQ_NPU_CONV_MASK ((1U << IRQ_NPU_PREDRP_PING) | (1U << IRQ_NPU_PREDRP_PONG))
+
+/**
+ * @brief PEC registers.
+ *
+ */
+#define PEC_D_OP_EN_TRIG 0x0
+#define PEC_D_OP_STATUS 0x4
+
+#define PEC_D_SPAD_PARAM0 0x8
+#define PEC_D_SPAD_PARAM1 0xC
+#define PEC_D_GLB_PARAM0 0x10
+#define PEC_D_CALC_MODE 0x14
+#define PEC_D_ROUNT_CASE_MODE_PADDING 0x18
+#define PEC_D_SPACE_OFFSET0 0x1C
+#define PEC_D_SPACE_OFFSET1 0x20
+#define PEC_D_PADDING_VALUE 0x24
+#define PEC_D_GLB_WT_IFM_REUSE 0x28
+#define PEC_WT_NAN_CNT 0x2C
+#define PEC_WT_IFN_CNT 0x30
+#define PEC_IFM_NAN_CNT 0x34
+#define PEC_IFM_IFN_CNT 0x38
+#define PEC_PSUM_OV_CNT 0x3C
+
+#define PEC_S_SOFT_RESET 0x0
+#define PEC_S_POINTER_FLAG 0x4
+#define PEC_S_PP_STATUS 0x8
+#define PEC_PERF_CNT_CLR_OV 0xC
+#define PEC_PERF_CNT_L 0x10
+#define PEC_PERF_CNT_H 0x14
+
+#define NPU_PEC_UCAST_ADDR_STRIDE (NPU_MODULE_STRIDE * 2)
+
+/**
+ * @brief MAC registers.
+ *
+ */
+#define MAC_D_OP_EN_TRIG 0x0
+#define MAC_D_OP_STATUS 0x4
+
+#define MAC_S_SOFT_RESET 0x0
+#define MAC_S_POINTER_FLAG 0x4
+#define MAC_S_PP_STATUS 0x8
+#define MAC_S_MAC_PERF_CNT_CLR_OV 0xc
+#define MAC_S_OP_EN_ACTIVE_CNT_L 0x10
+#define MAC_S_OP_EN_ACTIVE_CNT_H 0x14
+#define MAC_S_OP_EN_NOT_CNT_L 0x18
+#define MAC_S_OP_EN_NOT_CNT_H 0x1c
+#define MAC_S_INT_MASK_PING_BASE1 0x20
+#define MAC_S_INT_MASK_PONG_BASE1 0x2C
+
+#define MAC_CSC_MODE 0x2C
+
+/**
+ * @brief RDMA registers.
+ *
+ */
+#define RDMA_D_OP_EN_TRIG 0x0
+#define RDMA_D_OP_STATUS 0x4
+
+/**
+ * @brief The Ifmap and weight control register offset relative to RDMA base address.
+ *
+ */
+#define RDMA_D_IFM_CR 0x8
+#define RDMA_D_IFM_SA_H 0xc
+#define RDMA_D_IFM_SA_L 0x10
+#define RDMA_D_WT_SA_H 0x14
+#define RDMA_D_WT_SA_L 0x18
+#define RDMA_D_DEST_CHAN(n) (0x20 + (n * 4))
+
+/**
+ * @brief The WIG base address register offset relative to RDMA base address.
+ *
+ */
+#define RDMA_D_WIG_BASE_ADDR0 0x30
+#define RDMA_D_WIG_BASE_ADDR1 0x34
+#define RDMA_D_WIG_BASE_ADDR2 0x38
+#define RDMA_D_WIG_BASE_ADDR3 0x3c
+#define RDMA_D_LOOP_NUM2_CH 0x40
+#define RDMA_D_LOOP_NUM1_CH 0x44
+#define RDMA_D_LOOP_NUM0_CH 0x48
+#define RDMA_D_OFFSET9_CH 0x50
+#define RDMA_D_OFFSET8_CH 0x54
+#define RDMA_D_OFFSET7_CH 0x58
+#define RDMA_D_OFFSET6_CH 0x5c
+#define RDMA_D_OFFSET5_CH 0x60
+#define RDMA_D_OFFSET4_CH 0x64
+#define RDMA_D_OFFSET3_CH 0x68
+#define RDMA_D_OFFSET2_CH 0x6c
+#define RDMA_D_OFFSET1_CH 0x70
+#define RDMA_D_OFFSET0_CH 0x74
+
+#define RDMA_S_RST 0x0
+#define RDMA_S_POINTER_FLAG 0x4
+#define RDMA_S_PP_STAUTS 0x8
+#define RDMA_S_INTS_ENABLE 0xC
+
+#define RDMA_WRAPPER_D_OP_EN_TRIG 0x0
+#define RDMA_WRAPPER_D_OP_STATUS 0x4
+
+#define RDMA_WRAPPER_S_RST 0x0
+#define RDMA_WRAPPER_S_POINTER_FLAG 0x4
+#define RDMA_WRAPPER_S_PP_STATUS 0x8
+#define RDMA_WRAPPER_S_PING_INT_TASK 0x10
+#define RDMA_WRAPPER_S_PONG_INT_TASK 0x14
+
+/**
+ * @brief E31 GPR reset register.
+ *
+ */
+#define NPU_E31_GPR_REST 0x0
+
+/**
+ * @brief E31 debug reset register.
+ *
+ */
+#define NPU_E31_DEBUG_REST 0x4
+
+/**
+ * @brief E31 bus reset register.
+ *
+ */
+#define NPU_E31_BUS_REST 0x8
+
+/**
+ * @brief E31 core reset register.
+ *
+ */
+#define NPU_E31_CORE_REST 0xC
+
+/**
+ * @brief E31 core clock gate register.
+ *
+ */
+#define NPU_E31_CORE_CLOCK_GATE 0x10
+
+/**
+ * @brief E31 clock gate register.
+ *
+ */
+#define NPU_E31_CLOCK_GATE 0x14
+
+/**
+ * @brief The start address of node specific registers.
+ *
+ */
+#define NODE_CTRL_OFFSET 0x18
+
+/**
+ * @brief The stride between the beginning of one node control and its neighbor's.
+ *
+ */
+#define NODE_CTRL_STRIDE 0x18
+
+/**
+ * @brief This is the JTAG register.
+ * Bit[3:0] jtag version.
+ * Bit[19:4] part number.
+ * Bit[30:20]mfr id.
+ *
+ */
+#define JTAG_ID_CODE_OFFSET(node) (0x18 + (node)*NODE_CTRL_STRIDE)
+
+/**
+ * @brief This is the reset vector.
+ *
+ */
+#define RESET_VECTOR_OFFSET(node) (0x1C + (node)*NODE_CTRL_STRIDE)
+
+/**
+ * @brief This is a bitmap. Write to this register will set the corresponding bits in the interrupt status register if
+ * the written value in these bits are 1. Otherwise the bits remain unchanged.
+ *
+ */
+#define INT_SET_BITS(node) (0x20 + (node)*NODE_CTRL_STRIDE)
+
+/**
+ * @brief This is a bitmap. Write to this register will clear the corresponding bits in the interrupt status register if
+ * the written value in these bits are 1. Otherwise the bits remain unchanged.
+ *
+ */
+#define INT_CLR_BITS(node) (0x24 + (node)*NODE_CTRL_STRIDE)
+
+/**
+ * @brief This is a interrupt status register. If the value is non-zero, it will trigger an interrupt to the specific
+ * node. This register is read-only.
+ *
+ */
+#define INT_STATUS(node) (0x28 + (node)*NODE_CTRL_STRIDE)
+
+/**
+ * @brief CPU status register.
+ * Bit0: wfi status.
+ * Bit1: halt status.
+ * Bit2: debug status.
+ * Bit3: cease status.
+ *
+ */
+#define CPU_STATUS(node) (0x2C + (node)*NODE_CTRL_STRIDE)
+
+/**
+ * @brief The following definitions are E31 IRQ numbers.
+ *
+ */
+#define IRQ_E31_INTER_CORE_COMM 0
+
+/**
+ * @brief The register of scie hardware pattern.
+ *
+ */
+#define SCIE_CMD_DEC_MODE 0x10C
+
+#endif
\ No newline at end of file
diff --git a/drivers/soc/eswin/ai_driver/include/dla_interface.h b/drivers/soc/eswin/ai_driver/include/dla_interface.h
new file mode 100644
index 000000000000..82ed5865926d
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/include/dla_interface.h
@@ -0,0 +1,865 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+#ifndef _DLA_INTERFACE_H_
+#define _DLA_INTERFACE_H_
+
+#include "hetero_env.h"
+
+#if defined(__KERNEL__)
+#include <nvdla_interface.h>
+#else
+#include <stdint.h>
+#endif
+#include "es_nn_common.h"
+/*
+ * alignment
+ */
+#define ALIGNMENT (64)
+
+/**
+ * @ingroup Processors
+ * @name Maximum number of processors
+ * @{
+ */
+#define HW_OP_NUM 0x20
+/** @} */
+
+/**
+ * @ingroup Processors
+ * @name NPU Processors
+ * Processor modules in NPU engine. Each processor has it's
+ * own operation a.k.a. HW layer. Network is formed using
+ * graph of these operations
+ * @{
+ */
+
+#define DLA_OP_EDMA 0
+#define DLA_OP_CONV 1
+#define DLA_OP_SDP 2
+#define DLA_OP_PDP 3
+#define DLA_OP_RUBIK 4
+#define DLA_KMD_OP_DSP_0 5
+#define DLA_KMD_OP_DSP_1 6
+#define DLA_KMD_OP_DSP_2 7
+#define DLA_KMD_OP_DSP_3 8
+#define DLA_OP_EVENT_SINK 9
+#define DLA_OP_EVENT_SOURCE 0xa
+#define DLA_OP_DSP_0 0xb
+#define DLA_OP_DSP_1 0xc
+#define DLA_OP_DSP_2 0xd
+#define DLA_OP_DSP_3 0xe
+#define DLA_OP_HAE 0xf
+#define DLA_OP_GPU 0x10
+#define DLA_OP_SWITCH 0x11
+#define DLA_OP_MERGE 0x12
+
+/**
+ * @name Memory types
+ * @brief DLA engnine can read/write to/from 3 memory types
+ * @{
+ */
+#define DLA_MEM_MC 0 /* External DRAM */
+#define DLA_MEM_CV 1 /* CV-SRAM */
+#define DLA_MEM_HW 2 /* DLA sub-module */
+/** @} */
+
+/**
+ * @ingroup Events
+ * @name Operation events
+ * @brief Different events triggered by an operations
+ * @{
+ */
+#define DLA_EVENT_OP_COMPLETED 1
+#define DLA_EVENT_OP_PROGRAMMED 2
+#define DLA_EVENT_OP_ENABLED 3
+#define DLA_EVENT_CDMA_WT_DONE 4
+#define DLA_EVENT_CDMA_DT_DONE 5
+/** @} */
+
+/**
+ * @ingroup Processors
+ * @name Precision types
+ * @brief Precision formats supported by DLA engine
+ * @{
+ */
+#define PRECISION_INT8 0
+#define PRECISION_INT16 1
+#define PRECISION_FP16 2
+#define PRECISION_FP32 3
+/** @} */
+
+/**
+ * @ingroup Processors
+ * @name Bpe precision types
+ * @brief bytes per element, used by rubik
+ * @{
+ */
+#define BPE_PRECISION_INT8 1
+#define BPE_PRECISION_INT16 2
+#define BPE_PRECISION_FP16 2
+/** @} */
+
+/**
+ * @ingroup Processors
+ * @name Data formats
+ * @brief Data formats supported by DLA engine
+ * @{
+ */
+#define FORMAT_T_R8 0
+#define FORMAT_T_R10 1
+#define FORMAT_T_R12 2
+#define FORMAT_T_R16 3
+#define FORMAT_T_R16_I 4
+#define FORMAT_T_R16_F 5
+#define FORMAT_T_A16B16G16R16 6
+#define FORMAT_T_X16B16G16R16 7
+#define FORMAT_T_A16B16G16R16_F 8
+#define FORMAT_T_A16Y16U16V16 9
+#define FORMAT_T_V16U16Y16A16 10
+#define FORMAT_T_A16Y16U16V16_F 11
+#define FORMAT_T_A8B8G8R8 12
+#define FORMAT_T_A8R8G8B8 13
+#define FORMAT_T_B8G8R8A8 14
+#define FORMAT_T_R8G8B8A8 15
+#define FORMAT_T_X8B8G8R8 16
+#define FORMAT_T_X8R8G8B8 17
+#define FORMAT_T_B8G8R8X8 18
+#define FORMAT_T_R8G8B8X8 19
+#define FORMAT_T_A2B10G10R10 20
+#define FORMAT_T_A2R10G10B10 21
+#define FORMAT_T_B10G10R10A2 22
+#define FORMAT_T_R10G10B10A2 23
+#define FORMAT_T_A2Y10U10V10 24
+#define FORMAT_T_V10U10Y10A2 25
+#define FORMAT_T_A8Y8U8V8 26
+#define FORMAT_T_V8U8Y8A8 27
+#define FORMAT_T_Y8___U8V8_N444 28
+#define FORMAT_T_Y8___V8U8_N444 29
+#define FORMAT_T_Y10___U10V10_N444 30
+#define FORMAT_T_Y10___V10U10_N444 31
+#define FORMAT_T_Y12___U12V12_N444 32
+#define FORMAT_T_Y12___V12U12_N444 33
+#define FORMAT_T_Y16___U16V16_N444 34
+#define FORMAT_T_Y16___V16U16_N444 35
+#define FORMAT_FEATURE 36
+/** @} */
+
+/*
+ * version field
+ */
+#define NPU_INTERFACE_MAJOR_VERSION 0x00
+#define NPU_INTERFACE_MINOR_VERSION 0x00
+#define NPU_INTERFACE_SUBMINOR_VERSION 0x03
+
+struct npu_version {
+    uint8_t major_version;
+    uint8_t minor_version;
+    uint8_t subminor_version;
+    uint8_t reserved;
+} __attribute__((packed, aligned(ALIGNMENT)));
+
+/**
+ * Network descriptor
+ *
+ * Contains all information to execute a network
+ *
+ * @op_head: Index of first operation of each type in operations list
+ * @num_rois: Number of ROIs
+ * @num_operations: Number of operations in one list
+ * @num_luts: Number of LUTs
+ */
+struct dla_network_desc {
+    struct npu_version version;
+    uint32_t reserved;
+    int16_t operation_desc_index;
+    int16_t surface_desc_index;
+
+    int16_t dependency_graph_index;
+    int16_t lut_data_index;
+    int16_t op_config_index;
+
+    uint16_t num_operations;
+    uint16_t num_event_ops;
+
+    uint16_t num_luts;
+    uint16_t num_addresses;
+    uint16_t reserved0;
+} __attribute__((packed, aligned(ALIGNMENT)));
+
+struct dla_data_cube {
+    uint16_t type;   /* dla_mem_type */
+    int16_t address; /* offset to the actual IOVA in task.address_list */
+
+    uint32_t offset; /* offset within address */
+    uint32_t size;
+
+    /* cube dimensions */
+    uint16_t batch;
+    uint16_t width;
+    uint16_t height;
+
+    uint16_t channel;
+    uint16_t reserved0;
+
+    /* stride information */
+    uint32_t line_stride;
+    uint32_t surf_stride;
+
+    /* For Rubik only */
+    uint32_t plane_stride;
+} __attribute__((packed, aligned(ALIGNMENT)));
+
+struct dla_consumer {
+    int16_t index;
+    uint8_t event;
+    uint8_t res;
+} __attribute__((packed, aligned(ALIGNMENT)));
+
+struct dla_common_op_desc {
+    int16_t index; /* set by ucode */
+    int8_t roi_index;
+    uint8_t op_type;
+
+    uint8_t dependency_count;
+    uint8_t reserved0[3]; /* esim_tool uses reserved0[2] to save offset of op_index */
+
+    struct dla_consumer consumers[HW_OP_NUM];
+    struct dla_consumer fused_parent;
+} __attribute__((packed, aligned(ALIGNMENT)));
+
+struct dla_event_op_desc {
+    int16_t index;         // a unique event op index in loadable
+    int8_t submodel_type;  // 0-umd; 1-kmd
+} __attribute__((packed, aligned(ALIGNMENT)));
+
+#define EVENT_OP_TENSOR_NUM 8
+struct event_surface_desc {
+    struct dla_data_cube data[EVENT_OP_TENSOR_NUM];
+} __attribute__((packed, aligned(ALIGNMENT)));
+
+struct dla_cvt_param {
+    int16_t scale;
+    uint8_t truncate;
+    uint8_t enable;
+
+    int32_t offset;
+} __attribute__((packed, aligned(ALIGNMENT)));
+
+struct npu_edma_surface_desc {
+    struct dla_data_cube src_data;
+    struct dla_data_cube dst_data;
+} __attribute__((packed, aligned(ALIGNMENT)));
+
+struct npu_edma_op_desc {
+    uint32_t input_c0_bytes;
+    uint32_t src_num_line;
+    uint32_t src_stride_line_bytes;
+    uint32_t src_num_surface;
+    uint32_t src_stride_surface_bytes;
+    uint32_t src_num_cube;
+    uint32_t src_stride_cube_bytes;
+    uint32_t src_num_colony;
+
+    uint32_t output_c0_bytes;
+    uint32_t dst_num_line;
+    uint32_t dst_stride_line_bytes;
+    uint32_t dst_num_surface;
+    uint32_t dst_stride_surface_bytes;
+    uint32_t dst_num_cube;
+    uint32_t dst_stride_cube_bytes;
+    uint32_t dst_num_colony;
+} __attribute__((packed, aligned(ALIGNMENT)));
+
+/*
+ * Post DRP op description
+ *
+ * ref: https://ekm.eswincomputing.com/preview.html?fileid=1170951
+ *
+ */
+struct post_drp_op_desc {
+    // control info
+    uint32_t op_en_trig;
+
+    // 0 - idle; 1 - running
+    uint32_t op_en_status;
+
+    // represent the write out data stride for SRAM level ofmap
+    /*
+     * SRAM level ofmap的 G 方向的步进值，若数据类型为int8，则 g_stride_sram = N*E*M*F
+     * 否则  g_stride_sram = 2*N*E*M*F， 用于DRP写数据到LSRAM的地址计算
+     */
+    uint32_t g_stride_lsram;
+
+    /*
+     * SRAM level ofmap的 N 方向的步进值，若数据类型为int8，则 n_stride_sram = E*M*F
+     * 否则  n_stride_sram = 2*E*M*F， 用于DRP写数据到LSRAM的地址计算
+     */
+    uint32_t n_stride_lsram;
+
+    /*
+     * SRAM level ofmap的 H 方向的步进值，若数据类型为int8，则 h_stride = F*C0*C''*C'''
+     * 否则  h_stride = 2*F*C0*C''*C'''， 用于DRP写数据到LSRAM的地址计算
+     */
+    uint32_t h_stride;
+
+    /*
+     * SRAM level ofmap的 C' 方向的步进值，若数据类型为int8，则 c_stride = E*F*C0*C''*C'''
+     * 否则  c_stride = 2*E*F*C0*C''*C'''， 用于DRP写数据到LSRAM的地址计算
+     */
+    uint32_t c_stride;
+
+    /*
+     * 用于 C 方向在 W 方向扩展的地址计算， 若数据类型为int8，则 w_ext_stride = C''*C0
+     * 否则 h_ext_stride = 2*C''*C0
+     */
+    uint32_t w_stride;
+
+    /* represent the whole layer parameter */
+    uint32_t n;  /* N in one glb, N_glb = N0*N1*N2 */
+    uint32_t e;  /* E in one glb, E_glb = 4*E2*E3 or E1_last_cnt */
+    uint32_t m;  /* M and G in one glb, MG_glb = M0*M1*M2*G0*G1*G2 */
+    uint32_t f;  /* the whole layer F */
+    uint32_t c0; /* the next layer input c0 */
+
+    // DRP 输出 reshape 数据存放的基地址高32bit
+    uint32_t base_addr_ofmap_h;
+    // DRP 输出 reshape 数据存放的基地址低32bit
+    uint32_t base_addr_ofmap_l;
+
+    // 0 - int8; 1 - int16/fp16
+    uint32_t type_16;
+
+    // 1 : int8 -> int16; otherwise, 0
+    uint32_t surface_double;
+
+    // For PDP, PDP的split num相同;
+    // For SDP, split_num = F3, F is the ofm's W
+    uint32_t split_num;
+    uint16_t f_lst; /* F 切分的最后一个分段宽度 */
+    uint16_t f_mid; /* F 切分的中间分段宽度 */
+    uint16_t f_fst; /* F 切分的第一个分段宽度 */
+    uint16_t Reserved;
+
+    uint16_t e4_all; /* original E */
+    uint16_t m3_all; /* m3_all = g_glb* original_M, g_glb = G1*G2   */
+    uint16_t n3_all; /* original N */
+    uint16_t g3_all; /* g3_all = original_G * original_M  */
+} __attribute__((packed, aligned(ALIGNMENT)));
+
+/**
+ * @ingroup Convolution
+ * @name Convolution mode
+ * @brief Convolution modes support by DLA
+ * @{
+ */
+#define CONV_MODE_DIRECT 0
+#define CONV_MODE_WINOGRAD 1
+/** @} */
+
+/**
+ * @ingroup SDP
+ * @name Activation functions
+ * @brief Activation functions supported in SDP
+ * @{
+ */
+#define ACTIVATION_NONE 0
+#define ACTIVATION_RELU 1
+#define ACTIVATION_LUT 2
+#define ACTIVATION_PRELU 3
+/** @} */
+
+/**
+ * @ingroup LUT
+ * @name LUT size
+ * @brief LUT sizes for linear and exponentila LUT
+ * @{
+ */
+#define LUT_LINEAR_EXP_TABLE_ENTRY_LOG2 6
+#define LUT_LINEAR_ONLY_TABLE_ENTRY_LOG2 8
+/** @} */
+
+/**
+ * @ingroup LUT
+ * @name LUT types
+ * @brief DLA supports two types of LUT, linear and exonential
+ * @{
+ */
+#define LUT_LINEAR_EXP_TABLE 0
+#define LUT_LINEAR_ONLY_TABLE 1
+/** @} */
+
+/**
+ * @ingroup LUT
+ * @name LUT methods
+ * @brief DLA supports two types of LUT, linear and exonential
+ * @{
+ */
+#define LUT_METHOD_EXPONENTIAL 0
+#define LUT_METHOD_LINEAR 1
+/** @} */
+
+/**
+ * @ingroup LUT
+ * @name LUT
+ * @brief DLA supports two types of LUT, linear and exonential
+ * @{
+ */
+#define LUT_PRI_LINEAR_EXP 0
+#define LUT_PRI_LINEAR_ONLY 1
+/** @} */
+
+union dla_lut_offset {
+    /**
+     * Number should be subtracted on log domain before look up
+     * exponential table it has the same definition as hardware
+     * thus input scaling should also take into account when
+     * set this field.
+     */
+    int8_t exp_offset;
+    /**
+     * Number of bits should be right shift before looking
+     * up linear table
+     */
+    int8_t frac_bits;
+    uint16_t reserved0;
+} __attribute__((packed, aligned(ALIGNMENT)));
+
+/**
+ * This struct is used to represent floating point values by INT
+ * suppose we have a float point number fp_x, it will be represented
+ * as:
+ *
+ * fp_x = scale_int_x>>(shifter_x)
+ *
+ * This is very useful for INT pipeline;
+ */
+struct dla_float_data {
+    int16_t scale;
+    int8_t shifter;
+    uint8_t reserved0;
+} __attribute__((packed, aligned(ALIGNMENT)));
+
+/**
+ * For INT pipeline, we use the struct above to represent a floating number;
+ * For FP16 pipeline, we should store the FP16 encoded value into a uint16_t
+ * container
+ */
+union dla_slope {
+    struct dla_float_data data_i;
+
+    uint16_t data_f;
+} __attribute__((packed, aligned(ALIGNMENT)));
+
+struct dla_sdp_surface_desc {
+    /* Data cube */
+    /* source input cube, available when SDP working on offline mode */
+    struct dla_data_cube src_data;
+
+    /* X1 input cube */
+    struct dla_data_cube x1_data;
+
+    /* X2 input cube */
+    struct dla_data_cube x2_data;
+
+    /* Y input cube */
+    struct dla_data_cube y_data;
+
+    /* Output cube */
+    struct dla_data_cube dst_data;
+} __attribute__((packed, aligned(ALIGNMENT)));
+
+#define SDP_OP_NONE 0
+#define SDP_OP_MUL 1
+#define SDP_OP_ADD 2
+#define SDP_OP_BOTH 3
+
+#define SDP_ALU_OP_MAX 0
+#define SDP_ALU_OP_MIN 1
+#define SDP_ALU_OP_SUM 2
+#define SDP_ALU_OP_EQL 3
+
+#define SDP_OP_PER_LAYER 0
+#define SDP_OP_PER_KERNEL 1
+#define SDP_OP_PER_POINT 2
+
+struct dla_sdp_cvt {
+    struct dla_cvt_param alu_cvt;
+    struct dla_cvt_param mul_cvt;
+} __attribute__((packed, aligned(ALIGNMENT)));
+
+struct dla_sdp_op {
+    uint8_t enable;
+    uint8_t alu_type; /* dla_sdp_alu_op_type */
+    uint8_t type;     /* dla_sdp_op_type */
+    uint8_t mode;     /* dla_sdp_op_mode */
+
+    uint8_t act;          /* dla_act_type */
+    uint8_t shift_value;  // left shift
+    uint8_t truncate;
+    uint8_t precision;  // 0 1 2 3
+
+    int32_t alu_operand;
+    int32_t mul_operand;
+
+    struct dla_sdp_cvt cvt;
+} __attribute__((packed, aligned(ALIGNMENT)));
+
+struct dla_sdp_op_desc {
+    /* Precision parameters */
+    /* dla_precision */
+    uint8_t src_precision;
+    uint8_t dst_precision;
+    int16_t lut_index;
+
+    struct dla_cvt_param out_cvt;
+
+    /* Performance parameters */
+    /* dla_conv_mode */
+    uint8_t conv_mode;
+    uint8_t batch_num;
+    uint16_t reserved0;
+
+    uint32_t batch_stride;  // will be used when batch_num > 1
+
+    /* Algorithm parameters */
+    struct dla_sdp_op x1_op;
+    struct dla_sdp_op x2_op;
+    struct dla_sdp_op y_op;
+
+    struct post_drp_op_desc post_drp_op;
+} __attribute__((packed, aligned(ALIGNMENT)));
+
+#define POOL_MODE_AVG 0
+#define POOL_MODE_MAX 1
+#define POOL_MODE_MIN 2
+
+#define POOL_SIZE_1 0
+#define POOL_SIZE_2 1
+#define POOL_SIZE_3 2
+#define POOL_SIZE_4 3
+#define POOL_SIZE_5 4
+#define POOL_SIZE_6 5
+#define POOL_SIZE_7 6
+#define POOL_SIZE_8 7
+
+#define PDP_PAD_VAL_NUM 7
+
+struct dla_pdp_surface_desc {
+    /* Data cube */
+    struct dla_data_cube src_data;
+
+    struct dla_data_cube dst_data;
+} __attribute__((packed, aligned(ALIGNMENT)));
+
+struct dla_pdp_op_desc {
+    /* Performance parameters */
+    uint16_t partial_in_width_first;
+    uint16_t partial_in_width_mid;
+
+    uint16_t partial_in_width_last;
+    uint16_t partial_width_first;
+
+    uint16_t partial_width_mid;
+    uint16_t partial_width_last;
+
+    uint8_t split_num;
+
+    /* Algorithm parameters */
+    uint8_t pool_mode;   /* dla_pool_mode */
+    uint8_t pool_width;  /* dla_pool_width */
+    uint8_t pool_height; /* dla_pool_height */
+
+    uint8_t stride_x;
+    uint8_t stride_y;
+
+    /* The left/right padding size, pad_right might be less than pad_left */
+    uint8_t pad_left;
+    uint8_t pad_right;
+
+    /* The top/bottom padding size */
+    uint8_t pad_top;
+    uint8_t pad_bottom;
+
+    /* Precision parameters */
+    uint8_t precision; /* dla_precision */
+    uint8_t reserved0;
+    /**
+     * if input has non-zero "offset", this value should be set
+     * There'll be 7 different paddding values, the relationship between
+     * those versions are:
+     * padding_value[0] = -offset*scaling;
+     * padding_value[1] = 2*padding_value[0]
+     * padding_value[2] = 3*padding_value[0]
+     * ...
+     * The purpose is to avoid ucode implement FP16 multiplier(for FP16 mode)
+     */
+    int32_t padding_value[PDP_PAD_VAL_NUM];
+
+    struct post_drp_op_desc post_drp_op;
+} __attribute__((packed, aligned(ALIGNMENT)));
+
+struct dla_rubik_surface_desc {
+    /* Data cube */
+    struct dla_data_cube src_data;
+
+    struct dla_data_cube dst_data;
+} __attribute__((packed, aligned(ALIGNMENT)));
+
+/* rubik mode */
+#define RUBIK_MODE_CONTRACT 0
+#define RUBIK_MODE_SPLIT 1
+#define RUBIK_MODE_MERGE 2
+
+struct dla_rubik_op_desc {
+    /* Precision parameters */
+    uint8_t mode;
+    uint8_t precision;
+    uint8_t stride_x;
+    uint8_t stride_y;
+} __attribute__((packed, aligned(ALIGNMENT)));
+
+#define KERNEL_NAME_MAXLEN 128
+#define KERNEL_LIB_NAME_MAXLEN 128
+#define BUFFER_CNT_MAXSIZE 32
+
+struct dsp_op_desc {
+    /* *
+     * Total byte size of this data structure.
+     * */
+    uint32_t total_size;
+    /* *
+     * The authoritative name of the operator.
+     * */
+    char operator_name[KERNEL_NAME_MAXLEN];
+    /* *
+     * Specify total number of parameter buffers.
+     * */
+    uint32_t buffer_cnt_cfg;
+    /* *
+     * Specify total number of input buffers.
+     * */
+    uint32_t buffer_cnt_input;
+    /* *
+     * Specify total number of output buffers.
+     * */
+    uint32_t buffer_cnt_output;
+    /* *
+     * Specify the byte size of each buffer. This is an array describing the
+     * size of each buffer including parameter, input and output buffers. They
+     * are sequentially placed in this array.
+     * */
+    uint32_t buffer_size[BUFFER_CNT_MAXSIZE];
+    /* *
+     * This is a variable length field which holds parameter information. All
+     * parameter buffers are sequentially laid out in this field.
+     * */
+    // char param_data[0];
+
+    uint32_t dsp_core_id;
+    uint32_t mem_id;
+    uint32_t offset;
+} __attribute__((packed, aligned(ALIGNMENT)));
+
+#define DSP_KERNEL_MAX_INOUT_TENSOR_NUM 8
+struct dsp_surface_desc {
+    struct dla_data_cube src_data[DSP_KERNEL_MAX_INOUT_TENSOR_NUM];
+    struct dla_data_cube dst_data[DSP_KERNEL_MAX_INOUT_TENSOR_NUM];
+} __attribute__((packed, aligned(ALIGNMENT)));
+
+struct hae_op_desc {
+    /* Source color format*/
+    ES_COLOR_CODE_E srcFormat;
+
+    /* Interpolation method to be used for resizing */
+    ES_INTER_FLAG_E inter;
+
+    /* Dest Data precision types */
+    ES_DATA_PRECISION_E dstDataType;
+
+    /* Normalization mode (e.g., Z-Score or Min-Max scaling) */
+    ES_NORM_MODE_E mode;
+
+    /* Normalization factors for each channel (r, g, b, x/alpha). Can represent 1/(max-min) or 1/std */
+    ES_FLOAT normFactor[4];
+
+    /* Bias values for each channel (r, g, b, x/alpha) for normalization. Can represent min or mean */
+    ES_FLOAT bias[4];
+
+    /* Scaling factor applied post-normalization(for quant) */
+    ES_FLOAT scale;
+
+    /* Bitwise flag set by the SET_OP_FLAG macro. Each bit represents an operation's enabled status. */
+    ES_S32 flag;
+} __attribute__((packed, aligned(ALIGNMENT)));
+
+struct hae_surface_desc {
+    struct dla_data_cube src_data;
+    struct dla_data_cube dst_data;
+} __attribute__((packed, aligned(ALIGNMENT)));
+
+struct gpu_op_desc {
+} __attribute__((packed, aligned(ALIGNMENT)));
+struct gpu_surface_desc {
+} __attribute__((packed, aligned(ALIGNMENT)));
+
+struct cpu_op_desc {
+} __attribute__((packed, aligned(ALIGNMENT)));
+struct cpu_surface_desc {
+} __attribute__((packed, aligned(ALIGNMENT)));
+
+typedef struct LayerInfo {
+    int g;
+    int n;
+    int h;
+    int w;
+    int c;
+    int m;
+    int r;
+    int s;
+    int e;
+    int f;
+    int stride_h;
+    int stride_w;
+    int pad_up;
+    int pad_down;
+    int pad_left;
+    int pad_right;
+} LayerInfo;
+
+typedef struct MappingInfo_t {
+    int G4, N4, M4, E5;
+    int F3, G3, N3, M3, E4, C3;
+    int N2, C2, E3, R3, M2;
+    int G1, N1, M1, E2, R2, C1, E1, R1;
+    int E0, N0, F0, S, C0, M0;
+} MappingInfo;
+
+#define NOC_MAX_LEVEL_SIZE 6
+#define GLB_MAX_LEVEL_SIZE 5
+#define SRAM_MAX_LEVEL_SIZE 6
+
+#define DYN_LOOPS_MAX_ROWS 24
+#define MAC_COL 8
+#define MAC_ROW 10
+#define MAX_MAPPING 80
+
+typedef struct coordinate_t {
+    uint8_t x;
+    uint8_t y;
+    uint8_t broader;  // 1 is broader
+} coordinate_t;
+
+typedef struct broader_mapping {
+    coordinate_t listener[MAX_MAPPING];
+    coordinate_t broader[MAX_MAPPING];
+    uint8_t used_count;
+} broader_mapping_t;
+
+typedef enum noc_order_dim_t {
+    NOC_DIM_E = 0,  // E2
+    NOC_DIM_M,      // M1
+    NOC_DIM_N,      // N1
+    NOC_DIM_G,      // G1
+    NOC_DIM_C,      // C1
+    NOC_DIM_R,      // R2
+} noc_order_dim_t;
+
+typedef uint16_t half_fp16;
+
+// forward declare npu_conv_op_desc
+struct npu_conv_op_desc;
+
+#define NUMBER_OF_E21 2
+#define PEC_ROW 10
+#define PEC_COL 8
+#define N_LEVEL_LOOPS 12
+#define MAX_MAPPINGS 12
+#define MAX_TENSORS 4
+#define MAX_DATA_TRANS 10
+
+struct conv_mapping_info {
+    uint32_t F3, G3, N3, M3, E4, C3;
+    uint32_t G2, N2, C2, E3, R3, M2;
+    uint32_t E1, R1, CV;
+    uint32_t E0, F0, S, GMF, CMF, MMF;
+    uint32_t GF, MF, CF;
+
+    uint32_t G1_X, N1_X, M1_X, E2_X;
+    uint32_t G1_Y, N1_Y, M1_Y, E2_Y, R2, C1;
+} __attribute__((packed, aligned(ALIGNMENT)));
+
+struct soft_conv_info {
+    struct conv_mapping_info mapping_info;
+    uint32_t first_level;
+    uint32_t g, n, c, ofm_c0;
+    uint32_t psum_trunc;
+    uint8_t strides[2];
+    uint8_t padding[4];
+    uint8_t csc_format;
+    uint8_t reserved;
+    uint32_t ifmap_offset;
+    uint32_t ifmap_cube_stride;
+    uint32_t ifmap_surface_stride;
+    uint32_t real_h;
+    uint32_t real_w;
+} __attribute__((packed, aligned(ALIGNMENT)));
+
+#define CONV_CONFIG_MAX_SIZE (1536)
+struct npu_conv_op_desc {
+    char conv_config_data[CONV_CONFIG_MAX_SIZE];
+    struct dla_cvt_param in_cvt;  /* input converter parameters */
+    struct dla_cvt_param out_cvt; /* output converter parameters, support truncate only */
+    struct soft_conv_info soft_conv_config;
+    uint8_t src_precision;
+    uint8_t dst_precision;
+} __attribute__((packed, aligned(ALIGNMENT)));
+// #endif
+
+struct npu_conv_surface_desc {
+    /* Data cube */
+    struct dla_data_cube weight_data;
+    struct dla_data_cube wmb_data;
+    struct dla_data_cube wgs_data;
+    struct dla_data_cube src_data;
+    struct dla_data_cube dst_data;
+    /*
+     * u_addr = input_data.source_addr + offset_u
+     * this field should be set when YUV is not interleave format
+     * */
+    int64_t offset_u;
+
+    /* line stride for 2nd plane, must be 32bytes aligned */
+    uint32_t in_line_uv_stride;
+} __attribute__((packed, aligned(ALIGNMENT)));
+union dla_operation_container {
+    struct npu_edma_op_desc edma_op;
+    struct npu_conv_op_desc npu_conv_op;  //! add for npu conv desc
+    struct dla_sdp_op_desc sdp_op;
+    struct dla_pdp_op_desc pdp_op;
+    struct dsp_op_desc dsp_op;
+    struct dla_rubik_op_desc rubik_op;
+    struct dla_event_op_desc event_op;
+    struct hae_op_desc hae_op;
+    struct gpu_op_desc gpu_op;
+    struct cpu_op_desc cpu_op;
+};
+
+union dla_surface_container {
+    struct npu_edma_surface_desc edma_surface;
+    struct npu_conv_surface_desc conv_surface;
+    struct dla_sdp_surface_desc sdp_surface;
+    struct dla_pdp_surface_desc pdp_surface;
+    struct dla_rubik_surface_desc rubik_surface;
+    struct dsp_surface_desc dsp_surface;
+
+    struct event_surface_desc event_surface;
+    struct hae_surface_desc hae_surface;
+    struct gpu_surface_desc gpu_surface;
+    struct cpu_surface_desc cpu_surface;
+};
+
+#endif
diff --git a/drivers/soc/eswin/ai_driver/include/edma_regs.h b/drivers/soc/eswin/ai_driver/include/edma_regs.h
new file mode 100644
index 000000000000..507fb815e8ad
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/include/edma_regs.h
@@ -0,0 +1,68 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#ifndef __EDMA_REGS_H__
+#define __EDMA_REGS_H__
+
+#if !defined(__KERNEL__)
+#define EDMA_DESP_SIZE 0x18
+#define EDMA_S_BASE_ADDR 0x110000
+#define SRC_DESP_BASE 0x100
+#define DST_DESP_BASE 0x300
+#define EDMA_DESP_STRIDE 0x20
+#define REG_SRC_DESP_MAIN_BASE (EDMA_S_BASE_ADDR + SRC_DESP_BASE)
+#define REG_DST_DESP_MAIN_BASE (EDMA_S_BASE_ADDR + DST_DESP_BASE)
+typedef enum {
+    // EDMA REG
+    EDMA_REG_SOFT_RST = 0x0,
+    EDMA_REG_GENERAL_PARAMETER = 0x4,
+    EDMA_REG_STATUS = 0x8,
+    EDMA_REG_SW_TRIG = 0xc,
+    EDMA_REG_INT_EN = 0x10,
+    EDMA_REG_INT_MASK = 0x14,
+    EDMA_REG_INT_STATUS = 0x18,
+    EDMA_REG_PREFETCH_ADDR_LOW = 0x1c,
+    EDMA_REG_PREFETCH_ADDR_HIGH = 0x20,
+    EDMA_REG_PREFETCH_PARAMETER = 0x24,
+    EDMA_REG_ERR_ADDR_HIGH = 0x28,
+    EDMA_REG_ERR_ADDR_LOW = 0x2c,
+    EDMA_REG_AUX_PREFETCH_ADDR_LOW = 0x30,
+    EDMA_REG_AUX_PREFETCH_ADDR_HIGH = 0x34,
+    EDMA_REG_AUX_PREFETCH_PARAMETER = 0x38,
+    EDMA_REG_AUX_SW_TRIG = 0x3c,
+    EDMA_REG_COLONY_NUM = 0x40,
+    EDMA_REG_SRC_COLONY_STRIDE = 0x44,
+    EDMA_REG_DST_COLONY_STRIDE = 0x48,
+    EDMA_REG_AUX_COLONY_NUM = 0x50,
+    EDMA_REG_AUX_SRC_COLONY_STRIDE = 0x54,
+    EDMA_REG_AUX_DST_COLONY_STRIDE = 0x58,
+    EDMA_REG_REFRESH_TIMES = 0x60,
+    EDMA_REG_AUX_REFRESH_TIMES = 0x64,
+} EDMA_REG;
+#endif
+
+/*reg index*/
+enum {
+    EDMA_COLONY_NUM,
+    EDMA_SRC_COLONY_STRIDE,
+    EDMA_DST_COLONY_STRIDE,
+    EDMA_REFRESH_TIMES,
+    EDMA_RAM_SRC_BASE_0,
+    EDMA_RAM_SRC_BASE_1,
+    EDMA_RAM_SRC_BASE_2,
+    EDMA_RAM_SRC_BASE_3,
+    EDMA_RAM_SRC_BASE_4,
+    EDMA_RAM_SRC_BASE_5,
+    EDMA_RAM_DST_BASE_0,
+    EDMA_RAM_DST_BASE_1,
+    EDMA_RAM_DST_BASE_2,
+    EDMA_RAM_DST_BASE_3,
+    EDMA_RAM_DST_BASE_4,
+    EDMA_RAM_DST_BASE_5,
+    EDMA_REG_MAX,
+};
+#endif
diff --git a/drivers/soc/eswin/ai_driver/include/es_dsp_internal.h b/drivers/soc/eswin/ai_driver/include/es_dsp_internal.h
new file mode 100644
index 000000000000..ec2c202ed2d8
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/include/es_dsp_internal.h
@@ -0,0 +1,183 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#ifndef __ESWIN_DSP_INTERNAL_H__
+#define __ESWIN_DSP_INTERNAL_H__
+#include "es_type.h"
+#include "es_dsp_op_types.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif
+
+#ifdef __KERNEL__
+#include "eswin-khandle.h"
+#include <linux/dma-buf.h>
+struct dsp_file;
+
+struct dsp_dma_buf {
+    int fd;
+    u32 dma_addr;
+    struct dma_buf_attachment *attach;
+    struct dma_buf *dmabuf;
+    struct dsp_file *dsp_file;
+};
+
+struct dsp_dma_buf_ex {
+    struct khandle handle;
+    u32 count;
+    u32 offset;
+    struct dsp_dma_buf buf;
+};
+#endif
+
+typedef enum {
+    DSP_CMD_LEGACY,
+    DSP_CMD_FLAT1,
+    DSP_CMD_READY,
+    DSP_CMD_INVALID_ICACHE,
+} es_dsp_cmd;
+
+#if (defined(DSP_ENV_SIM) && DSP_ENV_SIM) || (defined(NPU_DEV_SIM) && NPU_DEV_SIM)
+#define KERNAL_NAME_MAXLEN 128
+struct operator_funcs {
+    /**
+     *  In simulation environment, DSP simulator accepts DSP operator name other
+     *  than the real DSP function pointers.
+     */
+    char op_name[KERNAL_NAME_MAXLEN];
+};
+#else
+struct operator_funcs {
+    ES_U32 dsp_prepare_fn;
+    ES_U32 dsp_eval_fn;
+};
+#endif
+
+typedef struct es_dsp_buffer_t {
+    ES_U32 addr;
+    ES_U32 size;
+} __attribute__((packed)) es_dsp_buffer;
+
+struct es_dsp_flat1_desc {
+    struct operator_funcs funcs;
+
+    /**
+     * Specifies total number of buffers attached to this descriptor. Note the
+     *  buffer space holds parameter buffers, input buffers and output buffers
+     *  in sequence.
+     */
+    ES_U32 num_buffer;
+    /**
+     * Specifies the offset of input (In number of elements) buffer to the start
+     * of buffer variable.
+     */
+    ES_U32 input_index;
+    /**
+     * Specifies the offset of output (In number of elements) buffer to the start
+     * of buffer variable.
+     */
+    ES_U32 output_index;
+    /**
+     * Specifies the actual buffer storage.
+     *
+     */
+    es_dsp_buffer buffers[0];
+} __attribute__((aligned(CACHE_LINE_SIZE)));
+
+typedef struct {
+    /**
+     * Accessing the IOVA corresponding to external storage
+     * space in DSP.
+     */
+    ES_U32 iova_ptr : 32;
+    /**
+     * Command for U84 to access DSP. The meanings of different values are as follows:
+     * 0: Legacy Mode, using XRP data structure.
+     * 1: Use FLAT1 data structure to pass operator execution commands.
+     * 2: Update the IOVA address of Scratch Pad.
+     */
+    ES_U32 command : 3;
+    /**
+     * 1: indicates that the FLAT1 data structure has been updated,
+     * and the DSP needs to synchronize the cache. 0 indicates
+     * that it is not necessary to synchronize the cache.
+     */
+    ES_U32 sync_cache : 1;
+    /**
+     * 0: means that prepare needs to be executed first and wait here;
+     * 1: means that eval is allowed to be executed. If prepare has not been
+     * executed at this point, both prepare and eval should be executed in sequence.
+     */
+    ES_U32 allow_eval : 1;
+    /**
+     * 0: means that the DSP driver is responsible for notifying the DSP
+     * when to perform the eval action;
+     * 1: means that the auxiliary CPU (E31) is responsible for notifying
+     * the DSP when to perform the eval action. The DSP needs to determine
+     * whether to interact with the DSP driver or the auxiliary CPU based on this flag
+     */
+    ES_U32 poll_mode : 1;
+    /**
+     * invalid icache size, unit is 4Byte, and max size is 128KB
+     */
+    ES_U32 size : 15;
+    /**
+     * reserved bit
+     */
+    ES_U32 reserved : 11;
+} es_dsp_h2d_msg;
+
+typedef struct {
+    /**
+     * DSP running result return value
+     */
+    ES_U32 return_value : 32;
+    /**
+     * DSP running result return status. The meanings of different values are:
+     * 0: Service completed normally 1: Service generated an exception,
+     * the specific reason can be seen in the return_value field
+     */
+    ES_U32 status : 15;
+    /**
+     * DSP core index
+     */
+    ES_U32 core_id : 4;
+    /**
+     * Reserved bits
+     */
+    ES_U32 reserved : 13;
+} es_dsp_d2h_msg;
+
+typedef struct {
+    /**
+     *  @brief Specifies the transaction layer protocol.
+     */
+    ES_U8 type;
+    /**
+     *  @brief Specifies the parameter passed to transaction layer handler.
+     */
+    ES_U8 param;
+    /**
+     *  @brief Specifies the long parameter passed to transaction layer handler.
+     */
+    ES_U16 lparam;
+    /**
+     * Reserved
+     */
+    ES_U32 reserved;
+} e31_msg_payload_t;
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif
+
+#endif
diff --git a/drivers/soc/eswin/ai_driver/include/es_dsp_op_types.h b/drivers/soc/eswin/ai_driver/include/es_dsp_op_types.h
new file mode 100644
index 000000000000..6e0ce6b31c63
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/include/es_dsp_op_types.h
@@ -0,0 +1,53 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#ifndef __ESWIN_DSP_OP_TYPES_H__
+#define __ESWIN_DSP_OP_TYPES_H__
+
+#include "es_type.h"
+
+#define CACHE_LINE_SIZE 64
+#define KERNEL_NAME_MAXLEN 128
+#define KERNEL_LIB_NAME_MAXLEN 128
+#define BUFFER_CNT_MAXSIZE 32
+
+// tensor shape info in dsp ping pong tiling
+typedef struct {
+    ES_U16 tileC;
+    ES_U16 tileH;
+    ES_U16 tileW;
+    ES_U32 offset;
+} ES_DSP_TILE_S;
+
+// padding information for tensor along h and w
+typedef struct {
+    ES_U8 top;
+    ES_U8 bottom;
+    ES_U8 left;
+    ES_U8 right;
+} ES_DSP_PAD_S;
+
+// tensor shape and padding info in dsp ping pong tiling
+typedef struct {
+    ES_DSP_PAD_S pad;
+    ES_DSP_TILE_S input;
+    ES_DSP_TILE_S output;
+} ES_DSP_TILE_INFO_S;
+
+#define OPERATOR_NAME_MAXLEN 128
+
+typedef struct DSP_OPERATOR_DESC_S {
+    ES_U32 totalSize;                           /* Total byte size of this data structure. */
+    ES_CHAR operatorName[OPERATOR_NAME_MAXLEN]; /* The authoritative name of the operator. */
+    ES_U32 bufferCntCfg;                        /* Specify total number of parameter buffers. */
+    ES_U32 bufferCntInput;                      /* Specify total number of input buffers. */
+    ES_U32 bufferCntOutput;                     /* Specify total number of output buffers. */
+    ES_U32 bufferSize[BUFFER_CNT_MAXSIZE];      /* Specify the byte size of each buffer. */
+    ES_CHAR paramData[0];                       /* All parameter buffers are sequentially laid out in this field. */
+} ES_DSP_OPERATOR_DESC_S;
+
+#endif  // __ESWIN_DSP_OP_TYPES_H__
diff --git a/drivers/soc/eswin/ai_driver/include/es_dsp_types.h b/drivers/soc/eswin/ai_driver/include/es_dsp_types.h
new file mode 100644
index 000000000000..473df42a41d3
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/include/es_dsp_types.h
@@ -0,0 +1,151 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#ifndef __ESWIN_DSP_TYPES_H__
+#define __ESWIN_DSP_TYPES_H__
+
+#include "es_type.h"
+#include <uapi/linux/es_vb_user.h>
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif
+
+typedef struct DSP_Capability_S {
+    ES_U64 reserved;
+} ES_DSP_Capability_S;
+
+typedef enum DSP_LOG_LEVEL_E {
+    ES_DSP_LOG_DEBUG = 0x0,
+    ES_DSP_LOG_INFO = 0x1,
+    ES_DSP_LOG_WARNING = 0x2,
+    ES_DSP_LOG_ERROR = 0x3,
+    ES_DSP_LOG_NONE = 0x4
+} ES_DSP_LOG_LEVEL_E;
+
+typedef enum DSP_ID_E {
+    ES_DSP_ID_0 = 0x0,
+    ES_DSP_ID_1 = 0x1,
+    ES_DSP_ID_2 = 0x2,
+    ES_DSP_ID_3 = 0x3,
+
+    ES_DSP_ID_4 = 0x4,
+    ES_DSP_ID_5 = 0x5,
+    ES_DSP_ID_6 = 0x6,
+    ES_DSP_ID_7 = 0x7,
+
+    ES_DSP_ID_BUTT
+} ES_DSP_ID_E;
+
+typedef enum DSP_LOAD_POLICY_E {
+    /**
+     * The operator will not be unloaded.
+     */
+    ES_LOAD_CACHED = 0x0,
+    /**
+     * The operator can be unloaded.
+     */
+    ES_LOAD_UNCACHED = 0x1,
+    ES_DSP_LOAD_BUTT
+} ES_DSP_LOAD_POLICY_E;
+
+typedef enum DSP_PRI_E {
+    ES_DSP_PRI_0 = 0x0,
+    ES_DSP_PRI_1 = 0x1,
+    ES_DSP_PRI_2 = 0x2,
+    ES_DSP_PRI_3 = 0x3,
+
+    ES_DSP_PRI_BUTT
+} ES_DSP_PRI_E;
+
+#define BUFFER_CNT_MAXSIZE 32
+
+typedef struct DEVICE_BUFFER_GROUP_S {
+    ES_DEV_BUF_S *buffers;
+    ES_U32 bufferCnt;
+} ES_DEVICE_BUFFER_GROUP_S;
+
+typedef ES_S32 ES_DSP_HANDLE;
+
+#define WAIT_FOR_TASK_COMPLETION -1
+
+/**
+ * @brief Callback function type for task completion or exception notification.
+ *
+ * This callback type is used to define functions that can be registered as
+ * callbacks to receive notifications when a task completes or encounters an exception.
+ *
+ * @param arg Pointer to user-defined data that can be passed to the callback.
+ * @param state An integer representing the state of the task.
+ *              - If state is 0, it indicates successful completion of the task.
+ *              - If state is non-zero, it indicates an exception or error during the task.
+ */
+typedef void (*ES_DSP_TASK_CALLBACK)(void *arg, ES_S32 state);
+
+typedef struct DSP_TASK_S {
+    /**
+     * Specify the handle of target operator.
+     */
+    ES_DSP_HANDLE operatorHandle;
+    /**
+     * Specify the device buffers that will be used by DSP device.
+     */
+    ES_DEV_BUF_S dspBuffers[BUFFER_CNT_MAXSIZE];
+    /**
+     * Specify total number of parameter buffers.
+     */
+    ES_U32 bufferCntCfg;
+    /**
+     * Specify total number of input buffers.
+     */
+    ES_U32 bufferCntInput;
+    /**
+     * Specify total number of output buffers.
+     */
+    ES_U32 bufferCntOutput;
+    /**
+     * Specify the priority of target operator.
+     */
+    ES_DSP_PRI_E priority;
+    /**
+     * Specify the driver responsible for host side cache synchronization.
+     */
+    ES_BOOL syncCache;
+    /**
+     * Specify DSP for starting evaluation and notifying `prepare` and `eval` completion events.
+     */
+    ES_BOOL pollMode;
+    /**
+     * Specify the handle of operator task.
+     * Can only be used in the low-level async interface.
+     */
+    ES_DSP_HANDLE taskHandle;
+    /**
+     * Specify the callback when the asyc task is completed.
+     * Can only be used in the low-level async interface.
+     */
+    ES_DSP_TASK_CALLBACK callback;
+    /**
+     * Specify the callback arguments.
+     * Can only be used in the low-level async interface.
+     */
+    ES_VOID *cbArg;
+    /**
+     * Reserved field.
+     */
+    ES_U32 reserved;
+} __attribute__((packed)) ES_DSP_TASK_S;
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif
+
+#endif
diff --git a/drivers/soc/eswin/ai_driver/include/es_nn_common.h b/drivers/soc/eswin/ai_driver/include/es_nn_common.h
new file mode 100644
index 000000000000..7ea0b4c7502e
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/include/es_nn_common.h
@@ -0,0 +1,269 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#ifndef _ES_NN_COMMONN_H_
+#define _ES_NN_COMMONN_H_
+
+#include "es_type.h"
+#include "es_dsp_types.h"
+#include "es_dsp_op_types.h"
+
+#define MAX_BOXES_NUM 32
+#define MAX_DIM_CNT 6
+
+// define normalization modes
+typedef enum {
+    ES_Z_SCORE = 1,  // Normalize using Z-Score: (x-mean) * (1/std)
+    ES_MIN_MAX = 2,  // Normalize using Min-Max scaling: (x – min) * (1/(max-min))
+} ES_NORM_MODE_E;
+
+// define output data formats for normalization
+// These attributes can be effectively represented by the shape and
+// dataType fields within the ES_TENSOR_S structure.
+typedef enum {
+    ES_RGB8B8 = 1,
+    ES_RGB8B8_PLANAR,
+    ES_RGB8BI,
+    ES_RGB8BI_PLANAR,
+    ES_R16G16B16I,
+    ES_R16G16B16I_PLANAR,
+    ES_R16G16B16F,
+    ES_R16G16B16F_PLANAR,
+    ES_R32G32B32F,
+    ES_R32G32B32F_PLANAR,
+    ES_GRAY8,
+    ES_GRAY8I,
+    ES_GRAY16I,
+    ES_GRAY16F,
+    ES_GRAY32F
+} ES_NORM_OUT_FORMAT_E;
+
+// define data precision types
+typedef enum {
+    ES_PRECISION_UNKNOWN,
+    ES_PRECISION_INT8,
+    ES_PRECISION_UINT8,
+    ES_PRECISION_INT16,
+    ES_PRECISION_UINT16,
+    ES_PRECISION_INT32,
+    ES_PRECISION_UINT32,
+    ES_PRECISION_INT64,
+    ES_PRECISION_UINT64,
+    ES_PRECISION_FP16,
+    ES_PRECISION_FP32,
+} ES_DATA_PRECISION_E;
+
+typedef struct {
+    ES_DATA_PRECISION_E precision;
+    char name[8];
+    int size;
+} DataTypeInfo;
+
+static const DataTypeInfo DataTypeInfoMap[] = {
+    {ES_PRECISION_UNKNOWN, "unknown", 0}, {ES_PRECISION_INT8, "s8", 1},    {ES_PRECISION_UINT8, "u8", 1},
+    {ES_PRECISION_INT16, "s16", 2},       {ES_PRECISION_UINT16, "u16", 2}, {ES_PRECISION_INT32, "i32", 4},
+    {ES_PRECISION_UINT32, "u32", 4},      {ES_PRECISION_INT64, "i64", 8},  {ES_PRECISION_UINT64, "u64", 8},
+    {ES_PRECISION_FP16, "f16", 2},        {ES_PRECISION_FP32, "f32", 4},
+};
+
+// define color codes
+typedef enum {
+    ES_RGB = 0,
+    ES_RGBX,         // packed NHWC
+    ES_RGBX_PLANAR,  // planar NCHW
+    ES_BGRX,         // packed NHWC
+    ES_BGRX_PLANAR,  // planar NCHW
+    ES_YUV_NV12,
+    ES_YUV_NV21,
+    ES_YUV420P,
+} ES_COLOR_CODE_E;
+
+// define color conversion codes
+typedef enum {
+    ES_YUV2RGB = 0,
+    ES_YUV2BGR,
+    ES_YUV2RGB_NV12,
+    ES_YUV2BGR_NV12,
+    ES_YUV2RGB_NV21,
+    ES_YUV2BGR_NV21,
+    ES_YUV420P2RGB,
+    ES_YUV420P2BGR,
+} ES_CVT_CODE_E;
+
+// define interpolation flags
+typedef enum {
+    ES_INTER_NEAREST = 0,
+    ES_INTER_LINEAR = 1,
+    ES_INTER_AREA = 2,
+    ES_INTER_CUBIC = 3,
+    ES_INTER_LANCZOS4 = 4,
+    ES_INTER_NEAREST_EXACT = 6,
+    ES_INTER_STRETCH = 20,  // for HAE
+    ES_INTER_FILTER = 21,   // for HAE
+} ES_INTER_FLAG_E;
+
+// define a bounding box with top-left and bottom-right coordinates
+typedef struct {
+    ES_FLOAT tlx;  // Top-left x-coordinate
+    ES_FLOAT tly;  // Top-left y-coordinate
+    ES_FLOAT brx;  // Bottom-right x-coordinate
+    ES_FLOAT bry;  // Bottom-right y-coordinate
+} ES_BOX_S;
+
+// define dimensions
+typedef struct {
+    ES_S32 height;  // Vertical dimension
+    ES_S32 width;   // Horizontal dimension
+} ES_SIZE_S;
+
+// define a 2D ratio
+typedef struct {
+    ES_FLOAT fx;  // Horizontal scaling factor or ratio
+    ES_FLOAT fy;  // Vertical scaling factor or ratio
+} ES_RATIO_S;
+
+typedef union {
+    ES_DEV_BUF_S devBuffer;  // for device
+    void* hostBuffer;        // for cpu
+} ES_DATA_BUFFER;
+
+/*
+ *  the layout is c0 -> w -> h -> c -> n,
+ *  each dimension is counted by elements
+ *  the constraint for C0 is C0 * bytes_per_elem <= 32 bytes
+ */
+typedef struct {
+    ES_S32 N;   // batch size
+    ES_S32 C;   // number of C0
+    ES_S32 H;   // height
+    ES_S32 W;   // width
+    ES_S32 C0;  // the atomic unit of channel
+    ES_S32 Cs;  // the real channels Cs <= C*C0 and C = ceil(Cs/C0)
+} ES_TENSOR_SHAPE_S;
+
+typedef struct {
+    union {
+        ES_DEV_BUF_S pData;
+        void *hostBuf;
+    };
+    ES_DATA_PRECISION_E dataType;
+    ES_U32 shapeDim;
+    ES_U32 shape[MAX_DIM_CNT];
+} ES_TENSOR_S;
+
+
+typedef enum {
+    MEM_UNKNOWN,
+    MEM_DDR,
+    MEM_LLC,
+    MEM_SRAM,
+    MEM_LINE,
+} ES_DSP_MEM_DESC_E;
+
+typedef struct {
+    ES_DATA_PRECISION_E precision;
+    /* Specify the data is on Online, DDR, LLC or SRAM. */
+    ES_DSP_MEM_DESC_E memInfo;
+    ES_TENSOR_SHAPE_S shape;
+    ES_S32 strideCs, strideC, strideH, strideW, strideN;
+} ES_DSP_TENSOR_DESC_S;
+
+// follow params using in mobile v2 net
+#define OP_ARR_NUM_MAX 256       /* the max op num of mobilenet v2 */
+#define OUT_CHANNEL_NUM_MAX 2048 /* equal to the num of conv kernel weight */
+
+/* Instruct dsp to go through different implementations */
+typedef enum {
+    ES_NORM_CONV = 1,
+    ES_DEPTHWISE_CONV = 2,
+    ES_POINTWISE_CONV = 3,
+    ES_ADD = 4,
+} ES_DSP_OP_TYPE_E;
+
+/* Info of a single op */
+typedef struct DSP_OP_INFO_S {
+    /* op public info */
+    ES_CHAR opName[OPERATOR_NAME_MAXLEN];
+    ES_DSP_OP_TYPE_E opType;
+    ES_TENSOR_SHAPE_S input_shape;
+    ES_TENSOR_SHAPE_S output_shape;
+
+    /* add op params ----> scale info */
+    ES_S16 addOpInput0Scale;
+    ES_S16 addOpInput1Scale;
+    ES_S16 addOpRightShift;
+
+    /* conv op params ----> weight and bias info */
+    ES_U32 kernelShape[2];
+    ES_U32 pads[4];
+    ES_U32 strides[2];
+    ES_U32 weightOffset;
+    ES_U32 biasOffset;
+    /* if is no relu6, it is -128 to 127.
+     * If is relu6, it needs to be calc using 6 / output_scale? */
+    ES_S32 upper_bound;
+    ES_S32 lower_bound;
+
+    /* conv op params ----> scale info */
+    ES_S16 convOpWeightScale[OUT_CHANNEL_NUM_MAX];
+    ES_S16 convOpRightShift;
+} ES_DSP_OP_INFO_S;
+
+/* The header information for weight and bias in ddr */
+typedef struct DSP_INFO_DESC_S {
+    ES_U32 totalBufSize;
+    ES_U32 totalOpNum;
+    ES_DSP_OP_INFO_S opInfoArr[OP_ARR_NUM_MAX];
+    ES_CHAR paramsData[0]; /* store weight and bias */
+} ES_DSP_OP_INFO_DESC_S;
+
+// detection out params
+#define MAX_IN_TENSOR_NUM 9
+#define MAX_TOTAL_ANCHORS_NUM 27  // max num of anchors in yolo net
+
+typedef enum {
+    yolov3 = 1,
+    yolov4 = 2,
+    yolov5 = 3,
+    yolov7 = 4,
+    yolov8 = 5,
+    yolo5face = 6,
+    ppyoloe = 7,
+    ssd = 20,
+    frcnn = 30,
+} ES_DET_NETWORK_E;
+
+typedef enum {
+    HARD_NMS,
+    SOFT_NMS_GAUSSIAN,
+    SOFT_NMS_LINEAR,
+} ES_NMS_METHOD_E;
+
+typedef enum {
+    IOU,
+    GIOU,
+    DIOU,
+} ES_IOU_METHOD_E;
+
+typedef enum {
+    XminYminXmaxYmax,
+    XminYminWH,
+    YminXminYmaxXmax,
+    XmidYmidWH,
+} ES_BOX_TYPE_E;
+
+#define MASK 0x00000001
+
+// Macro to set the 'flag' variable based on the status of various operations.
+// Each operation (crop, cvt, resize, normal) has a corresponding bit in 'flag'.
+// If an operation is enabled (value is 1), its corresponding bit is set.
+#define SET_OP_FLAG(flag, crop, cvt, resize, normal)                                                         \
+    {                                                                                                        \
+        flag = ((crop & MASK) << 0) | ((cvt & MASK) << 1) | ((resize & MASK) << 2) | ((normal & MASK) << 3); \
+    }
+
+#endif  // _ES_NN_COMMONN_H_
\ No newline at end of file
diff --git a/drivers/soc/eswin/ai_driver/include/es_type.h b/drivers/soc/eswin/ai_driver/include/es_type.h
new file mode 100644
index 000000000000..ab30d1383ff6
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/include/es_type.h
@@ -0,0 +1,75 @@
+
+#ifndef __ES_TYPE_H__
+#define __ES_TYPE_H__
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+/*----------------------------------------------*
+ * The common data type, will be used in the whole project.*
+ *----------------------------------------------*/
+
+typedef unsigned char ES_U8;
+typedef unsigned short ES_U16;
+typedef unsigned int ES_U32;
+
+typedef signed char ES_S8;
+typedef short ES_S16;
+typedef int ES_S32;
+
+typedef unsigned long ES_UL;
+typedef signed long ES_SL;
+
+typedef float ES_FLOAT;
+typedef double ES_DOUBLE;
+
+typedef unsigned long long ES_U64;
+typedef long long ES_S64;
+
+typedef char ES_CHAR;
+#define ES_VOID void
+
+typedef unsigned int ES_HANDLE;
+
+/*----------------------------------------------*
+ * const defination                             *
+ *----------------------------------------------*/
+typedef enum {
+    ES_FALSE = 0,
+    ES_TRUE = 1,
+} ES_BOOL;
+
+/*----------------------------------------------*
+ * log level defination                         *
+ *----------------------------------------------*/
+typedef enum {
+    ES_LOG_MIN         = -1,
+    ES_LOG_EMERGENCY   = 0,
+    ES_LOG_ALERT       = 1,
+    ES_LOG_CRITICAL    = 2,
+    ES_LOG_ERROR       = 3,
+    ES_LOG_WARN        = 4,
+    ES_LOG_NOTICE      = 5,
+    ES_LOG_INFO        = 6,
+    ES_LOG_DEBUG       = 7,
+    ES_LOG_MAX
+} ES_LOG_LEVEL_E;
+
+#ifndef NULL
+#define NULL 0L
+#endif
+
+#define ES_NULL 0L
+#define ES_SUCCESS 0
+#define ES_FAILURE (-1)
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __ES_TYPE_H__ */
diff --git a/drivers/soc/eswin/ai_driver/include/hetero_arch.h b/drivers/soc/eswin/ai_driver/include/hetero_arch.h
new file mode 100644
index 000000000000..31c2b75375db
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/include/hetero_arch.h
@@ -0,0 +1,206 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#ifndef __HETERO_UTILS_H__
+#define __HETERO_UTILS_H__
+
+#include "hetero_types.h"
+#include "hetero_common.h"
+#include "npu_base_regs.h"
+#include "sys_regs.h"
+
+#if defined(__KERNEL__)
+#else
+#include <strings.h>
+#include <assert.h>
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define set_bit_pos(bitmap, pos) ((bitmap) |= (1UL << (pos)))
+#define clear_bit_pos(bitmap, pos) ((bitmap) &= ~(1UL << pos))
+
+#if defined(__KERNEL__)
+#define hmb() smp_mb()
+#define printf printk
+#define io_read(addr) readl(addr)
+#define io_write(addr, value) writel(value, addr)
+#else  // (__KERNEL__)
+/**
+ * @brief Add a compiler time memory barrier honored by GCC. It is not honored by CPU.
+ *
+ */
+#define cmb() asm volatile("" : : : "memory")
+
+/**
+ * @brief Add a hardware memory barrier honored by GCC and CPU.
+ *
+ */
+#define hmb() __sync_synchronize()
+#endif  // (__KERNEL__)
+
+#if NPU_DEV_SIM != NPU_REAL_ENV
+
+#define ffs(value) ((value) == 0 ? sizeof(u32) * 8 : __builtin_ctz(value))
+#define popcnt __builtin_popcount
+
+extern void reg_write(u32 addr, u32 value);
+extern u32 reg_read(u32 addr);
+#ifndef __KERNEL__
+extern void get_scie_data(u32 &ret, u32 rs1, u32 func7);
+#endif
+extern void send_scie_data(u32 op_code, u32 rs1, u32 rs2);
+
+extern void sim_release_ref_in_context(u32 core_id, u32 pingpong);
+extern void prepare_conv_context(u32 pingpong, const conv_program_data_t *conv_prog, u64 extra_data_addr);
+extern u64 read_clock_cycles(void);
+static inline u32 es_sys_getcurcnt(void) { return 0; }
+/**
+ * @brief The high precision clock frequency.
+ *
+ */
+static const u64 clock_frequency = 1000000000ULL;
+
+#ifdef __cplusplus
+#define TLS thread_local
+#else  // __cplusplus
+#define TLS __thread
+#endif  // __cplusplus
+
+#define NO_RETURN
+
+extern bool all_frames_completed(void);
+
+#else  // NPU_DEV_SIM != NPU_REAL_ENV
+
+#define TLS
+#define NO_RETURN __attribute__((noreturn))
+
+#define get_scie_data(ret, rs1, func7) \
+    asm volatile(".insn r 0xB, 0x0, %3, %0, %1, %2" : "=r"(ret) : "r"(rs1), "r"(rs1), "I"(func7));
+/* Need to add a nop instruction in front of SCIe instruction. This is used temporarily to avoid an SCIe bug. */
+#define send_scie_data(op_code, rs1, rs2)                            \
+    asm volatile("ori tp, %2, %0\n"                                  \
+                 ".insn r 0xB, 0x0, 0x4, x0, %1, tp" ::"i"(op_code), \
+                 "r"(rs1), "r"(rs2));
+
+#ifndef __KERNEL__
+#define ffs(value) _ffs(value)
+#else
+#define ffs(value) ((value) == 0 ? sizeof(u32) * 8 : __builtin_ctz(value))
+#endif
+
+/**
+ * @brief Scan binary representation of r0 from LSB to MSB. Calculate the first occasion of 1 and return this value.
+ * Returns 32 if r0 equals 0.
+ *
+ * @param r0
+ * @return u32
+ */
+static inline u32 _ffs(u32 r0)
+{
+    u32 r1;
+    get_scie_data(r1, r0, 0x0);
+    return r1;
+}
+
+#define TIMER0_BASE 0x51840000
+#define PTS_CHAN 7
+#define PTS_END_CYCLE (*(u32 *)(TIMER0_BASE + 0x0 + PTS_CHAN * 0x14))
+#define PTS_START_CYCLE (*(u32 *)(TIMER0_BASE + 0x4 + PTS_CHAN * 0x14))
+
+static inline u32 es_sys_getcurcnt(void) { return (PTS_END_CYCLE - PTS_START_CYCLE); }
+
+/**
+ * @brief Calculate number of 1s in binary representation of r0 and return this value.
+ *
+ * @param r0
+ * @return u32
+ */
+static inline u32 popcnt(u32 r0)
+{
+    u32 r1;
+    get_scie_data(r1, r0, 0x1);
+    return r1;
+}
+
+/**
+ * @brief Write a DW data to a given register. Note no memory barrier is set. Caller is responsible for coordinating
+ * register order by utilizing memory barriers.
+ *
+ * @param addr      The address of register.
+ * @param value     The DW value to be written.
+ */
+static inline void reg_write(size_t addr, u32 value)
+{
+    ASSERT_REG_ADDR(addr);
+    *(volatile u32 *)(addr) = value;
+}
+
+/**
+ * @brief Read a DW data from a given register.
+ *
+ * @param addr      The address of register.
+ * @return u32      The DW value read from register.
+ */
+static inline u32 reg_read(size_t addr)
+{
+    ASSERT_REG_ADDR(addr);
+    return *(volatile u32 *)addr;
+}
+
+/**
+ * @brief Clear interrupt enable bitmap.
+ *
+ * @return The old mie value.
+ */
+static inline u32 clear_interrupt(void)
+{
+    u32 mie;
+    asm volatile("csrrw %0, mie, zero" : "=r"(mie));
+    return mie;
+}
+
+/**
+ * @brief Restore interrupt enable bitmap.
+ *
+ */
+static inline void restore_interrupt(u32 mie) { asm volatile("csrw mie, %0" ::"r"(mie)); }
+
+/**
+ * @brief Write the 15th bit of the test_reg_0 register to "1" for setting zebu breakpoint.
+ *
+ */
+static inline void set_zebu_breakpoint(void) { reg_write(SYS_CON_TEST_REG_0, 0x8000); }
+
+/**
+ * @brief The high precision clock frequency.
+ *
+ */
+static const u64 clock_frequency = 5000000L;
+
+/**
+ * @brief Read CPU clock cycles
+ *
+ * @return         The CPU clock cycles
+ */
+static inline unsigned long read_clock_cycles(void)
+{
+    unsigned long cycles;
+    asm volatile("rdcycle %0" : "=r"(cycles));
+    return cycles;
+}
+
+#endif  // NPU_DEV_SIM != NPU_REAL_ENV
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  // __HETERO_UTILS_H__
diff --git a/drivers/soc/eswin/ai_driver/include/hetero_common.h b/drivers/soc/eswin/ai_driver/include/hetero_common.h
new file mode 100644
index 000000000000..1bf7568415f8
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/include/hetero_common.h
@@ -0,0 +1,917 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#ifndef __HETERO_COMMON_H__
+#define __HETERO_COMMON_H__
+
+#include "hetero_env.h"
+#include "hetero_types.h"
+#include "edma_regs.h"
+#include "sdp_regs.h"
+#include "pdp_regs.h"
+#include "rubik_regs.h"
+#include "cdma_regs.h"
+#include "hetero_processor.h"
+#include "hetero_perf.h"
+
+#if NPU_DEV_SIM != NPU_REAL_ENV
+#include "dla_interface.h"
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define STATIC_ASSERT static_assert
+
+#define UNUSED(x) (void)(x)
+
+#define INVALID_U64_ADDRESS 0xFFFFFFFFFFFFFFFFULL
+
+#if NPU_DEV_SIM != NPU_REAL_ENV
+#ifdef __KERNEL__
+#define ASSERT(exp) BUG_ON(!(exp))
+#else
+#define ASSERT assert
+#endif
+#else
+#define ASSERT(exp) UNUSED(exp)
+#endif
+/**
+ * @brief Get the element count of an array.
+ *
+ */
+#define COUNT_OF(x) (sizeof(x) / sizeof(x[0]))
+
+/**
+ * @brief Get the byte offset of an member relative to the start of a given data type.
+ *
+ */
+#define ADDR_OFFSET(type, member) ((char *)(&((type *)0)->member) - (char *)0)
+
+/**
+ * @brief Create a bitmask for a given bit shift value.
+ *
+ */
+#define BITMASK(bit) ((1U << (bit)) - 1U)
+
+#if SMALL_PEC_MAT
+/* Rows of PE clusters. */
+#define NUM_PEC_ROW (2)
+/* Columns of PE clusters. */
+#define NUM_PEC_COLUMN (2)
+/* Number of E31 cores. */
+#define NUM_NPU_CORES (4)
+#else
+/* Rows of PE clusters. */
+#define NUM_PEC_ROW (8)
+/* Columns of PE clusters. */
+#define NUM_PEC_COLUMN (4)
+/* Number of E31 cores. */
+#define NUM_NPU_CORES (10)
+#endif
+
+#define BIT_PER_DEPCNT 4UL
+#define NUM_CNT_PER_BYTE 2UL
+#define DEP_CNT_MASK 0xf
+
+#define NUM_BITS_IN_BYTE 8UL
+#define NUM_BITS_IN_DWORD 32UL
+
+#define NUM_PINGPONG 2UL
+#define NUM_DATA_SLOT 4UL
+#define NUM_TIKTOK 2UL
+#define MAX_OP_NUM (4096UL * 8)
+#define MAX_CDMA_PROGRAM_SIZE 768UL
+#define NUM_CDMA_SLOT 2UL
+#define INVALID_TIKTOK -1
+
+#define CDMA_TRANSFER_BYTE_ALIGN 16
+#define CDMA_SRC_BYTE_ALIGN 16
+#define CDMA_DST_BYTE_ALIGN 16
+
+#define NUM_MAJOR_CORES (NUM_NPU_CORES - 2UL)
+
+#define ROUND_UP(x, y) (((x) + ((y) - 1)) / y * y)
+#define ROUND_DOWN(x, y) (x - ((x) % (y)))
+
+static const u32 NUM_BIT_IN_DWORD = 32;
+
+/**
+ * @brief Defines tensor element data types.
+ *
+ */
+enum type_fmt_e {
+    _INT8,
+    _UINT8,
+    _FP16,
+    _INT16,
+};
+
+// Complete event id (Complete operator use)
+#define COMPLETE_EVENT_ID (4096)
+
+/**
+ * @brief PEC matrix row and column information.
+ *
+ */
+/* Columns of PE clusters. */
+static const u32 num_max_pec_row = 8;
+static const u32 num_max_pec_column = 4;
+
+/* Number of all E31 cores in the system. */
+static const u32 max_num_npu_cores = 10;
+
+STATIC_ASSERT(NUM_PEC_COLUMN <= 4);
+
+/* Number of rows inside of a PEC. */
+static const u32 num_pe_row = 3;
+/* Number of columns inside of a PEC. */
+static const u32 num_pe_column = 4;
+
+STATIC_ASSERT(NUM_NPU_CORES >= 3);
+
+typedef struct _conv_dev_hdr {
+    /**
+     * @brief Specifies the total length of conv_config_data in DWs(4 bytes).
+     *
+     */
+    u16 total_len;
+
+    /**
+     * @brief Specifies the total length of rdma_dev_master_inf_t and pec_dev_master_inf_t in DWs(4 bytes).
+     *
+     */
+    u8 master_len;  // DO NOT remove this since model uses it!
+
+    /**
+     * @brief Specifies the total length of used num pec in row.
+     *
+     */
+    u8 used_num_pec_row;
+
+    /**
+     * @brief Specifies the total length of used num pec in column.
+     *
+     */
+    u8 used_num_pec_column;
+    u8 emission_len;  // used by npu_perf
+    u8 program_len;   // used by npu_perf
+
+    /**
+     * @brief Specifies how many DWs(4 bytes) of data for each Major nodes. This is a bitmap and each 4 bits
+     * correspond to a Major node.
+     *
+     */
+    union {
+        u8 major_lens[NUM_MAJOR_CORES];
+        u32 dws[0];
+    };
+} __attribute__((aligned(CDMA_TRANSFER_BYTE_ALIGN))) conv_dev_hdr_t;
+
+/**
+ * @brief Wrapper of device model.
+ *
+ */
+typedef struct _conv_dev_t {
+    struct {
+        conv_dev_hdr_t header;
+    } __attribute__((aligned(CDMA_TRANSFER_BYTE_ALIGN)));
+
+    /**
+     * @brief This is a placeholder of future extension fields.
+     *
+     */
+    u32 dws[0];
+} conv_dev_t __attribute__((aligned(CDMA_TRANSFER_BYTE_ALIGN)));
+
+/* dump tensor data to file need this head */
+struct dump_file_header {
+    int magic;
+    int magic_end_offset;
+    u32 op_num;
+
+    u32 depend_offset;
+    u32 depend_len;
+    u32 io_tensor_offset;
+    u32 io_tensor_len;
+    u32 lut_offset;
+    u32 lut_len;
+    u64 lut_base_iova;
+    conv_dev_hdr_t first_conv_hdr;
+
+    u32 pcer_op_num[NUM_OP_TYPE];
+    u32 op_data_offset[NUM_OP_TYPE];
+    u32 op_data_len[NUM_OP_TYPE];
+} __attribute__((packed));
+
+typedef struct _op_current {
+    /**
+     * @brief The IOVA of a pointer array. Each pointer points to an array of
+     * program data of given operation type.
+     */
+    u64 program_addr[NUM_OP_TYPE];
+
+    /**
+     * @brief The number of remaining operators of a given type.
+     */
+    u16 num_remain_ops[NUM_OP_TYPE];
+
+    /**
+     * @brief The program specification for convolution. This determines how to
+     * generate CDMA requests to transfer data from DDR to program and each
+     * major core.
+     */
+    conv_dev_hdr_t next_conv_hdr;
+} __attribute__((aligned(sizeof(u64)))) op_current_t;
+
+static const u8 invalid_tensor_idx = 0xFF;
+#define MAX_INPUTS 8
+#define MAX_OUTPUTS 8
+#define MAX_NUM_INPUT_OUTPUT (MAX_INPUTS + MAX_OUTPUTS)
+
+/**
+ * @brief The input and output tensor IOVA addresses from NPU side.
+ */
+typedef struct _npu_io_tensor {
+    u64 tensor_addr[MAX_NUM_INPUT_OUTPUT];
+} npu_io_tensor_t;
+
+#define MAX_DTIM_DEPCNT 4096
+#define NUM_DEPENDENCY_BITS 4
+
+/**
+ * @brief The dependency count of each operator. Maximum 4096 operators are
+ * supported. Each dependency count has maximum value of 15 and thus occupies 4
+ * bits of storage.
+ *
+ * dependency count of each frame is saved in DTIM. u84 initiates
+ * the whole entries and e31 updates entry per op execution.
+ *
+ * TODO: dtim address for dep_cnt is fixed as 0x0;
+ *
+ * 4KB entry x 4bit_per_entry
+ * from lowest bytes to highest bytes:
+ * |-- byte0 ------------|-- byte1--------------|
+ * op0_depcnt, op1_depcnt; op2_depcnt, op3_depcnt; etc.
+ */
+typedef struct _dependency {
+    /**
+     * @brief The actual operators in this inference frame.
+     */
+    u16 num_op;
+    u8 ref_count[MAX_DTIM_DEPCNT * NUM_DEPENDENCY_BITS / NUM_BITS_IN_BYTE];
+} __attribute__((aligned(sizeof(u32)))) dependency_t;
+
+/**
+ * @brief The frame descriptor that is shared by Host and E31 on how to trigger
+ * NPU evaluation.
+ */
+// TODO(JIRA13047 zhangyizhong): rename to hetero_ipc_frame_t
+typedef struct _frame_desc {
+    op_current_t op_current;
+    dependency_t op_dependency;
+} __attribute__((aligned(sizeof(u32)))) hetero_ipc_frame_t;
+
+typedef struct _frame_info {
+    npu_io_tensor_t io_tensor;
+    hetero_ipc_frame_t frame;
+    u32 is_ready;
+    u32 tiktok;
+} __attribute__((aligned(sizeof(u32)))) frame_info_t;
+
+typedef struct _resume_info {
+    u8 resume_flag;
+    u8 tiktok;
+    u16 op_index;
+} __attribute__((aligned(sizeof(u32)))) resume_info_t;
+
+typedef struct _event_op_info {
+    u8 tiktok;
+    u16 op_index;
+} __attribute__((aligned(sizeof(u32)))) event_op_info_t;
+
+static const u16 invalid_op_index = 0xFFFF;
+
+/**
+ * @brief The dependency information for each operator.
+ */
+typedef struct _npu_dep_info {
+    u16 depcnt;
+
+    u16 current_op_idx;
+
+    /**
+     * @brief This operator has enable dependency on current operator. If
+     * enable_op_idx equals invalid_op_index, then no operator has enable
+     * dependency.
+     */
+    u16 enable_op_idx;
+
+    /**
+     * @brief This is a bitmap. Each bit specifies if an operator of given type
+     * has a completion dependency on current operator.
+     */
+    u16 completion_event_bitmap : 12;
+
+    /**
+     * @brief If this bit is 1, notify host by sending NOTIFY_OP_DONE when this
+     * operation evaluation is done.
+     */
+    u16 notify_op_done : 1;
+
+    /**
+     * @brief If this bit is 1, pause the dependency resolution when an
+     * operation evaluation completes.
+     */
+    u16 pause_op_done : 1;
+
+    /**
+     * @brief The consumer's op_idx that completed dependency.
+     * max consumer is all npu op + dsp op
+     */
+    u16 completion_op_idx[MAX_KMD_DEPCNT];
+
+    /**
+     * @brief Provides the LUT IOVA for SDP. If this value is 0, then LUT is not
+     * needed.
+     */
+    union {
+        u64 lut_address;
+        u64 dsp_eval_param;
+    };
+} __attribute__((aligned(CDMA_SRC_BYTE_ALIGN))) npu_dep_info_t;
+
+/* This assertion ensures CDMA transfer address is in hardware capability range. */
+STATIC_ASSERT(__builtin_offsetof(npu_dep_info_t, lut_address) % sizeof(u64) == 0,
+              "please ensure lut_address aligned with 8 bytes.");
+
+/*** edma prog data ******/
+typedef struct _edma_program {
+    union {
+        u64 u84_bitmap;
+        u32 e31_bitmap[0];
+    };
+    u32 reg[EDMA_REG_MAX];
+    u8 input_tensor_idx;
+    u8 output_tensor_idx;
+} __attribute__((aligned(CDMA_SRC_BYTE_ALIGN), packed)) edma_program_t;
+
+typedef struct _edma_dev {
+    npu_dep_info_t npu_info;
+    edma_program_t prog_data;
+} __attribute__((aligned(CDMA_SRC_BYTE_ALIGN))) edma_dev_t;
+
+/*** conv prog data ******/
+typedef struct _conv_emission {
+    npu_dep_info_t npu_info;
+    conv_dev_hdr_t next_convolution_header;
+} __attribute__((aligned(CDMA_SRC_BYTE_ALIGN))) conv_emission_t;
+
+typedef struct _conv_program {
+    /**
+     * @brief Specifies the whole 48 bits RDMA Ifmap system base address from
+     * NPU's perspective. Note NPU may access the data via a SMMU.
+     */
+    u64 ifmap_base_addr;
+
+    /**
+     * @brief Specifies the whole 48 bits RDMA weight system base address from
+     * NPU's perspective. Note NPU may access the data via a SMMU.
+     */
+    u64 weight_base_addr;
+
+    /**
+     * @brief Specifies the whole 48 bits RDMA Ofmap system base address from
+     * NPU's perspective. Note NPU may access the data via a SMMU.
+     */
+    u64 ofmap_base_addr;
+
+    /**
+     * @brief Specifies the total length of used num pec in row.
+     *
+     */
+    u8 used_num_pec_row;
+
+    /**
+     * @brief Specifies the total length of used num pec in column.
+     *
+     */
+    u8 used_num_pec_column;
+
+    /**
+     * @brief Specifies the IO tensor index if this is an IO tensor. Otherwise
+     * set it to invalid_tensor_idx.
+     */
+    u8 input0_io_index;
+
+    /**
+     * @brief Specifies the IO tensor index if this is an IO tensor. Otherwise
+     * set it to invalid_tensor_idx. Output tensor is not necessary.
+     */
+    u8 output0_io_index;
+
+    /**
+     * @brief Specifies the IO tensor offset of input0.
+     */
+    u32 input0_io_offset;
+
+    /**
+     * @brief Specifies the IO tensor offset of output0.
+     */
+    u32 output0_io_offset;
+} __attribute__((aligned(CDMA_TRANSFER_BYTE_ALIGN))) conv_program_t;
+
+typedef struct _rdma_dev_com_inf {
+    /**
+     * @brief Specifies Ifmap related information. Note Ch0 and Che actually corresponds to multiple parts in our
+     * authoritative mapping: Ch0 = Cf x Gf x CMf x GMf and Che = div_up(conv_prob_.G, G0) * div_up(conv_prob_.C, C0)
+     * respectively. Meanwhile, the layout format is always E_FORMAT.
+     *
+     */
+    u16 Che;
+    u16 W, H;
+    u8 N;
+    u8 Ch0;
+    u8 ifmap_type_fmt;
+    u8 stride_h, stride_w;
+
+    /**
+     * @brief Specifies mapping related information. Note space parallelism is not specified here because for each
+     * PEC, it only needs its unique space parameters. Ch0 = Cf x Gf x CMf x GMf and thus we do not need to specify
+     * Cf, Gf, CMf, GMf separately.
+     *
+     */
+    u8 E1, R1, Cv, E0, F0, S, R;
+    u8 N3, N2, G3, G2, E3, R3, M2, F3;
+
+    /**
+     * @brief Specifies PEC space parallelism information. For Ifmap, G1 and C1 can be treated together.
+     *
+     */
+    u8 G1_C1, N1, M1, E2;
+
+    /**
+     * @brief Padding for top and left. Note compiler should verify padding constraints and ensure they are met.
+     * Firmware will not check the legitimacy again! Padding also take strides in height and width into account. If they
+     * does not begin at the origin, then pad_h_t and pad_w_l should subtract the offsets in height and width
+     * correspondingly.
+     *
+     */
+    s16 pad_h_t, pad_w_l;
+    u16 M3, E4, C3, C2;
+} __attribute__((aligned(CDMA_TRANSFER_BYTE_ALIGN))) rdma_dev_com_inf_t;
+
+union narrator_dev_desc_t {
+    struct {
+        /**
+         * @brief Specifies PEC space parallelism information. For Ifmap, g1 and c1 can be treated together. That
+         * means g1_c1 = g1 * C1 + c1;
+         *
+         */
+        u8 g1_c1, n1, m1, e2;
+    };
+    struct {
+        /**
+         * @brief Specifies the low 32 bits part of RDMA weight physical base address.
+         *
+         */
+        u32 weight_base_addr;
+    };
+};
+
+/**
+ * @brief Specifies device convolution related information sent to Master node.
+ *
+ */
+typedef struct _rdma_dev_master_inf {
+    /**
+     * @brief Specifies RDMA (Including WIG) related configurations.
+     * rdma and wig broadcast register bitmask
+     * 10'h008	IFM_WT_CR           bit0  -> 0
+     * 10'h00c	IFM_SADDR_H         bit1  -> 0
+     * 10'h010	IFM_SADDR_L         bit2  -> 0
+     * 10'h014	WT_INFO_SADDR_H     bit3  -> 0
+     * 10'h018	WT_INFO_SADDR_L     bit4  -> 0
+     * 10'h01c	EMPTY_HOLE          bit5  -> 0
+     * 10'h020	CHANEL_SIZE_0       bit6  -> 0  // use default
+     * 10'h024	CHANEL_SIZE_1       bit7  -> 0  // use default
+     * 10'h028	CHANEL_SIZE_2       bit8  -> 0  // use default
+     * 10'h02c	CHANEL_SIZE_3       bit9  -> 0  // use default
+     * 10'h030	WIG_BASE_ADDR_0     bit10 -> 0
+     * 10'h034	WIG_BASE_ADDR_1     bit11 -> 0
+     * 10'h038	WIG_BASE_ADDR_2     bit12 -> 0
+     * 10'h03c	WIG_BASE_ADDR_3	    bit13 -> 0
+     * 10'h040	LOOP_NUM_2_CH0      bit14 -> 1
+     * 10'h044	LOOP_NUM_1_CH0      bit15 -> 1
+     * 10'h048	LOOP_NUM_0_CH0      bit16 -> 1
+     * 10'h04c	EMPTY_HOLE          bit17 -> 0
+     * 10'h050	OFFSET_9_CH0        bit18 -> 1
+     * 10'h054	OFFSET_8_CH0        bit19 -> 1
+     * 10'h058	OFFSET_7_CH0        bit20 -> 1
+     * 10'h05c	OFFSET_6_CH0        bit21 -> 1
+     * 10'h060	OFFSET_5_CH0        bit22 -> 1
+     * 10'h064	OFFSET_4_CH0        bit23 -> 1
+     * 10'h068	OFFSET_3_CH0        bit24 -> 1
+     * 10'h06c	OFFSET_2_CH0        bit25 -> 1
+     * 10'h070	OFFSET_1_CH0        bit26 -> 1
+     * 10'h074	OFFSET_0_CH0        bit27 -> 1
+     * 10'h078  OFFSET_10_CH0       bit28 -> 1
+     * old rdma_and_wig_bitmap = 0x7FFE1E0
+     * new rdma_and_wig_bitmap = 0x1FFDC000
+     **/
+
+    u32 rdma_and_wig_bitmap;
+    /**
+     * @brief Specifies rdma and wig register configurations.
+     *
+     */
+    u32 regs[0];
+} rdma_dev_master_inf_t;
+
+/**
+ * @brief Specifies PreDRP register configurations.
+ *
+ */
+union pre_drp_regs_t {
+    struct {
+        /* registers */
+        u32 predrp_ctrl;
+        u32 n2_stride;
+        u32 g2_stride;
+        u32 e3_stride;
+        u32 m2_stride;
+        u32 m_stride;
+        u32 g3_threshold;
+        u32 n3_threshold;
+        u32 m3_threshold;
+        u32 e4_threshold;
+        u32 f3_threshold;
+        u32 pe_num;
+        u32 predrp_size_glb;
+
+        u32 reshape_ctrl;
+        u32 g_stride_glb;
+        u32 n_stride_glb;
+        u32 e_stride_glb;
+        u32 m_stride_glb;
+        u32 n_stride_sram;
+        u32 h_stride_sram;
+        u32 c_stride_sram;
+        /*rtl remove 2 registers, the address is not continues */
+        u32 imap_para_l;
+        u32 omap_para_rsp_w;
+        u32 layer_para_l;
+        u32 layer_para_m;
+        u32 layer_para_h;
+        u32 glb_para_l;
+        u32 glb_para_h;
+        u32 omap_para_l;
+        u32 reshape_size_glb;
+        u32 precision_ctrl_l;
+        u32 precision_ctrl_h;
+    };
+    u32 regs[0];
+};
+
+/**
+ * @brief Specifies the PEC related information that is sent to Master node.
+ *
+ */
+typedef struct _pec_dev_master_inf {
+    /**
+     * @brief Specifies the length of this data structure in DWs(4 bytes).
+     *
+     */
+    u8 struct_len;
+
+    /**
+     * @brief Specifies if each DW register exists in this data structure and should be broadcasted in this node.
+     *
+     */
+    u16 reg_bcast_bitmap;
+
+    /**
+     * @brief Specifies PEC active bitmap.
+     *
+     */
+    u32 pec_active_bitmap;
+    /**
+     * @brief Specifies Pre-data-reshaper registers.
+     *
+     */
+    union pre_drp_regs_t pre_drp_regs;
+
+    /**
+     * @brief Specifies PEC related registers.
+     *
+     */
+    u32 regs[0];
+} pec_dev_master_inf_t;
+
+/**
+ * @brief Specifies the PEC related information that is sent to each Major node.
+ *
+ */
+typedef struct _pec_dev_major_inf {
+    /**
+     * @brief Specifies the length of this data structure in DWs(4 bytes).
+     *
+     */
+    u8 struct_len;
+
+    /**
+     * @brief Specifies if each DW register exists in this data structure and should be multicasted in this node.
+     *
+     */
+    u8 reg_mcast_bitmap;
+
+    /**
+     * @brief Specifies if each DW register exists in this data structure and should be uniquecasted in this node.
+     *
+     */
+    u8 reg_ucast_bitmap;
+    /**
+     * @brief Specifies if each PEC should be enabled for trigger. If a given bit is 1, then the corresponding PEC
+     * should set pe_en_trig register to 2 so that it can be triggered by broadcasting pe_en_trigger.
+     *
+     */
+    u8 pec_en_bitmap;
+
+    /**
+     * @brief Specifies PEC register configurations.
+     *
+     */
+    u32 regs[0];
+} pec_dev_major_inf_t;
+
+/**
+ * @brief Specifies device convolution related information separately passed to each Major node. This data structure
+ * has variable length depending on the number of active Ifmap narrators.
+ *
+ */
+typedef struct _rdma_dev_major_inf {
+    /**
+     * @brief Specifies the length of this data structure in DWs(4 bytes).
+     *
+     */
+    u8 struct_len;
+
+    /**
+     * @brief Each bit specifies a given PEC is a narrator if corresponding bit is 1.
+     *
+     */
+    u8 weight_narrator_bitmap;
+    u8 ifmap_narrator_bitmap;
+
+    /**
+     * @brief Specifies if each RDMA should be enabled for trigger. If rdma_en_flag is true, then the corresponding
+     * RDMA should set op_en_trig register to 2 so that it can be triggered by broadcasting pe_en_trigger.
+     *
+     */
+    u8 rdma_en_flag : 1;
+
+    /**
+     * @brief Specifies if ifmap_weight_ctrl should be set in each Major core.
+     *
+     */
+    u8 is_ctrl_valid : 1;
+
+    /**
+     * @brief Specifies the value to be configured to RDMA Ifmap weight control register.
+     *
+     */
+    u32 ifmap_weight_ctrl;
+
+    /**
+     * @brief Each element corresponds to a given weight or Ifmap if corresponding bit in weight_narrator_bitmap or
+     * ifmap_narrator_bitmap is 1.
+     * Note if weight_narrator_bitmap has 3 outstanding narrators and ifmap_narrator_bitmap has 2 outstanding
+     * narrators, then narrator_desc[0~2] correspond to weight narrators and narrator_desc[3~4] correspond to Ifmap
+     * narrators.
+     *
+     */
+    union narrator_dev_desc_t narrator_desc[0];
+} rdma_dev_major_inf_t;
+
+/**
+ * @brief Specifies the maximum size of conv_dev_t in Program node.
+ * @todo paragraph describing what is to be done
+ */
+#define MAX_PROGRAM_CONV_CONFIG_SIZE                                                                     \
+    ROUND_UP(sizeof(rdma_dev_com_inf_t) + sizeof(rdma_dev_master_inf_t) + sizeof(pec_dev_master_inf_t) + \
+                 sizeof(conv_program_t) + 136,                                                           \
+             CDMA_TRANSFER_BYTE_ALIGN)
+
+typedef struct _conv_program_data {
+    u8 program_data[MAX_PROGRAM_CONV_CONFIG_SIZE];
+} conv_program_data_t;
+
+typedef struct _major_core_info {
+    rdma_dev_major_inf_t rdma_info;
+    pec_dev_major_inf_t pec_info;
+} major_core_info_t;
+
+#define NUM_LINEAR_EXP_TABLE_ENTRIES 65
+#define NUM_LINEAR_ONLY_TABLE_ENTRIES 257
+typedef struct _lut_dev {
+    u8 precision;
+    u32 lut_cfg;
+    u32 lut_info;
+    u32 le_start;
+    u32 le_end;
+    u32 lo_start;
+    u32 lo_end;
+    u32 le_slope_scale;
+    u32 lo_slope_scale;
+    u32 le_slope_shift;
+    u32 lo_slope_shift;
+
+    u16 linear_exp_table[NUM_LINEAR_EXP_TABLE_ENTRIES];
+    u16 linear_only_table[NUM_LINEAR_ONLY_TABLE_ENTRIES];
+} __attribute__((aligned(CDMA_SRC_BYTE_ALIGN))) lut_dev_t;
+
+/*** sdp ******/
+// 35 regs for sdp, 28 regs for sdp_rdma, 15 regs for post_drp. 78 total
+typedef struct _sdp_program {
+    union {
+        u64 u84_bitmap;
+        u32 e31_bitmap[0];
+    };
+    union {
+        u64 u84_drp_bitmap;
+        u32 e31_drp_bitmap[0];
+    };
+    union {
+        u64 u84_rdma_bitmap;
+        u32 e31_rdma_bitmap[0];
+    };
+    u32 reg[SDP_REG_MAX];
+    u32 sdp_drp_reg[POST_DRP_REG_MAX];
+    u32 sdp_rdma_reg[SDP_RDMA_REG_MAX];
+
+    u8 input_tensor_idx;
+    u8 output_tensor_idx;
+    u8 x1_tensor_idx;
+    u8 x2_tensor_idx;
+    u8 y_tensor_idx;
+    u8 is_rdma;
+} __attribute__((aligned(CDMA_SRC_BYTE_ALIGN), packed)) sdp_program_t;
+
+typedef struct _sdp_dev_t {
+    npu_dep_info_t npu_info;
+    sdp_program_t prog_data;
+} __attribute__((aligned(CDMA_SRC_BYTE_ALIGN))) sdp_dev_t;
+
+typedef struct _dsp_program {
+    u64 rsv;
+} __attribute__((aligned(CDMA_SRC_BYTE_ALIGN), packed)) dsp_program_t;
+
+typedef struct _dsp_dev_t {
+    npu_dep_info_t npu_info;
+    dsp_program_t prog_data;
+} __attribute__((aligned(CDMA_SRC_BYTE_ALIGN))) dsp_dev_t;
+
+/*** pdp 41 regs ******/
+typedef struct _pdp_program {
+    union {
+        u64 u84_bitmap;
+        u32 e31_bitmap[0];
+    };
+    union {
+        u64 u84_rdma_bitmap;
+        u32 e31_rdma_bitmap[0];
+    };
+    union {
+        u64 u84_drp_bitmap;
+        u32 e31_drp_bitmap[0];
+    };
+    u32 reg[PDP_REG_MAX];
+    u32 pdp_rdma_reg[PDP_RDMA_REG_MAX];
+    u32 pdp_drp_reg[PDP_DRP_REG_MAX];
+
+    u8 input_tensor_idx;
+    u8 output_tensor_idx;
+    u8 is_rdma;
+} __attribute__((aligned(CDMA_SRC_BYTE_ALIGN), packed)) pdp_program_t;
+
+typedef struct _pdp_dev {
+    npu_dep_info_t npu_info;
+    pdp_program_t prog_data;
+} __attribute__((aligned(CDMA_SRC_BYTE_ALIGN))) pdp_dev_t;
+
+/*** rubik ******/
+typedef struct _rubik_program {
+    u64 bitmap;
+    union {
+        u64 u84_bitmap;
+        u32 e31_bitmap[0];
+    };
+    u32 reg[RUBIK_REG_MAX];
+    u8 input_tensor_idx;
+    u8 output_tensor_idx;
+} __attribute__((aligned(CDMA_SRC_BYTE_ALIGN), packed)) rubik_program_t;
+
+typedef struct _rubik_dev {
+    npu_dep_info_t npu_info;
+    rubik_program_t prog_data;
+} __attribute__((aligned(CDMA_SRC_BYTE_ALIGN))) rubik_dev_t;
+
+/*** event ******/
+typedef struct _event_sink_program {
+    u32 reserved;
+} __attribute__((aligned(CDMA_SRC_BYTE_ALIGN), packed)) event_sink_program_t;
+
+typedef struct _event_sink_dev {
+    npu_dep_info_t npu_info;
+    event_sink_program_t prog_data;
+} __attribute__((aligned(CDMA_SRC_BYTE_ALIGN))) event_sink_dev_t;
+
+typedef struct _event_source_program {
+    u32 reserved;
+} __attribute__((aligned(CDMA_SRC_BYTE_ALIGN), packed)) event_source_program_t;
+
+typedef struct _event_source_dev {
+    npu_dep_info_t npu_info;
+    event_sink_program_t prog_data;
+} __attribute__((aligned(CDMA_SRC_BYTE_ALIGN))) event_source_dev_t;
+
+STATIC_ASSERT(sizeof(rdma_dev_com_inf_t) % CDMA_TRANSFER_BYTE_ALIGN == 0);
+
+/**
+ * @brief Specifies maximum number of narrator descriptors in each dev_rdma_major_inf_t instance.
+ *
+ */
+static const u32 max_num_narrator_desc = NUM_PEC_COLUMN * 2;
+
+/**
+ * @brief Specifies the optimal buffer alignment for Ifmap, Ofmap and weight in convolution unit.
+ *
+ */
+static const u32 device_buffer_align = 64;
+
+/**
+ * @brief Specifies the maximum size of conv_dev_t in Emission node.
+ * @todo paragraph describing what is to be done
+ */
+static const u32 MAX_EMISSION_CONV_CONFIG_SIZE =
+    ROUND_UP(sizeof(rdma_dev_com_inf_t) + sizeof(npu_dep_info_t) + sizeof(conv_dev_t), CDMA_TRANSFER_BYTE_ALIGN);
+
+/**
+ * @brief Specifies the maximum size of conv_dev_t in Major node.
+ * @todo
+ */
+#define MAX_MAJOR_CONFIG_SIZE                                                                               \
+    ROUND_UP(sizeof(rdma_dev_com_inf_t) + sizeof(rdma_dev_major_inf_t) + sizeof(pec_dev_major_inf_t) + 112, \
+             CDMA_TRANSFER_BYTE_ALIGN)
+
+static const u32 MAX_CONV_PROG_SIZE =
+    (MAX_EMISSION_CONV_CONFIG_SIZE + MAX_PROGRAM_CONV_CONFIG_SIZE + MAX_MAJOR_CONFIG_SIZE * NUM_MAJOR_CORES);
+
+#if NPU_DEV_SIM != NPU_REAL_ENV
+typedef struct _conv_extra_data {
+    struct npu_conv_op_desc conv_op_desc;
+    struct npu_conv_surface_desc conv_surface_desc;
+} conv_extra_data_t;
+
+typedef struct _conv_cmodel_data {
+    conv_program_t conv_prog_desc;
+    u64 conv_extra_desc_addr;
+} conv_cmodel_data_t;
+
+#define CONV_EXTRA_DATA_SIZE (sizeof(struct npu_conv_op_desc) + sizeof(struct npu_conv_surface_desc))
+#else
+#define CONV_EXTRA_DATA_SIZE 0U
+#endif
+
+#define MAX_CONV_PROG_DATA_SIZE (MAX_CONV_PROG_SIZE + CONV_EXTRA_DATA_SIZE)
+
+typedef struct _host_frame_done {
+    u32 param;
+    u32 stat_addr;
+} __attribute__((packed)) host_frame_done_t;
+
+typedef struct _model_stat {
+    npu_e31_perf_t op_stats[MAX_OP_NUM];
+} model_stat_t;
+
+typedef struct _model_op_stat {
+    npu_e31_perf_t op_stats[NUM_OP_TYPE];
+} model_op_stat_t;
+
+typedef struct _cdma_config_param {
+    union npu_cdma_misc_ctl_t misc_ctl;
+    union npu_cdma_misc_cfg0_t misc_cfg0;
+    union npu_cdma_misc_cfg1_t misc_cfg1;
+    union npu_cdma_err_intr_clr_t intr_clr;
+} cdma_config_param_t;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/drivers/soc/eswin/ai_driver/include/hetero_env.h b/drivers/soc/eswin/ai_driver/include/hetero_env.h
new file mode 100644
index 000000000000..107f4ad8e928
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/include/hetero_env.h
@@ -0,0 +1,17 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#ifndef __HETERO_ENV_H__
+#define __HETERO_ENV_H__
+
+// WARN: DO NOT include any header files in this file!
+#define NPU_REAL_ENV 0
+#define NPU_MCU_ALONE 1
+#define NPU_MCU_HOST 2
+#define NPU_ESIM_TOOL 3
+
+#endif
diff --git a/drivers/soc/eswin/ai_driver/include/hetero_host.h b/drivers/soc/eswin/ai_driver/include/hetero_host.h
new file mode 100644
index 000000000000..ca3902116229
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/include/hetero_host.h
@@ -0,0 +1,615 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#ifndef __HETERO_HOST_H__
+#define __HETERO_HOST_H__
+
+#include "conv_regs.h"
+#include "hetero_arch.h"
+#include "hetero_ipc.h"
+#include "hetero_types.h"
+#include "npu_base_regs.h"
+#ifndef __KERNEL__
+#include "hetero_log.h"
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+static const u32 legal_token = 0x6D696E2E;  // the value is the asm of ".nim"
+static const u32 nim_version = 0x0001;
+static const u32 nim_signature = 0x2030;
+
+typedef union pp_status_t {
+    struct {
+        u32 status_0 : 2;
+        u32 : 6;
+        u32 status_1 : 2;
+        u32 : 6;
+        u32 pp_status : 1;
+        u32 : 15;
+    };
+    u32 value;
+} pp_status_t;
+
+typedef struct {
+    /**
+     * @brief Specifies the start of elf session relative to the header of file.
+     *
+     */
+    u32 elf_start;
+
+    /**
+     * @brief Specifies the length in bytes of each elf session.
+     *
+     */
+    u32 elf_len;
+
+    /**
+     * @brief Each bit in this bitmap corresponds to a E31 node. If it is 1, then this elf maps to the target node.
+     *        If the bitmap is 0, then this elf maps to ddr as the bootloader for each E31 node.
+     */
+    u32 node_bitmap;
+} elf_descriptor_t;
+
+typedef struct {
+    /**
+     * @brief .nim file should start with .nim, token corresponds to this value.
+     *
+     */
+    u32 token;
+
+    /**
+     * @brief Specifies file version.
+     *
+     */
+    u32 version;
+
+    /**
+     * @brief Specifies total length of file in bytes.
+     *
+     */
+    u32 total_len;
+
+    /**
+     * @brief Specifies a signature of the whole file.
+     *
+     */
+    u32 signature;
+
+    /**
+     * @brief Specifies number of descriptors in .nim file.
+     *
+     */
+    u32 num_descriptors;
+
+    /**
+     * @brief This descriptor list describes how each elf session should be loaded.
+     *
+     */
+    elf_descriptor_t descriptors[0];
+} nim_header_t;
+
+#if defined(__KERNEL__) && NPU_DEV_SIM == NPU_REAL_ENV
+#include <asm/cacheflush.h>
+#include <linux/delay.h>
+/* ITIM 32k */
+#define E31_CORE_ITIM_BASE_ADDR 0x1800000
+#define E31_CORE_ITIM_MAX_ADDR 0x1808000
+/* DTIM 32k */
+#define E31_CORE_DTIM_BASE_ADDR 0x30000000
+#define E31_CORE_DTIM_MAX_ADDR 0x30008000
+
+/**
+ * According to HW best practice, NPU configuration reset should be treated
+ * specially.
+ */
+#define SW_NPU_CFG_RSTN 1
+
+/**
+ * @brief Activate E31 core with E31 interrupt.
+ *
+ * @param npu_cfg_base_addr     NPU control base address.
+ * @param core_idx              E31 core index.
+ */
+static inline void activate_system(u8 *npu_cfg_base_addr, u32 core_idx)
+{
+    io_write(npu_cfg_base_addr + (NPU_CTRL_OFFSET + INT_SET_BITS(core_idx)), 1U << IRQ_E31_INTER_CORE_COMM);
+}
+
+/**
+ * @brief Reset NPU subsystem.
+ *
+ * @param npu_cfg_base_addr NPU configuration base address.
+ */
+static inline void npu_clk_reset(u8 *npu_cfg_base_addr)
+{
+#ifndef __KERNEL__
+    /* E31's clk&reset already configured in e31_clk_reset_init(). */
+
+    /* Reset SW_NPU_CFG_RSTN first. */
+    io_write(npu_cfg_base_addr + NPU_RST_CTRL, ~(1U << SW_NPU_CFG_RSTN));
+    io_write(npu_cfg_base_addr + NPU_RST_CTRL, 0);
+    io_write(npu_cfg_base_addr + NPU_ACLK_CTRL, 0xC0000020);  // aclk:800M
+    io_write(npu_cfg_base_addr + NPU_LLC_CTRL, 0x80000220);   // llc:800M
+    // 0xC0001212--npu&&e31:1040M   0xC0002012--npu:1040M e31:750M
+    io_write(npu_cfg_base_addr + NPU_CORE_CTRL, 0xC0001212);
+    /* Release SW_NPU_CFG_RSTN last. */
+    io_write(npu_cfg_base_addr + NPU_RST_CTRL, ~(1U << SW_NPU_CFG_RSTN));
+    io_write(npu_cfg_base_addr + NPU_RST_CTRL, 0xFFFFFFFF);
+    /* PMC */
+    io_write(npu_cfg_base_addr + NPU_CLAMP_CTRL, io_read(npu_cfg_base_addr + NPU_CLAMP_CTRL) & (~1U));
+    /* Configure the JTAG chain. */
+    io_write(npu_cfg_base_addr + JTAG_CHAIN_CTRL, 0x39);
+#endif
+    /* Configure scie hardware pattern */
+    io_write(npu_cfg_base_addr + NPU_SCIE_CMD_OFFSET, 1);
+}
+
+/**
+ * @brief Activate E31 bootloader with E31 core num and bootloader entry address.
+ *
+ * @param npu_cfg_base_addr     NPU control base address.
+ * @param core_idx              E31 core index.
+ * @param entry_addr            E31 bootloader entry address.
+ */
+static inline void activate_bootloader(u8 *npu_cfg_base_addr, u32 core_idx, u32 boot_dma_addr)
+{
+    u32 value;
+
+    value = io_read(npu_cfg_base_addr + (NPU_CTRL_OFFSET + NPU_E31_CORE_REST));
+    io_write(npu_cfg_base_addr + (NPU_CTRL_OFFSET + NPU_E31_CORE_REST), set_bit_pos(value, core_idx));
+
+    value = io_read(npu_cfg_base_addr + (NPU_CTRL_OFFSET + NPU_E31_BUS_REST));
+    io_write(npu_cfg_base_addr + (NPU_CTRL_OFFSET + NPU_E31_BUS_REST), clear_bit_pos(value, core_idx));
+
+    value = io_read(npu_cfg_base_addr + (NPU_CTRL_OFFSET + NPU_E31_GPR_REST));
+    io_write(npu_cfg_base_addr + (NPU_CTRL_OFFSET + NPU_E31_GPR_REST), clear_bit_pos(value, core_idx));
+
+    io_write(npu_cfg_base_addr + (NPU_CTRL_OFFSET + RESET_VECTOR_OFFSET(core_idx)), boot_dma_addr);
+    io_write(npu_cfg_base_addr + (NPU_CTRL_OFFSET + JTAG_ID_CODE_OFFSET(core_idx)), (core_idx + 1));
+
+    value = io_read(npu_cfg_base_addr + (NPU_CTRL_OFFSET + NPU_E31_CLOCK_GATE));
+    io_write(npu_cfg_base_addr + (NPU_CTRL_OFFSET + NPU_E31_CLOCK_GATE), set_bit_pos(value, core_idx));
+
+    value = io_read(npu_cfg_base_addr + (NPU_CTRL_OFFSET + NPU_E31_CORE_CLOCK_GATE));
+    io_write(npu_cfg_base_addr + (NPU_CTRL_OFFSET + NPU_E31_CORE_CLOCK_GATE), set_bit_pos(value, core_idx));
+
+    value = io_read(npu_cfg_base_addr + (NPU_CTRL_OFFSET + NPU_E31_CORE_REST));
+    io_write(npu_cfg_base_addr + (NPU_CTRL_OFFSET + NPU_E31_CORE_REST), clear_bit_pos(value, core_idx));
+}
+
+/* elf e_ident */
+#define IS_ELF(ehdr)                                                                                                   \
+    ((ehdr).e_ident[EI_MAG0] == ELFMAG0 && (ehdr).e_ident[EI_MAG1] == ELFMAG1 && (ehdr).e_ident[EI_MAG2] == ELFMAG2 && \
+     (ehdr).e_ident[EI_MAG3] == ELFMAG3)
+
+/**
+ * @brief Check if a valid ELF image exists at the given memory location.
+ * @param addr    Address of the ELF image.
+ * @return        True is valid, false is invalid.
+ */
+static bool validate_elf_image(Elf32_Ehdr *ehdr)
+{
+    if (!IS_ELF(*ehdr)) {
+        printf("No elf image at address %px\n", ehdr);
+        return false;
+    }
+
+    if (ehdr->e_ident[EI_CLASS] == ELFCLASS64) {
+        printf("Not a 32-bit elf image at address %px\n", ehdr);
+        return false;
+    }
+
+    if (ehdr->e_type != ET_EXEC) {
+        printf("Not an execute image at address %px, e_type=0x%x\n", ehdr, ehdr->e_type);
+        return false;
+    }
+
+    return true;
+}
+
+/**
+ * @brief Get ELF text section data.
+ * @param img_addr          Address of the ELF image.
+ * @param entry_addr        Points to the start of text section in ELF file.
+ * @param bootloader_len    Points to the bootloader length variable.
+ * @return                  True if ELF section retrieves successfully.
+ */
+static inline bool get_elf_shdr(u8 *img_addr, u8 **entry_addr, u32 *bootloader_len)
+{
+    Elf32_Ehdr *ehdr;  // elf header structure pointer
+    Elf32_Shdr *shdr;  // section header structure pointer
+    int i;             // loop counter
+
+    ehdr = (Elf32_Ehdr *)img_addr;
+    if (!validate_elf_image(ehdr)) {
+        return false;
+    }
+
+    /* Find the section header string table for output info */
+    shdr = (Elf32_Shdr *)(img_addr + ehdr->e_shoff + (ehdr->e_shstrndx * sizeof(Elf32_Shdr)));
+
+    /* Load each appropriate section */
+    for (i = 0; i < ehdr->e_shnum; ++i) {
+        shdr = (Elf32_Shdr *)(img_addr + ehdr->e_shoff + (i * sizeof(Elf32_Shdr)));
+
+        if (!(shdr->sh_flags & SHF_ALLOC) || shdr->sh_addr == 0 || shdr->sh_size == 0) {
+            continue;
+        }
+        *entry_addr = (u8 *)img_addr + shdr->sh_offset;
+        *bootloader_len = shdr->sh_size;
+        break;
+    }
+
+    return true;
+}
+
+/**
+ * @brief Parse E31 bootloader entry address in ddr.
+ *
+ * @param nim_header        Points to the header of .nim data.
+ * @param entry_addr        Points to the start of text section in ELF file.
+ * @param bootloader_len    Points to the bootloader length variable.
+ * @return                  True means loading bootloader successfully.
+ */
+static inline bool load_bootloader(nim_header_t *nim_header, u8 **entry_addr, u32 *bootloader_len)
+{
+    u8 *img_addr;
+    u32 elf_idx;
+
+    printf("Parse bootloader entry from memory address:%px\n", nim_header);
+    *entry_addr = NULL;
+    *bootloader_len = 0;
+
+    /* Get the bootloader entry address */
+    for (elf_idx = 0; elf_idx != nim_header->num_descriptors; ++elf_idx) {
+        if (nim_header->descriptors[elf_idx].node_bitmap == 0) {
+            // Calculate elf image address
+            img_addr = (u8 *)nim_header + nim_header->descriptors[elf_idx].elf_start;
+            if (!get_elf_shdr(img_addr, entry_addr, bootloader_len)) {
+                printf(".nim elf[%d] load from %px failed\n", elf_idx, img_addr);
+            }
+            break;
+        }
+    }
+
+    printf("E31 bootloader entry_addr=%px, bootloader length=%u.\n", *entry_addr, *bootloader_len);
+    return *entry_addr != NULL;
+}
+
+/**
+ * @brief Verify whether the nim file header is correct.
+ * @param nim_header    Points to the header of .nim data.
+ * @return              True is valid, false is invalid.
+ */
+static inline bool validate_nim_header(nim_header_t *nim_header)
+{
+    if (nim_header->token != legal_token) {
+        printf("Invalid token:0x%x legal_token:0x%x\n", nim_header->token, legal_token);
+        return false;
+    }
+
+    if (nim_header->signature != nim_signature) {
+        printf("Signature:%x (%x) verification failed!\n", nim_header->signature, nim_signature);
+        return false;
+    }
+
+    printf("nim file total_len:%u, num_descriptors:%u\n", nim_header->total_len, nim_header->num_descriptors);
+
+    return true;
+}
+
+/**
+ * @brief Find the boot firmware image inside .nim file.
+ *
+ * @param nim_image         Points to the .nim file image in DDR.
+ * @param bootloader_len    Points to the bootloader length variable.
+ * @return                  The boot firmware image pointer in DDR or NULL if the given part can not be found.
+ */
+static inline u8 *find_boot_firmware(char *nim_image, u32 *bootloader_len)
+{
+    u8 *entry_addr = NULL;
+    nim_header_t *nim_header = NULL;
+
+    /* Let all E31 cores become active. */
+    if (nim_image == NULL) {
+        printf("Invalid input parameters %px\n", nim_image);
+        return NULL;
+    }
+
+    nim_header = (nim_header_t *)nim_image;
+    if (!validate_nim_header(nim_header)) {
+        return NULL;
+    }
+
+    if (!load_bootloader(nim_header, &entry_addr, bootloader_len)) {
+        return NULL;
+    }
+
+    flush_cache_all();
+
+    return entry_addr;
+}
+
+/**
+ * @brief Check if all E31s are activated.
+ *
+ * @param npu_cfg_base_addr     NPU control base address.
+ * @return                      Returns true to indicate system activation
+ *                              status.
+ */
+static inline bool check_system_activated(u8 *npu_cfg_base_addr)
+{
+    /* We must ensure all E31s are activated. */
+    u8 *tim_base_addr = npu_cfg_base_addr + NPU_CPU_OFFSET;
+    u32 remain_bitmap = BITMASK(NUM_NPU_CORES);
+    u32 times = 3;
+    u32 i = 0;
+    u32 index;
+    u32 *signauture_addr;
+
+    while (remain_bitmap != 0) {
+        if (i > times) {
+            printf("check mcu node_sigature failed, remain_bitmap=0x%x.\n", remain_bitmap);
+            return false;
+        }
+        index = ffs(remain_bitmap);
+        signauture_addr = (u32 *)(tim_base_addr + NPU_CPU_SIZE * index + NPU_DTIM_OFFSET);
+        if (*signauture_addr == node_signature) {
+            clear_bit_pos(remain_bitmap, index);
+            printf("E31(%u) validation passed\n", index);
+            i = 0;
+        } else {
+            printf("Wait for E31(%u) validation.\n", index);
+            mdelay(10);
+            i++;
+        }
+    }
+#ifdef LOG_DEBUG
+    printf("All nodes activated.\n");
+#endif
+    return true;
+}
+
+/**
+ * @brief Calculate ITIM or DTIM load address.
+ * @param shdr        ELF section.
+ * @param tim_addr    Address of the ELF destination address.
+ * @return            The section load address.
+ */
+static void *get_tim_load_addr(Elf32_Shdr *shdr, u8 *tim_addr)
+{
+    void *load_addr = NULL;
+
+    if ((E31_CORE_ITIM_BASE_ADDR <= shdr->sh_addr) && ((shdr->sh_addr + shdr->sh_size) <= E31_CORE_ITIM_MAX_ADDR)) {
+        load_addr = (tim_addr + NPU_ITIM_OFFSET) + (shdr->sh_addr - E31_CORE_ITIM_BASE_ADDR);
+    } else if ((E31_CORE_DTIM_BASE_ADDR <= shdr->sh_addr) &&
+               ((shdr->sh_addr + shdr->sh_size) <= E31_CORE_DTIM_MAX_ADDR)) {
+        load_addr = (tim_addr + NPU_DTIM_OFFSET) + (shdr->sh_addr - E31_CORE_DTIM_BASE_ADDR);
+    }
+
+    return load_addr;
+}
+
+/**
+ * @brief Load ELF from DDR to E31 ITIM/ DTIM
+ * @param img_addr    Address of the ELF image.
+ * @param tim_addr    Address of the ELF destination address.
+ * @return            True if ELF data loads successfully.
+ */
+static inline bool load_elf_shdr(u8 *img_addr, u8 *tim_addr)
+{
+    Elf32_Ehdr *ehdr;  // elf header structure pointer
+    Elf32_Shdr *shdr;  // section header structure pointer
+    char *strtab;      // string table pointer
+    char *image;       // binary image pointer
+    int i;             // loop counter
+    void *load_addr;   // load addr
+
+    ehdr = (Elf32_Ehdr *)img_addr;
+    if (!validate_elf_image(ehdr)) {
+        return false;
+    }
+
+    /* Find the section header string table for output info */
+    shdr = (Elf32_Shdr *)(img_addr + ehdr->e_shoff + (ehdr->e_shstrndx * sizeof(Elf32_Shdr)));
+
+    if (shdr->sh_type == SHT_STRTAB) {
+        strtab = (char *)(img_addr + shdr->sh_offset);
+        UNUSED(strtab);
+    }
+
+    /* Load each appropriate section */
+    for (i = 0; i < ehdr->e_shnum; ++i) {
+        shdr = (Elf32_Shdr *)(img_addr + ehdr->e_shoff + (i * sizeof(Elf32_Shdr)));
+
+        // get section name from .shstrtab
+        if (!(shdr->sh_flags & SHF_ALLOC) || shdr->sh_addr == 0 || shdr->sh_size == 0) {
+            continue;
+        }
+
+        load_addr = get_tim_load_addr(shdr, tim_addr);
+        if (load_addr == NULL) {
+            continue;
+        }
+
+        /* load image to ITIM/ DTIM */
+        if (shdr->sh_type == SHT_NOBITS) {
+            // TODO(someone) Temporarily disable memory clean process.
+            // memset(load_addr, 0, shdr->sh_size);
+        } else {
+            image = (char *)img_addr + shdr->sh_offset;
+            memcpy(load_addr, image, shdr->sh_size);
+        }
+    }
+
+    return true;
+}
+
+/**
+ * @brief Load ELF from given memory address in .nim format to ITim and DTim addresses.
+ *
+ * @param nim_header        Points to the header of .nim data.
+ * @param tim_base_addr     Points to the base memory of E31 clusters.
+ * @return                  true means ELF loading completes.
+ */
+static inline bool load_system(nim_header_t *nim_header, u8 *tim_base_addr)
+{
+    u8 *img_addr;
+    u8 *tim_addr;
+    u32 elf_idx;
+    u32 bitmap;
+    u32 core_idx;
+
+    if (nim_header == NULL || tim_base_addr == NULL) {
+        printf("Invalid params!\n");
+        return false;
+    }
+
+    printf("Load ELF from memory address:%px to cpu address:%px\n", nim_header, tim_base_addr);
+
+    /* Load elf to destination address */
+    for (elf_idx = 0; elf_idx < nim_header->num_descriptors; ++elf_idx) {
+        // calculate elf image address
+        img_addr = (u8 *)nim_header + nim_header->descriptors[elf_idx].elf_start;
+
+        bitmap = nim_header->descriptors[elf_idx].node_bitmap;
+        // get position of the only set bit in 'bitmap', and then calculate e31 node tim base address
+        while (bitmap != 0) {
+            core_idx = ffs(bitmap);
+            tim_addr = tim_base_addr + NPU_CPU_SIZE * core_idx;
+            printf("Start to load E31(%u) elf to address:%px\n", core_idx, img_addr);
+            if (!load_elf_shdr(img_addr, tim_addr)) {
+                printf(".nim elf[%d] load from %px failed\n", elf_idx, img_addr);
+                return false;
+            }
+
+            bitmap &= ~(1U << core_idx);
+        }
+    }
+
+    printf("Load image done.\n");
+    return true;
+}
+
+/**
+ * @brief Load firmware to convolution E31 cores. This function can be called in
+ * baremetal or linux environment.
+ *
+ * @param nim_image         Points to the .nim file image in DDR.
+ * @param boot_dma_addr     Provides the DMA address from E31 pespective.
+ * @param npu_ctrl_addr     The NPU ctrl base address.
+ * @param tim_addr          The TIM base address.
+ * @return                  Returns true means loading completes successfully.
+ */
+static inline bool load_firmware_to_conv_cpus(char *nim_image, u32 boot_dma_addr, u8 *npu_cfg_base_addr)
+{
+    u32 core_idx = 0;
+    u8 *tim_base_addr = NULL;
+    nim_header_t *nim_header = NULL;
+
+    if (nim_image == NULL || npu_cfg_base_addr == NULL) {
+        printf("Invalid nim_image:%px or npu_cfg_base_addr:%px\n", nim_image, npu_cfg_base_addr);
+        return false;
+    }
+
+    /* NPU reset and clock initialization. */
+    npu_clk_reset(npu_cfg_base_addr);
+
+    /* Active all e31 bootloaders */
+    for (core_idx = 0; core_idx != NUM_NPU_CORES; ++core_idx) {
+        activate_bootloader(npu_cfg_base_addr, core_idx, boot_dma_addr);
+    }
+
+    nim_header = (nim_header_t *)nim_image;
+    if (!validate_nim_header(nim_header)) {
+        return false;
+    }
+
+    /* Load .nim data. */
+    tim_base_addr = npu_cfg_base_addr + NPU_CPU_OFFSET;
+
+    if (!load_system(nim_header, tim_base_addr)) {
+        return false;
+    }
+
+    return true;
+}
+#endif
+
+static void host_ipc_initialize(u64 host_node_addr, u32 host_node_iova, u64 emission_addr, u64 program_addr)
+{
+    emission_node_t *pemission_node;
+    host_node_t *phost_node = (host_node_t *)host_node_addr;
+    phost_node->emission_base_addr = emission_addr;
+    phost_node->program_base_addr = program_addr;
+
+    pemission_node = (emission_node_t *)phost_node->emission_base_addr;
+    pemission_node->host_base_addr = host_node_iova;
+    hetero_init(phost_node->chn_to_emission, pemission_node->chn_from_host);
+    phost_node->chn_to_emission.channel.peer = ADDR_OFFSET(emission_node_t, chn_from_host);
+}
+
+static inline void *get_npu_ctrl_addr(void *npu_base)
+{
+    return (void *)((u8 *)npu_base + NPU_CTRL_OFFSET);  // NPU_CTRL_BASE_ADDR: 0x51D80000
+}
+
+static void send_frame_ready(u8 tiktok, bool enable_stat, hetero_ipc_frame_t *frame_desc, npu_io_tensor_t *io_tensor,
+                             void *npu_base, host_node_t *host_node)
+{
+    emission_node_t *pemission_node = (emission_node_t *)host_node->emission_base_addr;
+    program_node_t *program_node = (program_node_t *)host_node->program_base_addr;
+    u8 param = tiktok | (enable_stat ? 0x02 : 0x0);
+    msg_payload_t payload = {FRAME_READY, param};
+    memcpy(&pemission_node->frame_desc[tiktok], frame_desc, sizeof(hetero_ipc_frame_t));
+    memcpy(program_node->io_addr_list[tiktok].tensor_addr, io_tensor->tensor_addr, sizeof(io_tensor->tensor_addr));
+    host_hetero_send(&host_node->chn_to_emission, (void *)host_node->emission_base_addr, get_npu_ctrl_addr(npu_base),
+                     payload);
+#ifdef __KERNEL__
+    dla_debug("send msg:{%u,%u} to emission\n", payload.type, payload.param);
+#else
+    printf("send msg:{%u,%u} to emission\n", payload.type, payload.param);
+#endif
+}
+
+static void send_op_resume(u8 tiktok, u16 op_index, void *npu_base, host_node_t *host_node)
+{
+    msg_payload_t payload;
+    payload.type = NOTIFY_OP_RESUME;
+    payload.param = tiktok;
+    payload.lparam = op_index;
+    host_hetero_send(&host_node->chn_to_emission, (void *)host_node->emission_base_addr, get_npu_ctrl_addr(npu_base),
+                     payload);
+#ifdef __KERNEL__
+    dla_debug("send msg:{%u,%u,%u} to emission\n", payload.type, payload.param, payload.lparam);
+#endif
+}
+
+static void send_event_source_req(u8 tiktok, u16 op_index, void *npu_base, host_node_t *host_node)
+{
+    msg_payload_t payload;
+    payload.type = DEC_OP_REF;
+    payload.param = tiktok;
+    payload.param |= IDX_EVENT_SOURCE << 4;
+    payload.lparam = op_index;
+    host_hetero_send(&host_node->chn_to_emission, (void *)host_node->emission_base_addr, get_npu_ctrl_addr(npu_base),
+                     payload);
+#ifdef __KERNEL__
+    dla_debug("send event op msg:{%u,%u,%u} to emission\n", payload.type, payload.param, payload.lparam);
+#else
+    NPU_LOG_DBG("send event op tiktok=%u op_index=%u to emission\n", tiktok, op_index);
+#endif
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  // __HETERO_HOST_H__
diff --git a/drivers/soc/eswin/ai_driver/include/hetero_ioctl.h b/drivers/soc/eswin/ai_driver/include/hetero_ioctl.h
new file mode 100644
index 000000000000..f18e7dd29948
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/include/hetero_ioctl.h
@@ -0,0 +1,311 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#ifndef __HETERO_IOCTL_H_
+#define __HETERO_IOCTL_H_
+
+#include "hetero_types.h"
+#include "es_type.h"
+#include <uapi/linux/es_vb_user.h>
+
+enum {
+    mem_flag_swap,
+    mem_flag_input,
+    mem_flag_output,
+};
+
+/**
+ * struct nvdla_mem_handle structure for memory handles
+ *
+ * @handle		handle to DMA buffer allocated in userspace
+ * @reserved		Reserved for padding
+ * @offset		offset in bytes from start address of buffer
+ *
+ */
+struct nvdla_mem_handle {
+    u32 handle;
+    u32 flag;
+    u32 bind_id;
+    u32 memory_type;
+    u64 offset;
+};
+
+/**
+ * struct nvdla_ioctl_submit_task structure for single task information
+ *
+ * @num_addresses		total number of entries in address_list
+ * @reserved			Reserved for padding
+ * @address_list		pointer to array of struct nvdla_mem_handle
+ *
+ */
+struct nvdla_ioctl_submit_task {
+    u32 num_addresses;
+    u32 timeout;
+    u64 ret;
+    u64 address_list;
+};
+
+/**
+ * struct nvdla_submit_args structure for task submit
+ *
+ * @tasks		pointer to array of struct nvdla_ioctl_submit_task
+ * @num_tasks		number of entries in tasks
+ * @flags		flags for task submit, no flags defined yet
+ * @version		version of task structure
+ *
+ */
+struct nvdla_submit_args {
+    u64 tasks;
+    u16 num_tasks;
+    u16 flags;
+    u32 version;
+};
+
+/** struct win_ioctl_args->mode bit definition
+ * -------------------------------------
+ * | bit [7:4]         | bit [3:0]     |
+ * -------------------------------------
+ * | WIN_EMISSION_MODE | WIN_EXEC_MODE |
+ * -------------------------------------
+ */
+#define emission_mode_bit(m) (m << 4)
+#define get_emission_mode(m) ((m & 0xf0) >> 4)
+#define get_exec_mode(m) (m & 0xf)
+enum WIN_EMISSION_MODE {
+    EMISSION_MODE_STREAM,
+    EMISSION_MODE_STREAM_STEP,
+    EMISSION_MODE_DEP_GRAPH,
+};
+
+enum WIN_IOCTL_CMD {
+    CMD_SUBMIT_MODEL,
+    CMD_RELEASE_MODEL,
+    CMD_COMMIT_NEW_IO_TENSOR,
+    CMD_OUTPUT_GET,
+    CMD_CREATE_STREAM,
+    CMD_SYNC_STREAM,
+    CMD_ABORT_STREAM,
+    CMD_DESTROY_STREAM,
+    CMD_GET_CMA_INFO,
+    WIN_IOCTL_CMD_NUM,
+};
+
+#define TASK_RESULT_ARRAY_NUM 16
+
+enum task_result_status {
+    task_result_success = 1,
+    task_result_failed,
+    task_result_timeout,
+};
+
+struct task_result_t {
+    u32 task_id;
+    enum task_result_status result;
+};
+
+struct tasks_result_t {
+    u32 preserve;
+    u32 task_cnt;
+    struct task_result_t task_result[TASK_RESULT_ARRAY_NUM];
+};
+
+struct npu_cma_info {
+    u64 base;
+    u32 size;
+} __attribute__((aligned(sizeof(u32))));
+
+struct npu_op_dump_list {
+    u16 size;
+    u16 *op_idx_list;
+    char path[64];
+    u32 prcess_id;
+    u16 model_id;
+} __attribute__((aligned(sizeof(u32))));
+
+#define DUMP_PATH_LEN 128
+typedef struct _kmd_dump_info {
+    char path[DUMP_PATH_LEN];
+    u32 process_id;
+    u32 model_id;
+    u16 is_dump_enable;
+    u16 list_size;
+    u16 *op_idx_list;
+} kmd_dump_info_t __attribute__((aligned(sizeof(u32))));
+
+enum kmd_dump_status {
+    kmd_dump_disable = 0,
+    kmd_dump_enable,
+};
+
+union event_union {
+    s16 event_sinks[4];
+    u64 event_data;
+};
+
+struct win_ioctl_args {
+    union {
+        /* For ioctl submit model */
+        u64 shm_fd;
+        /* For ioctl commit new io_tensor and
+         * ioctl Dequeue Frames
+         */
+        struct {
+            union {
+                u32 frame_idx;
+                u32 frame_idx_buff_size;
+            };
+            u16 tensor_size;
+            u8 dump_enable;
+            u64 dump_info;
+        };
+        u16 event_source_val;
+    };
+    u64 data;
+    u64 pret;
+    u32 stream_id;
+    u16 model_idx;
+    u32 version;
+    u32 hetero_cmd;
+};
+
+typedef struct _sram_info {
+    s32 fd;
+    u32 size;
+} sram_info_t;
+
+enum WIN_EXEC_MODE {
+    WIN_MODE_BLOCK,
+    WIN_MODE_NON_BLOCK,
+};
+/* Must 64 bit */
+union win_ioctl_exec_args {
+    struct {
+        u32 rsv0;
+        u16 rsv1;
+        /* block or not*/
+        u8 mode;
+        u8 model_id;
+    };
+    u64 value;
+};
+
+/**
+ * struct nvdla_gem_create_args for allocating DMA buffer through GEM
+ *
+ * @handle		handle updated by kernel after allocation
+ * @flags		implementation specific flags
+ * @size		size of buffer to allocate
+ */
+struct nvdla_gem_create_args {
+    u32 fd;
+    u32 flags;
+    u64 size;
+    void *buffer;
+};
+
+/**
+ * struct nvdla_gem_map_offset_args for mapping DMA buffer
+ *
+ * @handle		handle of the buffer
+ * @reserved		reserved for padding
+ * @offset		offset updated by kernel after mapping
+ */
+struct nvdla_gem_map_offset_args {
+    u32 fd;
+    u32 reserved;
+    u64 offset;
+};
+
+/**
+ * struct nvdla_gem_destroy_args for destroying DMA buffer
+ *
+ * @handle		handle of the buffer
+ */
+struct nvdla_gem_destroy_args {
+    int32_t fd;
+};
+
+struct nvdla_spram_args {
+    u32 addr;
+    u32 len;
+    u8 *buffer;
+};
+
+struct nvdla_reg_args {
+    u32 addr;
+    u32 *buffer;
+    u32 num;
+};
+
+typedef struct _addrDesc {
+    ES_DEV_BUF_S devBuf;
+    int flag;
+    int bindId;
+    void *virtAddr;
+    uint32_t memoryType;
+} addrDesc_t;
+
+typedef struct _addrListDesc {
+    uint32_t numAddress;
+    addrDesc_t addrDesc[0];
+} addrListDesc_t;
+
+typedef struct _modelShmDesc {
+    uint16_t kmdSubModelId;     // kmd submodel id
+    uint32_t kmdNetworkAddrId;  // kmd network address index in model
+    int32_t dspFd[DSP_MAX_CORE_NUM];
+    addrListDesc_t addrList;    // model address list
+} modelShmDesc_t;
+
+typedef struct _modelRec {
+    int32_t dmabufFd;              // dmabuf fd for share memory
+    uint64_t bufLen;               // malloc len for dambufFd
+    modelShmDesc_t *modelShmDesc;  // virt address of dmabuf
+} modelRec_t;
+
+#define ES_NPU_IOCTL_BASE 'n'
+#define ES_NPU_IO(nr) _IO(ES_NPU_IOCTL_BASE, nr)
+#define ES_NPU_IOR(nr, type) _IOR(ES_NPU_IOCTL_BASE, nr, type)
+#define ES_NPU_IOW(nr, type) _IOW(ES_NPU_IOCTL_BASE, nr, type)
+#define ES_NPU_IOWR(nr, type) _IOWR(ES_NPU_IOCTL_BASE, nr, type)
+
+#define ES_NPU_IOCTL_GET_VERSION ES_NPU_IOR(0X00, int)
+#define ES_NPU_IOCTL_GET_PROPERTY ES_NPU_IOR(0X01, int)
+#define ES_NPU_IOCTL_GET_NUM_DEV ES_NPU_IOR(0X02, int)
+
+#define ES_NPU_IOCTL_MODEL_LOAD ES_NPU_IOWR(0X03, int)
+#define ES_NPU_IOCTL_MODEL_UNLOAD ES_NPU_IOWR(0X04, int)
+
+#define ES_NPU_IOCTL_TASK_SUBMIT ES_NPU_IOWR(0X05, int)
+#define ES_NPU_IOCTL_TASKS_GET_RESULT ES_NPU_IOWR(0X06, int)
+#define ES_NPU_IOCTL_HETERO_CMD ES_NPU_IOWR(0x7, int)
+
+#define ES_NPU_IOCTL_GET_EVENT ES_NPU_IOR(0X08, int)
+#define ES_NPU_IOCTL_SET_EVENT ES_NPU_IOWR(0X09, int)
+
+#define ES_NPU_IOCTL_GET_SRAM_FD ES_NPU_IOR(0X0a, int)
+#define ES_NPU_IOCTL_HANDLE_PERF ES_NPU_IOR(0X0b, int)
+#define ES_NPU_IOCTL_GET_PERF_DATA ES_NPU_IOR(0X0c, int)
+
+#define ES_NPU_IOCTL_MUTEX_LOCK ES_NPU_IOR(0X0d, int)
+#define ES_NPU_IOCTL_MUTEX_UNLOCK ES_NPU_IOWR(0X0e, int)
+#define ES_NPU_IOCTL_PREPARE_DMA_BUF ES_NPU_IOWR(0xf, int)
+#define ES_NPU_IOCTL_UNPREPARE_DMA_BUF ES_NPU_IOWR(0x10, int)
+
+#define ES_NPU_IOCTL_UNPREPARE_DMA_BUF ES_NPU_IOWR(0x10, int)
+
+#define NPU_HETERO_CMD_BASE 'h'
+#define NPU_HETERO_IOWR(nr, type) _IOWR(NPU_HETERO_CMD_BASE, nr, type)
+
+#define NPU_HETERO_GET_CMA_INFO NPU_HETERO_IOWR(0x00, int)
+#define NPU_HETERO_QUERY_FRAME_READY NPU_HETERO_IOWR(0x01, int)
+#define NPU_HETERO_SEND_FRAME_DONE NPU_HETERO_IOWR(0x02, int)
+#define NPU_HETERO_QUERY_OP_RESUME NPU_HETERO_IOWR(0x03, int)
+#define NPU_HETERO_SEND_OP_DONE NPU_HETERO_IOWR(0x04, int)
+#define NPU_HETERO_QUERY_EVENT_SOURCE NPU_HETERO_IOWR(0x05, int)
+#define NPU_HETERO_SEND_EVENT_SINK_DONE NPU_HETERO_IOWR(0x06, int)
+#endif
diff --git a/drivers/soc/eswin/ai_driver/include/hetero_ipc.h b/drivers/soc/eswin/ai_driver/include/hetero_ipc.h
new file mode 100644
index 000000000000..791132cfd645
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/include/hetero_ipc.h
@@ -0,0 +1,506 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#ifndef _HETERO_IPC_H_
+#define _HETERO_IPC_H_
+
+#include "hetero_env.h"
+#ifndef __KERNEL__
+#include <string.h>
+#include <stdint.h>
+#endif
+
+#if (NPU_DEV_SIM != NPU_ESIM_TOOL)
+#include "hetero_types.h"
+#include "hetero_common.h"
+#include "npu_base_regs.h"
+#include "conv_regs.h"
+#include "cdma_regs.h"
+#include "hetero_arch.h"
+#include "mailbox_regs.h"
+#endif
+#include "es_dsp_internal.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Define the core ID of each thread. */
+#define EMISSION_CORE_ID 0
+#define PROGRAM_CORE_ID 1
+#define MAJOR_0_CORE_ID 2
+#define MAJOR_1_CORE_ID 3
+#define MAJOR_2_CORE_ID 4
+#define MAJOR_3_CORE_ID 5
+#define MAJOR_4_CORE_ID 6
+#define MAJOR_5_CORE_ID 7
+#define MAJOR_6_CORE_ID 8
+#define MAJOR_7_CORE_ID 9
+#define DSP_0_CORE_ID 10
+#define DSP_1_CORE_ID 11
+#define DSP_2_CORE_ID 12
+#define DSP_3_CORE_ID 13
+/* In the real env, the interrupt register of e31 is only 10bit, per e31 use one bit.
+ * the u84 reuses the 0 bit of emssion core.
+ */
+#if (NPU_DEV_SIM == NPU_REAL_ENV)
+#define HOST_CORE_ID 0
+#else
+#define HOST_CORE_ID 14
+#endif
+
+#define NUM_IPC_CORES 15
+#define HETERO_HW_ID NUM_IPC_CORES
+#define HETERO_SIM_ID 16
+
+#define CDMA_64_BITS_ALIGN 64
+
+#if (NPU_DEV_SIM != NPU_ESIM_TOOL)
+typedef struct _msg_payload {
+    /**
+     *  @brief Specifies the transaction layer protocol.
+     */
+    u8 type;
+    /**
+     *  @brief Specifies the parameter passed to transaction layer handler.
+     */
+    u8 param;
+    /**
+     *  @brief Specifies the long parameter passed to transaction layer handler.
+     */
+    u16 lparam;
+} msg_payload_t;
+
+typedef struct _hetero_signal_channel {
+    volatile u8 produce_index;
+    volatile u8 consume_index;
+    /**
+     *  @brief Specifies the payload size. It should be aligned to 2^N, N should
+     *  be less than 8.
+     */
+    u8 fifo_size;
+    u8 reserved;
+    u32 peer;
+    msg_payload_t payloads[0];
+} hetero_signal_channel_t;
+
+/**
+ *  @brief Defines an instance of heterogeneous channel.
+ *
+ *  @param channel_name:    Specify the name of the channel.
+ *  @param fifo_size:       Specify the size of channel entry size.
+ */
+#define DECLARE_HETERO_CHANNEL(channel_name, fifo_size) \
+    struct {                                            \
+        hetero_signal_channel_t channel;                \
+        msg_payload_t reserved[fifo_size];              \
+    } channel_name;
+
+/**
+ *  @brief Defines an instance array of heterogeneous channel.
+ *
+ *  @param channel_name:    Specify the name of the channel.
+ *  @param fifo_size:       Specify the size of channel entry size.
+ *  @param inst_num:        Specify number of instance.
+ */
+#define DECLARE_HETERO_CHANNELS(channel_name, fifo_size, inst_num) \
+    struct {                                                       \
+        hetero_signal_channel_t channel;                           \
+        msg_payload_t reserved[fifo_size];                         \
+    } channel_name[inst_num];
+
+static const u32 invalid_signature = 0;
+static const u32 node_signature = 0xE31;
+
+typedef struct _cpu_node {
+    u32 signature;
+    u32 node_id;
+} cpu_node_t;
+
+typedef struct _program_node {
+    cpu_node_t cpu_node;
+    /**
+     * @brief Specifies the CDMA slots used for temporarily storing CDMA program
+     * data.
+     */
+    u8 padding[CDMA_64_BITS_ALIGN - sizeof(cpu_node_t)];
+    struct {
+        u32 program_info[MAX_CDMA_PROGRAM_SIZE / sizeof(u32)];
+    } cdma_program_slot[NUM_CDMA_SLOT] __attribute__((aligned(CDMA_SRC_BYTE_ALIGN)));
+
+    // Message header
+    // Sender
+    DECLARE_HETERO_CHANNEL(chn_to_emission, 0)
+    // Receiver
+    DECLARE_HETERO_CHANNEL(chn_from_emission, 16)
+
+    // Message body
+    npu_io_tensor_t io_addr_list[NUM_TIKTOK];
+
+#if NPU_DEV_SIM != NPU_REAL_ENV
+    u64 conv_extra_data_addr[NUM_DATA_SLOT];
+#endif
+} program_node_t;
+
+// program_node_t program_node __attribute__((section(".ipc_ram0")));
+
+typedef struct _emission_node {
+    cpu_node_t cpu_node;
+    u8 padding[CDMA_64_BITS_ALIGN - sizeof(cpu_node_t)];
+    /**
+     * @brief Specifies the dependency information for each operation type. Note
+     * for convolution operator type, conv_dep is used. CDMA is used to transfer
+     * data from DDR to local DTCM.
+     */
+    union {
+        npu_dep_info_t npu_dep[NUM_OP_TYPE - DSP_MAX_CORE_NUM - 1][NUM_DATA_SLOT];
+        struct {
+            // make sure the sequence is correct: edma, conv, sdp, pdp, rubik.
+            npu_dep_info_t edma_dep[NUM_DATA_SLOT];
+            npu_dep_info_t sdp_dep[NUM_DATA_SLOT];
+            npu_dep_info_t pdp_dep[NUM_DATA_SLOT];
+            npu_dep_info_t rubik_dep[NUM_DATA_SLOT];
+            npu_dep_info_t event_sink_dep[NUM_DATA_SLOT];
+            npu_dep_info_t event_source_dep[NUM_DATA_SLOT];
+        };
+    } __attribute__((aligned(CDMA_DST_BYTE_ALIGN)));
+    npu_dep_info_t dsp_dep_transfer;
+    conv_emission_t conv_dep[NUM_DATA_SLOT];
+    npu_dep_info_t dsp_dep[DSP_MAX_CORE_NUM][NUM_DATA_SLOT];
+    /**
+     *  @brief Specifies the IOVA for emission core to access U84.
+     */
+    u32 host_base_addr;
+
+    // Message header
+    // Sender
+    DECLARE_HETERO_CHANNEL(chn_to_program, 0)
+    // Receiver
+    DECLARE_HETERO_CHANNEL(chn_from_host, 2)
+    DECLARE_HETERO_CHANNEL(chn_from_program, 16)
+
+    // Message body
+    hetero_ipc_frame_t frame_desc[NUM_TIKTOK];
+} emission_node_t;
+
+typedef struct _major_node {
+    cpu_node_t cpu_node;
+    u8 padding[CDMA_64_BITS_ALIGN - sizeof(cpu_node_t)];
+    union {
+        rdma_dev_com_inf_t rdma_com;
+        u32 __buffer[MAX_MAJOR_CONFIG_SIZE / sizeof(u32)];
+    } buffer[NUM_DATA_SLOT];
+} major_node_t;
+
+typedef struct _host_node {
+    cpu_node_t cpu_node;
+
+    /**
+     *  @brief Specifies the mapped virtual address for U84 to access program
+     *  core.
+     */
+    u64 program_base_addr;
+
+    /**
+     *  @brief Specifies the mapped virtual address for U84 to access emission
+     *  core.
+     */
+    u64 emission_base_addr;
+
+    // Message header
+    // Sender
+    DECLARE_HETERO_CHANNEL(chn_to_emission, 0)
+    // Receiver
+
+    // Message body
+    /**
+     * @brief Specifies the model statistics data.
+     */
+#if NPU_PERF_STATS > 1
+    model_stat_t model_stat[NUM_TIKTOK];
+#endif
+} host_node_t;
+
+typedef struct _dsp_node {
+    cpu_node_t cpu_node;
+
+    // Message header
+    // Sender
+    DECLARE_HETERO_CHANNEL(chn_to_program, 0)
+    DECLARE_HETERO_CHANNEL(chn_to_emission, 0)
+    // Receiver
+
+    // Message body
+} dsp_node_t;
+
+typedef enum {
+    FRAME_READY = 0,
+    FRAME_DONE,
+
+    /**
+     * @brief Emission core use this message to notify host an operation is
+     * done. If host listen's this message, it should activate procedure that
+     * waits this message.
+     */
+    NOTIFY_OP_DONE,
+    NOTIFY_EVENT_SINK_DONE,
+
+    /**
+     * @brief Host core use this message to notify Emission core to resume
+     * evaluation completion process.
+     */
+    NOTIFY_OP_RESUME,
+
+    /**
+     * @brief Host core use this message to notify Emission core to decrease
+     * reference of a given operator.
+     */
+    DEC_OP_REF,
+    DATA_TRANSFER_REQ,
+    DATA_TRANSFER_DONE,
+    PROGRAM_REQ,
+    PROGRAM_DONE,
+    EVALUATE_REQ,
+    EVALUATE_DONE,
+    PROGRAM_DIR_REQ,
+    PROGRAM_DIR_DONE,
+    DSP_EVAL_DONE
+} CHANNAL_EVENT_TYPE;
+
+#ifndef __KERNEL__
+#if NPU_DEV_SIM == NPU_REAL_ENV
+#if CURRENT_CORE == PROGRAM_CORE_ID
+extern program_node_t local_program_node;
+#define node_id (((cpu_node_t *)&local_program_node)->node_id)
+#elif CURRENT_CORE == EMISSION_CORE_ID
+extern emission_node_t local_emission_node;
+#define node_id (((cpu_node_t *)&local_emission_node)->node_id)
+#else
+STATIC_ASSERT(CURRENT_CORE == MAJOR_0_CORE_ID);
+extern major_node_t local_major_node;
+#define node_id (((cpu_node_t *)&local_major_node)->node_id)
+#endif  // CURRENT_CORE
+extern emission_node_t emission_node;
+
+#else  // NPU_DEV_SIM != NPU_REAL_ENV
+extern TLS u32 node_id;
+extern emission_node_t &emission_node;
+
+#endif  // NPU_DEV_SIM == NPU_REAL_ENV
+static inline void notify_peer_by_intr(u32 peer)
+{
+    u32 peer_node_id = (peer - (u32)(u64)&emission_node) / NPU_CPU_SIZE;
+    reg_write(NPU_CTRL_BASE_ADDR + INT_SET_BITS(peer_node_id), 0x1UL << node_id);
+}
+
+static inline void notify_core_by_intr(u32 peer_core)
+{
+    reg_write(NPU_CTRL_BASE_ADDR + INT_SET_BITS(peer_core), 0x1UL << node_id);
+}
+
+/**
+ * @brief loop check cdma status util cdma done
+ */
+static inline void check_cdma(void)
+{
+    union npu_cdma_misc_ctl_t misc_ctrl;
+    do {
+        misc_ctrl.dw = reg_read(NPU_CDMA_BASE_ADDR + NPU_CDMA_MISC_CTL_OFFSET);
+    } while (misc_ctrl.dma_en);
+}
+
+/**
+ *  @brief Send a message payload to the receiver of this channel, assuming the
+ *  queue is not full. This function should be used by E31 and DSP.
+ *
+ *  @param channel:         Specify the channel port pointer.
+ *  @param payload:         Specify the message payload.
+ */
+static void hetero_send(void *channel, msg_payload_t payload)
+{
+    hetero_signal_channel_t *pchan = (hetero_signal_channel_t *)channel;
+    hetero_signal_channel_t *peer = (hetero_signal_channel_t *)((uintptr_t)pchan->peer);
+
+    while (pchan->produce_index - pchan->consume_index >= pchan->fifo_size) {
+        continue;  // no fifo, wait
+    }
+    check_cdma();
+    peer->payloads[pchan->produce_index & (pchan->fifo_size - 1)] = payload;
+    pchan->produce_index++;
+    peer->produce_index = pchan->produce_index;
+    hmb();
+    notify_peer_by_intr(pchan->peer);
+}
+
+/**
+ *  @brief Receive a message payload from this channel. This function should be
+ *  used by E31.
+ *
+ *  @param channel:         Specify the channel port pointer.
+ *  @param payload:         Specify the message payload to be received.
+ *  @return:                True if a message is received successfully.
+ */
+static bool hetero_receive(void *channel, msg_payload_t *payload)
+{
+    hetero_signal_channel_t *pchan = (hetero_signal_channel_t *)channel;
+    hetero_signal_channel_t *peer = (hetero_signal_channel_t *)((uintptr_t)pchan->peer);
+
+    if (pchan->produce_index == pchan->consume_index) {
+        return false;  // no data in fifo, wait
+    }
+    check_cdma();
+    *payload = pchan->payloads[pchan->consume_index & (pchan->fifo_size - 1)];
+    pchan->consume_index++;
+    peer->consume_index = pchan->consume_index;
+    return true;
+}
+#endif  // __KERNEL__
+
+/**
+ *  @brief Initialize the heterogeneous channel. This function should be called
+ *  inside the core that hold this channel port.
+ *
+ *  @param channel:         Specify the channel port.
+ *  @param peer_channel:    Specify the adversary channel port.
+ */
+
+#define hetero_init(local_channel, peer_channel)                                                          \
+    {                                                                                                     \
+        u32 local_size = (sizeof(local_channel) - sizeof(local_channel.channel)) / sizeof(msg_payload_t); \
+        u32 peer_size = (sizeof(peer_channel) - sizeof(peer_channel.channel)) / sizeof(msg_payload_t);    \
+        u32 fifo_size = local_size > peer_size ? local_size : peer_size;                                  \
+        memset(&local_channel, 0, sizeof(local_channel));                                                 \
+        local_channel.channel.fifo_size = fifo_size;                                                      \
+        local_channel.channel.peer = (u32)(u64) & peer_channel;                                           \
+    }
+
+/**
+ *  @brief Send a message payload to the receiver of this channel, assuming the
+ *  queue is not full. This function should be used by U84.
+ *
+ *  @param channel:         Specify the channel port pointer.
+ *  @param base_addr:       Specify a base address for peer offset.
+ *  @param intr_addr:       Specify the interrupt address to notify e31.
+ *  @param payload:         Specify the message payload.
+ */
+static void host_hetero_send(void *channel, void *base_addr, void *npu_ctrl_addr, msg_payload_t payload)
+{
+    union npu_cdma_misc_ctl_t misc_ctrl;
+    hetero_signal_channel_t *pchan = (hetero_signal_channel_t *)channel;
+    hetero_signal_channel_t *peer = (hetero_signal_channel_t *)((u8 *)base_addr + pchan->peer);
+    while (pchan->produce_index - pchan->consume_index >= pchan->fifo_size) {
+        continue;  // no fifo, wait
+    }
+    do {
+        misc_ctrl.dw =
+            reg_read((size_t)npu_ctrl_addr + NPU_CDMA_BASE_ADDR - NPU_CTRL_BASE_ADDR + NPU_CDMA_MISC_CTL_OFFSET);
+    } while (misc_ctrl.dma_en);
+
+    peer->payloads[pchan->produce_index & (pchan->fifo_size - 1)] = payload;
+    pchan->produce_index++;
+    peer->produce_index = pchan->produce_index;
+
+    reg_write((size_t)((size_t)npu_ctrl_addr + INT_SET_BITS(EMISSION_CORE_ID)), 0x1UL << HOST_CORE_ID);
+}
+
+/**
+ *  @brief Send a mailbox message payload to U84. This function should be used
+ *  by E31.
+ *
+ *  @param channel:         Specify the channel port pointer.
+ *  @param payload:         Specify the message payload to be received.
+ */
+static void messagebox_send(u16 channel_id, msg_payload_t payload)
+{
+    u32 mbox_base, data;
+
+    ASSERT(channel_id == MBOX_CHN_NPU_TO_U84);
+
+    mbox_base = MBOX_REG_BASE + channel_id * MBOX_REG_OFFSET;
+    while (reg_read(mbox_base + MBOX_NPU_FIFO_OFFSET) & 0x1) {
+    }
+
+    data = ((u32)payload.type | (u32)payload.param << 8 | (u32)payload.lparam << 16);
+    reg_write((size_t)(mbox_base + MBOX_NPU_WR_DATA0_OFFSET), data);
+    reg_write((size_t)(mbox_base + MBOX_NPU_WR_DATA1_OFFSET), MBOX_WRITE_FIFO_BIT);
+}
+
+/**
+ *  @brief Send a mailbox message payload to DSP. This function should be used
+ *  by E31.
+ *
+ *  @param op_type:         Specify the dsp operator type.
+ *  @param payload:         Specify the message payload to be received.
+ */
+static void messagebox_send_dsp(u32 op_type, u64 payload)
+{
+    u32 dsp_idx, mbox_base, mbox_int, mbox_lock, timeout;
+
+    ASSERT((op_type == IDX_KMD_DSP0) || (op_type == IDX_KMD_DSP1) || (op_type == IDX_KMD_DSP2) ||
+           (op_type == IDX_KMD_DSP3));
+
+    dsp_idx = op_type - IDX_KMD_DSP0;
+    mbox_base = MAILBOX_E31_TO_DSP_REG[dsp_idx];
+    mbox_int = MAILBOX_E31_TO_DSP_INT[dsp_idx];
+    mbox_lock = (1 << dsp_idx);  // must different with dsp driver(8/10/12/14)
+    timeout = 0;
+
+    // check lock bit and fifo
+    while (1) {
+        reg_write(mbox_base + MBOX_NPU_WR_LOCK, mbox_lock);
+
+        if ((reg_read(mbox_base + MBOX_NPU_WR_LOCK) & mbox_lock) ||
+            (reg_read(mbox_base + MBOX_NPU_FIFO_OFFSET) & 0x1) == 0) {
+            break;
+        }
+
+        if (timeout++ > MBX_LOCK_BIT_TIMEOUT) {
+            return;
+        }
+    }
+
+    // send data
+    reg_write(mbox_base + MBOX_NPU_WR_DATA0_OFFSET, (uint32_t)(payload & 0xFFFFFFFF));
+    reg_write(mbox_base + MBOX_NPU_WR_DATA1_OFFSET, (uint32_t)(payload >> 32) | MBOX_WRITE_FIFO_BIT);
+
+    // enable interrupt
+    reg_write(mbox_base + MBOX_NPU_INT_OFFSET, mbox_int);
+
+    // clear lock bit
+    reg_write(mbox_base + MBOX_NPU_WR_LOCK, 0);
+}
+
+/**
+ * @brief Receives data from a mailbox message.
+ *
+ * @param payload Pointer to the message to receive from u84 or dsp.
+ * @return int Returns 0 on success, or an error code on failure.
+ */
+static bool messagebox_receive_data(msg_payload_t *payload)
+{
+    u32 data[2];
+    /* must be first read rd data0. */
+    data[0] = reg_read(ESWIN_MAILBOX_U84_TO_NPU_0_REG_BASE + MBOX_NPU_RD_DATA0_OFFSET);
+    data[1] = reg_read(ESWIN_MAILBOX_U84_TO_NPU_0_REG_BASE + MBOX_NPU_RD_DATA1_OFFSET);
+    if (data[1] == 0) {
+        return false;
+    }
+
+    memcpy(payload, (msg_payload_t *)&data[0], sizeof(msg_payload_t));
+
+    reg_write(ESWIN_MAILBOX_U84_TO_NPU_0_REG_BASE + MBOX_NPU_RD_DATA1_OFFSET, 0);
+
+    return true;
+}
+
+#endif  // #if (NPU_DEV_SIM != NPU_ESIM_TOOL)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/drivers/soc/eswin/ai_driver/include/hetero_perf.h b/drivers/soc/eswin/ai_driver/include/hetero_perf.h
new file mode 100644
index 000000000000..5b5212e4034a
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/include/hetero_perf.h
@@ -0,0 +1,98 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#ifndef __HETERO_PERF_H__
+#define __HETERO_PERF_H__
+
+#include "hetero_env.h"
+#include "hetero_types.h"
+
+#define NPU_PERF_STATS_DEBUG 0
+#define NPU_PERF_STATS_RELEASE 1
+#define NPU_PERF_STATS_ALL 2
+#define NPU_PERF_STATS_HW 3
+
+#define OPERATOR_NAME_MAXLEN 128
+
+typedef struct _npu_model_perf {
+    u32 APIStartCycle;
+    u32 APIEndCycle;
+} npu_model_perf_t;
+
+typedef struct _npu_umd_perf {
+    u32 Die;
+    u32 OpIndex;
+    u32 OpType;
+    u32 OpStartCycle;
+    u32 OpEndCycle;
+} npu_umd_perf_t;
+
+typedef struct _npu_kmd_perf {
+    u32 Die;
+    u32 OpIndex;
+    u32 OpType;
+    u32 OpStartCycle;
+    u32 OpEndCycle;
+} npu_kmd_perf_t;
+
+typedef struct _npu_e31_perf {
+    u32 Die;
+    u32 OpIndex;
+    u32 OpType;
+    u32 OpStartCycle;
+    u32 OpCdmaStartCycle;
+    u32 OpCdmaEndCycle;
+    u32 OpTransferStartCycle;
+    u32 OpTransferEndCycle;
+    u32 OpProgramStartCycle;
+    u32 OpProgramEndCycle;
+    u32 OpEvalStartCycle;
+    u32 OpEvalEndCycle;
+    u32 OpEndCycle;
+    u32 ConvPecStartCycle;
+    u64 ConvMacPerfCnt;
+
+    // event task timestamp
+    u32 EvtRefStartCycle;
+    u32 EvtRefEndCycle;
+    // u32 EvtTransDoneStartCycle; // OpTransferEndCycle
+    u32 EvtTransDoneEndCycle;
+    // u32 EvtProgDonStartCycle; // OpProgramEndCycle
+    u32 EvtProgDoneEndCycle;
+    // u32 EvtCdmaDoneStartCycle; // OpCdmaEndCycle
+    u32 EvtCdmaDoneEndCycle;
+    u32 EvtEvalDoneStartCycle;
+    u32 EvtEvalDoneEndCycle;
+} npu_e31_perf_t;
+
+typedef struct _dsp_kmd_perf {
+    u32 Die;
+    u32 CoreId;
+    u32 OpIndex;
+    u32 OpType;
+    char OpName[OPERATOR_NAME_MAXLEN];
+    u32 OpStartCycle;
+    u32 OpSendTaskCycle;
+    u32 OpEndCycle;
+} dsp_kmd_perf_t;
+
+typedef struct _dsp_fw_perf {
+    u32 Die;
+    u32 CoreId;
+    u32 OpIndex;
+    u32 OpType;
+    char OpName[OPERATOR_NAME_MAXLEN];
+    u32 OpStartCycle;
+    u32 OpPrepareStartCycle;
+    u32 OpPrepareEndCycle;
+    u32 OpEvalStartCycle;
+    u32 OpEvalEndCycle;
+    u32 OpNotifyStartCycle;
+    u32 OpEndCycle;
+} dsp_fw_perf_t;
+
+#endif
diff --git a/drivers/soc/eswin/ai_driver/include/hetero_processor.h b/drivers/soc/eswin/ai_driver/include/hetero_processor.h
new file mode 100644
index 000000000000..da3b9d3afbdf
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/include/hetero_processor.h
@@ -0,0 +1,48 @@
+// Copyright (c) 2023 ESWIN Authors. All Rights Reserved.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+#ifndef ESWIN_COMMON_HETERO_PROCESSOR_H_
+#define ESWIN_COMMON_HETERO_PROCESSOR_H_
+#include "dla_interface.h"
+
+enum processors_list {
+    IDX_START = DLA_OP_EDMA,
+    IDX_EDMA = DLA_OP_EDMA,
+    IDX_CONV = DLA_OP_CONV,
+    IDX_SDP = DLA_OP_SDP,
+    IDX_PDP = DLA_OP_PDP,
+    IDX_RUBIK = DLA_OP_RUBIK,
+    IDX_KMD_DSP0 = DLA_KMD_OP_DSP_0,
+    IDX_KMD_DSP1 = DLA_KMD_OP_DSP_1,
+    IDX_KMD_DSP2 = DLA_KMD_OP_DSP_2,
+    IDX_KMD_DSP3 = DLA_KMD_OP_DSP_3,
+    IDX_EVENT_SINK = DLA_OP_EVENT_SINK,
+    IDX_EVENT_SOURCE = DLA_OP_EVENT_SOURCE,
+    NUM_OP_TYPE,
+    NUM_KMD_OP_TYPE = NUM_OP_TYPE,
+    IDX_DSP0 = DLA_OP_DSP_0,
+    IDX_DSP1 = DLA_OP_DSP_1,
+    IDX_DSP2 = DLA_OP_DSP_2,
+    IDX_DSP3 = DLA_OP_DSP_3,
+    IDX_HAE = DLA_OP_HAE,
+    IDX_GPU = DLA_OP_GPU,
+    IDX_SWITCH = DLA_OP_SWITCH,
+    IDX_MERGE = DLA_OP_MERGE,
+    NUM_OP_ALL = HW_OP_NUM,
+    IDX_LUT = NUM_OP_TYPE,
+    IDX_LAST_OP = NUM_OP_TYPE - 1,
+    IDX_KMD_LAST_OP = NUM_KMD_OP_TYPE - 1,
+    MAX_KMD_DEPCNT = NUM_OP_TYPE - 3,  // In order to align memory and save space
+    IDX_NONE = 0xFF,
+};
+#endif
diff --git a/drivers/soc/eswin/ai_driver/include/hetero_types.h b/drivers/soc/eswin/ai_driver/include/hetero_types.h
new file mode 100644
index 000000000000..50e8423d264e
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/include/hetero_types.h
@@ -0,0 +1,54 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#ifndef __HETERO_TYPES_H__
+#define __HETERO_TYPES_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define DSP_MAX_CORE_NUM 4
+
+#if __KERNEL__
+#include <linux/types.h>
+#else
+#if __GNUC__
+/*code for GNU C compiler */
+typedef char s8;
+typedef unsigned char u8;
+typedef short int s16;
+typedef unsigned short int u16;
+typedef int s32;
+typedef unsigned int u32;
+typedef long long s64;
+typedef unsigned long long u64;
+
+#ifndef __cplusplus
+typedef u8 bool;
+#define true 1
+#define false 0
+#endif
+
+#elif _MSC_VER
+/*code specific to MSVC compiler*/
+typedef __int8 s8;
+typedef unsigned __int8 u8;
+typedef __int16 s16;
+typedef unsigned __int16 u16;
+typedef __int32 s32;
+typedef unsigned __int32 u32;
+typedef __int64 s64;
+typedef unsigned __int64 u64;
+
+#endif
+#endif  // KERNEL
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/drivers/soc/eswin/ai_driver/include/mailbox_regs.h b/drivers/soc/eswin/ai_driver/include/mailbox_regs.h
new file mode 100644
index 000000000000..e656352821f6
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/include/mailbox_regs.h
@@ -0,0 +1,199 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#ifndef __MAILBOX_REGS_H__
+#define __MAILBOX_REGS_H__
+
+#define BIT0 (1 << 0)
+#define BIT1 (1 << 1)
+#define BIT2 (1 << 2)
+#define BIT3 (1 << 3)
+#define BIT4 (1 << 4)
+#define BIT5 (1 << 5)
+#define BIT6 (1 << 6)
+#define BIT7 (1 << 7)
+#define BIT8 (1 << 8)
+#define BIT9 (1 << 9)
+#define BIT10 (1 << 10)
+#define BIT11 (1 << 11)
+#define BIT12 (1 << 12)
+#define BIT13 (1 << 13)
+#define BIT14 (1 << 14)
+#define BIT31 ((uint32_t)1 << 31)
+
+/**
+ * @brief ESWIN_MAILBOX_REG_BASE 0x50a00000
+ *
+ */
+#define MBOX_REG_BASE 0x50a00000
+
+/**
+ * @brief MBOX_REG_OFFSET 0x10000
+ *
+ */
+#define MBOX_REG_OFFSET 0x10000
+
+/**
+ * @brief ESWIN_MAILBOX_U84_TO_NPU_0_REG_BASE (mailbox 4)
+ *
+ */
+#define ESWIN_MAILBOX_U84_TO_NPU_0_REG_BASE 0x50a40000
+
+/**
+ * @brief ESWIN_MAILBOX_NPU_0_TO_U84_REG_BASE (mailbox 5)
+ *
+ */
+#define ESWIN_MAILBOX_NPU_0_TO_U84_REG_BASE 0x50a50000
+
+/**
+ * @brief ESWIN_MAILBOX_U84_TO_DSP_0_REG_BASE (mailbox 8)
+ *
+ */
+#define ESWIN_MAILBOX_U84_TO_DSP_0_REG_BASE 0x50a80000UL
+
+/**
+ * @brief ESWIN_MAILBOX_U84_TO_DSP_1_REG_BASE (mailbox 10)
+ *
+ */
+#define ESWIN_MAILBOX_U84_TO_DSP_1_REG_BASE 0x50aa0000UL
+
+/**
+ * @brief ESWIN_MAILBOX_U84_TO_DSP_2_REG_BASE (mailbox 12)
+ *
+ */
+#define ESWIN_MAILBOX_U84_TO_DSP_2_REG_BASE 0x50ac0000UL
+
+/**
+ * @brief ESWIN_MAILBOX_U84_TO_DSP_3_REG_BASE (mailbox 14)
+ *
+ */
+#define ESWIN_MAILBOX_U84_TO_DSP_3_REG_BASE 0x50ae0000UL
+
+/**
+ * @brief MBOX_NPU_WR_DATA0_OFFSET
+ *
+ */
+#define MBOX_NPU_WR_DATA0_OFFSET 0
+
+/**
+ * @brief MBOX_NPU_WR_DATA1_OFFSET
+ *
+ */
+#define MBOX_NPU_WR_DATA1_OFFSET 0x4
+
+/**
+ * @brief MBOX_NPU_RD_DATA0_OFFSET
+ *
+ */
+#define MBOX_NPU_RD_DATA0_OFFSET 0x8
+
+/**
+ * @brief MBOX_NPU_RD_DATA1_OFFSET
+ *
+ */
+#define MBOX_NPU_RD_DATA1_OFFSET 0xC
+
+/**
+ * @brief MBOX_NPU_FIFO_OFFSET
+ *
+ */
+#define MBOX_NPU_FIFO_OFFSET 0x10
+
+/**
+ * @brief MBOX_NPU_INT_OFFSET
+ *
+ */
+#define MBOX_NPU_INT_OFFSET 0x18
+
+/**
+ * @brief MBOX_NPU_WR_LOCK
+ *
+ */
+#define MBOX_NPU_WR_LOCK 0x1C
+
+/**
+ * @brief MBOX_NPU_MAX_SIZE 0x80
+ *
+ */
+#define MBOX_NPU_MAX_SIZE 0x80
+
+/**
+ * @brief MBOX_WRITE_FIFO_BIT
+ *
+ */
+#define MBOX_WRITE_FIFO_BIT BIT31
+
+/**
+ * @brief indicate FIFO is empty
+ *
+ */
+#define MBOX_FIFO_STATUS_EMPTY 0x2
+
+/**
+ * @brief Mailbox interrupt to u84
+ *
+ */
+#define MBOX_INT_TO_U84 BIT0
+
+/**
+ * @brief Mailbox interrupt to npu0
+ *
+ */
+#define MBOX_INT_TO_NPU0 BIT3
+
+/**
+ * @brief Mailbox interrupt to npu1
+ *
+ */
+#define MBOX_INT_TO_NPU1 BIT4
+
+/**
+ * @brief Mailbox interrupt to dsp0
+ *
+ */
+#define MBOX_INT_TO_DSP0 BIT5
+
+/**
+ * @brief Mailbox interrupt to dsp1
+ *
+ */
+#define MBOX_INT_TO_DSP1 BIT6
+
+/**
+ * @brief Mailbox interrupt to dsp2
+ *
+ */
+#define MBOX_INT_TO_DSP2 BIT7
+
+/**
+ * @brief Mailbox interrupt to dsp3
+ *
+ */
+#define MBOX_INT_TO_DSP3 BIT8
+
+/**
+ * @brief Mailbox channel
+ *
+ */
+#define MBOX_CHN_NPU_TO_U84 5
+#define MBOX_CHN_NPU_TO_DSP0 8
+#define MBOX_CHN_NPU_TO_DSP1 10
+#define MBOX_CHN_NPU_TO_DSP2 12
+#define MBOX_CHN_NPU_TO_DSP3 14
+
+#define ESWIN_MAILBOX_NPU_LOCK_BIT BIT3
+
+static u32 MAILBOX_E31_TO_DSP_REG[] = {ESWIN_MAILBOX_U84_TO_DSP_0_REG_BASE, ESWIN_MAILBOX_U84_TO_DSP_1_REG_BASE,
+                                       ESWIN_MAILBOX_U84_TO_DSP_2_REG_BASE, ESWIN_MAILBOX_U84_TO_DSP_3_REG_BASE};
+
+static u32 MAILBOX_E31_TO_DSP_INT[] = {MBOX_INT_TO_DSP0, MBOX_INT_TO_DSP1, MBOX_INT_TO_DSP2, MBOX_INT_TO_DSP3};
+
+#define MBOX_INT_BIT_BASE 5
+
+#define MBX_LOCK_BIT_TIMEOUT 60000
+
+#endif
diff --git a/drivers/soc/eswin/ai_driver/include/md5.h b/drivers/soc/eswin/ai_driver/include/md5.h
new file mode 100644
index 000000000000..108f9c740437
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/include/md5.h
@@ -0,0 +1,68 @@
+// Copyright © 2024 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#ifndef MD5_H
+#define MD5_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef __KERNEL__
+#include <stddef.h>
+#include <stdint.h>
+#include <string.h>
+#endif
+
+#define MD5_LENGTH 33
+#define DSP_BUF_NUM 8
+
+typedef struct _conv_md5 {
+    unsigned char wgt_md5[MD5_LENGTH];
+} conv_md5_t;
+typedef struct _sdp_md5 {
+    unsigned char x1_md5[MD5_LENGTH];
+    unsigned char x2_md5[MD5_LENGTH];
+    unsigned char y_md5[MD5_LENGTH];
+} sdp_md5_t;
+typedef struct _dsp_md5 {
+    int16_t src_num;
+    int16_t dst_num;
+    unsigned char src_md5[DSP_BUF_NUM][MD5_LENGTH];
+    unsigned char dst_md5[DSP_BUF_NUM][MD5_LENGTH];
+} dsp_md5_t;
+typedef union _md5_spec {
+    conv_md5_t conv_md5;
+    sdp_md5_t sdp_md5;
+    dsp_md5_t dsp_md5;
+} md5_spec_t;
+
+typedef struct _md5_container {
+    int16_t calced_flag;
+    int16_t writed_flag;
+    uint32_t op_type;
+    unsigned char src_md5[MD5_LENGTH];
+    unsigned char dst_md5[MD5_LENGTH];
+    md5_spec_t md5_spec;
+} md5_container_t;
+
+#define MD5_DIGEST_LEN 16
+
+typedef struct _md5_ctx_t {
+    uint32_t state[4];
+    uint32_t count[2];
+    unsigned char buffer[64];
+} md5_ctx_t;
+
+void MD5Init(md5_ctx_t *context);
+void MD5Update(md5_ctx_t *context, const unsigned char *input, size_t inputLen);
+void MD5Final(unsigned char digest[MD5_DIGEST_LEN], md5_ctx_t *context);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/drivers/soc/eswin/ai_driver/include/npu_base_regs.h b/drivers/soc/eswin/ai_driver/include/npu_base_regs.h
new file mode 100644
index 000000000000..15894d65d304
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/include/npu_base_regs.h
@@ -0,0 +1,382 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#ifndef __NPU_BASE_REGS_H__
+#define __NPU_BASE_REGS_H__
+
+#include "mailbox_regs.h"
+
+#define NPU_TOP_CTRL 0x0
+#define NPU_TOP_INT_STATUS 0x10
+#define NPU_TOP_INT_CLEAR 0x14
+#define NPU_TOP_INT_ENABLE 0x18
+
+#define NPU_QOS_0 0x20
+#define NPU_QOS_SEL 0x30
+
+/**
+ * @brief NPU hardware module indices.
+ *
+ */
+typedef enum type_NPU_MODULE_SEL_ID_E {
+    NPU_MODULE_PEC0_S = 0x0,
+    NPU_MODULE_PEC0_D = 0x1,
+
+    NPU_MODULE_EDMA = 0x110,
+
+    NPU_MODULE_RDMA0_S = 0x112,
+    NPU_MODULE_RDMA0_D = 0x113,
+
+    NPU_MODULE_RDMA_WRAPPER0_S = 0x128,
+    NPU_MODULE_RDMA_WRAPPER0_D = 0x129,
+
+    NPU_MODULE_PRE_DRP_RESHARP_S = 0x130,
+    NPU_MODULE_PRE_DRP_RESHARP_D = 0x131,
+
+    NPU_MODULE_PRE_DRP_WR0_S = 0x132,
+    NPU_MODULE_PRE_DRP_WR0_D = 0x133,
+
+    NPU_MODULE_POST_DRP0_S = 0x13a,
+    NPU_MODULE_POST_DRP0_D = 0x13b,
+
+    NPU_MODULE_POST_DRP_SDP_S = NPU_MODULE_POST_DRP0_S,
+    NPU_MODULE_POST_DRP_SDP_D = NPU_MODULE_POST_DRP0_D,
+    NPU_MODULE_POST_DRP_PDP_S = 0x13c,
+    NPU_MODULE_POST_DRP_PDP_D = 0x13d,
+
+    NPU_MODULE_SDP_RDMA = 0x15a,
+    NPU_MODULE_SDP = 0x15b,
+    NPU_MODULE_PDP_RDMA = 0x15c,
+    NPU_MODULE_PDP = 0x15d,
+    NPU_MODULE_RUBIK = 0x160,
+
+    NPU_MODULE_E21_S = 0x180,
+    NPU_MODULE_CDMA_S = 0x181,
+
+    NPU_MODULE_LLC_0_S = 0x188,
+    NPU_MODULE_LLC_1_S = 0x189,
+
+    NPU_MODULE_MAC_TOP0_S = 0x190,
+    NPU_MODULE_MAC_TOP0_D = 0x191,
+
+    NPU_MODULE_TOP_S = 0x198,
+    NPU_MODULE_TOP_D = 0x199,
+
+    NPU_MODULE_MAX_SIZE = 0x200,
+} NPU_MODULE_SEL_ID_E;
+
+/* NPU system port base address */
+#define NPU_SYS_BASE_ADDR 0x51C00000
+/* NPU configuration base address */
+#define NPU_CFG_BASE_ADDR 0x51828000
+
+/* NPU PP port base address */
+#define NPU_PP_BASE_ADDR 0x20000000
+
+/* NPU sram base address */
+#define NPU_SRAM_BASE_ADDR 0x59000000
+
+/* SYS CON base address */
+#define SYS_CON_BASE_ADDR 0x51810000
+
+/* Power domain management control base address */
+#define PMC_BASE_ADDR 0x51800000
+
+#define PMC_REG_MAX 0x9000
+
+/* SYS CON noc_cfg0 */
+#define SYS_CON_NOC_CFG0 (SYS_CON_BASE_ADDR + CON_NOC_CFG_0)
+
+/* SYS CON test_reg_0 */
+#define SYS_CON_TEST_REG_0 (SYS_CON_BASE_ADDR + CON_TEST_REG_0)
+
+/**
+ * @brief Defines the stride between neighbor modules.
+ *
+ */
+#define NPU_MODULE_STRIDE 0x1000
+
+/**
+ * @brief Defines the hardware instance address range.
+ *
+ */
+#define NPU_HW_ADDR_RANGE (NPU_MODULE_STRIDE * 2)
+
+/**
+ * @brief Defines the module base of each hardware instance.
+ *
+ */
+#define NPU_GET_MODULE_BASE(n) (NPU_SYS_BASE_ADDR + (n)*NPU_MODULE_STRIDE)
+
+/**
+ * @brief Defines the broadcast address offset of RDMAs and PECs.
+ *
+ */
+#define NPU_BROADCAST_OFFSET 0x800
+
+/**
+ * @brief Defines the multicast address offset of PECs.
+ *
+ */
+#define NPU_MULTICAST_OFFSET 0x400
+
+/**
+ * @brief The max sram size 4M.
+ *
+ */
+#define SRAM_BYTE_SIZE 0x400000
+
+/**
+ * @brief The base address of control register space.
+ *
+ */
+#define NPU_CTRL_OFFSET (0x51D80000 - NPU_CFG_BASE_ADDR)
+
+/**
+ * @brief NPU_TOP_CSR_OFFSET
+ *
+ */
+#define NPU_MAPPING_BASE 0x51c00000
+#define NPU_TOP_CSR_OFFSET (NPU_MAPPING_BASE - NPU_CFG_BASE_ADDR + (0x198 << 12))
+
+/**
+ * @brief NPU configuration space range size
+ *
+ */
+#define NPU_CFG_ADDR_RANGE (0x5A920000 - NPU_CFG_BASE_ADDR)
+
+/**
+ * @brief The base address of E31 CPU space.
+ *
+ */
+#define NPU_CPU_BASE_ADDR 0x5A000000
+
+/**
+ * @brief The base address of E31 CPU space.
+ *
+ */
+#define NPU_CPU_OFFSET (NPU_CPU_BASE_ADDR - NPU_CFG_BASE_ADDR)
+
+/**
+ * @brief The size in bytes of each E31 CPU space.
+ *
+ */
+#define NPU_CPU_SIZE 0x00100000
+
+/**
+ * @brief The ITim offset relative to NPU_CPU_BASE_ADDR.
+ *
+ */
+#define NPU_ITIM_OFFSET 0
+
+/**
+ * @brief The DTim offset relative to NPU_CPU_BASE_ADDR.
+ *
+ */
+#define NPU_DTIM_OFFSET 0x10000
+
+/**
+ * @brief The DTim size of each E31 core.
+ *  From npu_metal_master.lds, npu_metal_aux.lds, npu_metal_major.lds
+ */
+#define E31_EMISSION_DTIM_SIZE 0x4000U
+#define E31_PROGRAM_DTIM_SIZE 0x4000U
+#define E31_MAJOR_DTIM_SIZE 0x2000U
+
+/**
+ * @brief The reset and clock gating address register space.
+ *
+ */
+#define NPU_RESET_BASE_ADDR NPU_GET_MODULE_BASE(NPU_MODULE_SYS_RESET)
+
+/**
+ * @brief The base address of configuration DMA register space.
+ *
+ */
+#define NPU_CDMA_BASE_ADDR NPU_GET_MODULE_BASE(NPU_MODULE_CDMA_S)
+
+/**
+ * @brief The base address of control register space.
+ *
+ */
+#define NPU_CTRL_BASE_ADDR NPU_GET_MODULE_BASE(NPU_MODULE_E21_S)
+
+/**
+ * @brief The base address of RDMA register space.
+ *
+ */
+#define NPU_RDMA_S_BASE_ADDR NPU_GET_MODULE_BASE(NPU_MODULE_RDMA0_S)
+#define NPU_RDMA_D_BASE_ADDR NPU_GET_MODULE_BASE(NPU_MODULE_RDMA0_D)
+
+/**
+ * @brief The base address of PEC register space.
+ *
+ */
+#define NPU_PEC_S_BASE_ADDR NPU_GET_MODULE_BASE(NPU_MODULE_PEC0_S)
+#define NPU_PEC_D_BASE_ADDR NPU_GET_MODULE_BASE(NPU_MODULE_PEC0_D)
+
+/**
+ * @brief The base address of PreDRP_WRITE register space.
+ *
+ */
+#define NPU_DRP_WR_S_BASE_ADDR NPU_GET_MODULE_BASE(NPU_MODULE_PRE_DRP_WR0_S)
+#define NPU_DRP_WR_D_BASE_ADDR NPU_GET_MODULE_BASE(NPU_MODULE_PRE_DRP_WR0_D)
+
+/**
+ * @brief The base address of DRP_RESHARP register space.
+ *
+ */
+#define NPU_DRP_RESHARP_S_BASE_ADDR NPU_GET_MODULE_BASE(NPU_MODULE_PRE_DRP_RESHARP_S)
+#define NPU_DRP_RESHARP_D_BASE_ADDR NPU_GET_MODULE_BASE(NPU_MODULE_PRE_DRP_RESHARP_D)
+
+/**
+ * @brief The base address of NPU top register space.
+ *
+ */
+#define NPU_TOP_S_BASE_ADDR NPU_GET_MODULE_BASE(NPU_MODULE_TOP_S)
+#define NPU_TOP_D_BASE_ADDR NPU_GET_MODULE_BASE(NPU_MODULE_TOP_D)
+
+/**
+ * @brief The base address of NPU llc space.
+ *
+ */
+#define NPU_LLC_0_BASE_ADDR NPU_GET_MODULE_BASE(NPU_MODULE_LLC_0_S)
+#define NPU_LLC_1_BASE_ADDR NPU_GET_MODULE_BASE(NPU_MODULE_LLC_1_S)
+
+/**
+ * @brief The base address of NPU MAC register space.
+ *
+ */
+#define NPU_MAC_S_BASE_ADDR NPU_GET_MODULE_BASE(NPU_MODULE_MAC_TOP0_S)
+#define NPU_MAC_D_BASE_ADDR NPU_GET_MODULE_BASE(NPU_MODULE_MAC_TOP0_D)
+
+/**
+ * @brief The base address of NPU RDMA wrapper register space.
+ *
+ */
+#define NPU_RMDA_WRAPPER_S_BASE_ADDR NPU_GET_MODULE_BASE(NPU_MODULE_RDMA_WRAPPER0_S)
+#define NPU_RMDA_WRAPPER_D_BASE_ADDR NPU_GET_MODULE_BASE(NPU_MODULE_RDMA_WRAPPER0_D)
+
+/**
+ * @brief The base address of NPU hardware modules register space.
+ *
+ */
+#define NPU_HW_MODULE_BASE_ADDR NPU_GET_MODULE_BASE(0)
+
+/**
+ * @brief The size in bytes of NPU hardware modules register space.
+ *
+ */
+#define NPU_HW_MODULE_SIZE (NPU_MODULE_STRIDE * NPU_MODULE_MAX_SIZE)
+
+/**
+ * @brief The offset address of npu nvdla.
+ *
+ */
+#define NPU_NVDLA_ADDRESS_OFFSET 0x150000
+
+/**
+ * @brief The int status of npu nvdla.
+ *
+ */
+#define NPU_NVDLA_INT_STATUS 0xc
+
+#define CONV_EDMA_STATUS_ADDR (NPU_MODULE_TOP_S * NPU_MODULE_STRIDE + NPU_TOP_INT_STATUS)
+#define DLA_OP_STATUS_ADDR (NPU_NVDLA_ADDRESS_OFFSET + NPU_NVDLA_INT_STATUS)
+
+/**
+ * @brief Assert the register access address is legal.
+ *
+ */
+#define ASSERT_REG_ADDR(addr)                                                                                   \
+    ASSERT(((addr)-NPU_HW_MODULE_BASE_ADDR) < NPU_HW_MODULE_SIZE || ((addr)-SYS_CON_BASE_ADDR) < CON_REG_MAX || \
+           ((addr)-PMC_BASE_ADDR) < PMC_REG_MAX || ((addr)-ESWIN_MAILBOX_NPU_0_TO_U84_REG_BASE) < MBOX_NPU_MAX_SIZE)
+
+/**
+ * @brief The ssid of write and read operation.
+ *
+ */
+#define NPU_DMA_SSID GENMASK(27, 8)
+
+/**
+ * @brief The sid of write and read operation.
+ *
+ */
+#define NPU_DMA_SID GENMASK(7, 0)  //
+
+/**
+ * @brief NPU_DMA_MMU_RID_REG_OFFSET
+ *
+ */
+#define NPU_DMA_MMU_RID_REG_OFFSET 0x34
+
+/**
+ * @brief NPU_DMA_MMU_WID_REG_OFFSET
+ *
+ */
+#define NPU_DMA_MMU_WID_REG_OFFSET 0x38
+
+/* NPU reset and clock base address */
+
+/**
+ * @brief npu aclk ctrl
+ *
+ */
+#define NPU_ACLK_CTRL (0x51828178 - NPU_CFG_BASE_ADDR)
+
+/**
+ * @brief npu llc ctrl
+ *
+ */
+#define NPU_LLC_CTRL (0x5182817C - NPU_CFG_BASE_ADDR)
+
+/**
+ * @brief npu core ctrl
+ *
+ */
+#define NPU_CORE_CTRL (0x51828180 - NPU_CFG_BASE_ADDR)
+
+/**
+ * @brief npu rst ctrl
+ *
+ */
+#define NPU_RST_CTRL (0x51828418 - NPU_CFG_BASE_ADDR)
+
+/**
+ * @brief NPU clamp control register. Refer to https://ekm.eswincomputing.com/preview.html?fileid=1179453
+ *
+ */
+#define NPU_CLAMP_CTRL (0x518081C4 - NPU_CFG_BASE_ADDR)
+
+/**
+ * @brief Control JTAG chain behaviors. Refer to https://ekm.eswincomputing.com/preview.html?fileid=641149
+ *
+ */
+#define JTAG_CHAIN_CTRL (0x518103BC - NPU_CFG_BASE_ADDR)
+
+/**
+ * @brief The base address of scie hardware pattern.
+ *
+ */
+#define NPU_SCIE_CMD_OFFSET (NPU_CTRL_OFFSET + SCIE_CMD_DEC_MODE)
+
+/********************NPU TOP**********************/
+#define REG_NPU_TOP_INT_STATUS (NPU_TOP_S_BASE_ADDR + NPU_TOP_INT_STATUS)
+#define REG_NPU_TOP_INT_CLEAR (NPU_TOP_S_BASE_ADDR + NPU_TOP_INT_CLEAR)
+
+/****************NPU E31 DTIM***************/
+#define E31_MASTER_DTIM_BASE (NPU_CPU_BASE_ADDR + NPU_DTIM_OFFSET)
+#define HOST2DEV_IPC_BASE_ADDR E31_MASTER_DTIM_BASE
+#define E31_EMISSION_DTIM_BASE (E31_MASTER_DTIM_BASE + NPU_CPU_SIZE * EMISSION_CORE_ID)
+#define E31_PROGRAM_DTIM_BASE (E31_MASTER_DTIM_BASE + NPU_CPU_SIZE * PROGRAM_CORE_ID)
+#define E31_MAJOR_DTIM_BASE(core_id) (E31_MASTER_DTIM_BASE + NPU_CPU_SIZE * (MAJOR_0_CORE_ID + core_id))
+
+#define UART_MUTEX_BASE_ADDR 0x51820000
+#define UART_MUTEX_ADDR_SIZE 0x1000
+#define UART_MUTEX_UNIT_OFFSET 4
+
+#endif
diff --git a/drivers/soc/eswin/ai_driver/include/pdp_regs.h b/drivers/soc/eswin/ai_driver/include/pdp_regs.h
new file mode 100644
index 000000000000..c75e777e3708
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/include/pdp_regs.h
@@ -0,0 +1,136 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#ifndef __PDP_REGS_H__
+#define __PDP_REGS_H__
+
+#if !defined(__KERNEL__)
+#define OFFSET_ADDRESS_NPU_NVDLA 0x150000
+#ifndef _MK_ADDR_CONST
+#define _MK_ADDR_CONST(_constant_) (OFFSET_ADDRESS_NPU_NVDLA + _constant_)
+#endif
+
+#define PDP_S_POINTER_0_PRODUCER_SHIFT (_MK_SHIFT_CONST(0))
+#define PDP_S_POINTER_0 (_MK_ADDR_CONST(0xd004))
+#define PDP_RDMA_S_POINTER_0 (_MK_ADDR_CONST(0xc004))
+
+#define PDP_RDMA_D_DATA_CUBE_IN_WIDTH_0 (_MK_ADDR_CONST(0xc00c))
+#define PDP_RDMA_D_DATA_CUBE_IN_HEIGHT_0 (_MK_ADDR_CONST(0xc010))
+#define PDP_RDMA_D_DATA_CUBE_IN_CHANNEL_0 (_MK_ADDR_CONST(0xc014))
+#define PDP_RDMA_D_SRC_BASE_ADDR_HIGH_0 (_MK_ADDR_CONST(0xc020))
+#define PDP_RDMA_D_SRC_BASE_ADDR_LOW_0 (_MK_ADDR_CONST(0xc01c))
+#define PDP_RDMA_D_SRC_LINE_STRIDE_0 (_MK_ADDR_CONST(0xc024))
+#define PDP_RDMA_D_SRC_SURFACE_STRIDE_0 (_MK_ADDR_CONST(0xc028))
+#define PDP_RDMA_D_DATA_FORMAT_0 (_MK_ADDR_CONST(0xc030))
+#define PDP_RDMA_D_SRC_RAM_CFG_0 (_MK_ADDR_CONST(0xc02c))
+#define PDP_RDMA_D_OPERATION_MODE_CFG_0 (_MK_ADDR_CONST(0xc034))
+#define PDP_RDMA_D_POOLING_KERNEL_CFG_0 (_MK_ADDR_CONST(0xc038))
+#define PDP_RDMA_D_POOLING_PADDING_CFG_0 (_MK_ADDR_CONST(0xc03c))
+#define PDP_RDMA_D_PARTIAL_WIDTH_IN_0 (_MK_ADDR_CONST(0xc040))
+
+#define PDP_D_DATA_CUBE_IN_WIDTH_0 (_MK_ADDR_CONST(0xd00c))
+#define PDP_D_DATA_CUBE_IN_HEIGHT_0 (_MK_ADDR_CONST(0xd010))
+#define PDP_D_DATA_CUBE_IN_CHANNEL_0 (_MK_ADDR_CONST(0xd014))
+#define PDP_D_DATA_CUBE_OUT_WIDTH_0 (_MK_ADDR_CONST(0xd018))
+#define PDP_D_DATA_CUBE_OUT_HEIGHT_0 (_MK_ADDR_CONST(0xd01c))
+#define PDP_D_DATA_CUBE_OUT_CHANNEL_0 (_MK_ADDR_CONST(0xd020))
+#define PDP_D_OPERATION_MODE_CFG_0 (_MK_ADDR_CONST(0xd024))
+#define PDP_D_PARTIAL_WIDTH_IN_0 (_MK_ADDR_CONST(0xd02c))
+#define PDP_D_PARTIAL_WIDTH_OUT_0 (_MK_ADDR_CONST(0xd030))
+#define PDP_D_POOLING_KERNEL_CFG_0 (_MK_ADDR_CONST(0xd034))
+#define PDP_D_RECIP_KERNEL_WIDTH_0 (_MK_ADDR_CONST(0xd038))
+#define PDP_D_RECIP_KERNEL_HEIGHT_0 (_MK_ADDR_CONST(0xd03c))
+#define PDP_D_POOLING_PADDING_CFG_0 (_MK_ADDR_CONST(0xd040))
+#define PDP_D_POOLING_PADDING_VALUE_1_CFG_0 (_MK_ADDR_CONST(0xd044))
+#define PDP_D_POOLING_PADDING_VALUE_2_CFG_0 (_MK_ADDR_CONST(0xd048))
+#define PDP_D_POOLING_PADDING_VALUE_3_CFG_0 (_MK_ADDR_CONST(0xd04c))
+#define PDP_D_POOLING_PADDING_VALUE_4_CFG_0 (_MK_ADDR_CONST(0xd050))
+#define PDP_D_POOLING_PADDING_VALUE_5_CFG_0 (_MK_ADDR_CONST(0xd054))
+#define PDP_D_POOLING_PADDING_VALUE_6_CFG_0 (_MK_ADDR_CONST(0xd058))
+#define PDP_D_POOLING_PADDING_VALUE_7_CFG_0 (_MK_ADDR_CONST(0xd05c))
+
+#define PDP_D_SRC_LINE_STRIDE_0 (_MK_ADDR_CONST(0xd068))
+#define PDP_D_SRC_SURFACE_STRIDE_0 (_MK_ADDR_CONST(0xd06c))
+#define PDP_D_DST_LINE_STRIDE_0 (_MK_ADDR_CONST(0xd078))
+#define PDP_D_DST_SURFACE_STRIDE_0 (_MK_ADDR_CONST(0xd07c))
+#define PDP_D_DST_RAM_CFG_0 (_MK_ADDR_CONST(0xd080))
+#define PDP_D_DATA_FORMAT_0 (_MK_ADDR_CONST(0xd084))
+
+#define PDP_RDMA_D_OP_ENABLE_0 (_MK_ADDR_CONST(0xc008))
+#define PDP_D_OP_ENABLE_0 (_MK_ADDR_CONST(0xd008))
+#endif
+
+/*reg index*/
+enum {
+    D_DATA_CUBE_IN_WIDTH,
+    D_DATA_CUBE_IN_HEIGHT,
+    D_DATA_CUBE_IN_CHANNEL,
+    D_DATA_CUBE_OUT_WIDTH,
+    D_DATA_CUBE_OUT_HEIGHT,
+    D_DATA_CUBE_OUT_CHANNEL,
+    D_OPERATION_MODE_CFG,
+    D_PARTIAL_WIDTH_IN,
+    D_PARTIAL_WIDTH_OUT,
+    D_POOLING_KERNEL_CFG,
+    D_RECIP_KERNEL_WIDTH,
+    D_RECIP_KERNEL_HEIGHT,
+    D_POOLING_PADDING_CFG,
+    D_POOLING_PADDING_VALUE_1_CFG,
+    D_POOLING_PADDING_VALUE_2_CFG,
+    D_POOLING_PADDING_VALUE_3_CFG,
+    D_POOLING_PADDING_VALUE_4_CFG,
+    D_POOLING_PADDING_VALUE_5_CFG,
+    D_POOLING_PADDING_VALUE_6_CFG,
+    D_POOLING_PADDING_VALUE_7_CFG,
+    D_SRC_LINE_STRIDE,
+    D_SRC_SURFACE_STRIDE,
+    D_PDP_DST_LINE_STRIDE,
+    D_PDP_DST_SURFACE_STRIDE,
+    D_PDP_DATA_FORMAT,
+    PDP_REG_MAX,
+};
+
+// pdp_rdma
+
+enum {
+    R_DATA_CUBE_IN_WIDTH,
+    R_DATA_CUBE_IN_HEIGHT,
+    R_DATA_CUBE_IN_CHANNEL,
+    R_SRC_BASE_ADDR_HIGH,
+    R_SRC_BASE_ADDR_LOW,
+    R_SRC_LINE_STRIDE,
+    R_SRC_SURFACE_STRIDE,
+    R_DATA_FORMAT,
+    R_SRC_RAM_CFG,
+    R_OPERATION_MODE_CFG,
+    R_POOLING_KERNEL_CFG,
+    R_POOLING_PADDING_CFG,
+    R_PARTIAL_WIDTH_IN,
+    PDP_RDMA_REG_MAX,
+};
+
+enum {
+    R_PDP_DRP_G_STRIDE_SRAM,
+    R_PDP_DRP_N_STRIDE_SRAM,
+    R_PDP_DRP_H_STRIDE_SRAM,
+    R_PDP_DRP_C_STRIDE_SRAM,
+    R_PDP_DRP_W_EXT_STRIDE,
+    R_PDP_DRP_LAYER_PARA_L,
+    R_PDP_DRP_LAYER_PARA_H,
+    R_PDP_DRP_OMAP_PARA_L,
+    R_PDP_DRP_CTRL,
+    R_PDP_DRP_SPLIT,
+    R_PDP_DRP_PARTIAL_WIDTH,
+    R_PDP_DRP_SRAM_LOOP_PARA_H,
+    R_PDP_DRP_SRAM_LOOP_PARA_L,
+    R_PDP_POST_BASE_ADDR_H,
+    R_PDP_POST_BASE_ADDR_L,
+    D_PDP_POST_DRP_ENABLE,
+    PDP_DRP_REG_MAX,
+};
+
+#endif
diff --git a/drivers/soc/eswin/ai_driver/include/rubik_regs.h b/drivers/soc/eswin/ai_driver/include/rubik_regs.h
new file mode 100644
index 000000000000..a41463b080f4
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/include/rubik_regs.h
@@ -0,0 +1,65 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#ifndef __RUBIK_REGS_H__
+#define __RUBIK_REGS_H__
+
+#if !defined(__KERNEL__)
+#define OFFSET_ADDRESS_NPU_NVDLA 0x150000
+#ifndef _MK_ADDR_CONST
+#define _MK_ADDR_CONST(_constant_) (OFFSET_ADDRESS_NPU_NVDLA + _constant_)
+#endif
+
+#define RBK_S_POINTER_0 (_MK_ADDR_CONST(0x10004))
+
+#define RBK_D_MISC_CFG_0 (_MK_ADDR_CONST(0x1000c))
+#define RBK_D_DAIN_RAM_TYPE_0 (_MK_ADDR_CONST(0x10010))
+#define RBK_D_DATAIN_SIZE_0_0 (_MK_ADDR_CONST(0x10014))
+#define RBK_D_DATAIN_SIZE_1_0 (_MK_ADDR_CONST(0x10018))
+#define RBK_D_DAIN_ADDR_LOW_0 (_MK_ADDR_CONST(0x10020))
+#define RBK_D_DAIN_ADDR_HIGH_0 (_MK_ADDR_CONST(0x1001c))
+#define RBK_D_DAIN_PLANAR_STRIDE_0 (_MK_ADDR_CONST(0x1002c))
+#define RBK_D_DAIN_SURF_STRIDE_0 (_MK_ADDR_CONST(0x10028))
+#define RBK_D_DAIN_LINE_STRIDE_0 (_MK_ADDR_CONST(0x10024))
+#define RBK_D_DAOUT_RAM_TYPE_0 (_MK_ADDR_CONST(0x10030))
+#define RBK_D_DATAOUT_SIZE_1_0 (_MK_ADDR_CONST(0x10034))
+#define RBK_D_DAOUT_ADDR_LOW_0 (_MK_ADDR_CONST(0x1003c))
+#define RBK_D_DAOUT_ADDR_HIGH_0 (_MK_ADDR_CONST(0x10038))
+#define RBK_D_DAOUT_LINE_STRIDE_0 (_MK_ADDR_CONST(0x10040))
+#define RBK_D_DAOUT_SURF_STRIDE_0 (_MK_ADDR_CONST(0x1004c))
+#define RBK_D_CONTRACT_STRIDE_0_0 (_MK_ADDR_CONST(0x10044))
+#define RBK_D_CONTRACT_STRIDE_1_0 (_MK_ADDR_CONST(0x10048))
+#define RBK_D_DECONV_STRIDE_0 (_MK_ADDR_CONST(0x10054))
+#define RBK_D_DAOUT_PLANAR_STRIDE_0 (_MK_ADDR_CONST(0x10050))
+
+#define RBK_D_OP_ENABLE_0 (_MK_ADDR_CONST(0x10008))
+#endif
+
+/*reg index*/
+enum {
+    D_MISC_CFG,
+    D_DAIN_RAM_TYPE,
+    D_DATAIN_SIZE_0,
+    D_DATAIN_SIZE_1,
+    D_DAIN_ADDR_LOW,
+    D_DAIN_ADDR_HIGH,
+    D_DAIN_PLANAR_STRIDE,
+    D_DAIN_SURF_STRIDE,
+    D_DAIN_LINE_STRIDE,
+    D_DAOUT_RAM_TYPE,
+    D_DATAOUT_SIZE_1,
+    D_DAOUT_ADDR_LOW,
+    D_DAOUT_ADDR_HIGH,
+    D_DAOUT_LINE_STRIDE,
+    D_DAOUT_SURF_STRIDE,
+    D_CONTRACT_STRIDE_0,
+    D_CONTRACT_STRIDE_1,
+    D_DECONV_STRIDE,
+    D_DAOUT_PLANAR_STRIDE,
+    RUBIK_REG_MAX,
+};
+#endif
diff --git a/drivers/soc/eswin/ai_driver/include/sdp_regs.h b/drivers/soc/eswin/ai_driver/include/sdp_regs.h
new file mode 100644
index 000000000000..3d782efa8ad7
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/include/sdp_regs.h
@@ -0,0 +1,207 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#ifndef __SDP_REGS_H__
+#define __SDP_REGS_H__
+
+#if !defined(__KERNEL__)
+#define OFFSET_ADDRESS_NPU_NVDLA 0x150000
+#ifndef _MK_ADDR_CONST
+#define _MK_ADDR_CONST(_constant_) (OFFSET_ADDRESS_NPU_NVDLA + _constant_)
+#endif
+
+#define SDP_S_POINTER_0 (_MK_ADDR_CONST(0xb004))
+#define SDP_RDMA_S_POINTER_0 (_MK_ADDR_CONST(0xa004))
+
+#define SDP_D_OP_ENABLE_0 (_MK_ADDR_CONST(0xb038))
+#define SDP_RDMA_D_OP_ENABLE_0 (_MK_ADDR_CONST(0xa008))
+
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0 (_MK_ADDR_CONST(0xa070))
+#define SDP_RDMA_D_BRDMA_CFG_0 (_MK_ADDR_CONST(0xa028))
+#define SDP_RDMA_D_NRDMA_CFG_0 (_MK_ADDR_CONST(0xa040))
+#define SDP_RDMA_D_ERDMA_CFG_0 (_MK_ADDR_CONST(0xa058))
+#define SDP_RDMA_D_DATA_CUBE_WIDTH_0 (_MK_ADDR_CONST(0xa00c))
+#define SDP_RDMA_D_DATA_CUBE_HEIGHT_0 (_MK_ADDR_CONST(0xa010))
+#define SDP_RDMA_D_DATA_CUBE_CHANNEL_0 (_MK_ADDR_CONST(0xa014))
+#define SDP_RDMA_D_SRC_BASE_ADDR_LOW_0 (_MK_ADDR_CONST(0xa018))
+#define SDP_RDMA_D_SRC_BASE_ADDR_HIGH_0 (_MK_ADDR_CONST(0xa01c))
+#define SDP_RDMA_D_SRC_LINE_STRIDE_0 (_MK_ADDR_CONST(0xa020))
+#define SDP_RDMA_D_SRC_SURFACE_STRIDE_0 (_MK_ADDR_CONST(0xa024))
+#define SDP_RDMA_D_SRC_DMA_CFG_0 (_MK_ADDR_CONST(0xa074))
+
+#define SDP_RDMA_D_BS_BASE_ADDR_LOW_0 (_MK_ADDR_CONST(0xa02c))
+#define SDP_RDMA_D_BS_BASE_ADDR_HIGH_0 (_MK_ADDR_CONST(0xa030))
+#define SDP_RDMA_D_BS_LINE_STRIDE_0 (_MK_ADDR_CONST(0xa034))
+#define SDP_RDMA_D_BS_SURFACE_STRIDE_0 (_MK_ADDR_CONST(0xa038))
+#define SDP_RDMA_D_BS_BATCH_STRIDE_0 (_MK_ADDR_CONST(0xa03c))
+
+#define SDP_RDMA_D_BN_BASE_ADDR_LOW_0 (_MK_ADDR_CONST(0xa044))
+#define SDP_RDMA_D_BN_BASE_ADDR_HIGH_0 (_MK_ADDR_CONST(0xa048))
+#define SDP_RDMA_D_BN_LINE_STRIDE_0 (_MK_ADDR_CONST(0xa04c))
+#define SDP_RDMA_D_BN_SURFACE_STRIDE_0 (_MK_ADDR_CONST(0xa050))
+#define SDP_RDMA_D_BN_BATCH_STRIDE_0 (_MK_ADDR_CONST(0xa054))
+
+#define SDP_RDMA_D_EW_BASE_ADDR_LOW_0 (_MK_ADDR_CONST(0xa05c))
+#define SDP_RDMA_D_EW_BASE_ADDR_HIGH_0 (_MK_ADDR_CONST(0xa060))
+#define SDP_RDMA_D_EW_LINE_STRIDE_0 (_MK_ADDR_CONST(0xa064))
+#define SDP_RDMA_D_EW_SURFACE_STRIDE_0 (_MK_ADDR_CONST(0xa068))
+#define SDP_RDMA_D_EW_BATCH_STRIDE_0 (_MK_ADDR_CONST(0xa06c))
+
+#define SDP_D_DATA_CUBE_WIDTH_0 (_MK_ADDR_CONST(0xb03c))
+#define SDP_D_DATA_CUBE_HEIGHT_0 (_MK_ADDR_CONST(0xb040))
+#define SDP_D_DATA_CUBE_CHANNEL_0 (_MK_ADDR_CONST(0xb044))
+#define SDP_D_DST_BASE_ADDR_HIGH_0 (_MK_ADDR_CONST(0xb04c))
+#define SDP_D_DST_BASE_ADDR_LOW_0 (_MK_ADDR_CONST(0xb048))
+#define SDP_D_DST_LINE_STRIDE_0 (_MK_ADDR_CONST(0xb050))
+#define SDP_D_DST_SURFACE_STRIDE_0 (_MK_ADDR_CONST(0xb054))
+#define SDP_D_DP_BS_CFG_0 (_MK_ADDR_CONST(0xb058))
+#define SDP_D_DP_BS_ALU_CFG_0 (_MK_ADDR_CONST(0xb05c))
+#define SDP_D_DP_BS_ALU_SRC_VALUE_0 (_MK_ADDR_CONST(0xb060))
+#define SDP_D_DP_BS_MUL_SRC_VALUE_0 (_MK_ADDR_CONST(0xb068))
+#define SDP_D_DP_BS_MUL_CFG_0 (_MK_ADDR_CONST(0xb064))
+#define SDP_D_DP_BN_CFG_0 (_MK_ADDR_CONST(0xb06c))
+#define SDP_D_DP_BN_ALU_CFG_0 (_MK_ADDR_CONST(0xb070))
+#define SDP_D_DP_BN_ALU_SRC_VALUE_0 (_MK_ADDR_CONST(0xb074))
+#define SDP_D_DP_BN_MUL_SRC_VALUE_0 (_MK_ADDR_CONST(0xb07c))
+#define SDP_D_DP_BN_MUL_CFG_0 (_MK_ADDR_CONST(0xb078))
+#define SDP_D_DP_EW_CFG_0 (_MK_ADDR_CONST(0xb080))
+#define SDP_D_DP_EW_ALU_CFG_0 (_MK_ADDR_CONST(0xb084))
+#define SDP_D_DP_EW_ALU_SRC_VALUE_0 (_MK_ADDR_CONST(0xb088))
+#define SDP_D_DP_EW_ALU_CVT_OFFSET_VALUE_0 (_MK_ADDR_CONST(0xb08c))
+#define SDP_D_DP_EW_ALU_CVT_SCALE_VALUE_0 (_MK_ADDR_CONST(0xb090))
+#define SDP_D_DP_EW_ALU_CVT_TRUNCATE_VALUE_0 (_MK_ADDR_CONST(0xb094))
+#define SDP_D_DP_EW_MUL_CFG_0 (_MK_ADDR_CONST(0xb098))
+#define SDP_D_DP_EW_MUL_SRC_VALUE_0 (_MK_ADDR_CONST(0xb09c))
+#define SDP_D_DP_EW_MUL_CVT_OFFSET_VALUE_0 (_MK_ADDR_CONST(0xb0a0))
+#define SDP_D_DP_EW_MUL_CVT_SCALE_VALUE_0 (_MK_ADDR_CONST(0xb0a4))
+#define SDP_D_DP_EW_MUL_CVT_TRUNCATE_VALUE_0 (_MK_ADDR_CONST(0xb0a8))
+#define SDP_D_DP_EW_TRUNCATE_VALUE_0 (_MK_ADDR_CONST(0xb0ac))
+
+#define SDP_D_FEATURE_MODE_CFG_0 (_MK_ADDR_CONST(0xb0b0))
+#define SDP_D_DST_DMA_CFG_0 (_MK_ADDR_CONST(0xb0b4))
+#define SDP_D_DST_BATCH_STRIDE_0 (_MK_ADDR_CONST(0xb0b8))
+#define SDP_D_DATA_FORMAT_0 (_MK_ADDR_CONST(0xb0bc))
+#define SDP_D_CVT_OFFSET_0 (_MK_ADDR_CONST(0xb0c0))
+#define SDP_D_CVT_SCALE_0 (_MK_ADDR_CONST(0xb0c4))
+#define SDP_D_CVT_SHIFT_0 (_MK_ADDR_CONST(0xb0c8))
+
+// LUT register define
+#define SDP_S_LUT_ACCESS_CFG_0 (_MK_ADDR_CONST(0xb008))
+#define SDP_S_LUT_ACCESS_DATA_0 (_MK_ADDR_CONST(0xb00c))
+#define SDP_S_LUT_CFG_0 (_MK_ADDR_CONST(0xb010))
+#define SDP_S_LUT_INFO_0 (_MK_ADDR_CONST(0xb014))
+#define SDP_S_LUT_LE_START_0 (_MK_ADDR_CONST(0xb018))
+#define SDP_S_LUT_LE_END_0 (_MK_ADDR_CONST(0xb01c))
+#define SDP_S_LUT_LO_START_0 (_MK_ADDR_CONST(0xb020))
+#define SDP_S_LUT_LO_END_0 (_MK_ADDR_CONST(0xb024))
+#define SDP_S_LUT_LE_SLOPE_SCALE_0 (_MK_ADDR_CONST(0xb028))
+#define SDP_S_LUT_LO_SLOPE_SCALE_0 (_MK_ADDR_CONST(0xb030))
+#define SDP_S_LUT_LE_SLOPE_SHIFT_0 (_MK_ADDR_CONST(0xb02c))
+#define SDP_S_LUT_LO_SLOPE_SHIFT_0 (_MK_ADDR_CONST(0xb034))
+
+#define LUT_LINEAR_EXP_TABLE_ENTRY_LOG2 6
+#define SDP_S_LUT_ACCESS_DATA_OFFSET (_MK_ADDR_CONST(0x0004))
+
+static const u32 SWITCH_RAW_TAB = 0x20000;
+static const u32 SWITCH_DENSTIY_TAB = 0x30000;
+#endif
+/*reg index*/
+enum {
+    // all values should be configured. default as 0x0;
+    // should post-drp be included?
+    D_DATA_CUBE_WIDTH,
+    D_DATA_CUBE_HEIGHT,
+    D_DATA_CUBE_CHANNEL,
+    D_DST_BASE_ADDR_HIGH,
+    D_DST_BASE_ADDR_LOW,
+    D_DST_LINE_STRIDE,
+    D_DST_SURFACE_STRIDE,
+    D_DP_BS_CFG,
+    D_DP_BS_ALU_CFG,
+    D_DP_BS_ALU_SRC_VALUE,
+    D_DP_BS_MUL_SRC_VALUE,
+    D_DP_BS_MUL_CFG,
+    D_DP_BN_CFG,
+    D_DP_BN_ALU_CFG,
+    D_DP_BN_ALU_SRC_VALUE,
+    D_DP_BN_MUL_SRC_VALUE,
+    D_DP_BN_MUL_CFG,
+    D_DP_EW_CFG,
+    D_DP_EW_ALU_CFG,
+    D_DP_EW_ALU_SRC_VALUE,
+    D_DP_EW_ALU_CVT_OFFSET_VALUE,
+    D_DP_EW_ALU_CVT_SCALE_VALUE,
+    D_DP_EW_ALU_CVT_TRUNCATE_VALUE,
+    D_DP_EW_MUL_CFG,
+    D_DP_EW_MUL_SRC_VALUE,
+    D_DP_EW_MUL_CVT_OFFSET_VALUE,
+    D_DP_EW_MUL_CVT_SCALE_VALUE,
+    D_DP_EW_MUL_CVT_TRUNCATE_VALUE,
+    D_DP_EW_TRUNCATE_VALUE,
+    D_FEATURE_MODE_CFG,
+    D_DST_DMA_CFG,
+    D_DST_BATCH_STRIDE,
+    D_DATA_FORMAT,
+    D_CVT_OFFSET,
+    D_CVT_SCALE,
+    D_CVT_SHIFT,
+    SDP_REG_MAX,
+};
+
+enum {
+    // 15 regs for sdp_post_drp
+    DRP_D_REG_G_STRIDE_SRAM = 0,
+    DRP_D_REG_N_STRIDE_SRAM,
+    DRP_D_REG_H_STRIDE_SRAM,
+    DRP_D_REG_C_STRIDE_SRAM,
+    DRP_D_REG_W_EXT_STRIDE,
+    DRP_D_REG_LAYER_PARA_L,
+    DRP_D_REG_LAYER_PARA_H,
+    DRP_D_REG_OMAP_PARA_L,
+    DRP_D_REG_CTRL,
+    DRP_D_REG_SPLIT,
+    DRP_D_REG_PARTIAL_WIDTH,
+    DRP_D_REG_SRAM_LOOP_PARA_H,
+    DRP_D_REG_SRAM_LOOP_PARA_L,
+    DRP_D_REG_BASE_ADDR_H,
+    DRP_D_REG_BASE_ADDR_L,
+    DRP_D_REG_OP_EN_TRIG,
+    POST_DRP_REG_MAX,
+};
+
+// sdp_rdma
+enum {
+    SDP_RDMA_D_DATA_CUBE_WIDTH,
+    SDP_RDMA_D_DATA_CUBE_HEIGHT,
+    SDP_RDMA_D_DATA_CUBE_CHANNEL,
+    SDP_RDMA_D_SRC_BASE_ADDR_LOW,
+    SDP_RDMA_D_SRC_BASE_ADDR_HIGH,
+    SDP_RDMA_D_SRC_LINE_STRIDE,
+    SDP_RDMA_D_SRC_SURFACE_STRIDE,
+    SDP_RDMA_D_BRDMA_CFG,
+    SDP_RDMA_D_NRDMA_CFG,
+    SDP_RDMA_D_BS_BASE_ADDR_LOW,
+    SDP_RDMA_D_BS_BASE_ADDR_HIGH,
+    SDP_RDMA_D_BS_LINE_STRIDE,
+    SDP_RDMA_D_BS_SURFACE_STRIDE,
+    SDP_RDMA_D_BS_BATCH_STRIDE,
+    SDP_RDMA_D_BN_BASE_ADDR_LOW,
+    SDP_RDMA_D_BN_BASE_ADDR_HIGH,
+    SDP_RDMA_D_BN_LINE_STRIDE,
+    SDP_RDMA_D_BN_SURFACE_STRIDE,
+    SDP_RDMA_D_BN_BATCH_STRIDE,
+    SDP_RDMA_D_ERDMA_CFG,
+    SDP_RDMA_D_EW_BASE_ADDR_LOW,
+    SDP_RDMA_D_EW_BASE_ADDR_HIGH,
+    SDP_RDMA_D_EW_LINE_STRIDE,
+    SDP_RDMA_D_EW_SURFACE_STRIDE,
+    SDP_RDMA_D_EW_BATCH_STRIDE,
+    SDP_RDMA_D_FEATURE_MODE_CFG,
+    SDP_RDMA_D_SRC_DMA_CFG,
+    SDP_RDMA_REG_MAX,
+};
+#endif
diff --git a/drivers/soc/eswin/ai_driver/include/sys_regs.h b/drivers/soc/eswin/ai_driver/include/sys_regs.h
new file mode 100644
index 000000000000..568df49362bb
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/include/sys_regs.h
@@ -0,0 +1,30 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#ifndef __SYSTEM_REGS_H__
+#define __SYSTEM_REGS_H__
+
+/**
+ * @brief SYS CON register indices.
+ *
+ */
+typedef enum type_SYS_CON_REG_E {
+    CON_DYNM_CSR_EN = 0x0000,
+    CON_NOC_CFG_0 = 0x0324,
+    CON_TEST_REG_0 = 0x0668,
+    CON_SEC_SID = 0x4004,
+
+    CON_REG_MAX,
+} SYS_CON_REG_E;
+
+typedef enum type_NPU_LLC_E {
+    NPU_LLC_0 = 0,
+    NPU_LLC_1 = 1,
+    NPU_LLC_MAX,
+} NPU_LLC_E;
+
+#endif
diff --git a/drivers/soc/eswin/ai_driver/npu/Makefile b/drivers/soc/eswin/ai_driver/npu/Makefile
new file mode 100644
index 000000000000..bcf99a489815
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/npu/Makefile
@@ -0,0 +1,54 @@
+﻿NPU_PERF_STATS ?= 0
+LOG_LEVEL ?= 0
+NPU_DEV_SIM ?= 0
+SMALL_PEC_MAT ?= 0
+
+ccflags-y += -I$(src)
+ccflags-y += -I$(srctree)/drivers/soc/eswin
+ccflags-y += -I$(srctree)/drivers/memory/eswin/codacache/
+ccflags-y += -I$(srctree)/$(src)/include
+ccflags-y += -I$(srctree)/$(src)/../dsp
+ccflags-y += -I$(srctree)/$(src)/../include
+
+ccflags-y += -DNPU_DEV_SIM=$(NPU_DEV_SIM)
+ccflags-y += -DENABLE_PROGRAM_CORE=$(ENABLE_PROGRAM_CORE)
+ccflags-y += -DDUAL_DIE=$(DUAL_DIE)
+ccflags-y += -DSMALL_PEC_MAT=$(SMALL_PEC_MAT)
+ccflags-y += -DNPU_DRV_SUPPORT_DSP=$(NPU_DSP_MODULE)
+ccflags-y += -DNPU_PERF_STATS=$(NPU_PERF_STATS)
+ccflags-y += -DNPU_DBG
+#ccflags-y += -DCONV_DUMP
+ccflags-y += -DLOG_LEVEL=$(LOG_LEVEL)
+ccflags-y += -Wno-unused-function
+ccflags-y += -Werror
+ccflags-y += -Wno-int-to-pointer-cast
+
+obj-$(CONFIG_ESWIN_NPU) += eic7700_npu.o
+eic7700_npu-y := edma.o \
+		engine.o \
+		npu_main.o \
+		pdp.o \
+		common.o \
+		rubik.o \
+		sdp.o \
+		conv.o \
+		debug.o \
+		dla_log.o \
+		npu_spram.o \
+		dla_driver.o \
+		user_context.o   \
+		parse_dep.o   \
+		scheduler.o   \
+		npu_frame.o \
+		dla_buffer.o \
+		event.o	\
+		nvdla_proc.o \
+		dsp.o
+
+ifeq ($(NPU_DEV_SIM), 0)
+eic7700_npu-y += npu_e31.o
+eic7700_npu-y += nvdla_hw.o
+else
+eic7700_npu-y += nvdla_sim.o
+endif
+
diff --git a/drivers/soc/eswin/ai_driver/npu/common.c b/drivers/soc/eswin/ai_driver/npu/common.c
new file mode 100644
index 000000000000..8089e861907d
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/npu/common.c
@@ -0,0 +1,123 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#include <opendla.h>
+#include <dla_err.h>
+#include <dla_interface.h>
+#include "common.h"
+#include "dla_engine_internal.h"
+#include "dla_log.h"
+#include "dla_driver.h"
+
+static const uint8_t map_lut_method[] = {
+	FIELD_ENUM(CDP_S_LUT_CFG_0, LUT_LE_FUNCTION, EXPONENT),
+	FIELD_ENUM(CDP_S_LUT_CFG_0, LUT_LE_FUNCTION, LINEAR)
+};
+static const uint8_t map_lut_out[] = {
+	FIELD_ENUM(CDP_S_LUT_CFG_0, LUT_UFLOW_PRIORITY, LE),
+	FIELD_ENUM(CDP_S_LUT_CFG_0, LUT_UFLOW_PRIORITY, LO)
+};
+
+static const uint16_t access_data_offset[] = {
+	CDP_S_LUT_ACCESS_DATA_0 - CDP_S_LUT_ACCESS_CFG_0,
+	SDP_S_LUT_ACCESS_DATA_0 - SDP_S_LUT_ACCESS_CFG_0,
+};
+static const uint16_t lut_cfg_offset[] = {
+	CDP_S_LUT_CFG_0 - CDP_S_LUT_ACCESS_CFG_0,
+	SDP_S_LUT_CFG_0 - SDP_S_LUT_ACCESS_CFG_0,
+};
+static const uint16_t lut_info_offset[] = {
+	CDP_S_LUT_INFO_0 - CDP_S_LUT_ACCESS_CFG_0,
+	SDP_S_LUT_INFO_0 - SDP_S_LUT_ACCESS_CFG_0,
+};
+static const uint16_t le_start_offset[] = {
+	CDP_S_LUT_LE_START_LOW_0 - CDP_S_LUT_ACCESS_CFG_0,
+	SDP_S_LUT_LE_START_0 - SDP_S_LUT_ACCESS_CFG_0,
+};
+static const uint16_t le_end_offset[] = {
+	CDP_S_LUT_LE_END_LOW_0 - CDP_S_LUT_ACCESS_CFG_0,
+	SDP_S_LUT_LE_END_0 - SDP_S_LUT_ACCESS_CFG_0,
+};
+static const uint16_t lo_start_offset[] = {
+	CDP_S_LUT_LO_START_LOW_0 - CDP_S_LUT_ACCESS_CFG_0,
+	SDP_S_LUT_LO_START_0 - SDP_S_LUT_ACCESS_CFG_0,
+};
+static const uint16_t lo_end_offset[] = {
+	CDP_S_LUT_LO_END_LOW_0 - CDP_S_LUT_ACCESS_CFG_0,
+	SDP_S_LUT_LO_END_0 - SDP_S_LUT_ACCESS_CFG_0,
+};
+static const uint16_t le_slope_scale_offset[] = {
+	CDP_S_LUT_LE_SLOPE_SCALE_0 - CDP_S_LUT_ACCESS_CFG_0,
+	SDP_S_LUT_LE_SLOPE_SCALE_0 - SDP_S_LUT_ACCESS_CFG_0,
+};
+static const uint16_t le_slope_shift_offset[] = {
+	CDP_S_LUT_LE_SLOPE_SHIFT_0 - CDP_S_LUT_ACCESS_CFG_0,
+	SDP_S_LUT_LE_SLOPE_SHIFT_0 - SDP_S_LUT_ACCESS_CFG_0,
+};
+static const uint16_t lo_slope_scale_offset[] = {
+	CDP_S_LUT_LO_SLOPE_SCALE_0 - CDP_S_LUT_ACCESS_CFG_0,
+	SDP_S_LUT_LO_SLOPE_SCALE_0 - SDP_S_LUT_ACCESS_CFG_0,
+};
+static const uint16_t lo_slope_shift_offset[] = {
+	CDP_S_LUT_LO_SLOPE_SHIFT_0 - CDP_S_LUT_ACCESS_CFG_0,
+	SDP_S_LUT_LO_SLOPE_SHIFT_0 - SDP_S_LUT_ACCESS_CFG_0,
+};
+
+int validate_data_cube(struct dla_data_cube *src_data_cube,
+		       struct dla_data_cube *dst_data_cube, uint8_t mem_type)
+{
+	int32_t ret = 0;
+
+	if ((src_data_cube->width > DCUBE_MAX_WIDTH) ||
+	    (src_data_cube->height > DCUBE_MAX_HEIGHT) ||
+	    (src_data_cube->channel > DCUBE_MAX_CHANNEL)) {
+		dla_error("Invalid SrcInput Cude[W: %u, H: %u, C: %u]",
+			  src_data_cube->width, src_data_cube->height,
+			  src_data_cube->channel);
+		ret = ERR(INVALID_INPUT);
+		goto exit;
+	}
+
+	if ((dst_data_cube->width > DCUBE_MAX_WIDTH) ||
+	    (dst_data_cube->height > DCUBE_MAX_HEIGHT) ||
+	    (dst_data_cube->channel > DCUBE_MAX_CHANNEL)) {
+		dla_error("Invalid DstInput Cude[W: %u, H: %u, C: %u]",
+			  dst_data_cube->width, dst_data_cube->height,
+			  dst_data_cube->channel);
+		ret = ERR(INVALID_INPUT);
+		goto exit;
+	}
+
+	if (src_data_cube->type > mem_type) {
+		dla_error("Invalid src_data.mem_type: %u\n",
+			  src_data_cube->type);
+		ret = ERR(INVALID_INPUT);
+		goto exit;
+	}
+
+	if (dst_data_cube->type > mem_type) {
+		dla_error("Invalid dst_data.mem_type: %u\n",
+			  dst_data_cube->type);
+		ret = ERR(INVALID_INPUT);
+		goto exit;
+	}
+
+exit:
+	return ret;
+}
+
+int validate_precision(uint8_t precision, uint8_t map_precision)
+{
+	int32_t ret = 0;
+
+	if (precision >= map_precision) {
+		dla_error("Invalid precision: %u\n", precision);
+		ret = ERR(INVALID_INPUT);
+	}
+
+	return ret;
+}
diff --git a/drivers/soc/eswin/ai_driver/npu/common.h b/drivers/soc/eswin/ai_driver/npu/common.h
new file mode 100644
index 000000000000..0c73e1ed235c
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/npu/common.h
@@ -0,0 +1,22 @@
+// Copyright © 2024 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#ifndef __FIRMWARE_COMMON_H_
+#define __FIRMWARE_COMMON_H_
+
+#include <dla_interface.h>
+
+#define DCUBE_MAX_WIDTH 8192
+#define DCUBE_MAX_HEIGHT 8192
+#define DCUBE_MAX_CHANNEL 8192
+
+int32_t validate_data_cube(struct dla_data_cube *src_data_cube,
+			   struct dla_data_cube *dst_data_cube,
+			   uint8_t mem_type);
+int32_t validate_precision(uint8_t precision, uint8_t map_precision);
+
+#endif /* __FIRMWARE_COMMON_H_ */
diff --git a/drivers/soc/eswin/ai_driver/npu/conv.c b/drivers/soc/eswin/ai_driver/npu/conv.c
new file mode 100644
index 000000000000..69dd91f79f07
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/npu/conv.c
@@ -0,0 +1,495 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#include <asm/errno.h>
+#include <linux/slab.h>
+#include <linux/dma-mapping.h>
+#include <asm-generic/barrier.h>
+#include <opendla.h>
+#include <dla_err.h>
+#include <dla_interface.h>
+#include "common.h"
+#include "dla_engine_internal.h"
+#include "nvdla_linux.h"
+#include "dla_log.h"
+#include "nvdla_interface.h"
+#include "opendla_initial.h"
+#include "conv.h"
+#include "debug.h"
+#include "internal_interface.h"
+#include "hetero_common.h"
+#include "dla_buffer.h"
+
+int dla_conv_rdma_check(struct dla_processor_group *group,
+			union dla_operation_container *op,
+			union dla_surface_container *surface)
+{
+	if (group) {
+		group->is_rdma_needed = 0;
+	}
+	return 0;
+}
+
+int conv_tensor_unfold(struct win_executor *executor, int op_idx,
+		       union dla_operation_container *operation_desc,
+		       union dla_surface_container *surface_desc, void *tensor,
+		       int idx)
+{
+	return 0;
+}
+
+#ifdef CONV_DUMP
+static inline void dump_conv_program_t(conv_program_t *conv_prog)
+{
+	dla_info("==========npu driver dump_conv_program_t================\n");
+	dla_info("ifmap_base_addr =0x%llx \n", conv_prog->ifmap_base_addr);
+	dla_info("weight_base_addr=0x%llx \n", conv_prog->weight_base_addr);
+	dla_info("ofmap_base_addr =0x%llx \n", conv_prog->ofmap_base_addr);
+	dla_info("used_num_pec_row=%u \n", conv_prog->used_num_pec_row);
+	dla_info("used_num_pec_column=%u \n", conv_prog->used_num_pec_column);
+	dla_info("input0_io_index=%u \n", conv_prog->input0_io_index);
+	dla_info("output0_io_index=%u \n", conv_prog->output0_io_index);
+}
+
+static void dump_rdma_dev_com_inf_t(rdma_dev_com_inf_t *rdma_com)
+{
+	dla_info("N %d Ch0 %d(C0xG0 also CfxGfxCMfxGMf) H %d W %d\n",
+		 rdma_com->N, rdma_com->Ch0, rdma_com->H, rdma_com->W);
+	dla_info(
+		"Che %d(G/G0 * C/C0 with div_up) total-channel %d(may padding0)\n",
+		rdma_com->Che, rdma_com->Che * rdma_com->Ch0);
+	dla_info("ifmap_type_fmt %d stride_h %d stride_w %d\n",
+		 rdma_com->ifmap_type_fmt, rdma_com->stride_h,
+		 rdma_com->stride_w);
+	dla_info("pad_h_t %d pad_w_l %d\n", rdma_com->pad_h_t,
+		 rdma_com->pad_w_l);
+	dla_info("SRAM loop G3 %d N3 %d M3 %d E4 %d F3 %d C3 %d\n",
+		 rdma_com->G3, rdma_com->N3, rdma_com->M3, rdma_com->E4,
+		 rdma_com->F3, rdma_com->C3);
+	dla_info("PEC loop G2 %d N2 %d C2 %d E3 %d R3 %d M2 %d\n", rdma_com->G2,
+		 rdma_com->N2, rdma_com->C2, rdma_com->E3, rdma_com->R3,
+		 rdma_com->M2);
+	dla_info(
+		"PEC space G1_C1(G1xC1) %d N1 %d M1 %d E2 %d R2 (constantly 1)\n",
+		rdma_com->G1_C1, rdma_com->N1, rdma_com->M1, rdma_com->E2);
+	dla_info("SPAD loop F0 %d S %d (GMF-CMF in Ch0)\n", rdma_com->F0,
+		 rdma_com->S);
+	dla_info("PE space E1 %d R1 %d Cv %d\n", rdma_com->E1, rdma_com->R1,
+		 rdma_com->Cv);
+	dla_info("More: E0 %d R %d(total r)\n", rdma_com->E0, rdma_com->R);
+}
+static void dump_rdma_dev_master_inf_t(rdma_dev_master_inf_t *rdma_mst)
+{
+	int i;
+	u32 rdma_and_wig_bitmap = rdma_mst->rdma_and_wig_bitmap;
+	u32 *reg = rdma_mst->regs;
+
+	dla_info("rdma_and_wig_bitmap 0x%x(indicate valid reg)\n",
+		 rdma_and_wig_bitmap);
+	for (i = 0; i < 32; i++) {
+		if ((1 << i) & rdma_and_wig_bitmap) {
+			dla_info("    rdma IFM_WT_CR + %d 0x%x\n", i, *reg++);
+		}
+	}
+}
+static void dump_pec_dev_master_inf_t(pec_dev_master_inf_t *pec_mst)
+{
+	u32 *reg = pec_mst->regs;
+	union pre_drp_regs_t *pre_drp = &pec_mst->pre_drp_regs;
+	int i;
+
+	dla_info("struct_len %d\n", pec_mst->struct_len);
+	dla_info("pec_active_bitmap 0x%x\n", pec_mst->pec_active_bitmap);
+	dla_info("reg_bcast_bitmap 0x%x\n", pec_mst->reg_bcast_bitmap);
+	for (i = 0; i < 32; i++) {
+		if ((1 << i) & pec_mst->reg_bcast_bitmap) {
+			dla_info("    pec_spad_param0 + %d 0x%x(broadcast)\n",
+				 i, *reg++);
+		}
+	}
+	dla_info("predrp_ctrl         0x%x", pre_drp->predrp_ctrl);
+	dla_info("n2_stride           0x%x", pre_drp->n2_stride);
+	dla_info("g2_stride           0x%x", pre_drp->g2_stride);
+	dla_info("e3_stride           0x%x", pre_drp->e3_stride);
+	dla_info("m2_stride           0x%x", pre_drp->m2_stride);
+	dla_info("m_stride            0x%x", pre_drp->m_stride);
+	dla_info("g3_threshold	       0x%x", pre_drp->g3_threshold);
+	dla_info("n3_threshold	       0x%x", pre_drp->n3_threshold);
+	dla_info("m3_threshold	       0x%x", pre_drp->m3_threshold);
+	dla_info("e4_threshold	       0x%x", pre_drp->e4_threshold);
+	dla_info("f3_threshold	       0x%x", pre_drp->f3_threshold);
+	dla_info("pe_num              0x%x", pre_drp->pe_num);
+	dla_info("predrp_size_glb     0x%x", pre_drp->predrp_size_glb);
+	dla_info("reshape_ctrl	       0x%x", pre_drp->reshape_ctrl);
+	dla_info("g_stride_glb	       0x%x", pre_drp->g_stride_glb);
+	dla_info("n_stride_glb	       0x%x", pre_drp->n_stride_glb);
+	dla_info("e_stride_glb	       0x%x", pre_drp->e_stride_glb);
+	dla_info("m_stride_glb	       0x%x", pre_drp->m_stride_glb);
+	dla_info("n_stride_sram       0x%x", pre_drp->n_stride_sram);
+	dla_info("h_stride_sram       0x%x", pre_drp->h_stride_sram);
+	dla_info("c_stride_sram       0x%x", pre_drp->c_stride_sram);
+	dla_info("imap_para_l         0x%x", pre_drp->imap_para_l);
+	dla_info("omap_para_rsp_w     0x%x", pre_drp->omap_para_rsp_w);
+	dla_info("layer_para_l	       0x%x", pre_drp->layer_para_l);
+	dla_info("layer_para_m	       0x%x", pre_drp->layer_para_m);
+	dla_info("layer_para_h	       0x%x", pre_drp->layer_para_h);
+	dla_info("glb_para_l          0x%x", pre_drp->glb_para_l);
+	dla_info("glb_para_h          0x%x", pre_drp->glb_para_h);
+	dla_info("omap_para_l         0x%x", pre_drp->omap_para_l);
+	dla_info("reshape_size_glb    0x%x", pre_drp->reshape_size_glb);
+	dla_info("precision_ctrl_l    0x%x", pre_drp->precision_ctrl_l);
+	dla_info("precision_ctrl_h    0x%x", pre_drp->precision_ctrl_h);
+}
+static void dump_rdma_dev_major_inf_t(rdma_dev_major_inf_t *rdma_maj)
+{
+	int i;
+	union narrator_dev_desc_t *n = rdma_maj->narrator_desc;
+
+	dla_info("struct_len %d\n", rdma_maj->struct_len);
+	dla_info("rdma_en_flag %d\n", rdma_maj->rdma_en_flag);
+	dla_info("is_ctrl_valid %d\n", rdma_maj->is_ctrl_valid);
+	dla_info("ifmap_weight_ctrl 0x%x\n", rdma_maj->ifmap_weight_ctrl);
+	dla_info("weight_narrator_bitmap 0x%x\n",
+		 rdma_maj->weight_narrator_bitmap);
+	for (i = 0; i < 8; i++) {
+		if ((1 << i) & rdma_maj->weight_narrator_bitmap) {
+			dla_info("    ch %d weight_base_addr 0x%x\n", i,
+				 (n++)->weight_base_addr);
+		}
+	}
+	dla_info("ifmap_narrator_bitmap 0x%x\n",
+		 rdma_maj->ifmap_narrator_bitmap);
+	for (i = 0; i < 8; i++) {
+		if ((1 << i) & rdma_maj->ifmap_narrator_bitmap) {
+			dla_info("    ch %d g1_c1 %d n1 %d m1 %d e2 %d\n", i,
+				 n->g1_c1, n->n1, n->m1, n->e2);
+		}
+	}
+}
+static void dump_pec_dev_major_inf_t(pec_dev_major_inf_t *pec_maj)
+{
+	int i;
+	u32 bitmap;
+	u32 *reg;
+
+	reg = pec_maj->regs;
+	dla_info("struct_len %d\n", pec_maj->struct_len);
+	bitmap = pec_maj->reg_mcast_bitmap;
+	dla_info("reg_mcast_bitmap 0x%x\n", bitmap);
+	for (i = 0; i < 8; i++) {
+		if ((1 << i) & bitmap) {
+			dla_info("    pec_spad_param0 + %d 0x%x\n", i, *reg++);
+		}
+	}
+	bitmap = pec_maj->reg_ucast_bitmap;
+	dla_info("reg_ucast_bitmap 0x%x\n", bitmap);
+	for (i = 0; i < 8; i++) {
+		if ((1 << i) & bitmap) {
+			dla_info("    pec_spad_param0 + %d 0x%x\n", i, *reg++);
+		}
+	}
+	bitmap = pec_maj->pec_en_bitmap;
+	dla_info("pec_en_bitmap 0x%x\n", bitmap);
+	for (i = 0; i < 8; i++) {
+		if ((1 << i) & bitmap) {
+			dla_info("    PEC idx %d in cur row trig enable\n", i);
+		}
+	}
+}
+#endif
+
+int conv_prepare_io_tensor(struct win_executor *executor, int seq,
+			   union dla_surface_container *surface_desc)
+{
+	conv_dev_hdr_t *conv_hdr = NULL;
+	conv_program_t *conv_prog = NULL;
+	conv_tensor_t *tensor = executor->tensor_set[IDX_CONV];
+	conv_tensor_t *conv_tensor = NULL;
+	struct npu_conv_surface_desc *surface;
+	u8 *prog_start_va = (u8 *)(executor->prog_data_buf_bobj[IDX_CONV]) +
+			    MAX_CONV_PROG_DATA_SIZE * seq;
+	// get conv header info
+	if (seq == 0) {
+		conv_hdr = &executor->op_prog_addrs.next_conv_hdr;
+	} else {
+		conv_hdr = (conv_dev_hdr_t *)(prog_start_va -
+					      MAX_CONV_PROG_DATA_SIZE +
+					      sizeof(rdma_dev_com_inf_t) +
+					      sizeof(npu_dep_info_t));
+	}
+
+	conv_prog =
+		(conv_program_t *)(prog_start_va + sizeof(rdma_dev_com_inf_t) +
+				   conv_hdr->emission_len * sizeof(u32) +
+				   conv_hdr->master_len * sizeof(u32));
+	surface = &surface_desc->conv_surface;
+	conv_tensor = &tensor[seq];
+
+	dla_info("input0_io_index=%u, output0_io_index=%u\n",
+		 conv_prog->input0_io_index, conv_prog->output0_io_index);
+	if (conv_prog->input0_io_index != invalid_tensor_idx) {
+		conv_prog->input0_io_offset = surface->src_data.offset;
+	}
+	if (conv_prog->output0_io_index != invalid_tensor_idx) {
+		conv_prog->output0_io_offset = surface->dst_data.offset;
+	}
+	return 0;
+}
+
+static void conv_dump(const char *label, const char *buf, const u32 len)
+{
+	dla_info("=======%s======\n", label);
+	dump_data(buf, len);
+}
+
+static int processor_conv_program(struct win_executor *executor, int rdma,
+				  int tensor_idx, u16 op_idx,
+				  union dla_operation_container *operation_desc,
+				  union dla_surface_container *surface_desc)
+{
+#ifdef CONV_DUMP
+	char label[32];
+	rdma_dev_master_inf_t *rdma_mst;
+	pec_dev_master_inf_t *pec_mst;
+#endif
+	u32 not_used = 0;
+	u16 consumer = invalid_op_index;
+	u32 ifmap_idx = (u32)invalid_tensor_idx;
+	u32 ofmap_idx = (u32)invalid_tensor_idx;
+	int i = 0;
+	int ret = 0;
+	int effect_idx = 0;
+	dma_addr_t iova, dma_addr;
+	u32 size, model_conv_config_size, req_size;
+	char *prog_start_va = NULL;
+	char *src = NULL;
+	char *dst = NULL;
+	void *vaddr = NULL;
+	conv_dev_hdr_t *conv_hdr = NULL;
+	conv_program_t *conv_prog = NULL;
+	npu_dep_info_t *dep_info = NULL;
+	struct dla_common_op_desc *comm_desc = NULL;
+	struct npu_conv_op_desc *conv_op = NULL;
+	struct npu_conv_surface_desc *conv_surface = NULL;
+	conv_dev_hdr_t *addr_for_cur_conv_hdr, *addr_for_prev_conv_hdr;
+
+	conv_op = (struct npu_conv_op_desc *)&(operation_desc->npu_conv_op);
+	conv_surface = &surface_desc->conv_surface;
+
+	vaddr = executor->prog_data_buf_bobj[IDX_CONV];
+	dma_addr = executor->dma_addr[IDX_CONV];
+	conv_hdr = (conv_dev_hdr_t *)(conv_op->conv_config_data);
+	model_conv_config_size =
+		conv_hdr->total_len * sizeof(u32) - sizeof(conv_dev_t);
+	// NOTE: conv_emission_t & conv_program_t has fixed length
+	req_size = model_conv_config_size + sizeof(conv_emission_t) +
+		   sizeof(conv_program_t);
+
+	// e31 requires two new structures.
+	conv_hdr->total_len = req_size / sizeof(u32);
+	conv_hdr->emission_len =
+		(sizeof(npu_dep_info_t) + sizeof(conv_dev_t)) / sizeof(u32);
+	conv_hdr->program_len =
+		conv_hdr->master_len + sizeof(conv_program_t) / sizeof(u32);
+
+	/* calculate start position for program data */
+	prog_start_va = (char *)vaddr + MAX_CONV_PROG_DATA_SIZE * tensor_idx;
+	iova = dma_addr + MAX_CONV_PROG_DATA_SIZE * tensor_idx;
+	dla_debug("%s %s %d\n", __FILE__, __FUNCTION__, __LINE__);
+#if NPU_DEV_SIM == NPU_REAL_ENV
+	dla_debug("req_size=%u, alloc=%u, wasted=%u. %s %s %d\n", req_size,
+#else
+	dla_debug("req_size=%u, alloc=%lu, wasted=%lu. %s %s %d\n", req_size,
+#endif
+		  MAX_CONV_PROG_DATA_SIZE, MAX_CONV_PROG_DATA_SIZE - req_size,
+		  __FILE__, __FUNCTION__, __LINE__);
+
+	dla_debug("total_len=%uDW, master_len=%uDW, major_lens[0]=%uDW, \n",
+		  conv_hdr->total_len, conv_hdr->master_len,
+		  conv_hdr->major_lens[0]);
+	dla_debug("emission_len=%uDW, program_len=%uDW\n",
+		  conv_hdr->emission_len, conv_hdr->program_len);
+	dla_debug(
+		"conv_hdr->used_num_pec_row=%u, conv_hdr->used_num_pec_column=%u\n",
+		conv_hdr->used_num_pec_row, conv_hdr->used_num_pec_column);
+	dla_debug("prog_start_va=0x%p, iova=%llu\n", prog_start_va, iova);
+
+	if (tensor_idx == 0) {
+		executor->op_prog_addrs.program_addr[IDX_CONV] = (u64)iova;
+		memcpy(&executor->op_prog_addrs.next_conv_hdr, conv_hdr,
+		       sizeof(conv_dev_t));
+		dla_debug("first conv_program called. total_len=%u\n",
+			  conv_hdr->total_len);
+	}
+
+	src = (char *)(conv_op->conv_config_data) + sizeof(conv_dev_t);
+	dst = prog_start_va;
+
+	/* common info */
+	memcpy(dst, src, sizeof(rdma_dev_com_inf_t));
+#ifdef CONV_DUMP
+	sprintf(label, "conv%d_op%hu_common_info", tensor_idx, op_idx);
+	conv_dump(label, dst, sizeof(rdma_dev_com_inf_t));
+	dump_rdma_dev_com_inf_t((rdma_dev_com_inf_t *)dst);
+#endif
+	src += sizeof(rdma_dev_com_inf_t);
+	dst += sizeof(rdma_dev_com_inf_t);
+
+	/* setup dep_info */
+	dep_info = (npu_dep_info_t *)dst;
+	dep_info->current_op_idx = op_idx;
+
+	comm_desc = (struct dla_common_op_desc *)&executor->task
+			    ->common_desc[op_idx];
+	dep_info->enable_op_idx = invalid_op_index;
+	if (comm_desc->fused_parent.index != invalid_op_index) {
+		dep_info->enable_op_idx = comm_desc->fused_parent.index;
+	}
+	dep_info->completion_event_bitmap = 0;
+
+	for (i = IDX_START; i < NUM_OP_TYPE; i++) {
+		dep_info->completion_op_idx[effect_idx] = invalid_op_index;
+		consumer = comm_desc->consumers[i].index;
+		if (consumer != invalid_op_index &&
+		    comm_desc->consumers[i].event == DLA_EVENT_OP_COMPLETED) {
+			if (unlikely(effect_idx >= MAX_KMD_DEPCNT)) {
+				dla_error(
+					"op index:%d dependency count over max\n",
+					op_idx);
+				BUG_ON(false);
+				return -1;
+			}
+			dep_info->completion_event_bitmap |= (1 << i);
+			dep_info->completion_op_idx[effect_idx] = consumer;
+			effect_idx++;
+		}
+	}
+
+	addr_for_cur_conv_hdr = (conv_dev_hdr_t *)&((conv_emission_t *)dst)
+					->next_convolution_header;
+	memset(addr_for_cur_conv_hdr, 0, sizeof(conv_dev_hdr_t));
+	if (tensor_idx > 0) {
+		addr_for_prev_conv_hdr =
+			(conv_dev_hdr_t *)((char *)addr_for_cur_conv_hdr -
+					   MAX_CONV_PROG_DATA_SIZE);
+		memcpy(addr_for_prev_conv_hdr, conv_hdr,
+		       sizeof(conv_dev_hdr_t));
+	}
+	dst += sizeof(conv_emission_t);
+#ifdef CONV_DUMP
+	sprintf(label, "conv%d_op%hu_emission_core", tensor_idx, op_idx);
+	conv_dump(label, dst - sizeof(conv_emission_t),
+		  sizeof(conv_emission_t));
+#endif
+
+	/* for program core*/
+	size = conv_hdr->master_len * sizeof(u32);
+	memcpy(dst, src, size);
+	src += size;
+	dst += size;
+
+	conv_prog = (conv_program_t *)dst;
+	ret = read_input_address(executor, &conv_surface->src_data,
+				 &conv_prog->ifmap_base_addr, &ifmap_idx);
+	conv_prog->input0_io_index = (u8)ifmap_idx;
+	if (ret) {
+		dla_error("Failed to read ifmap_base_addr\n");
+		return -1;
+	}
+
+	if (conv_surface->dst_data.type != DLA_MEM_HW) {
+		ret = dla_get_dma_cube_address(
+			executor->driver_context, executor->mem_handles,
+			conv_surface->dst_data.address,
+			conv_surface->dst_data.offset,
+			(void *)&conv_prog->ofmap_base_addr, &ofmap_idx);
+		conv_prog->output0_io_index = (u8)ofmap_idx;
+		if (ret) {
+			dla_error("Failed to read ofmap_base_addr\n");
+			return -1;
+		}
+	} else {
+		conv_prog->ofmap_base_addr = 0;
+	}
+	dla_debug("actual conv ifmap_idx=%u, ofmap_idx=%u\n", ifmap_idx,
+		  ofmap_idx);
+
+	ret = read_input_address(executor, &conv_surface->weight_data,
+				 &conv_prog->weight_base_addr, &not_used);
+	if (ret) {
+		dla_error("Failed to read weight_base_addr\n");
+		return -1;
+	}
+
+	conv_prog->used_num_pec_row = conv_hdr->used_num_pec_row;
+	conv_prog->used_num_pec_column = conv_hdr->used_num_pec_column;
+	dst += sizeof(conv_program_t);
+#ifdef CONV_DUMP
+	dump_conv_program_t((conv_program_t *)dst - 0x1);
+	sprintf(label, "conv%d_op%hu_program_core", tensor_idx, op_idx);
+	conv_dump(label,
+		  dst - sizeof(conv_program_t) -
+			  conv_hdr->master_len * sizeof(u32),
+		  sizeof(conv_program_t) + conv_hdr->master_len * sizeof(u32));
+	rdma_mst =
+		(rdma_dev_master_inf_t *)(dst - sizeof(conv_program_t) -
+					  conv_hdr->master_len * sizeof(u32));
+	dump_rdma_dev_master_inf_t(rdma_mst);
+	pec_mst =
+		(pec_dev_master_inf_t
+			 *)(((u8 *)rdma_mst) + sizeof(rdma_dev_master_inf_t) +
+			    sizeof(u32) *
+				    (hweight32(rdma_mst->rdma_and_wig_bitmap)));
+	dump_pec_dev_master_inf_t(pec_mst);
+#endif
+
+	/* for major 0-7 */
+	for (i = 0; i <= NUM_MAJOR_CORES; i++) {
+		size = conv_hdr->major_lens[i] * sizeof(u32);
+		memcpy(dst, src, size);
+#ifdef CONV_DUMP
+		sprintf(label, "conv%d_op%hu_major_core_%d", tensor_idx, op_idx,
+			i);
+		conv_dump(label, dst, size);
+		dump_rdma_dev_major_inf_t((rdma_dev_major_inf_t *)dst);
+		dump_pec_dev_major_inf_t(
+			(pec_dev_major_inf_t *)(dst +
+						((rdma_dev_major_inf_t *)dst)
+								->struct_len *
+							sizeof(u32)));
+#endif
+		src += size;
+		dst += size;
+	}
+	conv_prepare_io_tensor(executor, tensor_idx, surface_desc);
+#if NPU_DEV_SIM != NPU_REAL_ENV
+	//send op_desc and op_surf_desc to e31 for simulation
+	dst = prog_start_va + MAX_CONV_PROG_SIZE;
+	memcpy(dst, (char *)operation_desc, sizeof(struct npu_conv_op_desc));
+	dst += sizeof(struct npu_conv_op_desc);
+	memcpy(dst, (char *)surface_desc, sizeof(struct npu_conv_surface_desc));
+#endif
+
+	return 0;
+}
+
+int32_t
+dla_conv_prepare_prog_data(struct win_executor *executor, int rdma,
+			   int tensor_idx, u16 op_idx,
+			   union dla_operation_container *operation_desc,
+			   union dla_surface_container *surface_desc)
+{
+	int32_t ret;
+
+	ret = processor_conv_program(executor, rdma, tensor_idx, op_idx,
+				     operation_desc, surface_desc);
+	if (ret)
+		goto exit;
+
+exit:
+	return ret;
+}
diff --git a/drivers/soc/eswin/ai_driver/npu/conv.h b/drivers/soc/eswin/ai_driver/npu/conv.h
new file mode 100644
index 000000000000..11643f5d8770
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/npu/conv.h
@@ -0,0 +1,34 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#ifndef __CONV_H__
+#define __CONV_H__
+#include "hetero_common.h"
+
+typedef enum ipc_message_t {
+	IPC_NONE = 0,
+	IPC_CONFIG0_TRG,  //1
+	IPC_CONFIG1_TRG,  //2
+	IPC_CONFIG0_CPL,  //3
+	IPC_CPNFIG1_CPL,  //4
+	IPC_EVAL0_TRG,	//5
+	IPC_EVAL1_TRG,
+	IPC_MAX_MSG,
+} ipc_message_t;
+
+/**
+ * @brief Defines message queue between a pair of E31 cores.
+ *
+ */
+#define QUEUE_SIZE 8
+#define QUEUE_LIMIT 16
+#define IPC_MESSAGE_BITS 3
+
+#define NPU_CPU_SIZE 0x00100000
+#define NPU_DTIM_OFFSET 0x10000
+
+#endif
diff --git a/drivers/soc/eswin/ai_driver/npu/debug.c b/drivers/soc/eswin/ai_driver/npu/debug.c
new file mode 100644
index 000000000000..1393e345c2f5
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/npu/debug.c
@@ -0,0 +1,1131 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#include <linux/shmem_fs.h>
+#include <linux/pipe_fs_i.h>
+#include <linux/mount.h>
+#include <linux/fs_struct.h>
+#include <linux/task_work.h>
+#include <asm/errno.h>
+#include <linux/dma-mapping.h>
+#include <asm-generic/barrier.h>
+#include <opendla.h>
+#include <dla_err.h>
+#include <dla_interface.h>
+#include <linux/dma-buf.h>
+#include <linux/dma-mapping.h>
+#include <linux/list.h>
+#include <nvdla_linux.h>
+#include <linux/time.h>
+#include <linux/rtc.h>
+#include "hetero_ioctl.h"
+#include "common.h"
+#include "dla_engine_internal.h"
+#include "dla_engine.h"
+#include "nvdla_linux.h"
+#include "dla_log.h"
+#include "nvdla_interface.h"
+#include "opendla_initial.h"
+#include "debug.h"
+#include "npu_spram.h"
+#include "post_drp.h"
+#include "internal_interface.h"
+#include "dla_buffer.h"
+#include "hetero_host.h"
+#include <crypto/hash.h>
+#include "md5.h"
+
+char g_op_names[][16] = { "OP_EDMA", "OP_CONV",	 "OP_SDP", "OP_PDP",
+			  "OP_CDP",  "OP_RUBIK", "OP_BDMA" };
+
+static int32_t max_index = 0;
+
+static md5_container_t md5_dump[MAX_OP_NUM] = { 0 };
+
+static int npu_dump_data_enable = 1;
+module_param(npu_dump_data_enable, int, 0644);
+
+static int npu_dump_op_num_start = 0;
+module_param(npu_dump_op_num_start, int, 0644);
+
+int npu_dump_data_len = 16;
+module_param(npu_dump_data_len, int, 0644);
+
+static int npu_dump_data_start = 0;
+module_param(npu_dump_data_start, int, 0644);
+
+static void md5_to_hex(char *out, char *ck_data)
+{
+	int i;
+	for (i = 0; i < ((MD5_LENGTH - 1) / 2); i++) {
+		unsigned char c = ck_data[i];
+		*out++ =
+			'0' + ((c & 0xf0) >> 4) + (c >= 0xa0) * ('a' - '9' - 1);
+		*out++ = '0' + (c & 0x0f) +
+			 ((c & 0x0f) >= 0x0a) * ('a' - '9' - 1);
+	}
+}
+
+static void calc_md5(char *md5, u8 *data, u32 len)
+{
+	u32 ck_len;
+	u8 *ck_data;
+	struct crypto_shash *tfm;
+	md5[MD5_LENGTH - 1] = '\0';
+
+	tfm = crypto_alloc_shash("md5", 0, 0);
+	if (IS_ERR(tfm)) {
+		dla_error("failed to call crypto alloc shash.\n");
+		return;
+	}
+
+	ck_len = crypto_shash_digestsize(tfm);
+	ck_data = kzalloc(ck_len, GFP_KERNEL);
+	if (ck_data == NULL) {
+		dla_error("kzalloc mem failed.\n");
+		goto out;
+	}
+
+	if (crypto_shash_tfm_digest(tfm, data, len, ck_data)) {
+		dla_error("failed to call crypto_shash_tfm_disgest.\n");
+	} else {
+		md5_to_hex(md5, ck_data);
+	}
+
+	kfree(ck_data);
+out:
+	crypto_free_shash(tfm);
+	return;
+}
+
+void dump_data(const void *buf, const u32 len)
+{
+#ifdef NPU_DBG
+	int i = 0;
+	const unsigned char *cbuf = buf;
+
+	dla_debug("=======================\n");
+	dla_debug("ver01: buf=0x%px, len=%u.\n", buf, len);
+	for (i = 0; i < len; i++) {
+		if (i % 16 == 0) {
+			dla_debug("\n0x%04x: ", i);
+		}
+		dla_debug(KERN_CONT "%02X ", cbuf[i]);
+	}
+	dla_debug("========================\n");
+#endif
+}
+
+int dump2file(const char *fname, const void *data, size_t len)
+{
+	loff_t pos = 0;
+	struct file *filep = NULL;
+	dla_debug("dump buf %px to file %s, len=%lu.\n", data, fname, len);
+
+	if (filep == NULL) {
+		filep = filp_open(fname, O_RDWR | O_CREAT, 0644);
+	}
+
+	if (IS_ERR(filep)) {
+		dla_error("Open file %s error\n", fname);
+		return -1;
+	}
+
+	kernel_write(filep, data, len, &pos);
+
+	if (filep != NULL) {
+		filp_close(filep, NULL);
+	}
+	dla_debug("dump2file done.\n");
+	return 0;
+}
+
+int dumpMD5(const char *fname, struct win_executor *executor, uint32_t index)
+{
+	int i;
+	int len = 0;
+	char content[512] = { 0 };
+	loff_t pos = 0;
+	struct file *filep = NULL;
+
+	if (filep == NULL) {
+		filep = filp_open(fname, O_RDWR | O_CREAT | O_APPEND, 0644);
+	}
+
+	if (IS_ERR(filep)) {
+		dla_error("Open file %s error\n", fname);
+		return -1;
+	}
+
+	if (max_index < index) {
+		max_index = index;
+	}
+
+	for (i = npu_dump_op_num_start; i < (max_index + 1); i++) {
+		if (md5_dump[i].calced_flag == 0) {
+			goto end_dumpMD5;
+		}
+
+		if (md5_dump[i].writed_flag == 0) {
+			md5_dump[i].writed_flag = 1;
+			len = snprintf(
+				content, sizeof(content), "%d_%s_INPUT: %s\n",
+				i,
+				pcer2str(
+					executor->task->common_desc[i].op_type),
+				md5_dump[i].src_md5);
+			len += snprintf(
+				content + len, sizeof(content) - len,
+				"%d_%s_OUTPUT: %s\n", i,
+				pcer2str(
+					executor->task->common_desc[i].op_type),
+				md5_dump[i].dst_md5);
+
+			if (executor->task->common_desc[i].op_type ==
+			    DLA_OP_CONV) {
+				len += snprintf(
+					content + len, sizeof(content) - len,
+					"%d_%s_WEIGHT: %s\n", i,
+					pcer2str(executor->task->common_desc[i]
+							 .op_type),
+					md5_dump[i].md5_spec.conv_md5.wgt_md5);
+			}
+
+			if (executor->task->common_desc[i].op_type ==
+			    DLA_OP_SDP) {
+				len += snprintf(
+					content + len, sizeof(content) - len,
+					"%d_%s_X1: %s\n", i,
+					pcer2str(executor->task->common_desc[i]
+							 .op_type),
+					md5_dump[i].md5_spec.sdp_md5.x1_md5);
+				len += snprintf(
+					content + len, sizeof(content) - len,
+					"%d_%s_X2: %s\n", i,
+					pcer2str(executor->task->common_desc[i]
+							 .op_type),
+					md5_dump[i].md5_spec.sdp_md5.x2_md5);
+				len += snprintf(
+					content + len, sizeof(content) - len,
+					"%d_%s_Y: %s\n", i,
+					pcer2str(executor->task->common_desc[i]
+							 .op_type),
+					md5_dump[i].md5_spec.sdp_md5.y_md5);
+			}
+			kernel_write(filep, content, strlen(content), &pos);
+		}
+	}
+
+end_dumpMD5:
+	if (filep != NULL) {
+		filp_close(filep, NULL);
+	}
+
+	dla_debug("dumpMD5 done.\n");
+	return 0;
+}
+
+void dump_dtim_to_file(struct win_engine *engine, u32 tiktok)
+{
+	char name[60];
+	int i;
+	ktime_t k_time;
+	struct rtc_time tm;
+	k_time = ktime_get_real();
+	tm = rtc_ktime_to_tm(k_time);
+
+	if (engine->master_mem) {
+		sprintf(name,
+			"/opt/mcu_emission_tiktok%d_%d-%02d-%02d-%02d%02d%02d.bin",
+			tiktok, tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
+			tm.tm_hour + 8, tm.tm_min, tm.tm_sec);
+
+		dump2file(name, engine->master_mem, E31_EMISSION_DTIM_SIZE);
+	}
+	if (engine->aux_mem) {
+		sprintf(name,
+			"/opt/mcu_program_tiktok%d_%d-%02d-%02d-%02d%02d%02d.bin",
+			tiktok, tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
+			tm.tm_hour + 8, tm.tm_min, tm.tm_sec);
+
+		dump2file(name, engine->aux_mem, E31_PROGRAM_DTIM_SIZE);
+	}
+	for (i = 0; i < NUM_MAJOR_CORES; i++) {
+		if (engine->major_mem[i]) {
+			sprintf(name,
+				"/opt/mcu_major%d_tiktok%d_%d-%02d-%02d-%02d%02d%02d.bin",
+				i, tiktok, tm.tm_year + 1900, tm.tm_mon + 1,
+				tm.tm_mday, tm.tm_hour + 8, tm.tm_min,
+				tm.tm_sec);
+			dump2file(name, engine->major_mem[i],
+				  E31_MAJOR_DTIM_SIZE);
+		}
+	}
+}
+
+static char *pcer_name[] = {
+	[IDX_START] = "EDMA",
+	[IDX_CONV] = "CONV",
+	[IDX_SDP] = "SDP",
+	[IDX_PDP] = "PDP",
+	[IDX_RUBIK] = "RUBIK",
+	[IDX_KMD_DSP0] = "KMD_DSP0",
+	[IDX_KMD_DSP1] = "KMD_DSP1",
+	[IDX_KMD_DSP2] = "KMD_DSP2",
+	[IDX_KMD_DSP3] = "KMD_DSP3",
+	[IDX_EVENT_SINK] = "EVENT_SINK",
+	[IDX_EVENT_SOURCE] = "EVENT_SOURCE",
+};
+
+char *pcer2str(u8 pcer)
+{
+	if (pcer == IDX_NONE) {
+		return "NONE";
+	}
+	if (pcer >= ARRAY_SIZE(pcer_name)) {
+		return "FAIL";
+	}
+	return pcer_name[pcer];
+}
+
+#define DATA_CNT_ONE_LINE 16
+#define P_BUF_LEN 128
+#define F_NAME_LEN 512
+
+void dump_data_cube(struct win_executor *executor, struct host_frame_desc *f,
+		    struct dla_data_cube *data,
+		    struct dla_common_op_desc *op_desc, const char *name)
+{
+	int16_t src_addr_index = -1;
+	int16_t src_type = -1;
+	uint64_t src_data_size = 0;
+	uint64_t offset = 0;
+	u64 input_address;
+	uint32_t dump_buf_len = 0;
+	u32 input_is_io_tensor;
+	int32_t ret;
+	int32_t index = op_desc->index;
+	int32_t op_type = op_desc->op_type;
+	struct user_model *model = executor->model;
+	char *src_dump_buf = NULL;
+	char f_name[F_NAME_LEN] = { 0 };
+	kmd_dump_info_t *dump_info = &executor->dump_info;
+	char md5[MD5_LENGTH] = { 0 };
+
+	src_addr_index = data->address;
+	src_data_size = data->size;
+	offset = data->offset;
+	src_type = data->type;
+	if ((-1 == src_addr_index) || (src_type == DLA_MEM_HW)) {
+		if (strstr(name, "weight") != NULL) {
+			strcpy(md5_dump[index].md5_spec.conv_md5.wgt_md5,
+			       "on-fly");
+		} else if (strstr(name, "x1") != NULL) {
+			strcpy(md5_dump[index].md5_spec.sdp_md5.x1_md5,
+			       "on-fly");
+		} else if (strstr(name, "x2") != NULL) {
+			strcpy(md5_dump[index].md5_spec.sdp_md5.x2_md5,
+			       "on-fly");
+		} else if (strstr(name, "y") != NULL) {
+			strcpy(md5_dump[index].md5_spec.sdp_md5.y_md5,
+			       "on-fly");
+		}
+
+		dla_error("%s dump failed, src_addr_index:%d\n", name,
+			  src_addr_index);
+		return;
+	}
+	dump_buf_len = src_data_size;
+	read_input_address(executor, data, &input_address, &input_is_io_tensor);
+	dla_debug("input_address:0x%llx, input_is_io_tensor:%d\n",
+		  input_address, input_is_io_tensor);
+
+	if (src_type == DLA_MEM_MC) {
+		if (input_is_io_tensor == invalid_tensor_idx) {
+			ret = dla_data_get_vaddr(&model->mem_handles,
+						 src_addr_index,
+						 (void **)&src_dump_buf);
+			if (ret < 0) {
+				dla_error("err:get index(%d) vaddr failed!\n",
+					  src_addr_index);
+				return;
+			}
+
+			src_dump_buf += offset;
+		} else {
+			input_address =
+				f->io_tensors_addr_list[input_is_io_tensor] +
+				offset;
+			if (f->input_bobj[input_is_io_tensor] != NULL)
+				src_dump_buf = dla_dmabuf_vmap(
+					f->input_bobj[input_is_io_tensor]);
+		}
+
+		if (src_dump_buf == NULL) {
+			dla_error("%d, error:src_dump_buf == NULL!index=%d\n",
+				  __LINE__, index);
+			return;
+		}
+
+	} else if (src_type == DLA_MEM_CV) {
+		int addr_offset =
+			input_address -
+			((struct nvdla_device *)(executor->driver_context))
+				->spram_base_addr;
+
+		struct dla_buffer_object *spram_bobj =
+			((struct nvdla_device *)(executor->driver_context))
+				->spram_bobj;
+
+		if (spram_bobj != NULL) {
+			src_dump_buf = dla_dmabuf_vmap(spram_bobj);
+			src_dump_buf += addr_offset;
+		}
+
+		if (src_dump_buf == NULL) {
+			dla_error("%d, error:src_dump_buf == NULL!index=%d\n",
+				  __LINE__, index);
+			return;
+		}
+	} else {
+		dla_error("invalid error\n");
+		return;
+	}
+
+	sprintf(f_name, "%s/%d_%d_%d_%s_%d_0_%s.bin", dump_info->path,
+		dump_info->process_id, dump_info->model_id, f->frame_idx,
+		pcer2str(op_type), index, name);
+
+	dump2file(f_name, src_dump_buf, src_data_size);
+
+	calc_md5(md5, src_dump_buf, src_data_size);
+	if (strstr(name, "weight") != NULL) {
+		memcpy(md5_dump[index].md5_spec.conv_md5.wgt_md5, md5,
+		       MD5_LENGTH);
+	} else if (strstr(name, "x1") != NULL) {
+		memcpy(md5_dump[index].md5_spec.sdp_md5.x1_md5, md5,
+		       MD5_LENGTH);
+	} else if (strstr(name, "x2") != NULL) {
+		memcpy(md5_dump[index].md5_spec.sdp_md5.x2_md5, md5,
+		       MD5_LENGTH);
+	} else if (strstr(name, "y") != NULL) {
+		memcpy(md5_dump[index].md5_spec.sdp_md5.y_md5, md5, MD5_LENGTH);
+	}
+}
+
+void dla_dump_src_data(struct win_executor *executor, struct host_frame_desc *f,
+		       int op_index)
+{
+	int16_t src_addr_index = -1;
+	uint64_t src_data_size = 0;
+	uint64_t offset = 0;
+	uint32_t op_num;
+	uint32_t index;
+	int32_t ret;
+	int op_type = 0;
+	int src_type = 0;
+	int i = 0, j = 0, k = 0;
+	char *src_dump_buf = NULL;
+	uint32_t dump_buf_len = 0;
+	struct dla_data_cube *src_data;
+	u64 input_address;
+	u32 input_is_io_tensor;
+	struct user_model *model = executor->model;
+	char f_name[F_NAME_LEN] = { 0 };
+	char p_buf[P_BUF_LEN] = { 0 };
+	uint32_t seg_data_len = npu_dump_data_len;
+	uint32_t seg_adrr[3] = { 0 };
+	kmd_dump_info_t *dump_info = &executor->dump_info;
+	char md5[MD5_LENGTH] = { 0 };
+
+	if ((npu_dump_data_enable == 0) || (npu_dump_data_len <= 0)) {
+		return;
+	}
+
+	op_num = executor->network->num_operations;
+
+	if (npu_dump_op_num_start >= op_num) {
+		dla_error("error:npu_dump_op_num_start(%d) >= op_num(%d)!\n",
+			  npu_dump_op_num_start, op_num);
+		return;
+	}
+
+	for (i = npu_dump_op_num_start; i < op_num; i++) {
+		src_addr_index = -1;
+		index = executor->task->common_desc[i].index;
+		op_type = executor->task->common_desc[i].op_type;
+		if (index != op_index)
+			continue;
+		switch (op_type) {
+		case DLA_OP_EDMA:
+			src_data = &executor->task->surface_desc[index]
+					    .edma_surface.src_data;
+			src_addr_index = executor->task->surface_desc[index]
+						 .edma_surface.src_data.address;
+			src_data_size = executor->task->surface_desc[index]
+						.edma_surface.src_data.size;
+			offset = executor->task->surface_desc[index]
+					 .edma_surface.src_data.offset;
+			src_type = executor->task->surface_desc[index]
+					   .edma_surface.src_data.type;
+			break;
+		case DLA_OP_CONV:
+			src_data = &executor->task->surface_desc[index]
+					    .conv_surface.src_data;
+			src_addr_index = executor->task->surface_desc[index]
+						 .conv_surface.src_data.address;
+			src_data_size = executor->task->surface_desc[index]
+						.conv_surface.src_data.size;
+			offset = executor->task->surface_desc[index]
+					 .conv_surface.src_data.offset;
+			src_type = executor->task->surface_desc[index]
+					   .conv_surface.src_data.type;
+			break;
+		case DLA_OP_SDP:
+			src_data = &executor->task->surface_desc[index]
+					    .sdp_surface.src_data;
+			src_addr_index = executor->task->surface_desc[index]
+						 .sdp_surface.src_data.address;
+			src_data_size = executor->task->surface_desc[index]
+						.sdp_surface.src_data.size;
+			offset = executor->task->surface_desc[index]
+					 .sdp_surface.src_data.offset;
+			src_type = executor->task->surface_desc[index]
+					   .sdp_surface.src_data.type;
+
+			break;
+		case DLA_OP_PDP:
+			src_data = &executor->task->surface_desc[index]
+					    .pdp_surface.src_data;
+			src_addr_index = executor->task->surface_desc[index]
+						 .pdp_surface.src_data.address;
+			src_data_size = executor->task->surface_desc[index]
+						.pdp_surface.src_data.size;
+			offset = executor->task->surface_desc[index]
+					 .pdp_surface.src_data.offset;
+			src_type = executor->task->surface_desc[index]
+					   .pdp_surface.src_data.type;
+
+			break;
+		case DLA_OP_RUBIK:
+			src_data = &executor->task->surface_desc[index]
+					    .rubik_surface.src_data;
+			src_addr_index =
+				executor->task->surface_desc[index]
+					.rubik_surface.src_data.address;
+			src_data_size = executor->task->surface_desc[index]
+						.rubik_surface.src_data.size;
+			offset = executor->task->surface_desc[index]
+					 .rubik_surface.src_data.offset;
+			src_type = executor->task->surface_desc[index]
+					   .rubik_surface.src_data.type;
+			break;
+		case DLA_KMD_OP_DSP_0:
+		case DLA_KMD_OP_DSP_1:
+		case DLA_KMD_OP_DSP_2:
+		case DLA_KMD_OP_DSP_3:
+			src_data = &executor->task->surface_desc[index]
+					    .dsp_surface.src_data[0];
+			src_addr_index = executor->task->surface_desc[index]
+						 .dsp_surface.src_data[0]
+						 .address;
+			src_data_size = executor->task->surface_desc[index]
+						.dsp_surface.src_data[0]
+						.size;
+			offset = executor->task->surface_desc[index]
+					 .dsp_surface.src_data[0]
+					 .offset;
+			src_type = executor->task->surface_desc[index]
+					   .dsp_surface.src_data[0]
+					   .type;
+			break;
+		default:
+			continue;
+		}
+
+		if (op_type == IDX_CONV) {
+			dump_data_cube(executor, f,
+				       &executor->task->surface_desc[index]
+						.conv_surface.weight_data,
+				       &executor->task->common_desc[i],
+				       "weight");
+		} else if (op_type == IDX_SDP) {
+			dump_data_cube(executor, f,
+				       &executor->task->surface_desc[index]
+						.sdp_surface.x1_data,
+				       &executor->task->common_desc[i], "x1");
+			dump_data_cube(executor, f,
+				       &executor->task->surface_desc[index]
+						.sdp_surface.x2_data,
+				       &executor->task->common_desc[i], "x2");
+			dump_data_cube(executor, f,
+				       &executor->task->surface_desc[index]
+						.sdp_surface.y_data,
+				       &executor->task->common_desc[i], "y");
+		}
+
+		dla_debug(
+			"src data dump %d:index:%d op_type:%d src_type:%d src_addr_index: %d size:0x%llx offset:0x%llx\n",
+			__LINE__, index, op_type, src_type, src_addr_index,
+			src_data_size, offset);
+
+		if ((-1 == src_addr_index) || (src_type == DLA_MEM_HW)) {
+			strcpy(md5_dump[index].src_md5, "on-fly");
+			continue;
+		}
+		if ((index == 0) && (op_type == 0) && (src_type == 0) &&
+		    (src_addr_index == 0)) {
+			continue;
+		}
+
+		dump_buf_len = src_data_size;
+
+		seg_adrr[1] = src_data_size / 2;
+		seg_adrr[2] = src_data_size - seg_data_len;
+
+		read_input_address(executor, src_data, &input_address,
+				   &input_is_io_tensor);
+		dla_debug("input_address:0x%llx, input_is_io_tensor:%d\n",
+			  input_address, input_is_io_tensor);
+
+		if (src_type == DLA_MEM_MC) {
+			if (input_is_io_tensor == invalid_tensor_idx) {
+				ret = dla_data_get_vaddr(
+					&model->mem_handles, src_addr_index,
+					(void **)&src_dump_buf);
+				if (ret < 0) {
+					dla_error(
+						"err:get index(%d) vaddr failed!\n",
+						src_addr_index);
+					return;
+				}
+
+				src_dump_buf += offset;
+			} else {
+				input_address = f->io_tensors_addr_list
+							[input_is_io_tensor] +
+						offset;
+				if (f->input_bobj[input_is_io_tensor] != NULL)
+					src_dump_buf = dla_dmabuf_vmap(
+						f->input_bobj
+							[input_is_io_tensor]);
+			}
+
+			if (src_dump_buf == NULL) {
+				dla_error(
+					"%d, error:src_dump_buf == NULL!index=%d\n",
+					__LINE__, index);
+				continue;
+			}
+
+		} else if (src_type == DLA_MEM_CV) {
+			int addr_offset =
+				input_address -
+				((struct nvdla_device
+					  *)(executor->driver_context))
+					->spram_base_addr;
+
+			struct dla_buffer_object *spram_bobj =
+				((struct nvdla_device
+					  *)(executor->driver_context))
+					->spram_bobj;
+
+			if (spram_bobj != NULL) {
+				src_dump_buf = dla_dmabuf_vmap(spram_bobj);
+				src_dump_buf += addr_offset;
+			}
+
+			if (src_dump_buf == NULL) {
+				dla_error(
+					"%d, error:src_dump_buf == NULL!index=%d\n",
+					__LINE__, index);
+				continue;
+			}
+
+		} else {
+			continue;
+		}
+
+		memset(p_buf, 0, P_BUF_LEN);
+		for (k = 0; k < 3; k++) {
+			for (j = 0; j < seg_data_len; j++) {
+				if (j % DATA_CNT_ONE_LINE == 0) {
+					if (j != 0) {
+						dla_debug("%s\n", p_buf);
+						memset(p_buf, 0, P_BUF_LEN);
+					}
+					snprintf(p_buf + strlen(p_buf),
+						 P_BUF_LEN - strlen(p_buf),
+						 "%05x: ", seg_adrr[k] + j);
+				}
+				snprintf(p_buf + strlen(p_buf),
+					 P_BUF_LEN - strlen(p_buf), "%02x",
+					 src_dump_buf[seg_data_len * k + j]);
+			}
+			dla_debug("%s\n", p_buf);
+			memset(p_buf, 0, P_BUF_LEN);
+		}
+
+		sprintf(f_name, "%s/%d_%d_%d_%s_%d_0_in.bin", dump_info->path,
+			dump_info->process_id, dump_info->model_id,
+			f->frame_idx, pcer2str(op_type), index);
+
+		dump2file(f_name, src_dump_buf, src_data_size);
+
+		calc_md5(md5, src_dump_buf, src_data_size);
+		memcpy(md5_dump[index].src_md5, md5, MD5_LENGTH);
+	}
+
+	return;
+}
+
+void dla_dump_dst_data(struct win_executor *executor, struct host_frame_desc *f,
+		       int op_index)
+{
+	int16_t dst_addr_index = -1;
+	uint64_t dst_data_size = 0;
+	uint64_t offset = 0;
+	uint32_t op_num;
+	uint32_t index;
+	int32_t ret;
+	int op_type = 0;
+	int dst_type = 0;
+	int i = 0, j = 0, k = 0;
+	char *dst_dump_buf = NULL;
+	uint32_t dump_buf_len = 0;
+	struct dla_data_cube *dst_data;
+	u64 output_address;
+	u32 output_is_io_tensor;
+	struct user_model *model = executor->model;
+	char f_name[F_NAME_LEN] = { 0 };
+	char md5_f_name[F_NAME_LEN] = { 0 };
+	char p_buf[P_BUF_LEN] = { 0 };
+	uint32_t seg_data_len = npu_dump_data_len;
+	uint32_t seg_adrr[3] = { 0 };
+	kmd_dump_info_t *dump_info = &executor->dump_info;
+	char md5[MD5_LENGTH] = { 0 };
+
+	if ((npu_dump_data_enable == 0) || (npu_dump_data_len <= 0)) {
+		return;
+	}
+
+	op_num = executor->network->num_operations;
+
+	if (npu_dump_op_num_start >= op_num) {
+		dla_error("error:npu_dump_op_num_start(%d) >= op_num(%d)!\n",
+			  npu_dump_op_num_start, op_num);
+		return;
+	}
+
+	for (i = npu_dump_op_num_start; i < op_num; i++) {
+		dst_addr_index = -1;
+		index = executor->task->common_desc[i].index;
+		op_type = executor->task->common_desc[i].op_type;
+		if (index != op_index)
+			continue;
+		switch (op_type) {
+		case DLA_OP_EDMA:
+			dst_data = &executor->task->surface_desc[index]
+					    .edma_surface.dst_data;
+			dst_addr_index = executor->task->surface_desc[index]
+						 .edma_surface.dst_data.address;
+			dst_data_size = executor->task->surface_desc[index]
+						.edma_surface.dst_data.size;
+			offset = executor->task->surface_desc[index]
+					 .edma_surface.dst_data.offset;
+			dst_type = executor->task->surface_desc[index]
+					   .edma_surface.dst_data.type;
+			break;
+		case DLA_OP_CONV:
+			dst_data = &executor->task->surface_desc[index]
+					    .conv_surface.dst_data;
+			dst_addr_index = executor->task->surface_desc[index]
+						 .conv_surface.dst_data.address;
+			dst_data_size = executor->task->surface_desc[index]
+						.conv_surface.dst_data.size;
+			offset = executor->task->surface_desc[index]
+					 .conv_surface.dst_data.offset;
+			dst_type = executor->task->surface_desc[index]
+					   .conv_surface.dst_data.type;
+			break;
+		case DLA_OP_SDP:
+			dst_data = &executor->task->surface_desc[index]
+					    .sdp_surface.dst_data;
+			dst_addr_index = executor->task->surface_desc[index]
+						 .sdp_surface.dst_data.address;
+			dst_data_size = executor->task->surface_desc[index]
+						.sdp_surface.dst_data.size;
+			offset = executor->task->surface_desc[index]
+					 .sdp_surface.dst_data.offset;
+			dst_type = executor->task->surface_desc[index]
+					   .sdp_surface.dst_data.type;
+
+			break;
+		case DLA_OP_PDP:
+			dst_data = &executor->task->surface_desc[index]
+					    .pdp_surface.dst_data;
+			dst_addr_index = executor->task->surface_desc[index]
+						 .pdp_surface.dst_data.address;
+			dst_data_size = executor->task->surface_desc[index]
+						.pdp_surface.dst_data.size;
+			offset = executor->task->surface_desc[index]
+					 .pdp_surface.dst_data.offset;
+			dst_type = executor->task->surface_desc[index]
+					   .pdp_surface.dst_data.type;
+
+			break;
+		case DLA_OP_RUBIK:
+			dst_data = &executor->task->surface_desc[index]
+					    .rubik_surface.dst_data;
+			dst_addr_index =
+				executor->task->surface_desc[index]
+					.rubik_surface.dst_data.address;
+			dst_data_size = executor->task->surface_desc[index]
+						.rubik_surface.dst_data.size;
+			offset = executor->task->surface_desc[index]
+					 .rubik_surface.dst_data.offset;
+			dst_type = executor->task->surface_desc[index]
+					   .rubik_surface.dst_data.type;
+			break;
+		case DLA_KMD_OP_DSP_0:
+		case DLA_KMD_OP_DSP_1:
+		case DLA_KMD_OP_DSP_2:
+		case DLA_KMD_OP_DSP_3:
+			dst_data = &executor->task->surface_desc[index]
+					    .dsp_surface.dst_data[0];
+			dst_addr_index = executor->task->surface_desc[index]
+						 .dsp_surface.dst_data[0]
+						 .address;
+			dst_data_size = executor->task->surface_desc[index]
+						.dsp_surface.dst_data[0]
+						.size;
+			offset = executor->task->surface_desc[index]
+					 .dsp_surface.dst_data[0]
+					 .offset;
+			dst_type = executor->task->surface_desc[index]
+					   .dsp_surface.dst_data[0]
+					   .type;
+			break;
+		default:
+			continue;
+		}
+
+		dla_debug(
+			"dst data dump %d:index:%d op_type:%d dst_type:%d dst_addr_index: %d size:0x%llx offset:0x%llx\n",
+			__LINE__, index, op_type, dst_type, dst_addr_index,
+			dst_data_size, offset);
+		sprintf(md5_f_name, "%s/%d_%d_%d_md5.txt", dump_info->path,
+			dump_info->process_id, dump_info->model_id,
+			f->frame_idx);
+		if (-1 == dst_addr_index) {
+			if (dst_type == DLA_MEM_HW) {
+				strcpy(md5_dump[index].dst_md5, "on-fly");
+				md5_dump[index].calced_flag = 1;
+				dumpMD5(md5_f_name, executor, index);
+			}
+			continue;
+		}
+
+		if ((index == 0) && (op_type == 0) && (dst_type == 0) &&
+		    (dst_addr_index == 0)) {
+			continue;
+		}
+
+		dump_buf_len = dst_data_size;
+
+		seg_adrr[1] = dst_data_size / 2;
+		seg_adrr[2] = dst_data_size - seg_data_len;
+
+		read_input_address(executor, dst_data, &output_address,
+				   &output_is_io_tensor);
+		dla_debug("output_address:0x%llx, output_is_io_tensor:%d\n",
+			  output_address, output_is_io_tensor);
+
+		if (dst_type == DLA_MEM_MC) {
+			if (output_is_io_tensor == invalid_tensor_idx) {
+				ret = dla_data_get_vaddr(
+					&model->mem_handles, dst_addr_index,
+					(void **)&dst_dump_buf);
+				if (ret < 0) {
+					dla_error(
+						"err:get index(%d) vaddr failed!\n",
+						dst_addr_index);
+					return;
+				}
+
+				dst_dump_buf += offset;
+			} else {
+				output_address = f->io_tensors_addr_list
+							 [output_is_io_tensor] +
+						 offset;
+				if (f->output_bobj[output_is_io_tensor] != NULL)
+					dst_dump_buf = dla_dmabuf_vmap(
+						f->output_bobj
+							[output_is_io_tensor]);
+				dst_dump_buf += offset;
+			}
+
+			if (dst_dump_buf == NULL) {
+				dla_error(
+					"%d, error:dst_dump_buf == NULL!index=%d\n",
+					__LINE__, index);
+				continue;
+			}
+
+		} else if (dst_type == DLA_MEM_CV) {
+			int addr_offset =
+				output_address -
+				((struct nvdla_device
+					  *)(executor->driver_context))
+					->spram_base_addr;
+
+			struct dla_buffer_object *spram_bobj =
+				((struct nvdla_device
+					  *)(executor->driver_context))
+					->spram_bobj;
+
+			if (spram_bobj != NULL) {
+				dst_dump_buf = dla_dmabuf_vmap(spram_bobj);
+				dst_dump_buf += addr_offset;
+			}
+
+			if (dst_dump_buf == NULL) {
+				dla_error(
+					"%d, error:dst_dump_buf == NULL!index=%d\n",
+					__LINE__, index);
+				continue;
+			}
+
+		} else {
+			continue;
+		}
+
+		memset(p_buf, 0, P_BUF_LEN);
+		for (k = 0; k < 3; k++) {
+			for (j = 0; j < seg_data_len; j++) {
+				if (j % DATA_CNT_ONE_LINE == 0) {
+					if (j != 0) {
+						dla_debug("%s\n", p_buf);
+						memset(p_buf, 0, P_BUF_LEN);
+					}
+					snprintf(p_buf + strlen(p_buf),
+						 P_BUF_LEN - strlen(p_buf),
+						 "%05x: ", seg_adrr[k] + j);
+				}
+				snprintf(p_buf + strlen(p_buf),
+					 P_BUF_LEN - strlen(p_buf), "%02x",
+					 dst_dump_buf[seg_data_len * k + j]);
+			}
+			dla_debug("%s\n", p_buf);
+			memset(p_buf, 0, P_BUF_LEN);
+		}
+
+		sprintf(f_name, "%s/%d_%d_%d_%s_%d_0_out.bin", dump_info->path,
+			dump_info->process_id, dump_info->model_id,
+			f->frame_idx, pcer2str(op_type), index);
+
+		dump2file(f_name, dst_dump_buf, dst_data_size);
+
+		calc_md5(md5, dst_dump_buf, dst_data_size);
+		memcpy(md5_dump[index].dst_md5, md5, MD5_LENGTH);
+		md5_dump[index].calced_flag = 1;
+		dumpMD5(md5_f_name, executor, index);
+	}
+
+	return;
+}
+
+#if (NPU_DEV_SIM == NPU_MCU_ALONE)
+static char *E31_FRAME_DESC_BIN = "/sim_frame_desc";
+#define FILE_NAME_MAX_LEN 128
+#endif
+
+static void send_op_resume_to_hw(struct win_engine *engine, u8 tiktok,
+				 u16 op_index)
+{
+	msg_payload_t payload;
+	payload.type = NOTIFY_OP_RESUME;
+	payload.param = tiktok;
+	payload.lparam = op_index;
+	send_mbx_msg_to_e31(engine, payload);
+}
+
+void dump_data_to_file(struct work_struct *work)
+{
+#if (NPU_DEV_SIM == NPU_REAL_ENV)
+	struct dump_op_work_t *dump_op_work =
+		container_of(work, struct dump_op_work_t, work);
+
+	int tiktok = dump_op_work->tiktok;
+	u16 op_index = dump_op_work->op_index;
+	struct host_frame_desc *f = dump_op_work->f;
+	struct win_executor *executor = f->executor;
+	struct win_engine *engine = executor->engine;
+
+	dla_dump_src_data(executor, f, op_index);
+	dla_dump_dst_data(executor, f, op_index);
+	send_op_resume_to_hw(engine, tiktok, op_index);
+
+#elif (NPU_DEV_SIM == NPU_MCU_ALONE)
+	struct dump_file_work_t *dump_file_work =
+		container_of(work, struct dump_file_work_t, work);
+	int tiktok = dump_file_work->tiktok;
+	struct host_frame_desc *f = dump_file_work->f;
+	struct win_executor *executor = f->executor;
+	struct win_engine *engine = executor->engine;
+	struct file *flip = NULL;
+	loff_t pos = 0;
+	struct user_model *model = f->model;
+	hetero_ipc_frame_t *frame_info =
+		(hetero_ipc_frame_t *)&model->e31_frame_info;
+
+	int wsize;
+	int i;
+	//	struct processors_interface *pcer = engine->processors;
+	struct dump_file_header *header;
+	int buf_size = 0;
+	u32 cur_pos = 0;
+	void *tmp = NULL;
+	int *magic_end = NULL;
+	u8 *dependent = frame_info->op_dependency
+				.ref_count;  // executor->dependency_count;
+	char *buffer = NULL;
+	npu_io_tensor_t *io_addr = NULL;
+	char *name;
+
+	name = kzalloc(FILE_NAME_MAX_LEN, GFP_KERNEL);
+	if (name == NULL) {
+		printk("%s, %d, alloc name mem failed.\n", __func__, __LINE__);
+		return;
+	}
+	snprintf(name, FILE_NAME_MAX_LEN, "%s-%d.bin", E31_FRAME_DESC_BIN,
+		 engine->frame_seq);
+	engine->frame_seq++;
+	flip = filp_open(name, O_RDWR | O_APPEND | O_CREAT, 0666);
+	if (IS_ERR(flip)) {
+		printk("open file e31_data_file.c error.\n");
+		goto err_file;
+	}
+
+	buf_size += sizeof(struct dump_file_header);
+	buf_size += executor->network->num_operations;
+	buf_size += sizeof(npu_io_tensor_t);
+	buf_size = ROUND_UP(buf_size, CDMA_TRANSFER_BYTE_ALIGN);
+	for (i = IDX_START; i < NUM_OP_TYPE; i++) {
+		if (executor->op_num[i] <= 0) {
+			continue;
+		}
+		buf_size += executor->prog_data_size[i];
+		printk("%s, %d, buf_size=%d.\n", __func__, __LINE__, buf_size);
+	}
+	if (executor->network->num_luts) {
+		buf_size += executor->network->num_luts * sizeof(lut_dev_t);
+	}
+	buf_size += sizeof(int);
+	buffer = kzalloc(buf_size, GFP_KERNEL);
+	if (buffer == NULL) {
+		printk("%s, %d, alloc buffer failed.\n", __func__, __LINE__);
+		goto err_buffer;
+	}
+
+	header = (struct dump_file_header *)buffer;
+	if (header == NULL) {
+		printk("%s, %d, why..\n", __func__, __LINE__);
+	}
+	header->magic = 0x20230809;
+
+	header->op_num = executor->network->num_operations;
+	memcpy(&header->first_conv_hdr, &executor->op_prog_addrs.next_conv_hdr,
+	       sizeof(conv_dev_hdr_t));
+	dla_debug("total_len=%u\n", header->first_conv_hdr.total_len);
+	dla_debug("master_len=%u\n", header->first_conv_hdr.master_len);
+	for (i = IDX_START; i < NUM_OP_TYPE; i++) {
+		printk("%s, %d, i=%d, op_num=%d.\n", __func__, __LINE__, i,
+		       executor->op_num[i]);
+		header->pcer_op_num[i] = executor->op_num[i];
+	}
+
+	cur_pos += sizeof(struct dump_file_header);
+	header->depend_offset = sizeof(struct dump_file_header);
+	header->depend_len = header->op_num > MAX_DTIM_DEPCNT ?
+				     MAX_DTIM_DEPCNT :
+				     header->op_num;
+	tmp = (void *)(buffer + cur_pos);
+	memcpy(tmp, dependent, header->depend_len);
+	cur_pos += header->op_num;
+	header->io_tensor_offset = cur_pos;
+
+	tmp = (void *)(buffer + cur_pos);
+	io_addr = &f->io_tensor;
+	memcpy(tmp, (void *)io_addr, sizeof(npu_io_tensor_t));
+
+	cur_pos += sizeof(npu_io_tensor_t);
+	cur_pos = ROUND_UP(cur_pos, CDMA_TRANSFER_BYTE_ALIGN);
+	for (i = IDX_START; i < NUM_OP_TYPE; i++) {
+		if (executor->op_num[i] <= 0 ||
+		    executor->prog_data_size[i] == 0) {
+			header->op_data_offset[i] = 0;
+			header->op_data_len[i] = 0;
+			continue;
+		}
+
+		tmp = (void *)(buffer + cur_pos);
+		header->op_data_offset[i] = cur_pos;
+		header->op_data_len[i] = executor->prog_data_size[i];
+		printk("%s, op_type=%d, op_data_offset=%d, op_data_len=%d.\n",
+		       __func__, i, header->op_data_offset[i],
+		       header->op_data_len[i]);
+
+		if (header->op_data_len[i]) {
+			memcpy(tmp, executor->prog_data_buf_bobj[i],
+			       executor->prog_data_size[i]);
+		}
+
+		cur_pos += executor->prog_data_size[i];
+		printk("%s, i=%d, offset=%d, len=%d.\n", __func__, i,
+		       header->op_data_offset[i], header->op_data_len[i]);
+	}
+
+	if (executor->network->num_luts) {
+		header->lut_len =
+			executor->network->num_luts * sizeof(lut_dev_t);
+		printk("%s, %d. NOTE: fill lut with zero. header->lut_len=%u, lut_bse_iova=0x%llx\n",
+		       __func__, __LINE__, header->lut_len,
+		       executor->lut_base_iova);
+		header->lut_offset = cur_pos;
+		tmp = (void *)(buffer + cur_pos);
+		memset(tmp, 0, header->lut_len);
+		header->lut_base_iova = executor->lut_base_iova;
+		cur_pos += header->lut_len;
+	} else {
+		header->lut_offset = 0;
+		header->lut_len = 0;
+		printk("%s, %d. no lut been used. header->lut_len=%u, lut_bse_iova=0x%llx\n",
+		       __func__, __LINE__, header->lut_len,
+		       executor->lut_base_iova);
+	}
+
+	magic_end = (int *)(buffer + cur_pos);
+	header->magic_end_offset = cur_pos;
+	*magic_end = 0x131452;
+	printk("%s, %d, magic_end_ofs=%d.\n", __func__, __LINE__,
+	       header->magic_end_offset);
+
+	wsize = kernel_write(flip, buffer, buf_size, &pos);
+	printk("%s, %d, wsize=%d, header size=%d, pos=%lld.\n", __func__,
+	       __LINE__, wsize, buf_size, pos);
+
+	mbx_irq_frame_done(executor->engine, tiktok, 0);
+
+	kfree(buffer);
+
+err_buffer:
+	filp_close(flip, NULL);
+err_file:
+	kfree(name);
+#endif
+}
diff --git a/drivers/soc/eswin/ai_driver/npu/debug.h b/drivers/soc/eswin/ai_driver/npu/debug.h
new file mode 100644
index 000000000000..7d85d754ed2d
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/npu/debug.h
@@ -0,0 +1,37 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#ifndef __DEBUG_H__
+#define __DEBUG_H__
+#include <dla_engine.h>
+#include "internal_interface.h"
+
+#define OP_STAT_START 0x1
+#define OP_STAT_END 0x2
+
+#define PG_STAT_START 0x4
+#define PG_STAT_END 0x8
+
+#define STAT_IN_INTR 0x10
+#define OP_STAT_NPU 0x20
+#define OP_STAT_DLA 0x40
+
+void dump_dtim_to_file(struct win_engine *engine, u32 tiktok);
+
+void dump_data(const void *buf, const u32 len);
+int dump2file(const char *fname, const void *data, size_t len);
+void dla_dump_src_data(struct win_executor *executor, struct host_frame_desc *f,
+		       int op_index);
+void dla_dump_dst_data(struct win_executor *executor, struct host_frame_desc *f,
+		       int op_index);
+
+void dla_op_stats(struct dla_engine *engine, struct dla_common_op_desc *op,
+		  uint8_t flag);
+void dla_dump_op_stats(struct dla_engine *engine);
+void dump_data_to_file(struct work_struct *work);
+
+#endif
diff --git a/drivers/soc/eswin/ai_driver/npu/dla_buffer.c b/drivers/soc/eswin/ai_driver/npu/dla_buffer.c
new file mode 100644
index 000000000000..32090ca1ac64
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/npu/dla_buffer.c
@@ -0,0 +1,402 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#include "dla_driver.h"
+#include "dla_engine.h"
+#include "dla_log.h"
+#include "dla_buffer.h"
+#include "hetero_ioctl.h"
+#include "internal_interface.h"
+
+struct dla_buffer_object *dla_alloc_dmabuf(size_t size,
+					   enum es_malloc_policy policy)
+{
+	struct dla_buffer_object *bobj = NULL;
+	int ret = 0;
+
+	bobj = kzalloc(sizeof(struct dla_buffer_object), GFP_KERNEL);
+	if (bobj == NULL) {
+		dla_error("err:malloc dla_buffer_object failed!\n");
+		return NULL;
+	}
+
+	ret = dev_mem_alloc(size, policy, &bobj->dmabuf);
+	if (ret < 0) {
+		dla_error("err:dev_mem_alloc failed!\n");
+		kfree(bobj);
+		return NULL;
+	}
+
+	bobj->fd = ret;
+	bobj->size = size;
+
+	return bobj;
+}
+
+int dla_attach_dmabuf(struct dla_buffer_object *bobj, struct device *attach_dev)
+{
+	dma_addr_t dma_addr = 0;
+
+	if (!bobj) {
+		dla_error("err:bobj is NULL!\n");
+		return -EINVAL;
+	}
+
+	if (!attach_dev) {
+		dla_error("err:attach_dev is NULL!\n");
+		return -EINVAL;
+	}
+
+	if (!bobj->dmabuf) {
+		dla_error("err:bobj->dmabuf is NULL!\n");
+		return -EINVAL;
+	}
+
+	dma_addr = dev_mem_attach(bobj->dmabuf, attach_dev, DMA_BIDIRECTIONAL,
+				  &bobj->attach);
+	if (dma_addr == 0) {
+		dla_error("err:dev_mem_attach failed!\n");
+		return -ENOMEM;
+	}
+
+	bobj->dma_addr = dma_addr;
+
+	return 0;
+}
+
+int dla_detach_dmabuf(struct dla_buffer_object *bobj)
+{
+	if (!bobj) {
+		dla_error("err:bobj is NULL!\n");
+		return -EINVAL;
+	}
+
+	if (!bobj->attach) {
+		dla_error("err:bobj->attach is NULL!\n");
+		return -EINVAL;
+	}
+
+	dev_mem_detach(bobj->attach, DMA_BIDIRECTIONAL);
+	bobj->attach = NULL;
+	bobj->sg = NULL;
+
+	return 0;
+}
+
+void *dla_dmabuf_vmap(struct dla_buffer_object *bobj)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 6, 0)
+	struct iosys_map map;
+#else
+	struct dma_buf_map map;
+#endif
+	int ret;
+
+	if (!bobj) {
+		dla_error("err:bobj is NULL!\n");
+		return NULL;
+	}
+
+	if (bobj->vaddr)
+		return bobj->vaddr;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 6, 0)
+	ret = dma_buf_vmap_unlocked(bobj->dmabuf, &map);
+#else
+	ret = dma_buf_vmap(bobj->dmabuf, &map);
+#endif
+
+	if (ret)
+		return NULL;
+
+	WARN_ON_ONCE(map.is_iomem);
+	bobj->vaddr = map.vaddr;
+
+	return bobj->vaddr;
+}
+
+void dla_dmabuf_vunmap(struct dla_buffer_object *bobj)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 6, 0)
+	struct iosys_map map;
+#else
+	struct dma_buf_map map;
+#endif
+
+	WARN_ON(!bobj);
+	if (bobj && bobj->vaddr) {
+		map.vaddr = bobj->vaddr;
+		map.is_iomem = 0;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 6, 0)
+		dma_buf_vunmap_unlocked(bobj->dmabuf, &map);
+#else
+		dma_buf_vunmap(bobj->dmabuf, &map);
+#endif
+		bobj->vaddr = NULL;
+	}
+}
+
+void dla_release_bobj(struct dla_buffer_object *bobj)
+{
+	if (!bobj) {
+		dla_error("err:bobj is NULL!\n");
+		return;
+	}
+
+	if (bobj->vaddr) {
+		dla_dmabuf_vunmap(bobj);
+	}
+
+	if (bobj->attach) {
+		dla_detach_dmabuf(bobj);
+	}
+
+	if (bobj->dmabuf) {
+		dev_mem_free(bobj->dmabuf);
+	}
+
+	kfree(bobj);
+	bobj = NULL;
+}
+
+struct dla_buffer_object *dla_import_fd_to_device(int fd,
+						  struct device *attach_dev)
+{
+	struct dma_buf *dma_buf;
+	struct dla_buffer_object *obj;
+	int ret;
+
+	/* get dmabuf handle */
+	dma_buf = dma_buf_get(fd);
+	if (IS_ERR(dma_buf))
+		return ERR_CAST(dma_buf);
+
+	obj = kzalloc(sizeof(struct dla_buffer_object), GFP_KERNEL);
+	if (obj == NULL) {
+		dla_error("err:malloc dla_buffer_object failed!\n");
+		ret = -ENOMEM;
+		goto fail;
+	}
+
+	obj->dmabuf = dma_buf;
+	obj->fd = fd;
+	obj->size = dma_buf->size;
+
+	ret = dla_attach_dmabuf(obj, attach_dev);
+	if (ret < 0) {
+		dla_error("err:dla_attach_dmabuf failed!\n");
+		goto fail;
+	}
+
+	return obj;
+
+fail:
+	if (obj) {
+		kfree(obj);
+	}
+	dma_buf_put(dma_buf);
+
+	return ERR_PTR(ret);
+}
+
+int dla_mapdma_buf_to_dev(int fd, struct dla_buffer_object *obj,
+			  struct device *attach_dev)
+{
+	struct dma_buf *dma_buf;
+	int ret;
+
+	if (obj == NULL) {
+		dla_error("param obj is null, failed!\n");
+		return -EINVAL;
+	}
+	dma_buf = dma_buf_get(fd);
+	if (IS_ERR(dma_buf)) {
+		return -EIO;
+	}
+	obj->dmabuf = dma_buf;
+	obj->fd = fd;
+	obj->size = dma_buf->size;
+
+	ret = dla_attach_dmabuf(obj, attach_dev);
+	if (ret < 0) {
+		dla_error("err:dla_attach_dmabuf failed!\n");
+		goto fail;
+	}
+	return 0;
+fail:
+	dma_buf_put(dma_buf);
+	return ret;
+}
+
+void dla_unmapdma_buf_to_dev(struct dla_buffer_object *bobj)
+{
+	if (!bobj) {
+		dla_error("err:bobj is NULL!\n");
+		return;
+	}
+
+	if (bobj->vaddr) {
+		dla_dmabuf_vunmap(bobj);
+	}
+
+	if (bobj->attach) {
+		dla_detach_dmabuf(bobj);
+	}
+
+	if (bobj->dmabuf) {
+		dev_mem_free(bobj->dmabuf);
+	}
+}
+
+int dla_import_dmabuf_from_model(struct user_model *model)
+{
+	addrDesc_t *address;
+	int num_address;
+	struct dla_buffer_object *bobjs;
+	struct nvdla_device *nvdla_dev;
+	struct dma_buf *dma_buf;
+	int ret = 0;
+	int i = 0;
+
+	num_address = model->mem_handles.addrlist->numAddress;
+	address = model->mem_handles.addrlist->addrDesc;
+	nvdla_dev = model->nvdla_dev;
+
+	dla_detail("num_address=%d\n", num_address);
+	bobjs = kzalloc(num_address * sizeof(struct dla_buffer_object),
+			GFP_KERNEL);
+	if (bobjs == NULL) {
+		dla_error("err:bobjs is NULL,no memory!\n");
+		return -ENOMEM;
+	}
+
+	for (i = 0; i < num_address; i++) {
+		bobjs[i].fd = address[i].devBuf.memFd;
+		dla_detail("i=%d bobjs[i].fd=%d\n", i, bobjs[i].fd);
+		if (bobjs[i].fd <= 0) {
+			continue;
+		}
+
+		dma_buf = dma_buf_get(bobjs[i].fd);
+		if (IS_ERR(dma_buf)) {
+			ret = PTR_ERR(dma_buf);
+			dla_error("err:dma_buf_get failed!i:%d fd:%d, ret:%d\n",
+				  i, bobjs[i].fd, ret);
+			goto fail;
+		}
+
+		dla_detail("i=%d bobjs[i].fd=%d,dma_buf=0x%px counter=%lld\n",
+			   i, bobjs[i].fd, dma_buf,
+			   dma_buf->file->f_count.counter);
+		bobjs[i].dmabuf = dma_buf;
+		ret = dla_attach_dmabuf(&bobjs[i], &nvdla_dev->pdev->dev);
+		if (ret < 0) {
+			dla_error("err:dla_attach_dmabuf failed!\n");
+			dma_buf_put(dma_buf);
+			bobjs[i].fd = -1;
+			goto fail;
+		}
+	}
+
+	model->mem_handles.bobjs = bobjs;
+
+	return ret;
+fail:
+
+	for (i = 0; i < num_address; i++) {
+		if (bobjs[i].fd > 0) {
+			dla_detach_dmabuf(&bobjs[i]);
+			if (bobjs[i].dmabuf) {
+				dma_buf_put(bobjs[i].dmabuf);
+			}
+		}
+	}
+
+	kfree(bobjs);
+
+	return ret;
+}
+
+int dla_detach_dmabuf_from_model(struct user_model *model)
+{
+	int num_address;
+	struct dla_buffer_object *bobjs;
+	int ret = 0;
+	int i = 0;
+
+	num_address = model->mem_handles.addrlist->numAddress;
+	dla_detail("num_address=%d\n", num_address);
+
+	bobjs = model->mem_handles.bobjs;
+
+	for (i = 0; i < num_address; i++) {
+		dla_detail("i=%d bobjs[i].fd=%d\n", i, bobjs[i].fd);
+		if (bobjs[i].fd > 0) {
+			dla_detach_dmabuf(&bobjs[i]);
+			if (bobjs[i].dmabuf) {
+				dma_buf_put(bobjs[i].dmabuf);
+			}
+		}
+	}
+
+	kfree(bobjs);
+
+	return ret;
+}
+
+int dla_dmabuf_vmap_for_model(struct user_model *model)
+{
+	int num_address;
+	struct dla_buffer_object *bobjs;
+	int ret = 0;
+	int i = 0;
+
+	num_address = model->mem_handles.addrlist->numAddress;
+	bobjs = model->mem_handles.bobjs;
+
+	for (i = 0; i < num_address; i++) {
+		dla_detail("i=%d bobjs[i].fd=%d\n", i, bobjs[i].fd);
+		if (bobjs[i].fd <= 0) {
+			continue;
+		}
+		if (dla_dmabuf_vmap(&bobjs[i]) == NULL) {
+			dla_error("err:i=%d bobjs[i].fd=%d vmap failed\n", i,
+				  bobjs[i].fd);
+			ret = -1;
+			goto fail;
+		}
+	}
+
+	return ret;
+fail:
+
+	for (i = 0; i < num_address; i++) {
+		if (bobjs[i].fd > 0) {
+			if (bobjs[i].vaddr) {
+				dla_dmabuf_vunmap(&bobjs[i]);
+			}
+		}
+	}
+
+	return ret;
+}
+
+void dla_dmabuf_vunmap_for_model(struct user_model *model)
+{
+	int num_address;
+	struct dla_buffer_object *bobjs;
+	int i = 0;
+
+	num_address = model->mem_handles.addrlist->numAddress;
+	bobjs = model->mem_handles.bobjs;
+
+	for (i = 0; i < num_address; i++) {
+		if (bobjs[i].fd > 0 && bobjs[i].vaddr != NULL) {
+			dla_dmabuf_vunmap(&bobjs[i]);
+		}
+	}
+}
diff --git a/drivers/soc/eswin/ai_driver/npu/dla_buffer.h b/drivers/soc/eswin/ai_driver/npu/dla_buffer.h
new file mode 100644
index 000000000000..7fa41c8c4f98
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/npu/dla_buffer.h
@@ -0,0 +1,59 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#ifndef DLA_BUFFER_H
+#define DLA_BUFFER_H
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <linux/mm.h>
+#include <linux/uaccess.h>
+#include <linux/fs.h>
+#include <linux/file.h>
+#include <linux/dma-buf.h>
+#include <linux/dma-mapping.h>
+#include <linux/dma-map-ops.h>
+#include "internal_interface.h"
+#include <linux/dsp_dma_buf.h>
+
+struct user_model;
+
+struct dla_buffer_object {
+	int32_t fd;
+	void *vaddr;
+	dma_addr_t dma_addr;
+	uint32_t size;
+	struct dma_buf *dmabuf;
+	struct dma_buf_attachment *attach;
+	struct sg_table *sg;
+};
+
+struct npu_dma_buf_ex {
+	struct khandle handle;
+	ES_DEV_BUF_S buf_info;
+	struct dla_buffer_object obj;
+};
+
+struct dla_buffer_object *dla_alloc_dmabuf(size_t size,
+					   enum es_malloc_policy policy);
+int dla_attach_dmabuf(struct dla_buffer_object *dobj,
+		      struct device *attach_dev);
+int dla_detach_dmabuf(struct dla_buffer_object *dobj);
+void *dla_dmabuf_vmap(struct dla_buffer_object *dobj);
+void dla_dmabuf_vunmap(struct dla_buffer_object *dobj);
+void dla_release_bobj(struct dla_buffer_object *dobj);
+struct dla_buffer_object *dla_import_fd_to_device(int fd,
+						  struct device *attach_dev);
+int dla_import_dmabuf_from_model(struct user_model *model);
+int dla_detach_dmabuf_from_model(struct user_model *model);
+
+int dla_dmabuf_vmap_for_model(struct user_model *model);
+void dla_dmabuf_vunmap_for_model(struct user_model *model);
+
+int dla_mapdma_buf_to_dev(int fd, struct dla_buffer_object *obj,
+			  struct device *attach_dev);
+void dla_unmapdma_buf_to_dev(struct dla_buffer_object *obj);
+#endif
diff --git a/drivers/soc/eswin/ai_driver/npu/dla_driver.c b/drivers/soc/eswin/ai_driver/npu/dla_driver.c
new file mode 100644
index 000000000000..b2eb069aa0fa
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/npu/dla_driver.c
@@ -0,0 +1,14 @@
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/of_irq.h>
+#include "dla_driver.h"
+
+void dla_reg_write(struct nvdla_device *dev, uint32_t addr, uint32_t value)
+{
+	writel(value, dev->base + addr);
+}
+
+uint32_t dla_reg_read(struct nvdla_device *dev, uint32_t addr)
+{
+	return readl(dev->base + addr);
+}
diff --git a/drivers/soc/eswin/ai_driver/npu/dla_driver.h b/drivers/soc/eswin/ai_driver/npu/dla_driver.h
new file mode 100644
index 000000000000..e732c99a91f8
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/npu/dla_driver.h
@@ -0,0 +1,73 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#ifndef DLA_DRIVER_H
+#define DLA_DRIVER_H
+
+#include <linux/types.h>
+#include <linux/completion.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/spinlock.h>
+#include <linux/wait.h>
+#include <linux/clk.h>
+#include <linux/mailbox_controller.h>
+
+#include "dla_interface.h"
+#include "hetero_common.h"
+
+struct nvdla_device {
+	int numa_id;
+	int32_t npu_irq;
+	int32_t dla_irq;
+	void __iomem *base;
+	void __iomem *e31_mmio_base;
+	void __iomem *emission_base;
+	void __iomem *program_base;
+	void __iomem *uart_mutex_base;
+	char *e31_fw_virt_base;
+	dma_addr_t e31_nim_iova;
+	uint32_t e31_fw_size;
+	struct mutex task_mutex;
+	void *engine_context;
+	void *win_engine;
+	struct mbox_chan *mbx_chan;
+	struct platform_device *mbox_pdev;
+
+	void *executor;
+	struct platform_device *pdev;
+	bool irq_happened;
+	wait_queue_head_t event_wq;
+	spinlock_t nvdla_lock;
+	struct dla_buffer_object *spram_bobj;
+	uint64_t spram_base_addr;
+	uint32_t spram_size;
+	void *edma;
+	bool perf_stat;
+
+	struct reset_control *rstc_e31_core;
+	struct clk *e31_core_clk;
+
+	struct clk *mbox_pclk_device;
+	struct clk *mbox_pclk;
+	int32_t mbox_irq;
+	struct reset_control *mbox_rst_device;
+	struct reset_control *mbox_rst;
+	void __iomem *mbox_rx_base;
+	void __iomem *mbox_tx_base;
+	u32 mbox_tx_lock_bit;
+	u32 mbox_tx_irq_bit;
+	spinlock_t mbox_lock;
+
+	uint16_t *pause_op_list;
+};
+
+void dla_reg_write(struct nvdla_device *dev, uint32_t addr, uint32_t value);
+
+uint32_t dla_reg_read(struct nvdla_device *dev, uint32_t addr);
+
+#endif
diff --git a/drivers/soc/eswin/ai_driver/npu/dla_engine_internal.h b/drivers/soc/eswin/ai_driver/npu/dla_engine_internal.h
new file mode 100644
index 000000000000..1ab86ecaa78c
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/npu/dla_engine_internal.h
@@ -0,0 +1,176 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#ifndef __DLA_ENGINE_INTERNAL_H_
+#define __DLA_ENGINE_INTERNAL_H_
+
+#include <opendla.h>
+#include <dla_engine.h>
+#include <dla_interface.h>
+#include "nvdla_interface.h"
+#include <linux/kernel.h>
+#include "internal_interface.h"
+
+#define BITS(num, range) ((((0xFFFFFFFF >> (31 - (1 ? range))) & \
+			(0xFFFFFFFF << (0 ? range))) & num) >> \
+			(0 ? range))
+#define HIGH32BITS(val64bit) ((uint32_t)((val64bit) >> 32))
+#define LOW32BITS(val64bit) ((uint32_t)(val64bit))
+
+#ifdef MIN
+#undef MIN
+#endif /* MIN */
+
+#ifdef MAX
+#undef MAX
+#endif /* MAX */
+
+#define MIN(a, b) ((a) > (b) ? (b) : (a))
+#define MAX(a, b) ((a) > (b) ? (a) : (b))
+
+/*********************************************************/
+/******************** Utilities **************************/
+/*********************************************************/
+#ifdef DEBUG
+#define CHECK_ALIGN(val, align) assert((val & (align - 1)) == 0)
+#else
+#define CHECK_ALIGN(val, align)
+#endif /* DEBUG */
+
+#define NPU_MASK(reg, field) (reg##_##field##_FIELD)
+#define FIELD_ENUM(r, f, e) (r##_##f##_##e)
+#define SHIFT(reg, field) (reg##_##field##_SHIFT)
+
+#define GLB_REG(name) GLB_##name##_0
+#define MCIF_REG(name) MCIF_##name##_0
+#define CVIF_REG(name) CVIF_##name##_0
+#define BDMA_REG(name) BDMA_##name##_0
+#define CDMA_REG(name) CDMA_##name##_0
+#define CSC_REG(name) CSC_##name##_0
+#define CMAC_A_REG(name) CMAC_A_##name##_0
+#define CMAC_B_REG(name) CMAC_B_##name##_0
+#define CACC_REG(name) CACC_##name##_0
+#define SDP_RDMA_REG(name) SDP_RDMA_##name##_0
+#define SDP_REG(name) SDP_##name##_0
+#define PDP_RDMA_REG(name) PDP_RDMA_##name##_0
+#define PDP_REG(name) PDP_##name##_0
+#define CDP_RDMA_REG(name) CDP_RDMA_##name##_0
+#define CDP_REG(name) CDP_##name##_0
+#define RBK_REG(name) RBK_##name##_0
+
+/* alias for register read for each sub-module */
+#define glb_reg_read(base, reg) readl(base + GLB_REG(reg))
+
+/* alias for register write for each sub-module */
+#define glb_reg_write(base, reg, val) writel(val, base + GLB_REG(reg))
+
+int dla_enable_intr(struct nvdla_device *dev, uint32_t mask);
+int dla_disable_intr(struct nvdla_device *dev, uint32_t mask);
+int dla_get_dma_cube_address(void *driver_context, void *task_data,
+			     int16_t index, uint32_t offset, void *dst_ptr,
+			     u32 *is_io_tensor);
+int dla_read_input_address(struct dla_data_cube *data, uint64_t *address);
+int dla_get_sram_cube_address(void *driver_context, void *task_data,
+			      int16_t index, uint32_t offset, uint64_t *dst_ptr,
+			      u32 *is_io_tensor);
+
+/**
+ * Convolution operations
+ */
+int dla_conv_rdma_check(struct dla_processor_group *group,
+			union dla_operation_container *op,
+			union dla_surface_container *surface);
+
+/**
+ * SDP operations
+ */
+int dla_sdp_rdma_check(struct dla_processor_group *group,
+		       union dla_operation_container *op,
+		       union dla_surface_container *surface);
+/**
+ * PDP operations
+ */
+int dla_pdp_rdma_check(struct dla_processor_group *group,
+		       union dla_operation_container *op,
+		       union dla_surface_container *surface);
+
+/**
+ * RUBIK operations
+ */
+int dla_rubik_rdma_check(struct dla_processor_group *group,
+			 union dla_operation_container *op,
+			 union dla_surface_container *surface);
+
+int edma_rdma_check(struct dla_processor_group *group,
+		    union dla_operation_container *op,
+		    union dla_surface_container *surface);
+
+int dsp_register_interface(void *rt, int instance_num);
+void dsp_set_producer(int32_t group_id, int32_t __unused);
+int dsp_enable(struct dla_processor_group *group);
+int dsp_rdma_check(struct dla_processor_group *group,
+		   union dla_operation_container *op,
+		   union dla_surface_container *surface);
+int dsp_is_ready(struct processors_interface *processor,
+		 struct dla_processor_group *group);
+void dsp_dump_config(struct dla_processor_group *group);
+
+void sim_pdp_set_producer(int32_t group_id, int32_t rdma_group_id);
+
+int sim_pdp_enable(struct dla_processor_group *group);
+
+void sim_pdp_rdma_check(struct dla_processor_group *group);
+
+int32_t sim_pdp_program(struct dla_processor_group *group);
+
+int sim_pdp_is_ready(struct dla_processor *processor,
+		     struct dla_processor_group *group);
+
+void sim_pdp_dump_config(struct dla_processor_group *group);
+
+void sim_pdp_stat_data(struct dla_processor *processor,
+		       struct dla_processor_group *group);
+
+void sim_pdp_dump_stat(struct dla_processor *processor);
+
+void sim_sdp_set_producer(int32_t group_id, int32_t rdma_group_id);
+
+int sim_sdp_enable(struct dla_processor_group *group);
+
+void sim_sdp_rdma_check(struct dla_processor_group *group);
+
+int32_t sim_sdp_program(struct dla_processor_group *group);
+
+int sim_sdp_is_ready(struct dla_processor *processor,
+		     struct dla_processor_group *group);
+
+void sim_sdp_dump_config(struct dla_processor_group *group);
+
+void sim_sdp_stat_data(struct dla_processor *processor,
+		       struct dla_processor_group *group);
+
+void sim_sdp_dump_stat(struct dla_processor *processor);
+
+void sim_edma_set_producer(int32_t group_id, int32_t rdma_group_id);
+
+int sim_edma_enable(struct dla_processor_group *group);
+
+void sim_edma_rdma_check(struct dla_processor_group *group);
+
+int32_t sim_edma_program(struct dla_processor_group *group);
+
+int sim_edma_is_ready(struct dla_processor *processor,
+		      struct dla_processor_group *group);
+
+void sim_edma_dump_config(struct dla_processor_group *group);
+
+void sim_edma_stat_data(struct dla_processor *processor,
+			struct dla_processor_group *group);
+
+void sim_edma_dump_stat(struct dla_processor *processor);
+
+#endif
diff --git a/drivers/soc/eswin/ai_driver/npu/dla_log.c b/drivers/soc/eswin/ai_driver/npu/dla_log.c
new file mode 100644
index 000000000000..d12729d8600f
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/npu/dla_log.c
@@ -0,0 +1,169 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#include <linux/printk.h>
+#include <linux/module.h>
+#include <linux/sched/clock.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/spinlock.h>
+#include "dla_log.h"
+
+/*/sys/module/npu/parameters/*/
+#if NPU_PERF_STATS
+int npu_debug_control = NPU_PRINT_ERROR;
+#else
+#if LOG_LEVEL == 0
+int npu_debug_control = NPU_PRINT_ERROR;
+#elif LOG_LEVEL == 1
+int npu_debug_control = NPU_PRINT_WARN;
+#elif LOG_LEVEL == 2
+int npu_debug_control = NPU_PRINT_INFO;
+#else
+int npu_debug_control = NPU_PRINT_DETAIL;
+#endif
+#endif
+
+int loop_buf_enable = 0;
+module_param(loop_buf_enable, int, 0644);
+MODULE_PARM_DESC(loop_buf_enable, "loop buf enable");
+
+static int loop_buf_cnt = 1500;
+module_param(loop_buf_cnt, int, 0644);
+MODULE_PARM_DESC(loop_buf_cnt, "loop buf cnt");
+
+module_param(npu_debug_control, int, 0644);
+MODULE_PARM_DESC(npu_debug_control, "npu debug control");
+
+#define LP_BUF_LEN 128
+
+static char *loop_buf = NULL;
+static int lb_pointer = -1;
+static spinlock_t lb_spin_lock;
+static int lp_buf_cnt = 0;
+
+static int dla_loop_buf_init(void)
+{
+	lp_buf_cnt = loop_buf_cnt;
+
+	if (loop_buf != NULL) {
+		vfree(loop_buf);
+		loop_buf = NULL;
+	}
+
+	loop_buf = vmalloc(lp_buf_cnt * LP_BUF_LEN);
+	if (loop_buf == NULL) {
+		printk("malloc loop_buf failed!lp_buf_cnt=%d\n", lp_buf_cnt);
+		loop_buf_enable = 0;
+		return -1;
+	}
+	memset(loop_buf, 0, lp_buf_cnt * LP_BUF_LEN);
+
+	spin_lock_init(&lb_spin_lock);
+
+	return 0;
+}
+
+void dla_loop_buf_exit(void)
+{
+	if (loop_buf != NULL) {
+		vfree(loop_buf);
+		loop_buf = NULL;
+	}
+
+	return;
+}
+
+void dla_loop_buf_enable(void)
+{
+	loop_buf_enable = 1;
+}
+
+void dla_loop_buf_disable(void)
+{
+	loop_buf_enable = 0;
+	lb_pointer = -1;
+	if (loop_buf != NULL) {
+		memset(loop_buf, 0, lp_buf_cnt * LP_BUF_LEN);
+	}
+}
+
+static size_t print_time(u64 ts, char *buf)
+{
+	unsigned long rem_nsec = do_div(ts, 1000000000);
+
+	return sprintf(buf, "[%5lu.%06lu]", (unsigned long)ts, rem_nsec / 1000);
+}
+
+void dla_print_to_loopbuf(const char *str, ...)
+{
+	int ret = 0;
+	size_t len = 0;
+	char *t_buf = NULL;
+	u64 ts_nsec;
+	unsigned long flags;
+	va_list args;
+
+	if (loop_buf_enable == 0)
+		return;
+	if ((loop_buf == NULL) || (lp_buf_cnt != loop_buf_cnt)) {
+		ret = dla_loop_buf_init();
+		if (ret)
+			return;
+	}
+
+	va_start(args, str);
+	ts_nsec = local_clock();
+
+	spin_lock_irqsave(&lb_spin_lock, flags);
+	if (lb_pointer == lp_buf_cnt - 1 || lb_pointer == -1) {
+		lb_pointer = 0;
+	}
+
+	t_buf = loop_buf + lb_pointer * LP_BUF_LEN;
+
+	memset(t_buf, 0, LP_BUF_LEN);
+	len = print_time(ts_nsec, t_buf);
+	len += vsnprintf(t_buf + len, LP_BUF_LEN - len, str, args);
+
+	lb_pointer++;
+	spin_unlock_irqrestore(&lb_spin_lock, flags);
+
+	va_end(args);
+
+	return;
+}
+
+void dla_output_loopbuf(void)
+{
+	int i = 0;
+	unsigned long flags;
+
+	if (lb_pointer == -1)
+		return;
+
+	spin_lock_irqsave(&lb_spin_lock, flags);
+	for (i = lb_pointer; i < lp_buf_cnt; i++) {
+		if (loop_buf[i * LP_BUF_LEN] == 0)
+			break;
+		printk("%s", loop_buf + i * LP_BUF_LEN);
+	}
+
+	for (i = 0; i < lb_pointer; i++) {
+		printk("%s", loop_buf + i * LP_BUF_LEN);
+	}
+
+	lb_pointer = -1;
+	spin_unlock_irqrestore(&lb_spin_lock, flags);
+
+	return;
+}
+
+void set_debug_level(int level)
+{
+	npu_debug_control = level;
+}
diff --git a/drivers/soc/eswin/ai_driver/npu/dla_log.h b/drivers/soc/eswin/ai_driver/npu/dla_log.h
new file mode 100644
index 000000000000..d1be7e55e9b6
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/npu/dla_log.h
@@ -0,0 +1,53 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#ifndef DLA_LOG_H
+#define DLA_LOG_H
+
+void dla_loop_buf_enable(void);
+void dla_loop_buf_disable(void);
+void dla_loop_buf_exit(void);
+void dla_output_loopbuf(void);
+void dla_print_to_loopbuf(const char *str, ...);
+
+#define DEBUG_SHIFT_EDMA 0
+#define DEBUG_SHIFT_CONV 4
+#define DEBUG_SHIFT_SDP 8
+#define DEBUG_SHIFT_PDP 12
+#define DEBUG_SHIFT_DLA 16
+#define DEBUG_SHIFT_DSP 20
+
+#define DEBUG_BIT_MASK 0xf
+
+#define NPU_PRINT_ERROR 1
+#define NPU_PRINT_WARN 2
+#define NPU_PRINT_INFO 3
+#define NPU_PRINT_DEBUG 4
+#define NPU_PRINT_DETAIL 5
+
+extern int npu_debug_control;
+extern int loop_buf_enable;
+
+#define npu_log(level, fmt, ...)                                          \
+	do {                                                              \
+		if (level <= npu_debug_control)                           \
+			printk(KERN_INFO "[NPU][DRIVER][%s](%s:%d) " fmt, \
+			       level == NPU_PRINT_ERROR ? "ERROR" :       \
+			       level == NPU_PRINT_WARN	? "WARNING" :     \
+			       level == NPU_PRINT_INFO	? "INFO" :        \
+			       level == NPU_PRINT_DEBUG ? "DEBUG" :       \
+								"DETAIL",       \
+			       __func__, __LINE__, ##__VA_ARGS__);        \
+	} while (0)
+
+#define dla_error(fmt, ...) npu_log(NPU_PRINT_ERROR, fmt, ##__VA_ARGS__);
+#define dla_warn(fmt, ...) npu_log(NPU_PRINT_WARN, fmt, ##__VA_ARGS__);
+#define dla_info(fmt, ...) npu_log(NPU_PRINT_INFO, fmt, ##__VA_ARGS__);
+#define dla_debug(fmt, ...) npu_log(NPU_PRINT_DEBUG, fmt, ##__VA_ARGS__);
+#define dla_detail(fmt, ...) npu_log(NPU_PRINT_DETAIL, fmt, ##__VA_ARGS__);
+
+#endif
diff --git a/drivers/soc/eswin/ai_driver/npu/dsp.c b/drivers/soc/eswin/ai_driver/npu/dsp.c
new file mode 100644
index 000000000000..60c66db71704
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/npu/dsp.c
@@ -0,0 +1,865 @@
+// Copyright © 2024 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#include <opendla.h>
+#include <dla_err.h>
+#include <dla_interface.h>
+#include "common.h"
+#include "dla_engine_internal.h"
+#include "dla_log.h"
+#include "internal_interface.h"
+#include "dsp_hw.h"
+#include "hetero_ioctl.h"
+#include "dsp.h"
+#include "dla_buffer.h"
+
+static struct dsp_dma_buf *npu_get_dsp_dmabuf(struct file *file, int memfd)
+{
+	struct dsp_file *dsp_file = NULL;
+	struct dsp_dma_buf *dma_buf = NULL;
+
+	if (file == NULL) {
+		dla_error("%s, %d, file is null.\n", __func__, __LINE__);
+		return NULL;
+	}
+	dsp_file = file->private_data;
+	if (dsp_file == NULL) {
+		dla_error("%s, %d, dsp file is null.\n", __func__, __LINE__);
+		goto err;
+	}
+	dma_buf = dsp_get_dma_buf_ex(dsp_file, memfd);
+	if (dma_buf == NULL) {
+		dma_buf = NULL;
+		goto err;
+	}
+err:
+	return dma_buf;
+}
+
+static void npu_put_dsp_dmabuf(struct file *file, struct dsp_dma_buf **dma_buf)
+{
+	struct dsp_file *dsp_file = NULL;
+
+	if (dma_buf == NULL) {
+		return;
+	}
+
+	if (file == NULL) {
+		return;
+	}
+
+	dsp_file = file->private_data;
+
+	if (dsp_file == NULL) {
+		dla_error("%s, %d, dsp file is null.\n", __func__, __LINE__);
+		goto err;
+	}
+	dla_debug("%s, %d, file count=%ld.\n", __func__, __LINE__,
+		  file_count(file));
+	dsp_unmap_dmabuf(dsp_file, dma_buf, 1);
+err:
+	return;
+}
+
+static u32 npu_get_dsp_ddr(struct win_executor *executor, int devid, int index)
+{
+	struct nvdla_task *task;
+	struct dsp_dma_buf *dmabuf;
+	int memfd;
+
+	task = executor->mem_handles;
+	if (task == NULL) {
+		dla_error("%s, %d, task is null. error.\n", __func__, __LINE__);
+		return 0;
+	}
+
+	memfd = task->bobjs[index].fd;
+	if (memfd < 0) {
+		dla_error("%s, %d, index=%d, memfd is not invalid.\n", __func__,
+			  __LINE__, index);
+		return 0;
+	}
+	mutex_lock(&executor->xrray_lock[devid]);
+	dmabuf = xa_load(&executor->dsp_ddr_xrray[devid], memfd);
+	if (dmabuf) {
+		mutex_unlock(&executor->xrray_lock[devid]);
+		return dmabuf->dma_addr;
+	}
+
+	dmabuf = npu_get_dsp_dmabuf(executor->dsp_file[devid], memfd);
+	if (dmabuf == NULL) {
+		mutex_unlock(&executor->xrray_lock[devid]);
+		dla_error(
+			"%s, %d, cannot get index=%d, memfd=%d dmabuf, error.\n",
+			__func__, __LINE__, index, memfd);
+		return 0;
+	}
+
+	xa_store(&executor->dsp_ddr_xrray[devid], memfd, dmabuf, GFP_KERNEL);
+	mutex_unlock(&executor->xrray_lock[devid]);
+	return dmabuf->dma_addr;
+}
+
+static void npu_put_dsp_ddr(struct win_executor *executor, int devid)
+{
+	unsigned long idx = 0;
+	struct dsp_dma_buf *entry = NULL;
+
+	if (executor->dsp_file[devid] == NULL) {
+		return;
+	}
+	mutex_lock(&executor->xrray_lock[devid]);
+	xa_for_each(&executor->dsp_ddr_xrray[devid], idx, entry) {
+		xa_erase(&executor->dsp_ddr_xrray[devid], idx);
+		npu_put_dsp_dmabuf(executor->dsp_file[devid], &entry);
+	}
+	mutex_unlock(&executor->xrray_lock[devid]);
+}
+
+static int dsp_tensor_unfold(struct win_executor *executor, int op_idx,
+			     union dla_operation_container *operation_desc,
+			     union dla_surface_container *surface_desc,
+			     void *tensor, int idx, int op_type)
+{
+	struct dsp_op_desc *dsp_op = NULL;
+	dsp_tensor_t *tensor_set = (dsp_tensor_t *)tensor;
+	dsp_tensor_t *dsp_tensor;
+	struct dsp_surface_desc *surface = &surface_desc->dsp_surface;
+	int dsp_dev_idx = op_type - DLA_KMD_OP_DSP_0;
+	u32 mem_id, offset;
+	int flat1_size;
+	int ret, i;
+	dsp_dev_t *vaddr = (dsp_dev_t *)executor->prog_data_buf_bobj[op_type];
+	dsp_dev_t *dsp = (dsp_dev_t *)&vaddr[idx];
+
+	dsp_op = &operation_desc->dsp_op;
+
+	dsp_tensor = &tensor_set[idx];
+	dla_debug("%s, %d, op_idx=%d, idx=%d, dsp_tensor=0x%px.\n", __func__,
+		  __LINE__, op_idx, idx, dsp_tensor);
+
+	if (tensor_set != NULL && dsp_tensor != NULL &&
+	    dsp_tensor->have_unfold) {
+		dsp->npu_info.current_op_idx = op_idx;
+		ret = load_operator(executor->engine->dsp_dev[dsp_dev_idx],
+				    NULL, dsp_op->operator_name,
+				    &dsp_tensor->handle);
+		if (ret != 0) {
+			dla_error(
+				"err:dsp load_operator failed,ret:%d dsp_dev_idx:%d idx:%d\n",
+				ret, dsp_dev_idx, idx);
+			return -1;
+		}
+		dla_debug(
+			"%s, %d, op_idx=%d, dsp_tensor=0x%px, handle=0x%llx.\n",
+			__func__, __LINE__, op_idx, dsp_tensor,
+			dsp_tensor->handle);
+		return 0;
+	}
+
+	flat1_size = (dsp_op->buffer_cnt_cfg + dsp_op->buffer_cnt_input +
+		      dsp_op->buffer_cnt_output) *
+		     sizeof(es_dsp_buffer);
+	flat1_size += sizeof(struct es_dsp_flat1_desc);
+	flat1_size = round_up(flat1_size, 64);
+
+	dla_debug("mem_id=%d,flat1_size=%d\n", dsp_op->mem_id, flat1_size);
+
+	mem_id = dsp_op->mem_id;
+	offset = dsp_op->offset;
+
+	dsp_tensor = &tensor_set[idx];
+	dla_debug("%s, %d, op_type=%d.\n", __func__, __LINE__, op_type);
+	dla_debug("%s, %d, idx=%d, tensor_set=0x%px.\n", __func__, __LINE__,
+		  idx, tensor_set);
+	dla_debug("%s, %d, idx=%d, dsp_tensor=0x%px.\n", __func__, __LINE__,
+		  idx, dsp_tensor);
+	for (i = 0; i < dsp_op->buffer_cnt_input; i++) {
+		ret = read_input_address(executor, &surface->src_data[i],
+					 (void *)&dsp_tensor->src_base_addr[i],
+					 &dsp_tensor->src_is_io_tensor[i]);
+		if (ret != 0) {
+			dla_error("%s %d bad memory type %d\n", __func__,
+				  __LINE__, surface->src_data[i].type);
+			return -1;
+		}
+		if (dsp_tensor->src_is_io_tensor[i] != invalid_tensor_idx) {
+			executor->dsp_all_inout
+				[dsp_dev_idx][dsp_tensor->src_is_io_tensor[i]]++;
+			executor->dsp_iobuf_cnt[dsp_dev_idx]++;
+		}
+		dla_debug("i=%d src_base_addr=0x%llx src_is_io_tensor=0x%x\n",
+			  i, dsp_tensor->src_base_addr[i],
+			  dsp_tensor->src_is_io_tensor[i]);
+	}
+
+	for (i = 0; i < dsp_op->buffer_cnt_output; i++) {
+		ret = read_input_address(executor, &surface->dst_data[i],
+					 (void *)&dsp_tensor->dst_base_addr[i],
+					 &dsp_tensor->dst_is_io_tensor[i]);
+		if (ret != 0) {
+			dla_error("%s %d bad memory type %d\n", __func__,
+				  __LINE__, surface->dst_data[i].type);
+			return -1;
+		}
+		if (dsp_tensor->dst_is_io_tensor[i] != invalid_tensor_idx) {
+			executor->dsp_all_inout
+				[dsp_dev_idx][dsp_tensor->dst_is_io_tensor[i]]++;
+			executor->dsp_iobuf_cnt[dsp_dev_idx]++;
+		}
+
+		dla_debug(
+			"i=%d op_idx=%d, type=%d, dst_base_addr=0x%llx dst_is_io_tensor=0x%x\n",
+			i, op_idx, surface->dst_data[i].type,
+			dsp_tensor->dst_base_addr[i],
+			dsp_tensor->dst_is_io_tensor[i]);
+	}
+
+	dsp_tensor->have_unfold = 1;
+	return flat1_size;
+}
+
+int dsp0_tensor_unfold(struct win_executor *executor, int op_idx,
+		       union dla_operation_container *operation_desc,
+		       union dla_surface_container *surface_desc, void *tensor,
+		       int idx)
+{
+	return dsp_tensor_unfold(executor, op_idx, operation_desc, surface_desc,
+				 tensor, idx, DLA_KMD_OP_DSP_0);
+}
+
+int dsp1_tensor_unfold(struct win_executor *executor, int op_idx,
+		       union dla_operation_container *operation_desc,
+		       union dla_surface_container *surface_desc, void *tensor,
+		       int idx)
+{
+	return dsp_tensor_unfold(executor, op_idx, operation_desc, surface_desc,
+				 tensor, idx, DLA_KMD_OP_DSP_1);
+}
+
+int dsp2_tensor_unfold(struct win_executor *executor, int op_idx,
+		       union dla_operation_container *operation_desc,
+		       union dla_surface_container *surface_desc, void *tensor,
+		       int idx)
+{
+	return dsp_tensor_unfold(executor, op_idx, operation_desc, surface_desc,
+				 tensor, idx, DLA_KMD_OP_DSP_2);
+}
+
+int dsp3_tensor_unfold(struct win_executor *executor, int op_idx,
+		       union dla_operation_container *operation_desc,
+		       union dla_surface_container *surface_desc, void *tensor,
+		       int idx)
+{
+	return dsp_tensor_unfold(executor, op_idx, operation_desc, surface_desc,
+				 tensor, idx, DLA_KMD_OP_DSP_3);
+}
+
+static int processor_dsp_program(struct win_executor *executor, int idx,
+				 u16 op_idx,
+				 union dla_operation_container *op_desc,
+				 union dla_surface_container *surf_desc,
+				 int op_type)
+{
+	struct dsp_op_desc *dsp_op;
+	u32 param_data_loac_offset = offsetof(struct dsp_op_desc, dsp_core_id);
+	dsp_tensor_t *tensor_set = executor->tensor_set[op_type];
+	dsp_tensor_t *dsp_tensor = &tensor_set[idx];
+	dsp_dev_t *vaddr = (dsp_dev_t *)executor->prog_data_buf_bobj[op_type];
+	dsp_dev_t *dsp = (dsp_dev_t *)&vaddr[idx];
+	struct es_dsp_flat1_desc *flat1_desc;
+	es_dsp_buffer *dsp_buffer;
+	struct dsp_surface_desc *surface;
+	u32 param_addr_offset = 0;
+	u32 dsp_buf_idx = 0;
+	u32 offset;
+	es_dsp_h2d_msg h2d_msg;
+	int i, io_cnt;
+	int dev_id = op_type - DLA_KMD_OP_DSP_0;
+
+	dsp_op = &op_desc->dsp_op;
+	surface = &surf_desc->dsp_surface;
+
+	offset = dsp_op->offset;
+
+	flat1_desc = (struct es_dsp_flat1_desc *)dsp_tensor->flat1_vaddr;
+
+	dla_debug("%s, %d, flat1_desc=0x%px.\n", __func__, __LINE__,
+		  flat1_desc);
+	dla_debug("%s, %d, cnt_cfg=%d.\n", __func__, __LINE__,
+		  dsp_op->buffer_cnt_cfg);
+	dla_debug("%s, %d, cnt_input=%d.\n", __func__, __LINE__,
+		  dsp_op->buffer_cnt_input);
+	dla_debug("%s, %d, cnt_output=%d.\n", __func__, __LINE__,
+		  dsp_op->buffer_cnt_output);
+	flat1_desc->num_buffer = dsp_op->buffer_cnt_cfg +
+				 dsp_op->buffer_cnt_input +
+				 dsp_op->buffer_cnt_output;
+
+	dla_debug("%s, %d op_handle=0x%llx.\n", __func__, __LINE__,
+		  dsp_tensor->handle);
+	dsp_set_flat_func(flat1_desc, dsp_tensor->handle);
+
+	flat1_desc->input_index = dsp_op->buffer_cnt_cfg;
+	flat1_desc->output_index =
+		dsp_op->buffer_cnt_cfg + dsp_op->buffer_cnt_input;
+	dsp_buffer = flat1_desc->buffers;
+
+	for (i = 0; i < dsp_op->buffer_cnt_cfg; i++) {
+		dsp_buffer[i].addr = dsp_tensor->data_dma_addr +
+				     param_data_loac_offset + offset +
+				     param_addr_offset;
+		dsp_buffer[i].size = dsp_op->buffer_size[i];
+		param_addr_offset += dsp_op->buffer_size[i];
+		dla_debug("%s, %d cfg=%d , addr=0x%x, size=0x%x.\n", __func__,
+			  __LINE__, i, dsp_buffer[i].addr, dsp_buffer[i].size);
+	}
+
+	dsp_buf_idx = dsp_op->buffer_cnt_cfg;
+
+	for (i = 0; i < dsp_op->buffer_cnt_input; i++) {
+		if (dsp_tensor->src_is_io_tensor[i] == invalid_tensor_idx) {
+			if (surface->src_data[i].type == DLA_MEM_MC) {
+				dsp_buffer[dsp_buf_idx + i].addr =
+					npu_get_dsp_ddr(
+						executor, dev_id,
+						surface->src_data[i].address) +
+					surface->src_data[i].offset;
+			} else if (surface->src_data[i].type == DLA_MEM_CV) {
+				dsp_buffer[dsp_buf_idx + i]
+					.addr = dsp_get_sram_iova_by_addr(
+					executor->engine->dsp_dev[dev_id],
+					dsp_tensor->src_base_addr[i]);
+				dla_debug("get dsp sram iova = 0x%x.\n",
+					  dsp_buffer[dsp_buf_idx + i].addr);
+			}
+		} else {
+			dsp_buffer[dsp_buf_idx + i].addr =
+				surface->src_data[i].offset;
+			io_cnt =
+				executor->dsp_io[dev_id]
+						[dsp_tensor->src_is_io_tensor[i]]
+							.io_cnt;
+			executor->dsp_io[dev_id][dsp_tensor->src_is_io_tensor[i]]
+				.virt[io_cnt] =
+				(u64)&dsp_buffer[dsp_buf_idx + i].addr;
+			executor->dsp_io[dev_id][dsp_tensor->src_is_io_tensor[i]]
+				.offset[io_cnt] = surface->src_data[i].offset;
+			executor->dsp_io[dev_id][dsp_tensor->src_is_io_tensor[i]]
+				.io_cnt++;
+		}
+		dsp_buffer[dsp_buf_idx + i].size = surface->src_data[i].size;
+	}
+
+	dsp_buf_idx += dsp_op->buffer_cnt_input;
+	for (i = 0; i < dsp_op->buffer_cnt_output; i++) {
+		if (dsp_tensor->dst_is_io_tensor[i] == invalid_tensor_idx) {
+			if (surface->dst_data[i].type == DLA_MEM_MC) {
+				dla_debug(
+					"%s, %d, output dst mc, address index=%d.\n",
+					__func__, __LINE__,
+					surface->dst_data[i].address);
+				dsp_buffer[dsp_buf_idx + i].addr =
+					npu_get_dsp_ddr(
+						executor, dev_id,
+						surface->dst_data[i].address) +
+					surface->dst_data[i].offset;
+				dla_debug("%s, %d, i=%d, addr=0x%x.\n",
+					  __func__, __LINE__, i,
+					  dsp_buffer[dsp_buf_idx + i].addr);
+			} else if (surface->dst_data[i].type == DLA_MEM_CV) {
+				dsp_buffer[dsp_buf_idx + i]
+					.addr = dsp_get_sram_iova_by_addr(
+					executor->engine->dsp_dev[dev_id],
+					dsp_tensor->dst_base_addr[i]);
+				dla_debug(
+					"%s, %d, cv. output offset=0x%x, addr=0x%x.\n",
+					__func__, __LINE__,
+					surface->dst_data[i].offset,
+					dsp_buffer[dsp_buf_idx + i].addr);
+			}
+			dla_debug(
+				"%s, %d, i=%d, outidx=%d, buffer addr=0x%x, offset=0x%x. size=0x%x.\n",
+				__func__, __LINE__, i, dsp_buf_idx + i,
+				dsp_buffer[dsp_buf_idx + i].addr,
+				surface->dst_data[i].offset,
+				dsp_buffer[dsp_buf_idx + i].size);
+		} else {
+			dsp_buffer[dsp_buf_idx + i].addr =
+				surface->dst_data[i].offset;
+			io_cnt =
+				executor->dsp_io[dev_id]
+						[dsp_tensor->dst_is_io_tensor[i]]
+							.io_cnt;
+			executor->dsp_io[dev_id][dsp_tensor->dst_is_io_tensor[i]]
+				.virt[io_cnt] =
+				(u64)&dsp_buffer[dsp_buf_idx + i].addr;
+			executor->dsp_io[dev_id][dsp_tensor->dst_is_io_tensor[i]]
+				.offset[io_cnt] = surface->dst_data[i].offset;
+			dla_debug(
+				"%s, %d, io_cnt=%d, dsp_io=%d, dst=0x%llx.\n",
+				__func__, __LINE__, io_cnt,
+				dsp_tensor->dst_is_io_tensor[i],
+				executor->dsp_io[dev_id]
+						[dsp_tensor->dst_is_io_tensor[i]]
+							.virt[io_cnt]);
+			dla_debug("%s, %d, output %d, offset=0x%x.\n", __func__,
+				  __LINE__, dsp_buf_idx + i,
+				  dsp_buffer[dsp_buf_idx + i].addr);
+			executor->dsp_io[dev_id][dsp_tensor->dst_is_io_tensor[i]]
+				.io_cnt++;
+		}
+		dsp_buffer[dsp_buf_idx + i].size = surface->dst_data[i].size;
+	}
+
+	h2d_msg.command = DSP_CMD_FLAT1;
+	h2d_msg.reserved = op_idx;
+	h2d_msg.allow_eval = 1;
+	h2d_msg.poll_mode = 1;
+	h2d_msg.sync_cache = 0;
+
+	h2d_msg.iova_ptr = dsp_tensor->flat1_dma_addr;
+	memcpy((void *)&dsp->npu_info.dsp_eval_param, (void *)&h2d_msg,
+	       sizeof(h2d_msg));
+	return 0;
+}
+
+int dsp0_prepare_prog_data(struct win_executor *executor, int rdma, int idx,
+			   u16 op_idx, union dla_operation_container *op_desc,
+			   union dla_surface_container *surf_desc)
+{
+	int ret;
+	dla_debug("%s, %d, op_idx=%d.\n", __func__, __LINE__, op_idx);
+	ret = processor_dsp_program(executor, idx, op_idx, op_desc, surf_desc,
+				    DLA_KMD_OP_DSP_0);
+	return ret;
+}
+
+int dsp1_prepare_prog_data(struct win_executor *executor, int rdma, int idx,
+			   u16 op_idx, union dla_operation_container *op_desc,
+			   union dla_surface_container *surf_desc)
+{
+	int ret;
+
+	ret = processor_dsp_program(executor, idx, op_idx, op_desc, surf_desc,
+				    DLA_KMD_OP_DSP_1);
+	return ret;
+}
+
+int dsp2_prepare_prog_data(struct win_executor *executor, int rdma, int idx,
+			   u16 op_idx, union dla_operation_container *op_desc,
+			   union dla_surface_container *surf_desc)
+{
+	int ret;
+
+	ret = processor_dsp_program(executor, idx, op_idx, op_desc, surf_desc,
+				    DLA_KMD_OP_DSP_2);
+	return ret;
+}
+
+int dsp3_prepare_prog_data(struct win_executor *executor, int rdma, int idx,
+			   u16 op_idx, union dla_operation_container *op_desc,
+			   union dla_surface_container *surf_desc)
+{
+	int ret;
+
+	ret = processor_dsp_program(executor, idx, op_idx, op_desc, surf_desc,
+				    DLA_KMD_OP_DSP_3);
+	return ret;
+}
+
+static int npu_acquire_dsp_file(struct win_executor *executor)
+{
+	struct file *file = NULL;
+	struct dsp_file *dsp_file = NULL;
+	int i;
+	int filefd;
+
+	for (i = 0; i < DSP_MAX_CORE_NUM; i++) {
+		if (executor->dsp_fd[i] < 3) {
+			executor->dsp_file[i] = NULL;
+			continue;
+		}
+		filefd = executor->dsp_fd[i];
+		file = fget(filefd);
+		if (file == NULL) {
+			dla_error(
+				"%s, %d, cannot find dsp%d dsp_file fd=%d file, error\n",
+				__func__, __LINE__, i, filefd);
+			executor->dsp_file[i] = NULL;
+			continue;
+		}
+
+		dsp_file = file->private_data;
+		if (dsp_file == NULL) {
+			dla_error("%s, %d, dsp file(%d) is null.\n", __func__,
+				  __LINE__, filefd);
+			executor->dsp_file[i] = NULL;
+			fput(file);
+			continue;
+		}
+		executor->dsp_file[i] = file;
+	}
+	return 0;
+}
+
+static void npu_release_dsp_file(struct win_executor *executor)
+{
+	int i;
+
+	for (i = 0; i < DSP_MAX_CORE_NUM; i++) {
+		if (executor->dsp_file[i] == NULL) {
+			continue;
+		}
+		if (file_count(executor->dsp_file[i])) {
+			fput(executor->dsp_file[i]);
+		}
+		executor->dsp_file[i] = NULL;
+	}
+}
+
+int resolve_dsp_data(struct win_executor *executor)
+{
+	int i, j, op_num;
+	dsp_tensor_t *tensor_set;
+	dsp_tensor_t *dsp_tensor;
+	struct processors_interface *pcer_interface;
+	struct dla_task *task = executor->task;
+	u32 flat1_total_len[DSP_MAX_CORE_NUM] = { 0 };
+	int dsp_tensor_idx[DSP_MAX_CORE_NUM] = { 0 };
+	int op_type, op_idx, size;
+	int dsp_op_cnt = 0;
+	struct device *dsp_dev = NULL;
+	int ret;
+	dma_addr_t dma_set, data_dma_set;
+	void *flat_vaddr_set = NULL;
+	int fd;
+
+	ret = npu_acquire_dsp_file(executor);
+
+	op_num = executor->network->num_operations;
+	for (i = 0; i < op_num; i++) {
+		op_type = executor->task->common_desc[i].op_type;
+		op_idx = executor->task->common_desc[i].index;
+		if ((op_type == DLA_KMD_OP_DSP_0) ||
+		    (op_type == DLA_KMD_OP_DSP_1) ||
+		    (op_type == DLA_KMD_OP_DSP_2) ||
+		    (op_type == DLA_KMD_OP_DSP_3)) {
+			tensor_set = executor->tensor_set[op_type];
+			dsp_tensor =
+				&tensor_set[dsp_tensor_idx[op_type -
+							   DLA_KMD_OP_DSP_0]];
+			pcer_interface = executor->engine->processors[op_type];
+
+			j = dsp_tensor_idx[op_type - DLA_KMD_OP_DSP_0];
+			size = pcer_interface->tensor_unfold(
+				executor, op_idx, &task->op_desc[op_idx],
+				&task->surface_desc[op_idx], tensor_set,
+				j);  //get dsp flat1 len and mem_id
+			if (size < 0) {
+				dla_error("err:get dsp flat1 len failed!\n");
+				return -1;
+			}
+
+			dsp_tensor->flat1_size = size;
+			dsp_tensor->flat1_addr_offset =
+				flat1_total_len[op_type - DLA_KMD_OP_DSP_0];
+			flat1_total_len[op_type - DLA_KMD_OP_DSP_0] +=
+				dsp_tensor->flat1_size;
+
+			dsp_tensor_idx[op_type - DLA_KMD_OP_DSP_0]++;
+			dsp_op_cnt++;
+		}
+	}
+	executor->dsp_op_num = dsp_op_cnt;
+	if (!dsp_op_cnt) {
+		dla_detail("no dsp op\n");
+		return 0;
+	}
+
+	for (i = 0; i < DSP_MAX_CORE_NUM; i++) {
+		xa_init_flags(&executor->dsp_ddr_xrray[i], GFP_KERNEL);
+		mutex_init(&executor->xrray_lock[i]);
+
+		if (executor->dsp_iobuf_cnt[i] == 0) {
+			continue;
+		}
+		executor->dsp_iobuf_virt[i] =
+			kzalloc(executor->dsp_iobuf_cnt[i] *
+					(sizeof(u64) + sizeof(u32)),
+				GFP_KERNEL);
+		if (executor->dsp_iobuf_virt[i] == NULL) {
+			dla_error(
+				"%s, %d, alloc dsp iobuf vir for device %d error.\n",
+				__func__, __LINE__, i);
+			goto alloc_err;
+		}
+		size = 0;
+		executor->dsp_iobuf_offset[i] =
+			executor->dsp_iobuf_virt[i] +
+			executor->dsp_iobuf_cnt[i] * sizeof(u64);
+		for (j = 0; j < DSP_KERNEL_MAX_INOUT_TENSOR_NUM; j++) {
+			if (executor->dsp_all_inout[i][j] != 0) {
+				executor->dsp_io[i][j].virt =
+					(u64 *)(executor->dsp_iobuf_virt[i] +
+						size * sizeof(u64));
+				executor->dsp_io[i][j].offset =
+					(u32 *)(executor->dsp_iobuf_offset[i] +
+						size * sizeof(u32));
+				dla_debug("%s, %d, virt[0]=0x%px.\n", __func__,
+					  __LINE__,
+					  executor->dsp_io[i][j].virt);
+				size += executor->dsp_all_inout[i][j];
+			}
+		}
+	}
+	for (i = 0; i < DSP_MAX_CORE_NUM; i++) {
+		if (dsp_tensor_idx[i] == 0) {
+			continue;
+		}
+		dsp_dev = executor->engine->dsp_dev[i];
+		if (dsp_dev == NULL) {
+			dla_error("%s, %d, dsp device%d is NULL, err.\n",
+				  __func__, __LINE__, i);
+			ret = -ENODEV;
+			goto err_dev;
+		}
+
+		executor->dsp_flat1_set_vaddr[i] = dma_alloc_coherent(
+			dsp_dev, flat1_total_len[i],
+			&executor->dsp_flat1_set_dma[i], GFP_KERNEL);
+		if (executor->dsp_flat1_set_vaddr[i] == NULL) {
+			dla_error(
+				"%s, %d, dma alloc cohernet for dsp dev%d error.\n",
+				__func__, __LINE__, i);
+			goto alloc_err;
+		}
+		dla_debug("%s, %d, i=%d, flat vaddr=0x%px.\n", __func__,
+			  __LINE__, i, executor->dsp_flat1_set_vaddr[i]);
+		executor->dsp_flat1_set_size[i] = flat1_total_len[i];
+		/*get the fd of dsp param buffer*/
+		fd = dla_data_get_fd(executor->driver_context,
+				     executor->mem_handles, NULL,
+				     executor->network->op_config_index);
+		if (fd < 0) {
+			dla_error(
+				"err:dla_data_get_fd failed,i=%d op_config_index=%d!\n",
+				i, executor->network->op_config_index);
+			goto alloc_err;
+		}
+		executor->model_dsp_dmabuf[i] =
+			npu_get_dsp_dmabuf(executor->dsp_file[i], fd);
+		if (executor->model_dsp_dmabuf[i] == NULL) {
+			dla_error("err:import dsp data dmabuf error!\n");
+			goto alloc_err;
+		}
+	}
+
+	for (op_type = DLA_KMD_OP_DSP_0; op_type <= DLA_KMD_OP_DSP_3;
+	     op_type++) {
+		if (dsp_tensor_idx[op_type - DLA_KMD_OP_DSP_0] == 0) {
+			continue;
+		}
+		tensor_set = executor->tensor_set[op_type];
+		dma_set =
+			executor->dsp_flat1_set_dma[op_type - DLA_KMD_OP_DSP_0];
+		flat_vaddr_set =
+			executor->dsp_flat1_set_vaddr[op_type -
+						      DLA_KMD_OP_DSP_0];
+		data_dma_set =
+			executor->model_dsp_dmabuf[op_type - DLA_KMD_OP_DSP_0]
+				->dma_addr;
+
+		for (i = 0; i < dsp_tensor_idx[op_type - DLA_KMD_OP_DSP_0];
+		     i++) {
+			dsp_tensor = &tensor_set[i];
+			dsp_tensor->flat1_dma_addr =
+				dma_set + dsp_tensor->flat1_addr_offset;
+			dsp_tensor->flat1_vaddr =
+				flat_vaddr_set + dsp_tensor->flat1_addr_offset;
+			dsp_tensor->data_dma_addr = data_dma_set;
+		}
+	}
+	dla_debug("%s, %d, done.\n", __func__, __LINE__);
+	return 0;
+
+alloc_err:
+	npu_release_dsp_file(executor);
+err_dev:
+	for (i = 0; i < DSP_MAX_CORE_NUM; i++) {
+		dsp_dev = executor->engine->dsp_dev[i];
+		if (dsp_dev == NULL) {
+			continue;
+		}
+		if (executor->dsp_flat1_set_vaddr[i] != NULL) {
+			dma_free_coherent(dsp_dev,
+					  executor->dsp_flat1_set_size[i],
+					  executor->dsp_flat1_set_vaddr[i],
+					  executor->dsp_flat1_set_dma[i]);
+			executor->dsp_flat1_set_vaddr[i] = NULL;
+			executor->dsp_flat1_set_dma[i] = 0;
+		}
+		if (executor->model_dsp_dmabuf[i] != NULL) {
+			npu_put_dsp_dmabuf(executor->dsp_file[i],
+					   &executor->model_dsp_dmabuf[i]);
+			executor->model_dsp_dmabuf[i] = NULL;
+		}
+		if (executor->dsp_iobuf_virt[i] != NULL) {
+			kfree(executor->dsp_iobuf_virt[i]);
+			executor->dsp_iobuf_virt[i] = NULL;
+		}
+		xa_destroy(&executor->dsp_ddr_xrray[i]);
+	}
+	return -EINVAL;
+}
+
+int npu_set_dsp_iobuf(struct win_executor *executor, struct host_frame_desc *f)
+{
+	int i, j, k;
+	int fd;
+	addrDesc_t *address = f->io_tensor_list;
+	u32 *tmp;
+	u32 offset = 0;
+
+	for (i = 0; i < DSP_MAX_CORE_NUM; i++) {
+		if (executor->dsp_iobuf_cnt[i] == 0) {
+			continue;
+		}
+		for (j = 0; j < DSP_KERNEL_MAX_INOUT_TENSOR_NUM; j++) {
+			if (executor->dsp_all_inout[i][j] == 0) {
+				continue;
+			}
+			fd = address[j].devBuf.memFd;
+
+			f->dsp_io_dmabuf[i][j] =
+				npu_get_dsp_dmabuf(executor->dsp_file[i], fd);
+			if (f->dsp_io_dmabuf[i][j] == NULL) {
+				dla_error(
+					"%s, %d, npu get dsp%d dmabuf-%d error.\n ",
+					__func__, __LINE__, i, j);
+				return -EINVAL;
+			}
+			dla_debug("%s, %d dspio=%d.\n", __func__, __LINE__,
+				  executor->dsp_io[i][j].io_cnt);
+			for (k = 0; k < executor->dsp_io[i][j].io_cnt; k++) {
+				dla_debug("%s, %d, virt=0x%llx.\n", __func__,
+					  __LINE__,
+					  executor->dsp_io[i][j].virt[k]);
+				tmp = (u32 *)executor->dsp_io[i][j].virt[k];
+				offset = executor->dsp_io[i][j].offset[k];
+				dla_debug(
+					"%s, %d, offset=0x%x, dma addr=0x%x.\n",
+					__func__, __LINE__, offset,
+					f->dsp_io_dmabuf[i][j]->dma_addr);
+				*tmp = offset +
+				       f->dsp_io_dmabuf[i][j]->dma_addr;
+				dla_debug("tmp content=0x%x.\n", *tmp);
+			}
+		}
+	}
+	return 0;
+}
+
+static int npu_unload_dsp_op(struct win_executor *executor, int idx,
+			     int op_type)
+{
+	dsp_tensor_t *tensor_set = executor->tensor_set[op_type];
+	dsp_tensor_t *dsp_tensor = NULL;
+	int dev_id = op_type - DLA_KMD_OP_DSP_0;
+	int ret;
+
+	if (executor->engine->dsp_dev[dev_id] == NULL) {
+		dla_error("%s, %d, unload op for dsp%d, idx=%d.\n", __func__,
+			  __LINE__, dev_id, idx);
+		return -EINVAL;
+	}
+	if (tensor_set == NULL) {
+		dla_error("%s, %d, tensor set is null, idx=%d, op_type=%d.\n",
+			  __func__, __LINE__, idx, op_type);
+		return -EINVAL;
+	}
+	dsp_tensor = &tensor_set[idx];
+	if (dsp_tensor == NULL || (dsp_tensor->handle == 0)) {
+		dla_error(
+			"%s, %d, idx=%d, op_type=%d.\n dsp tensor null or handle is 0, err.\n",
+			__func__, __LINE__, idx, op_type);
+		return -EINVAL;
+	}
+	ret = unload_operator(executor->engine->dsp_dev[dev_id],
+			      dsp_tensor->handle);
+	return ret;
+}
+
+void destroy_frame_dsp_info(struct win_executor *executor,
+			    struct host_frame_desc *f)
+{
+	int i, j;
+
+	for (i = 0; i < DSP_MAX_CORE_NUM; i++) {
+		if (executor->dsp_iobuf_cnt[i] == 0) {
+			continue;
+		}
+		for (j = 0; j < DSP_KERNEL_MAX_INOUT_TENSOR_NUM; j++) {
+			if (f->dsp_io_dmabuf[i][j] == NULL) {
+				continue;
+			}
+			npu_put_dsp_dmabuf(executor->dsp_file[i],
+					   &f->dsp_io_dmabuf[i][j]);
+			f->dsp_io_dmabuf[i][j] = NULL;
+		}
+	}
+}
+
+void dsp_resource_destroy(struct win_executor *executor)
+{
+	int i;
+	struct device *dsp_dev = NULL;
+	int pcer, op_num;
+
+	if (executor->dsp_op_num == 0) {
+		goto put_dsp_file;
+	}
+
+	for (i = 0; i < DSP_MAX_CORE_NUM; i++) {
+		dsp_dev = executor->engine->dsp_dev[i];
+
+		if (dsp_dev == NULL) {
+			continue;
+		}
+
+		npu_put_dsp_ddr(executor, i);
+		xa_destroy(&executor->dsp_ddr_xrray[i]);
+
+		if (executor->dsp_flat1_set_vaddr[i] != NULL) {
+			dma_free_coherent(dsp_dev,
+					  executor->dsp_flat1_set_size[i],
+					  executor->dsp_flat1_set_vaddr[i],
+					  executor->dsp_flat1_set_dma[i]);
+			executor->dsp_flat1_set_vaddr[i] = NULL;
+			executor->dsp_flat1_set_dma[i] = 0;
+		}
+		if (executor->model_dsp_dmabuf[i] != NULL) {
+			npu_put_dsp_dmabuf(executor->dsp_file[i],
+					   &executor->model_dsp_dmabuf[i]);
+			executor->model_dsp_dmabuf[i] = NULL;
+		}
+
+		if (executor->dsp_iobuf_virt[i] != NULL) {
+			kfree(executor->dsp_iobuf_virt[i]);
+			executor->dsp_iobuf_virt[i] = NULL;
+		}
+	}
+
+	for (pcer = IDX_KMD_DSP0; pcer < IDX_KMD_DSP3; pcer++) {
+		op_num = executor->op_num[pcer];
+		for (i = 0; i < op_num; i++) {
+			npu_unload_dsp_op(executor, i, pcer);
+		}
+	}
+put_dsp_file:
+	npu_release_dsp_file(executor);
+}
diff --git a/drivers/soc/eswin/ai_driver/npu/dsp.h b/drivers/soc/eswin/ai_driver/npu/dsp.h
new file mode 100644
index 000000000000..0601e922481e
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/npu/dsp.h
@@ -0,0 +1,17 @@
+#ifndef _NPU_DSP_H_
+#define _NPU_DSP_H_
+#include "internal_interface.h"
+
+/* npu add dsp device info. */
+int resolve_dsp_data(struct win_executor *executor);
+
+/* npu set frame dsp io info */
+int npu_set_dsp_iobuf(struct win_executor *executor, struct host_frame_desc *f);
+
+/* when destroy model, need destroy dsp info */
+void dsp_resource_destroy(struct win_executor * executor);
+
+/* when release frame info ,need free dsp io info */
+void destroy_frame_dsp_info(struct win_executor *executor, struct host_frame_desc *f);
+
+#endif
diff --git a/drivers/soc/eswin/ai_driver/npu/edma.c b/drivers/soc/eswin/ai_driver/npu/edma.c
new file mode 100644
index 000000000000..f8638dad0dff
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/npu/edma.c
@@ -0,0 +1,954 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#include <opendla.h>
+#include <dla_log.h>
+#include <dla_interface.h>
+#include <linux/kernel.h>
+#include <linux/kthread.h>
+#include <linux/spinlock.h>
+
+#include <linux/of.h>
+#include <linux/of_address.h>
+
+#include "common.h"
+#include "dla_engine_internal.h"
+#include "nvdla_linux.h"
+#include <linux/delay.h>
+#include <linux/slab.h>
+
+#include "edma.h"
+#include "npu_top_csr.h"
+#include <linux/dma-mapping.h>
+#include <linux/list.h>
+#include "dla_log.h"
+#include "dla_buffer.h"
+#include "internal_interface.h"
+
+union hw_common_soft_reset {
+	struct {
+		uint32_t soft_rst : 1;
+		uint32_t clk_gate : 1;
+		/* Not used */
+		uint32_t clk_gate_ctl : 1;
+		uint32_t rsv0 : 28;
+		uint32_t halt : 1;
+	};
+	/* RW */
+	uint32_t soft_reset;
+} __attribute__((packed, aligned(4)));
+union hw_common_general_parameter {
+	struct {
+		uint32_t aux_mode : 1;
+		uint32_t rsv1 : 25;
+		uint32_t burst_length : 6;
+	};
+	/* RW */
+	uint32_t general_parameter;
+} __attribute__((packed, aligned(4)));
+union hw_common_status {
+	struct {
+		uint32_t edma_busy : 1;
+		uint32_t edma_wr_busy : 1;
+		uint32_t edma_rd_busy : 1;
+		uint32_t edma_aux_triger_busy : 1;
+		uint32_t edma_main_triger_busy : 1;
+		uint32_t rsv2 : 4;
+		uint32_t aux_error_entry_num : 8;
+		uint32_t error_entry_num : 8;
+		uint32_t error_type : 2;
+		uint32_t error_cause : 4;
+		uint32_t error_flag : 1;
+	};
+	/* RO */
+	uint32_t status;
+} __attribute__((packed, aligned(4)));
+
+union hw_common_intr_status {
+#define INTR_ENTRY_NUM_OFFSET (3)
+#define INTR_ENTRY_NUM (0x8)
+#define INTR_ENTRY_NUM_MASK (INTR_ENTRY_NUM - 1)
+	struct {
+		/* RC */
+		uint32_t rd_transport_finish_intr : 1;
+		/* RO */
+		uint32_t rd_int_entry_num : 4;
+		/* RC */
+		uint32_t wr_transport_finish_intr : 1;
+		/* RO */
+		uint32_t wr_int_entry_num : 4;
+		/* RC */
+		uint32_t aux_rd_transport_finish_intr : 1;
+		/* RO */
+		uint32_t aux_rd_int_entry_num : 4;
+		/* RC */
+		uint32_t aux_wr_transport_finish_intr : 1;
+		/* RO */
+		uint32_t aux_wr_int_entry_num : 4;
+		uint32_t rsv5 : 12;
+	};
+	uint32_t int_status;
+} __attribute__((packed, aligned(4)));
+
+union hw_common_sw_trig {
+	struct {
+		uint32_t rd_triger_num : 4;
+		uint32_t rsv3 : 12;
+		uint32_t wr_triger_num : 4;
+		uint32_t rsv4 : 9;
+		uint32_t prefetch_addr_reset : 1;
+		uint32_t desp_ram_invalid : 1;
+		uint32_t sw_triger : 1;
+	};
+	/* RW */
+	uint32_t sw_trig;
+} __attribute__((packed, aligned(4)));
+union hw_common_aux_sw_trig {
+	struct {
+		uint32_t aux_rd_triger_num : 4;
+		uint32_t aux_rsv6 : 12;
+		uint32_t aux_wr_triger_num : 4;
+		uint32_t aux_rsv7 : 9;
+		uint32_t aux_prefetch_addr_reset : 1;
+		uint32_t aux_desp_ram_invalid : 1;
+		uint32_t aux_sw_triger : 1;
+	};
+	/* RW */
+	uint32_t aux_sw_trig;
+} __attribute__((packed, aligned(4)));
+struct hw_common_reg {
+	union hw_common_soft_reset rst;
+	union hw_common_general_parameter gparam;
+	union hw_common_status hw_status;
+	union hw_common_sw_trig sw_trig;
+	/* As hardware enginer said: Not currently available */
+	union {
+		struct {
+			uint32_t rd_int_en_entry_bit : 16;
+			uint32_t wr_int_en_entry_bit : 16;
+		};
+		uint32_t int_en;
+	};
+	/* As hardware enginer said: Not currently available */
+	union {
+		struct {
+			uint32_t rd_int_mask_entry_bit : 16;
+			uint32_t wr_int_mask_entry_bit : 16;
+		};
+		uint32_t int_mask;
+	};
+	union hw_common_intr_status intr_status;
+	/* 4K Byte align needed */
+	uint32_t prefetch_addr_low;
+	uint32_t prefetch_addr_high;
+	union {
+		struct {
+			/* Need align with despRAM size */
+			uint32_t prefetch_total_depth : 16; /* RO */
+			uint32_t prefetch_current_addr_offset : 16;
+		};
+		uint32_t prefetch_parameter;
+	};
+	uint32_t err_addr_high;
+	uint32_t err_addr_low;
+	/* 64 Byte align needed */
+	uint32_t aux_prefetch_addr_low;
+	uint32_t aux_prefetch_addr_high;
+	union {
+		struct {
+			/* Need align with despRAM size */
+			uint32_t aux_prefetch_total_depth : 16;
+			uint32_t aux_prefetch_current_addr_offset : 16;
+		};
+		/* RW */
+		uint32_t aux_prefetch_parameter;
+	};
+	union hw_common_aux_sw_trig aux_sw_trig;
+	struct hw_colony colony;
+} __attribute__((packed, aligned(4)));
+
+#define HW_PING_CH_NUM (8)
+#define HW_PONG_CH_NUM (8)
+#define MAX_HW_CH_NUM (HW_PING_CH_NUM + HW_PONG_CH_NUM)
+struct edma_context {
+	struct nvdla_device *dev;
+	struct hw_common_reg common_reg;
+	/**
+	 * Lock protected!
+	 * You Get the lock, you Gain the hardware and buffer
+	 */
+	spinlock_t hw_lock;
+	void (*edma_restart)(struct edma_context *);
+#define PREFETCH_BUFF_SIZE (4096)
+#define PREFETCH_DEPTH (5)
+#define PREFETCH_BUFF_STRIDE                                         \
+	((sizeof(struct hw_desc_src) + sizeof(struct hw_desc_dst)) * \
+	 HW_PING_CH_NUM)
+};
+
+static void dump_hw_common_soft_reset(const char *str,
+				      union hw_common_soft_reset *rst)
+{
+	if (str) {
+		dla_info("****%s****\n", str);
+	}
+	dla_info("--------------------start-%s --------------------\n",
+		 __func__);
+	dla_info("%s soft_rst:1;    [%d]\n", __func__, rst->soft_rst);
+	dla_info("%s clk_gate:1;    [%d]\n", __func__, rst->clk_gate);
+	dla_info("%s clk_gate_ctl:1;[%d]\n", __func__, rst->clk_gate_ctl);
+	dla_info("%s rsv0:28;       [%d]\n", __func__, rst->rsv0);
+	dla_info("%s halt:1;        [%d]\n", __func__, rst->halt);
+	dla_info("--------------------end--%s --------------------\n",
+		 __func__);
+}
+static void
+dump_hw_common_general_parameter(const char *str,
+				 union hw_common_general_parameter *gparam)
+{
+	if (str) {
+		dla_info("****%s****\n", str);
+	}
+	dla_info("--------------------start-%s --------------------\n",
+		 __func__);
+	dla_info("%s aux_mode:1;    [%d]\n", __func__, gparam->aux_mode);
+	dla_info("%s rsv1:25;       [%d]\n", __func__, gparam->rsv1);
+	dla_info("%s burst_length:6;[%d]\n", __func__, gparam->burst_length);
+	dla_info("--------------------end--%s --------------------\n",
+		 __func__);
+}
+static void dump_hw_common_status(const char *str,
+				  union hw_common_status *status)
+{
+	if (str) {
+		dla_info("****%s****\n", str);
+	}
+	dla_info("--------------------start-%s --------------------\n",
+		 __func__);
+	dla_info("%s edma_busy:1;            [%d]\n", __func__,
+		 status->edma_busy);
+	dla_info("%s edma_wr_busy:1;         [%d]\n", __func__,
+		 status->edma_wr_busy);
+	dla_info("%s edma_rd_busy:1;         [%d]\n", __func__,
+		 status->edma_rd_busy);
+	dla_info("%s edma_aux_triger_busy:1; [%d]\n", __func__,
+		 status->edma_aux_triger_busy);
+	dla_info("%s edma_main_triger_busy:1;[%d]\n", __func__,
+		 status->edma_main_triger_busy);
+	dla_info("%s rsv2:4;                 [%d]\n", __func__, status->rsv2);
+	dla_info("%s aux_error_entry_num:8;  [%d]\n", __func__,
+		 status->aux_error_entry_num);
+	dla_info("%s error_entry_num:8;      [%d]\n", __func__,
+		 status->error_entry_num);
+	dla_info("%s error_type:2;           [%d]\n", __func__,
+		 status->error_type);
+	dla_info("%s error_cause:4;          [%d]\n", __func__,
+		 status->error_cause);
+	dla_info("%s error_flag:1;           [%d]\n", __func__,
+		 status->error_flag);
+	dla_info("--------------------end--%s --------------------\n",
+		 __func__);
+}
+static void dump_hw_common_sw_trig(const char *str,
+				   union hw_common_sw_trig *trig)
+{
+	if (str) {
+		dla_info("****%s****\n", str);
+	}
+	dla_info("--------------------start-%s --------------------\n",
+		 __func__);
+	dla_info("%s rd_triger_num:4;      [%d]\n", __func__,
+		 trig->rd_triger_num);
+	dla_info("%s rsv3:12;              [%d]\n", __func__, trig->rsv3);
+	dla_info("%s wr_triger_num:4;      [%d]\n", __func__,
+		 trig->wr_triger_num);
+	dla_info("%s rsv4:9;               [%d]\n", __func__, trig->rsv4);
+	dla_info("%s prefetch_addr_reset:1;[%d]\n", __func__,
+		 trig->prefetch_addr_reset);
+	dla_info("%s desp_ram_invalid:1;   [%d]\n", __func__,
+		 trig->desp_ram_invalid);
+	dla_info("%s sw_triger:1;          [%d]\n", __func__, trig->sw_triger);
+	dla_info("--------------------end--%s --------------------\n",
+		 __func__);
+}
+
+static void dump_hw_common_intr_status(const char *str,
+				       union hw_common_intr_status *intr_status)
+{
+	if (str) {
+		dla_info("****%s****\n", str);
+	}
+	dla_info("--------------------start-%s --------------------\n",
+		 __func__);
+	dla_info("%s rd_transport_finish_intr:1;    [%d]\n", __func__,
+		 intr_status->rd_transport_finish_intr);
+	dla_info("%s rd_int_entry_num:4;            [%d]\n", __func__,
+		 intr_status->rd_int_entry_num);
+	dla_info("%s wr_transport_finish_intr:1;    [%d]\n", __func__,
+		 intr_status->wr_transport_finish_intr);
+	dla_info("%s wr_int_entry_num:4;            [%d]\n", __func__,
+		 intr_status->wr_int_entry_num);
+	dla_info("%s aux_rd_transport_finish_intr:1;[%d]\n", __func__,
+		 intr_status->aux_rd_transport_finish_intr);
+	dla_info("%s aux_rd_int_entry_num:4;        [%d]\n", __func__,
+		 intr_status->aux_rd_int_entry_num);
+	dla_info("%s aux_wr_transport_finish_intr:1;[%d]\n", __func__,
+		 intr_status->aux_wr_transport_finish_intr);
+	dla_info("%s aux_wr_int_entry_num:4;        [%d]\n", __func__,
+		 intr_status->aux_wr_int_entry_num);
+	dla_info("--------------------end--%s --------------------\n",
+		 __func__);
+}
+
+static void dump_hw_common_aux_sw_trig(const char *str,
+				       union hw_common_aux_sw_trig *trig)
+{
+	if (str) {
+		dla_info("****%s****\n", str);
+	}
+	dla_info("--------------------start-%s --------------------\n",
+		 __func__);
+	dla_info("%s aux_rd_triger_num:4;      [%d]\n", __func__,
+		 trig->aux_rd_triger_num);
+	dla_info("%s aux_rsv3:12;              [%d]\n", __func__,
+		 trig->aux_rsv6);
+	dla_info("%s aux_wr_triger_num:4;      [%d]\n", __func__,
+		 trig->aux_wr_triger_num);
+	dla_info("%s aux_rsv4:9;               [%d]\n", __func__,
+		 trig->aux_rsv7);
+	dla_info("%s aux_prefetch_addr_reset:1;[%d]\n", __func__,
+		 trig->aux_prefetch_addr_reset);
+	dla_info("%s aux_desp_ram_invalid:1;   [%d]\n", __func__,
+		 trig->aux_desp_ram_invalid);
+	dla_info("%s aux_sw_triger:1;          [%d]\n", __func__,
+		 trig->aux_sw_triger);
+	dla_info("--------------------end--%s --------------------\n",
+		 __func__);
+}
+
+static void dump_hw_colony(const char *str, struct hw_colony *colony)
+{
+	if (str) {
+		dla_info("****%s****\n", str);
+	}
+	dla_info("--------------------start-%s --------------------\n",
+		 __func__);
+	dla_info("%s src_colony_num:16;[%d]\n", __func__,
+		 colony->src_colony_num);
+	dla_info("%s dst_colony_num:16;[%d]\n", __func__,
+		 colony->dst_colony_num);
+	dla_info("%s src_colony_stride;[0x%x]\n", __func__,
+		 colony->src_colony_stride);
+	dla_info("%s dst_colony_stride;[0x%x]\n", __func__,
+		 colony->dst_colony_stride);
+	dla_info("%s aux_src_colony_num:16;[%d]\n", __func__,
+		 colony->aux_src_colony_num);
+	dla_info("%s aux_dst_colony_num:16;[%d]\n", __func__,
+		 colony->aux_dst_colony_num);
+	dla_info("%s aux_src_colony_stride;[0x%x]\n", __func__,
+		 colony->aux_src_colony_stride);
+	dla_info("%s aux_dst_colony_stride;[0x%x]\n", __func__,
+		 colony->aux_dst_colony_stride);
+	dla_info("--------------------end--%s --------------------\n",
+		 __func__);
+}
+
+static void dump_hw_common_reg_all_from_reg(const char *str,
+					    struct edma_context *edma,
+					    uint64_t base)
+{
+	int i;
+	uint32_t *p;
+	struct hw_common_reg reg;
+
+	p = (uint32_t *)(&reg);
+	for (i = 0; i < sizeof(struct hw_common_reg); i += 4) {
+		*(p++) = dla_reg_read(edma->dev, base + i);
+	}
+	dump_hw_common_soft_reset(str, &reg.rst);
+	dump_hw_common_general_parameter(str, &reg.gparam);
+	dump_hw_common_status(str, &reg.hw_status);
+	dump_hw_common_sw_trig(str, &reg.sw_trig);
+	dla_info("%s rd_int_en_entry_bit:16;[%d]\n", __func__,
+		 reg.rd_int_en_entry_bit);
+	dla_info("%s wr_int_en_entry_bit:16;[%d]\n", __func__,
+		 reg.wr_int_en_entry_bit);
+	dla_info("%s rd_int_mask_entry_bit:16;[%d]\n", __func__,
+		 reg.rd_int_mask_entry_bit);
+	dla_info("%s wr_int_mask_entry_bit:16;[%d]\n", __func__,
+		 reg.wr_int_mask_entry_bit);
+	dump_hw_common_intr_status(str, &reg.intr_status);
+	dla_info("%s prefetch_addr_low; [0x%x]\n", __func__,
+		 reg.prefetch_addr_low);
+	dla_info("%s prefetch_addr_high;[0x%x]\n", __func__,
+		 reg.prefetch_addr_high);
+	dla_info("%s prefetch_total_depth:16;        [%d]\n", __func__,
+		 reg.prefetch_total_depth);
+	dla_info("%s prefetch_current_addr_offset:16;[%d]\n", __func__,
+		 reg.prefetch_current_addr_offset);
+	dla_info("%s err_addr_high;         [0x%x]\n", __func__,
+		 reg.err_addr_high);
+	dla_info("%s err_addr_low;          [0x%x]\n", __func__,
+		 reg.err_addr_low);
+	dla_info("%s aux_prefetch_addr_low; [0x%x]\n", __func__,
+		 reg.aux_prefetch_addr_low);
+	dla_info("%s aux_prefetch_addr_high;[0x%x]\n", __func__,
+		 reg.aux_prefetch_addr_high);
+	dla_info("%s aux_prefetch_total_depth:16;     [%d]\n", __func__,
+		 reg.aux_prefetch_total_depth);
+	dla_info("%s aux_prefetch_current_addr_offset:[%d]\n", __func__,
+		 reg.aux_prefetch_current_addr_offset);
+	dump_hw_common_aux_sw_trig(str, &reg.aux_sw_trig);
+	dump_hw_colony(str, &reg.colony);
+	dla_info("--------------------end--%s --------------------\n",
+		 __func__);
+}
+
+static void config_general_parameter(struct edma_context *edma,
+				     struct nvdla_device *nvdla_dev)
+{
+	edma->common_reg.gparam.general_parameter = dla_reg_read(
+		nvdla_dev, EDMA_S_BASE_ADDR + EDMA_REG_GENERAL_PARAMETER);
+	edma->common_reg.gparam.aux_mode = 1;
+	edma->common_reg.gparam.burst_length = 1;
+	dla_reg_write(nvdla_dev, EDMA_S_BASE_ADDR + EDMA_REG_GENERAL_PARAMETER,
+		      edma->common_reg.gparam.general_parameter);
+	return;
+}
+
+static void restart(struct edma_context *edma)
+{
+	union hw_common_soft_reset reset;
+	/* TODO:
+	 *     1. clean hw_desc->status
+	 *     2. invalid hw_desc->prev_link_index
+	 *     3. trigger hw_common_reg->soft_rst
+	 */
+	dump_hw_common_reg_all_from_reg("edma restart trigger", edma,
+					EDMA_S_BASE_ADDR);
+	reset.soft_reset =
+		dla_reg_read(edma->dev, EDMA_S_BASE_ADDR + EDMA_REG_SOFT_RST);
+	reset.soft_rst = 1;
+	reset.halt = 0;
+	dla_reg_write(edma->dev, EDMA_S_BASE_ADDR + EDMA_REG_SOFT_RST,
+		      reset.soft_reset);
+	return;
+}
+
+static inline void setup_one_despram(struct nvdla_device *dev,
+				     edma_program_t *edma_prog,
+				     uint32_t desc_offset,
+				     uint32_t *src_desc_start,
+				     uint32_t *dst_desc_start)
+{
+	int i;
+	int j;
+	uint32_t src_base;
+	uint32_t dst_base;
+
+	src_base = REG_SRC_DESP_MAIN_BASE + desc_offset * EDMA_DESP_STRIDE;
+	dst_base = REG_DST_DESP_MAIN_BASE + desc_offset * EDMA_DESP_STRIDE;
+	for (i = 0, j = 0; i < EDMA_DESP_SIZE; i += 4, j++) {
+		edma_prog->reg[EDMA_RAM_SRC_BASE_0 + j] = *src_desc_start;
+		edma_prog->reg[EDMA_RAM_DST_BASE_0 + j] = *dst_desc_start;
+		npu_set_u64_bit(EDMA_RAM_SRC_BASE_0 + j,
+				&edma_prog->u84_bitmap);
+		npu_set_u64_bit(EDMA_RAM_DST_BASE_0 + j,
+				&edma_prog->u84_bitmap);
+		src_desc_start++;
+		dst_desc_start++;
+	}
+	return;
+}
+
+static inline void setup_ping_colony_register(struct nvdla_device *dev,
+					      edma_program_t *edma_prog,
+					      struct hw_colony *colony)
+{
+	edma_prog->reg[EDMA_COLONY_NUM] = colony->colony_num;
+	npu_set_u64_bit(EDMA_COLONY_NUM, &edma_prog->u84_bitmap);
+
+	edma_prog->reg[EDMA_SRC_COLONY_STRIDE] = colony->src_colony_stride;
+	npu_set_u64_bit(EDMA_SRC_COLONY_STRIDE, &edma_prog->u84_bitmap);
+
+	edma_prog->reg[EDMA_DST_COLONY_STRIDE] = colony->dst_colony_stride;
+	npu_set_u64_bit(EDMA_DST_COLONY_STRIDE, &edma_prog->u84_bitmap);
+	return;
+}
+
+static inline void setup_ping_refresh_register(struct nvdla_device *dev,
+					       edma_program_t *edma_prog,
+					       struct hw_refresh *refresh)
+{
+	edma_prog->reg[EDMA_REFRESH_TIMES] = refresh->main_refresh_times;
+	npu_set_u64_bit(EDMA_REFRESH_TIMES, &edma_prog->u84_bitmap);
+}
+
+static int setup_hw_desc_src(struct edma_desc *desc, struct hw_desc_src *hw,
+			     struct hw_colony *colony)
+{
+	hw->src_addr_low = LOW32BITS(desc->src_base_addr);
+	hw->src_addr_high = (uint16_t)HIGH32BITS(desc->src_base_addr);
+	/* Maybe Not really valid */
+	hw->src_input_c0 = (uint16_t)(desc->op->input_c0_bytes >>
+				      N_FORMAT_C0_OFFSET); /* /32 */
+	hw->src_input_c0 = ((hw->src_input_c0 == 1) ? 0 : hw->src_input_c0);
+	hw->src_line_len =
+		(uint16_t)(desc->op->src_num_line * desc->op->input_c0_bytes);
+	hw->src_line_stride = desc->op->src_stride_line_bytes;
+	hw->src_line_num = (uint16_t)desc->op->src_num_surface;
+	hw->src_slice_stride = desc->op->src_stride_surface_bytes;
+	colony->src_colony_stride = desc->op->src_stride_cube_bytes;
+
+	hw->src_slice_num = desc->op->src_num_cube;
+	/* enable dst finish intr and disable src */
+	hw->src_link_item_finish_intr = 0;
+
+	/* Notice: Colony need supplementary_dimension_enable */
+	if (desc->op->src_num_colony > 1) {
+		hw->src_link_item_supply_dim_en = 1;
+	} else {
+		hw->src_link_item_supply_dim_en = 0;
+	}
+	colony->src_colony_num = desc->op->src_num_colony;
+	/* we do't know ping or pong will work until now, set both */
+	colony->aux_src_colony_num = colony->src_colony_num;
+
+	/* n2e */
+	if (desc->op->input_c0_bytes != desc->op->output_c0_bytes) {
+		if (desc->op->input_c0_bytes & N_FORMAT_C0_MASK) {
+			dla_error("%s, %d, invalid input c0\n", __func__,
+				  __LINE__);
+			return -EINVAL;
+		}
+		hw->src_link_item_op_mode_n2e = 1;
+		switch (desc->op->output_c0_bytes &
+			N_FORMAT_C0_MASK) { /* %32 */
+		case 1:
+			hw->src_link_item_op_mode_c0 = 0x4; /* 0b100 */
+			break;
+		case 2:
+			hw->src_link_item_op_mode_c0 = 0; /* 0b000 */
+			break;
+		case 4:
+			hw->src_link_item_op_mode_c0 = 0x1; /* 0b001 */
+			break;
+		case 8:
+			hw->src_link_item_op_mode_c0 = 0x2; /* 0b010 */
+			break;
+		case 16:
+			hw->src_link_item_op_mode_c0 = 0x3; /* 0b0111 */
+			break;
+		default:
+			dla_error("%s %d bad output_c0 0x%x\n", __func__,
+				  __LINE__, desc->op->output_c0_bytes);
+			return -1;
+		}
+
+		if (desc->op->input_c0_bytes > N_FORMAT_C0) {
+			hw->src_line_len = N_FORMAT_C0;
+			hw->src_line_num = desc->op->src_num_line;
+			hw->src_line_stride = desc->op->input_c0_bytes;
+			hw->src_slice_num = desc->op->src_num_surface;
+			hw->src_slice_stride = desc->op->src_stride_line_bytes;
+		}
+
+		/* n2e Need colony stride */
+		if (desc->op->src_num_cube > 1 ||
+		    desc->op->src_num_colony > 1) {
+			if (desc->op->input_c0_bytes == N_FORMAT_C0) {
+				hw->src_slice_num = 1;
+				colony->src_colony_stride =
+					hw->src_slice_stride;
+			} else {
+				colony->src_colony_stride =
+					desc->op->src_stride_surface_bytes;
+			}
+		}
+		colony->src_colony_num = 1;
+		hw->src_link_item_supply_dim_en = 1;
+		colony->aux_src_colony_num = colony->src_colony_num;
+		colony->aux_src_colony_stride = colony->src_colony_stride;
+	} else {
+		hw->src_link_item_op_mode_n2e = 0;
+		hw->src_link_item_op_mode_c0 = 0;
+	}
+	/* TODO: So what if compiler want u16 */
+	hw->src_data_type = 0;
+	/* If link mode is needed, setup this field in other func, not here */
+	hw->src_link_item_link_mode = 0;
+	colony->aux_src_colony_stride = colony->src_colony_stride;
+	return 0;
+}
+
+static int setup_hw_desc_dst(struct edma_desc *desc, struct hw_desc_dst *dst,
+			     struct hw_desc_src *src, struct hw_colony *colony)
+{
+	int piece;
+	int line_num_offset;
+	uint32_t data_size;
+	struct npu_edma_op_desc *op;
+
+	/* set default 0 */
+	dst->dst_slice_num_link_item = 0;
+	op = desc->op;
+	dst->dst_addr_low = LOW32BITS(desc->dst_base_addr);
+	dst->dst_addr_high = (uint16_t)HIGH32BITS(desc->dst_base_addr);
+	/* enable dst finish intr and disable src */
+	dst->dst_link_item_finish_intr = 1;
+	/* copy src */
+	dst->dst_link_item_op_mode_n2e = src->src_link_item_op_mode_n2e;
+
+	if (desc->op->dst_num_colony > 1) {
+		dst->dst_link_item_supply_dim_en = 1;
+	} else {
+		dst->dst_link_item_supply_dim_en = 0;
+	}
+
+	/* n2e */
+	if (dst->dst_link_item_op_mode_n2e == 1) {
+		data_size =
+			N_FORMAT_C0 * op->src_num_line * op->src_num_surface;
+
+		if (op->input_c0_bytes > N_FORMAT_C0) {
+			colony->dst_colony_num = src->src_input_c0;
+		} else {
+			colony->dst_colony_num = 1;
+		}
+		dst->dst_link_item_supply_dim_en = 1;
+
+		if (src->src_data_type == 0) {
+			dst->dst_line_num = 32 / op->output_c0_bytes;
+		} else {
+			dst->dst_line_num = 16 / op->output_c0_bytes;
+		}
+		switch (dst->dst_line_num) {
+		case 32:
+			line_num_offset = 0x5;
+			break;
+		case 16:
+			line_num_offset = 0x4;
+			break;
+		case 8:
+			line_num_offset = 0x3;
+			break;
+		case 4:
+			line_num_offset = 0x2;
+			break;
+		case 2:
+			line_num_offset = 0x1;
+			break;
+		default:
+			line_num_offset = 0x0;
+			dla_error("unsupported fast divide\n");
+			break;
+		}
+		dst->dst_line_stride = data_size >> line_num_offset;
+		if (data_size >= EDMA_BUFFER_LEN) {
+			//EDMA_BUFFER_LEN / dst->dst_line_num;
+			dst->dst_line_len = EDMA_BUFFER_LEN >> line_num_offset;
+			piece = data_size >> EDMA_BUFFER_LEN_OFFSET;
+			/* roundup data_size / 2048 */
+			dst->dst_slice_num =
+				piece +
+				((data_size & (EDMA_BUFFER_LEN_MASK)) ? 1 : 0);
+			// data_size / dst->dst_line_num;
+			dst->dst_supply_line_len = dst->dst_line_stride -
+						   dst->dst_line_len * piece;
+		} else {
+			//data_size / dst->dst_line_num;
+			dst->dst_line_len = dst->dst_line_stride;
+			/* roundup data_size / 2048 */
+			dst->dst_slice_num = 1;
+			// data_size / dst->dst_line_num;
+			dst->dst_supply_line_len = data_size >> line_num_offset;
+		}
+		dst->dst_slice_stride = dst->dst_line_len;
+	} else {
+		dst->dst_supply_line_len = 0x0;	 //0;
+		dst->dst_line_len =
+			(uint16_t)(op->dst_num_line * op->input_c0_bytes);
+		dst->dst_line_num = (uint16_t)op->dst_num_surface;
+		dst->dst_line_stride = op->dst_stride_line_bytes;
+		dst->dst_slice_stride = op->dst_stride_surface_bytes;
+		dst->dst_slice_num = op->dst_num_cube;
+	}
+	/* Should consistent with src */
+	dst->dst_link_item_op_mode_c0 = src->src_link_item_op_mode_c0;
+	/* copy src */
+	dst->dst_link_item_link_mode = src->src_link_item_link_mode;
+	/* Notice: Colony need supplementary_dimension_enable(dst) */
+	if (dst->dst_link_item_op_mode_n2e == 1) {
+		colony->dst_colony_stride = data_size;
+	} else {
+		colony->dst_colony_num = op->dst_num_colony;
+		colony->dst_colony_stride = op->dst_stride_cube_bytes;
+	}
+	/* copy src */
+	dst->dst_data_type = src->src_data_type;
+	/* we do't know ping or pong will work until now, config both */
+	colony->aux_dst_colony_num = colony->dst_colony_num;
+	colony->aux_dst_colony_stride = colony->dst_colony_stride;
+	return 0;
+}
+
+/**
+ * return: number of hw_desc that construct and linked togetcher
+ */
+static int descs_constructor(struct edma_desc *desc[], struct hw_desc hw[],
+			     int desc_num)
+{
+	uint8_t i;
+	int ret, link_cnt;
+	int refresh_times = 0;
+
+	link_cnt = 0;
+	for (i = 0; i < desc_num; i++) {
+		ret = setup_hw_desc_src(desc[i], hw[i].src, &hw[i].colony);
+		if (ret < 0) {
+			dla_info("%s %d desc[%d] src construct fail\n",
+				 __func__, __LINE__, i);
+			return -EINVAL;
+		}
+		ret = setup_hw_desc_dst(desc[i], hw[i].dst, hw[i].src,
+					&hw[i].colony);
+		if (ret < 0) {
+			dla_info("%s %d desc[%d] dst construct fail\n",
+				 __func__, __LINE__, i);
+			return -EINVAL;
+		}
+
+		if (desc[i]->op->input_c0_bytes !=
+			    desc[i]->op->output_c0_bytes &&
+		    (desc[i]->op->src_num_cube != 1 ||
+		     desc[i]->op->src_num_colony != 1)) {
+			if (desc[i]->op->src_num_cube *
+				    desc[i]->op->src_stride_surface_bytes !=
+			    desc[i]->op->src_stride_cube_bytes) {
+				dla_error("%s %d n2e cube exist stride\n",
+					  __func__, __LINE__);
+				return -EINVAL;
+			}
+			refresh_times = desc[i]->op->src_num_cube *
+					desc[i]->op->src_num_colony;
+
+			if (refresh_times > 65535) {
+				dla_error(
+					"%s %d n2e dst cube x colony %d > 65535\n",
+					__func__, __LINE__, refresh_times);
+				return -EINVAL;
+			}
+			// hw need -1 config
+			hw[i].refresh.main_refresh_times = refresh_times - 1;
+			hw[i].refresh.aux_refresh_times = refresh_times - 1;
+			hw[i].src->src_link_item_link_mode =
+				PING_PONG_NON_SEQ_REFRESH;
+			hw[i].dst->dst_link_item_link_mode =
+				PING_PONG_NON_SEQ_REFRESH;
+			goto exit;
+		}
+
+		/* Task with same colony could linked together */
+		if (i > 0) {
+			ret = memcmp(&hw[i].colony, &hw[i - 1].colony,
+				     sizeof(struct hw_colony));
+			if (ret == 0 && link_cnt < HW_PING_CH_NUM) {
+				hw[i - 1].src->src_link_item_link_mode =
+					PING_PONG_SEQ_AND_PREFETCH;
+				hw[i - 1].dst->dst_link_item_link_mode =
+					PING_PONG_SEQ_AND_PREFETCH;
+				hw[i - 1]
+					.src
+					->src_link_item_entryNum_or_reGen_times =
+					link_cnt;
+				hw[i - 1]
+					.dst
+					->dst_link_item_entryNum_or_reGen_times =
+					link_cnt;
+				/* Linked desp only need last intr */
+				hw[i - 1].dst->dst_link_item_finish_intr = 0;
+				hw[i - 1].next_task = &hw[i];
+				link_cnt++;
+			} else {
+				hw[i - 1].src->src_link_item_link_mode =
+					PING_PONG_NON_LINK;
+				hw[i - 1].dst->dst_link_item_link_mode =
+					PING_PONG_NON_LINK;
+				hw[i - 1]
+					.src
+					->src_link_item_entryNum_or_reGen_times =
+					0;
+				hw[i - 1]
+					.dst
+					->dst_link_item_entryNum_or_reGen_times =
+					0;
+				hw[i - 1].next_task = NULL;
+				break;
+			}
+		} else {
+			hw[i].src->src_link_item_link_mode = PING_PONG_NON_LINK;
+			hw[i].dst->dst_link_item_link_mode = PING_PONG_NON_LINK;
+			hw[i].src->src_link_item_entryNum_or_reGen_times = 0;
+			hw[i].dst->dst_link_item_entryNum_or_reGen_times = 0;
+			hw[i].next_task = NULL;
+		}
+	}
+exit:
+	return (link_cnt + 1);
+}
+
+int edma_rdma_check(struct dla_processor_group *group,
+		    union dla_operation_container *op,
+		    union dla_surface_container *surface)
+{
+	return 0;
+}
+
+int edma_tensor_unfold(struct win_executor *executor, int op_idx,
+		       union dla_operation_container *operation_desc,
+		       union dla_surface_container *surface_desc, void *tensor,
+		       int idx)
+{
+	struct npu_edma_surface_desc *surface = &surface_desc->edma_surface;
+	edma_tensor_t *edma_tensor = tensor;
+	int ret, cnt;
+	u64 src_base_addr, dst_base_addr;
+	struct edma_desc edesc;
+	struct edma_desc *pdesc[1];
+	edma_dev_t *edma = NULL;
+	edma_dev_t *edma_dev = NULL;
+	npu_dep_info_t *npu_info = NULL;
+	edma_program_t *edma_prog;
+
+	edma = (edma_dev_t *)executor->prog_data_buf_bobj[IDX_EDMA];
+	edma_dev = (edma_dev_t *)&edma[idx];
+	npu_info = &edma_dev->npu_info;
+
+	edma_prog = &edma_dev->prog_data;
+
+	edma_prog->input_tensor_idx = invalid_tensor_idx;
+	edma_prog->output_tensor_idx = invalid_tensor_idx;
+
+	ret = read_input_address(executor, &surface->src_data,
+				 (void *)&src_base_addr,
+				 &edma_tensor[idx].src_is_io_tensor);
+
+	if (ret != 0) {
+		dla_error("%s %d bad memory type %d\n", __func__, __LINE__,
+			  surface->src_data.type);
+		return -1;
+	}
+	ret = read_input_address(executor, &surface->dst_data,
+				 (void *)&dst_base_addr,
+				 &edma_tensor[idx].dst_is_io_tensor);
+
+	if (ret != 0) {
+		dla_error("%s %d bad memory type %d\n", __func__, __LINE__,
+			  surface->dst_data.type);
+		return -1;
+	}
+	if (edma_tensor[idx].src_is_io_tensor == invalid_tensor_idx) {
+		if (unlikely(src_base_addr == -1)) {
+			dla_error("%s %d bad memory type %d\n", __func__,
+				  __LINE__, surface->src_data.type);
+			return -1;
+		} else {
+			edesc.src_base_addr = src_base_addr;
+		}
+	} else {
+		edesc.src_base_addr = surface->src_data.offset;
+		edma_prog->input_tensor_idx = edma_tensor[idx].src_is_io_tensor;
+	}
+
+	if (edma_tensor[idx].dst_is_io_tensor == invalid_tensor_idx) {
+		if (unlikely(dst_base_addr == -1)) {
+			dla_error("%s %d bad memory type %d\n", __func__,
+				  __LINE__, surface->dst_data.type);
+			return -1;
+		} else {
+			edesc.dst_base_addr = dst_base_addr;
+		}
+	} else {
+		edesc.dst_base_addr = surface->dst_data.offset;
+		edma_prog->output_tensor_idx = edma_tensor[idx].dst_is_io_tensor;
+	}
+	edesc.op = &operation_desc->edma_op;
+	pdesc[0] = &edesc;
+	edma_tensor[idx].hw.src = &edma_tensor[idx].src;
+	edma_tensor[idx].hw.dst = &edma_tensor[idx].dst;
+	edma_tensor[idx].hw.next_task = NULL;
+	edma_tensor[idx].hw.d = NULL;
+	npu_info->current_op_idx = op_idx;
+	cnt = descs_constructor(pdesc, &edma_tensor[idx].hw, 1);
+
+	if (cnt < 0 || cnt != 1) {
+		dla_error("cnt: %d desc_num: 1\n", cnt);
+	}
+	return 0;
+}
+
+int edma_prepare_prog_data(struct win_executor *executor, int rdma, int seq,
+			   u16 op_idx,
+			   union dla_operation_container *operation_desc,
+			   union dla_surface_container *surface_desc)
+{
+	struct npu_edma_surface_desc *surface;
+	struct nvdla_device *nvdla_dev;
+	edma_tensor_t *tensor = executor->tensor_set[IDX_EDMA];
+	edma_tensor_t *edma_tensor = NULL;
+	edma_dev_t *edma =
+		(edma_dev_t *)executor->prog_data_buf_bobj[IDX_EDMA];
+	edma_dev_t *edma_dev = (edma_dev_t *)&edma[seq];
+	edma_program_t *edma_prog = &edma_dev->prog_data;
+
+	surface = &surface_desc->edma_surface;
+	nvdla_dev = executor->driver_context;
+	edma_tensor = &tensor[seq];
+
+	setup_ping_colony_register(nvdla_dev, edma_prog,
+				   &edma_tensor->hw.colony);
+	setup_ping_refresh_register(nvdla_dev, edma_prog,
+				    &edma_tensor->hw.refresh);
+	setup_one_despram(nvdla_dev, edma_prog, 0,
+			  (uint32_t *)edma_tensor->hw.src,
+			  (uint32_t *)edma_tensor->hw.dst);
+	return 0;
+}
+
+void edma_free(struct nvdla_device *nvdla_dev)
+{
+	struct edma_context *edma;
+
+	edma = nvdla_dev->edma;
+	if (edma == NULL) {
+		return;
+	}
+	kfree(edma);
+	nvdla_dev->edma = NULL;
+	return;
+}
+
+int edma_init(struct nvdla_device *nvdla_dev)
+{
+	struct edma_context *edma;
+
+	if (nvdla_dev->edma) {
+		dla_info("%s %d edma already exist\n", __func__, __LINE__);
+		return -1;
+	}
+	edma = kzalloc(sizeof(struct edma_context), GFP_KERNEL);
+	if (edma == NULL) {
+		dla_info("%s %d edma can't alloc memory\n", __func__, __LINE__);
+		return -1;
+	}
+	spin_lock_init(&edma->hw_lock);
+	config_general_parameter(edma, nvdla_dev);
+	edma->edma_restart = restart;
+	nvdla_dev->edma = edma;
+	edma->dev = nvdla_dev;
+	return 0;
+}
diff --git a/drivers/soc/eswin/ai_driver/npu/edma.h b/drivers/soc/eswin/ai_driver/npu/edma.h
new file mode 100644
index 000000000000..6f5301811ffe
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/npu/edma.h
@@ -0,0 +1,370 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#ifndef __EDMA_H_
+#define __EDMA_H_
+
+#include "dla_interface.h"
+// #define DESC_PREFETCH
+
+// Define base address
+#define EDMA_S_BASE_ADDR 0x110000
+#define EDMA_D_BASE_ADDR 0x111000
+#define SRAM_BASE_ADDR 0x59000000
+
+#define EDMA_BUFFER_LEN 2048
+#define EDMA_BUFFER_LEN_OFFSET (11)
+#define EDMA_BUFFER_LEN_MASK (2048 - 1)
+#define N_FORMAT_C0_OFFSET 5
+#define N_FORMAT_C0 32
+#define N_FORMAT_C0_MASK (32 - 1)
+
+// Define REG_SOFT mask
+#define REG_SOFT_MASK 0xffffffff
+#define REG_SOFT_RST_MASK 0x00000001
+#define REG_SOFT_RST_GATE_MASK 0x00000002
+#define REG_SOFT_RST_GATE_CTL_MASK 0x00000004
+#define REG_SOFT_RST_HALT_MASK 0x80000000
+
+// Define REG_SOFT value
+#define REG_SOFT_RST_VAL 0
+#define REG_SOFT_RST_HALT_VAL 0
+
+// Define REG_GENERAL_PARAMETER mask
+#define REG_GENERAL_PARAMETER_MASK 0xffffffff
+#define REG_GENERAL_PARAMETER_AUX_MASK 0x00000001
+#define REG_GENERAL_PARAMETER_LEN_MASK 0xfc000000
+
+// Define REG_GENERAL_PARAMETER value
+#define REG_GENERAL_PARAMETER_AUX_VAL 0x00000001
+#define REG_GENERAL_PARAMETER_LEN_VAL 0x04000000
+
+// Define REG_SW_TRIG mask
+#define REG_SW_TRIG_MASK 0xffffffff
+#define REG_SW_TRIG_RD_NUM_MASK 0x0000000f
+#define REG_SW_TRIG_WR_NUM_MASK 0x000f0000
+#define REG_SW_TRIG_PRE_ADDR_RESET_MASK 0x20000000
+#define REG_SW_TRIG_DESP_RAM_INVALID_MASK 0x40000000
+#define REG_SW_TRIGGER_MASK 0x80000000
+
+// Define REG_SW_TRIG value
+#ifdef DESC_PREFETCH
+#define REG_SW_TRIG_PRE_ADDR_RESET_VAL 0x20000000
+#define REG_SW_TRIG_DESP_RAM_INVALID_VAL 0x40000000
+#else
+#define REG_SW_TRIG_PRE_ADDR_RESET_VAL 0x00000000
+#define REG_SW_TRIG_DESP_RAM_INVALID_VAL 0x00000000
+#endif
+#define REG_SW_TRIGGER_VAL 0x80000000
+
+// Define REG_AUX_SW_TRG mask
+#define REG_SW_TRIG_AUX_RD_NUM_MASK 0x0000000f
+#define REG_SW_TRIG_AUX_WR_NUM_MASK 0x000f0000
+#define REG_SW_TRIG_AUX_DESP_RAM_INVALID_MASK 0x40000000
+#define REG_SW_TRIGGER_AUX_MASK 0x80000000
+
+// Define REG_AUX_SW_TRIG value
+#define REG_SW_TRIG_AUX_DESP_RAM_INVALID_VAL 0x00000000
+#define REG_SW_TRIGGER_AUX_VAL 0x80000000
+
+// Define REG_PREFETCH_PARAMETER mask
+#define REG_PREFETCH_PARAMETER_MASK
+#define REG_PREFETCH_PARAMETER_TOTAL_DEPTH_MASK 0x0000ffff
+#define REG_PREFETCH_PARAMETER_ADDR_OFFSET_MASK 0xffff0000
+
+// Define REG_PREFETCH_PARAMETER value
+#define REG_PREFETCH_PARAMETER_TOTAL_DEPTH_VAL \
+	0x00000780  // 1920 = 384 * 5 < 2048
+
+// Define REG_STATUS mask
+#define REG_STATUS_BUSY 0x00000001
+#define REG_STATUS_WR_BUSY 0x00000002
+#define REG_STATUS_RD_BUSY 0x00000004
+#define REG_STATUS_AUX_TRIG_BUSY 0x00000008
+#define REG_STATUS_MAIN_TRIG_BUSY 0x00000010
+#define REG_STATUS_AUX_ERR_ENTRY_NUM 0x0001fe00
+#define REG_STATUS_ERR_ENTRY_NUM 0x01fe0000
+#define REG_STATUS_ERR_TYPE 0x06000000
+#define REG_STATUS_ERR_CAUSE 0x78000000
+#define REG_STATUS_ERR_FLAG 0x80000000
+
+// Define REG_INT_STATUS mask
+#define REG_INT_STATUS_RD_INTR_MASK 0x00000001
+#define REG_INT_STATUS_RD_ENTRY_NUM_MASK 0x0000001e
+#define REG_INT_STATUS_WR_INTR_MASK 0x00000020
+#define REG_INT_STATUS_WR_ENTRY_NUM_MASK 0x000003c0
+#define REG_INT_STATUS_AUX_RD_INTR_MASK 0x00000400
+#define REG_INT_STATUS_AUX_RD_ENTRY_NUM_MASK 0x00007800
+#define REG_INT_STATUS_AUX_WR_INTR_MASK 0x00008000
+#define REG_INT_STATUS_AUX_WR_ENTRY_NUM_MASK 0x000f0000
+
+// Define REG_DST_COLONY_NUM offset
+#define REG_DST_COLONY_NUM_OFFSET 16
+
+// Define RAM_SRC_ADDRESS mask
+#define RAM_SRC_ADDR_LOW_MASK 0xffffffff
+#define RAM_SRC_ADDR_HIGH_MASK 0xffffffff
+
+// Define RAM_SRC_LINE_LEN_WITH_NUM mask
+#define RAM_SRC_LINE_LEN_WITH_NUM_MASK 0xffffffff
+#define RAM_SRC_LINE_LEN_MASK 0x0000ffff
+#define RAM_SRC_LINE_NUM_MASK 0xffff0000
+
+// Define RAM_SRC_ADDR_HIGH_BIT_OFFSET
+#define RAM_SRC_ADDR_HIGH_BIT_OFFSET 0
+#define RAM_SRC_INPUT_C0_BITOFFSET 16
+
+// Define RAM_SRC_LINE_LEN_WITH_NUM bit offset
+#define RAM_SRC_LINE_LEN_BIT_OFFSET 0
+#define RAM_SRC_LINE_NUM_BIT_OFFSET 16
+
+// Define RAM_SRC_LINE_SLICE_STRIDE mask
+#define RAM_SRC_LINE_SLICE_STRIDE_MASK 0xffffffff
+#define RAM_SRC_LINE_STRIDE_MASK 0x0000ffff
+#define RAM_SRC_SLICE_STRIDE_MASK 0xffff0000
+
+// Define RAM_SRC_LINE_SLICE_STRIDE bit offset
+#define RAM_SRC_LINE_STRIDE_BIT_OFFSET 0
+#define RAM_SRC_SLICE_STRIDE_BIT_OFFSET 16
+
+// Define RAM_SRC_SLICENUM_LINKITEM mask
+#define RAM_SRC_SLICENUM_LINKITEM_MASK 0xffffffff
+#define RAM_SRC_SLICE_NUM_MASK 0x0000ffff
+#define RAM_SRC_LINK_ITEM_LINK_MODE_MASK 0x00070000
+#define RAM_SRC_LINK_ITEM_ENTRY_NUM_MASK 0x00780000
+#define RAM_SRC_LINK_ITEM_SUPPLY_DIM_MASK 0x08000000
+#define RAM_SRC_LINK_ITEM_DATA_TYPE_MASK 0x04000000
+#define RAM_SRC_LINK_ITEM_OP_MODE_MASK 0x78000000
+#define RAM_SRC_LINK_ITEM_INTR_MASK 0x80000000
+
+// Define RAM_SRC_SLICENUM_LINKITEM bit offset
+#define RAM_SRC_SLICE_NUM_BIT_OFFSET 0
+#define RAM_SRC_LINK_ITEM_LINK_MODE_BIT_OFFSET 16
+#define RAM_SRC_LINK_ITEM_ENTRY_NUM_BIT_OFFSET 19
+#define RAM_SRC_LINK_ITEM_SUPPLY_DIM_BIT_OFFSET 25
+#define RAM_SRC_LINK_ITEM_DATA_TYPE_BIT_OFFSET 26
+#define RAM_SRC_LINK_ITEM_OP_MODE_BIT_OFFSET 27
+#define RAM_SRC_LINK_ITEM_INTR_BIT_OFFSET 31
+
+// Define RAM_DST_ADDRESS mask
+#define RAM_DST_ADDR_LOW_MASK 0xffffffff
+#define RAM_DST_ADDR_HIGH_MASK 0xffffffff
+
+// Define RAM_DST_LINE_LEN_WITH_NUM mask
+#define RAM_DST_LINE_LEN_WITH_NUM_MASK 0xffffffff
+#define RAM_DST_LINE_LEN_MASK 0x0000ffff
+#define RAM_DST_LINE_NUM_MASK 0xffff0000
+
+// Define RAM_DST_LINE_LEN_WITH_NUM bit offset
+#define RAM_DST_LINE_LEN_BIT_OFFSET 0
+#define RAM_DST_LINE_NUM_BIT_OFFSET 16
+
+// Define RAM_DST_LINE_SLICE_STRIDE mask
+#define RAM_DST_LINE_SLICE_STRIDE_MASK 0xffffffff
+#define RAM_DST_LINE_STRIDE_MASK 0x0000ffff
+#define RAM_DST_SLICE_STRIDE_MASK 0xffff0000
+
+// Define COLONY_NUM bit offset
+#define RAM_SRC_COLONY_NUM_BIT_OFFSET 0
+#define RAM_DST_COLONY_NUM_BIT_OFFSET 16
+
+// Define DST_ADDR_HIGH bit offset
+#define RAM_DST_ADDR_HIGH_BIT_OFFSET 0
+#define RAM_DST_SUPPLY_LINE_LEN_BIT_OFFSET 16
+
+// Define RAM_DST_LINE_SLICE_STRIDE bit offset
+#define RAM_DST_LINE_STRIDE_BIT_OFFSET 0
+#define RAM_DST_SLICE_STRIDE_BIT_OFFSET 16
+
+// Define RAM_DST_SLICENUM_LINKITEM mask
+#define RAM_DST_SLICENUM_LINKITEM_MASK 0xffffffff
+#define RAM_DST_SLICE_NUM_MASK 0x0000ffff
+#define RAM_DST_LINK_ITEM_LINK_MODE_MASK 0x00070000
+#define RAM_DST_LINK_ITEM_ENTRY_NUM_MASK 0x00780000
+#define RAM_DST_LINK_ITEM_DATA_TYPE_MASK 0x04000000
+#define RAM_DST_LINK_ITEM_OP_MODE_MASK 0x78000000
+#define RAM_DST_LINK_ITEM_INTR_MASK 0x80000000
+
+// Define RAM_DST_SLICENUM_LINKITEM bit offset
+#define RAM_DST_SLICE_NUM_BIT_OFFSET 0
+#define RAM_DST_LINK_ITEM_LINK_MODE_BIT_OFFSET 16
+#define RAM_DST_LINK_ITEM_ENTRY_NUM_BIT_OFFSET 19
+#define RAM_DST_LINK_ITEM_SUPPLY_DIM_BIT_OFFSET 25
+#define RAM_DST_LINK_ITEM_DATA_TYPE_BIT_OFFSET 26
+#define RAM_DST_LINK_ITEM_OP_MODE_BIT_OFFSET 27
+#define RAM_DST_LINK_ITEM_INTR_BIT_OFFSET 31
+
+#define SRC_DESP_BASE 0x100
+#define DST_DESP_BASE 0x300
+
+#define AUX_DESP_INDEX 8
+#define EDMA_DESP_SIZE 0x18
+#define EDMA_DESP_STRIDE 0x20
+
+#define PREFETCH_DST_INDEX_OFFSET 8
+
+#define AUX_PREFETCH_ADDR_OFFSET 2048
+
+#define REG_SRC_DESP_MAIN_BASE (EDMA_S_BASE_ADDR + SRC_DESP_BASE)
+#define REG_SRC_DESP_AUX_BASE \
+	(EDMA_S_BASE_ADDR + SRC_DESP_BASE + AUX_DESP_INDEX * EDMA_DESP_STRIDE)
+#define REG_DST_DESP_MAIN_BASE (EDMA_S_BASE_ADDR + DST_DESP_BASE)
+#define REG_DST_DESP_AUX_BASE \
+	(EDMA_S_BASE_ADDR + DST_DESP_BASE + AUX_DESP_INDEX * EDMA_DESP_STRIDE)
+
+#define NUM_MAX_EDMA_OPS 8
+
+typedef enum {
+	// EDMA REG
+	EDMA_REG_SOFT_RST = 0x0,
+	EDMA_REG_GENERAL_PARAMETER = 0x4,
+	EDMA_REG_STATUS = 0x8,
+	EDMA_REG_SW_TRIG = 0xc,
+	EDMA_REG_INT_EN = 0x10,
+	EDMA_REG_INT_MASK = 0x14,
+	EDMA_REG_INT_STATUS = 0x18,
+	EDMA_REG_PREFETCH_ADDR_LOW = 0x1c,
+	EDMA_REG_PREFETCH_ADDR_HIGH = 0x20,
+	EDMA_REG_PREFETCH_PARAMETER = 0x24,
+	EDMA_REG_ERR_ADDR_HIGH = 0x28,
+	EDMA_REG_ERR_ADDR_LOW = 0x2c,
+	EDMA_REG_AUX_PREFETCH_ADDR_LOW = 0x30,
+	EDMA_REG_AUX_PREFETCH_ADDR_HIGH = 0x34,
+	EDMA_REG_AUX_PREFETCH_PARAMETER = 0x38,
+	EDMA_REG_AUX_SW_TRIG = 0x3c,
+	EDMA_REG_COLONY_NUM = 0x40,
+	EDMA_REG_SRC_COLONY_STRIDE = 0x44,
+	EDMA_REG_DST_COLONY_STRIDE = 0x48,
+	EDMA_REG_AUX_COLONY_NUM = 0x50,
+	EDMA_REG_AUX_SRC_COLONY_STRIDE = 0x54,
+	EDMA_REG_AUX_DST_COLONY_STRIDE = 0x58,
+	EDMA_REG_REFRESH_TIMES = 0x60,
+	EDMA_REG_AUX_REFRESH_TIMES = 0x64
+} EDMA_REG;
+
+struct edma_desc {
+	struct npu_edma_op_desc *op;
+	uint64_t src_base_addr;
+	uint64_t dst_base_addr;
+};
+
+struct hw_desc_src {
+	uint32_t src_addr_low;
+	/* Not semantics related, Just comfort hardware arrangement */
+	struct {
+		uint16_t src_addr_high;
+		uint16_t src_input_c0;
+	};
+	struct {
+		uint16_t src_line_len;
+		uint16_t src_line_num;
+	};
+	uint32_t src_line_stride;
+	uint32_t src_slice_stride;
+	union {
+		struct {
+			uint32_t src_slice_num : 16;
+#define PING_PONG_NON_LINK 0x0
+#define PING_PONG_NON_SEQ_LINK 0x1
+/* TODO: Not really acknowledged */
+#define PING_PONG_NON_SEQ_RELOAD 0x2
+#define PING_PONG_NON_SEQ_REFRESH 0x4
+#define NON_PING_PONG_SEQ_REFRESH_PREMETCH 0x5
+#define PING_PONG_SEQ_AND_PREFETCH 0x6
+			uint32_t src_link_item_link_mode : 3;
+			uint32_t src_link_item_entryNum_or_reGen_times : 4;
+			uint32_t rsv : 2;
+			uint32_t src_link_item_supply_dim_en : 1;
+			uint32_t src_data_type : 1;
+			uint32_t src_link_item_op_mode_n2e : 1;
+			uint32_t src_link_item_op_mode_c0 : 3;
+			uint32_t src_link_item_finish_intr : 1;
+		};
+		uint32_t src_slice_num_link_item;
+	};
+} __attribute__((packed, aligned(4)));
+
+struct hw_desc_dst {
+	uint32_t dst_addr_low;
+	/* Not semantics related, Just comfort hardware arrangement */
+	struct {
+		uint16_t dst_addr_high;
+		/* n2e only */
+		uint16_t dst_supply_line_len;
+	};
+	struct {
+		uint16_t dst_line_len;
+		uint16_t dst_line_num;
+	};
+	uint32_t dst_line_stride;
+	uint32_t dst_slice_stride;
+	union {
+		struct {
+			uint32_t dst_slice_num : 16;
+			uint32_t dst_link_item_link_mode : 3;
+			uint32_t dst_link_item_entryNum_or_reGen_times : 4;
+			uint32_t rsv : 2;
+			uint32_t dst_link_item_supply_dim_en : 1;
+			uint32_t dst_data_type : 1;
+			uint32_t dst_link_item_op_mode_n2e : 1;
+			uint32_t dst_link_item_op_mode_c0 : 3;
+			uint32_t dst_link_item_finish_intr : 1;
+		};
+		uint32_t dst_slice_num_link_item;
+	};
+} __attribute__((packed, aligned(4)));
+
+struct hw_colony {
+	union {
+		struct {
+			uint32_t src_colony_num : 16;
+			uint32_t dst_colony_num : 16;
+		};
+#define COLONY_NONE (0x00010001)
+		uint32_t colony_num;
+	};
+	uint32_t src_colony_stride;
+	uint32_t dst_colony_stride;
+	union {
+		struct {
+			uint32_t aux_src_colony_num : 16;
+			uint32_t aux_dst_colony_num : 16;
+		};
+		uint32_t aux_colony_num;
+	};
+	uint32_t aux_src_colony_stride;
+	uint32_t aux_dst_colony_stride;
+} __attribute__((packed, aligned(4)));
+
+struct hw_refresh {
+	union {
+		struct {
+			uint32_t main_refresh_times : 16;
+			uint32_t main_reserved : 16;
+		};
+		uint32_t main_refresh_times_32;
+	};
+	union {
+		struct {
+			uint32_t aux_refresh_times : 16;
+			uint32_t aux_reserved : 16;
+		};
+		uint32_t aux_refresh_times_32;
+	};
+};
+
+struct hw_desc {
+	struct hw_desc_src *src;
+	struct hw_desc_dst *dst;
+	struct hw_colony colony;
+	struct hw_refresh refresh;
+	struct hw_desc *next_task;
+	struct edma_desc *d;
+};
+int edma_init(struct nvdla_device *nvdla_dev);
+void edma_free(struct nvdla_device *nvdla_dev);
+#endif /* __EDMA_H_ */
diff --git a/drivers/soc/eswin/ai_driver/npu/engine.c b/drivers/soc/eswin/ai_driver/npu/engine.c
new file mode 100644
index 000000000000..f51eacae6f10
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/npu/engine.c
@@ -0,0 +1,957 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#include <opendla.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/of.h>
+#include <linux/iommu.h>
+#include <linux/es_iommu_rsv.h>
+#include <dla_err.h>
+#include <dla_interface.h>
+#include "dla_engine.h"
+#include "dla_engine_internal.h"
+#include "hetero_ioctl.h"
+#include "hetero_host.h"
+#include "dla_driver.h"
+#include "common.h"
+#include "dla_log.h"
+#include "internal_interface.h"
+#include "dla_buffer.h"
+#include "debug.h"
+#include "dsp_hw.h"
+
+#include "dsp.h"
+const u8 processor_idx_convert[NUM_OP_TYPE] = {
+	[IDX_EDMA] = DLA_OP_EDMA,
+	[IDX_CONV] = DLA_OP_CONV,
+	[IDX_SDP] = DLA_OP_SDP,
+	[IDX_PDP] = DLA_OP_PDP,
+	[IDX_RUBIK] = DLA_OP_RUBIK,
+	[IDX_KMD_DSP0] = DLA_KMD_OP_DSP_0,
+	[IDX_KMD_DSP1] = DLA_KMD_OP_DSP_1,
+	[IDX_KMD_DSP2] = DLA_KMD_OP_DSP_2,
+	[IDX_KMD_DSP3] = DLA_KMD_OP_DSP_3,
+	[IDX_EVENT_SINK] = DLA_OP_EVENT_SINK,
+	[IDX_EVENT_SOURCE] = DLA_OP_EVENT_SOURCE,
+};
+const u8 processor_dla_convert[HW_OP_NUM] = {
+	[DLA_OP_EDMA] = IDX_EDMA,
+	[DLA_OP_CONV] = IDX_CONV,
+	[DLA_OP_SDP] = IDX_SDP,
+	[DLA_OP_PDP] = IDX_PDP,
+	[DLA_OP_RUBIK] = IDX_RUBIK,
+	[DLA_KMD_OP_DSP_0] = IDX_KMD_DSP0,
+	[DLA_KMD_OP_DSP_1] = IDX_KMD_DSP1,
+	[DLA_KMD_OP_DSP_2] = IDX_KMD_DSP2,
+	[DLA_KMD_OP_DSP_3] = IDX_KMD_DSP3,
+	[DLA_OP_EVENT_SINK] = IDX_EVENT_SINK,
+	[DLA_OP_EVENT_SOURCE] = IDX_EVENT_SOURCE,
+};
+
+int set_current(struct win_engine *engine, struct win_executor *executor,
+		u32 tiktok)
+{
+	struct win_engine *win_engine = engine;
+
+	if (unlikely(win_engine->cur[tiktok] != NULL || executor == NULL)) {
+		dla_error(
+			"BUG: trying to use busy engine or set engine NULL\n");
+		return -1;
+	}
+	win_engine->cur[tiktok] = executor;
+	return 0;
+}
+int unset_current(struct win_engine *engine, struct win_executor *executor,
+		  u32 tiktok)
+{
+	if (unlikely(engine->cur[tiktok] != executor)) {
+		dla_info("trying to unset invalid executor, nothing todo\n");
+		return -1;
+	}
+	engine->cur[tiktok] = NULL;
+	return 0;
+}
+
+int32_t dla_enable_intr(struct nvdla_device *dev, uint32_t mask)
+{
+	void *base = (struct nvdla_device *)dev->base;
+	uint32_t reg = glb_reg_read(base, S_INTR_MASK);
+
+	reg = reg & (~mask);
+	glb_reg_write(base, S_INTR_MASK, reg);
+
+	return 0;
+}
+
+int32_t dla_disable_intr(struct nvdla_device *dev, uint32_t mask)
+{
+	void *base = (struct nvdla_device *)dev->base;
+	uint32_t reg = glb_reg_read(base, S_INTR_MASK);
+
+	reg = reg | mask;
+	glb_reg_write(base, S_INTR_MASK, reg);
+
+	return 0;
+}
+
+/**
+ * Get DMA data cube address
+ */
+int dla_get_dma_cube_address(void *driver_context, void *task_data,
+			     int16_t index, uint32_t offset, void *dst_ptr,
+			     u32 *is_io_tensor)
+{
+	int32_t ret = 0;
+	uint64_t *pdst = (uint64_t *)dst_ptr;
+
+	ret = dla_get_dma_address(driver_context, task_data, index, dst_ptr,
+				  is_io_tensor);
+	if (ret < 0)
+		goto exit;
+
+	if (ret == 1) {
+		ret = 0;
+		goto exit;
+	}
+	pdst[0] += offset;
+
+exit:
+	return ret;
+}
+
+int dla_get_sram_cube_address(void *driver_context, void *task_data,
+			      int16_t index, uint32_t offset, uint64_t *dst_ptr,
+			      u32 *is_io_tensor)
+{
+	int32_t ret = 0;
+	ret = dla_get_sram_address(driver_context, task_data, index, dst_ptr,
+				   is_io_tensor);
+	if (ret < 0)
+		goto exit;
+
+	if (ret == 1) {
+		ret = 0;
+		goto exit;
+	}
+	*dst_ptr += offset;
+
+exit:
+	return ret;
+}
+
+int read_input_address(struct win_executor *executor,
+		       struct dla_data_cube *data, uint64_t *address,
+		       u32 *is_io_tensor)
+{
+	int32_t ret = ERR(INVALID_INPUT);
+
+	/**
+	 * If memory type is HW then no address required
+	 */
+	if (data->type == DLA_MEM_HW) {
+		*address = -1ull;
+		*is_io_tensor = invalid_tensor_idx;
+		ret = 0;
+		goto exit;
+	}
+
+	if (data->address == -1) {
+		dla_error("address is invalid\n");
+		goto exit;
+	}
+	if (data->type == DLA_MEM_MC) {
+		ret = dla_get_dma_cube_address(executor->driver_context,
+					       executor->mem_handles,
+					       data->address, data->offset,
+					       (void *)address, is_io_tensor);
+		if (ret < 0) {
+			dla_error("dla_get_cube_address fail\n");
+		}
+	} else if (data->type == DLA_MEM_CV) {
+		ret = dla_get_sram_cube_address(executor->driver_context,
+						executor->mem_handles,
+						data->address, data->offset,
+						(void *)address, is_io_tensor);
+		if (ret < 0) {
+			dla_error("dla_get_sram_address fail\n");
+			goto exit;
+		}
+	} else {
+		dla_error("data type is invalid\n");
+		ret = -1;
+	}
+exit:
+	return ret;
+}
+
+int io_tensor_record(struct win_executor *executor, addrDesc_t *address,
+		     u32 *is_io_tensor)
+{
+	if (is_io_tensor == NULL) {
+		return 0;
+	}
+
+	switch (address->flag) {
+	case mem_flag_input:
+		if (address->bindId > executor->input_num) {
+			dla_error("%s %d invalid bind_id %d\n", __func__,
+				  __LINE__, address->bindId);
+			return -1;
+		}
+		*is_io_tensor = address->bindId;
+		return 1;
+	case mem_flag_output:
+		if (address->bindId > executor->output_num) {
+			dla_error("%s %d invalid bind_id %d\n", __func__,
+				  __LINE__, address->bindId);
+			return -1;
+		}
+		*is_io_tensor = address->bindId + executor->input_num;
+		return 1;
+	default:
+		*is_io_tensor = invalid_tensor_idx;
+		return 0;
+	}
+}
+
+static struct processors_interface edma_interface = {
+	.name = "EDMA",
+	.op_type = DLA_OP_EDMA,
+	.tensor_unfold = edma_tensor_unfold,
+	.prepare_prog_data = edma_prepare_prog_data,
+	.rdma_check = edma_rdma_check,
+};
+static struct processors_interface conv_interface = {
+	.name = "Convolution",
+	.op_type = DLA_OP_CONV,
+	.tensor_unfold = conv_tensor_unfold,
+	.prepare_prog_data = dla_conv_prepare_prog_data,
+	.rdma_check = dla_conv_rdma_check,
+};
+static struct processors_interface sdp_interface = {
+	.name = "SDP",
+	.op_type = DLA_OP_SDP,
+	.tensor_unfold = sdp_tensor_unfold,
+	.prepare_prog_data = dla_sdp_prepare_prog_data,
+	.rdma_check = dla_sdp_rdma_check,
+};
+static struct processors_interface pdp_interface = {
+	.name = "PDP",
+	.op_type = DLA_OP_PDP,
+	.tensor_unfold = pdp_tensor_unfold,
+	.prepare_prog_data = dla_pdp_prepare_prog_data,
+	.rdma_check = dla_pdp_rdma_check,
+};
+static struct processors_interface rubik_interface = {
+	.name = "RUBIK",
+	.op_type = DLA_OP_RUBIK,
+	.tensor_unfold = rubik_tensor_unfold,
+	.prepare_prog_data = dla_rubik_prepare_prog_data,
+	.rdma_check = dla_rubik_rdma_check,
+};
+static struct processors_interface event_sink_interface = {
+	.name = "EVENT_SINK",
+	.op_type = DLA_OP_EVENT_SINK,
+	.tensor_unfold = event_sink_tensor_unfold,
+	.prepare_prog_data = dla_event_sink_prepare_prog_data,
+	.rdma_check = dla_event_sink_rdma_check,
+};
+static struct processors_interface event_source_interface = {
+	.name = "EVENT_SOURCE",
+	.op_type = DLA_OP_EVENT_SOURCE,
+	.tensor_unfold = event_source_tensor_unfold,
+	.prepare_prog_data = dla_event_source_prepare_prog_data,
+	.rdma_check = dla_event_source_rdma_check,
+};
+
+static struct processors_interface dsp0_interface = {
+	.name = "DSP0",
+	.op_type = DLA_KMD_OP_DSP_0,
+	.tensor_unfold = dsp0_tensor_unfold,
+	.prepare_prog_data = dsp0_prepare_prog_data,
+	.rdma_check = NULL,
+};
+
+static struct processors_interface dsp1_interface = {
+	.name = "DSP1",
+	.op_type = DLA_KMD_OP_DSP_1,
+	.tensor_unfold = dsp1_tensor_unfold,
+	.prepare_prog_data = dsp1_prepare_prog_data,
+	.rdma_check = NULL,
+};
+
+static struct processors_interface dsp2_interface = {
+	.name = "DSP2",
+	.op_type = DLA_KMD_OP_DSP_2,
+	.tensor_unfold = dsp2_tensor_unfold,
+	.prepare_prog_data = dsp2_prepare_prog_data,
+	.rdma_check = NULL,
+};
+
+static struct processors_interface dsp3_interface = {
+	.name = "DSP3",
+	.op_type = DLA_KMD_OP_DSP_3,
+	.tensor_unfold = dsp3_tensor_unfold,
+	.prepare_prog_data = dsp3_prepare_prog_data,
+	.rdma_check = NULL,
+};
+
+static void frame_done_handler(struct work_struct *w)
+{
+	int ret;
+	struct host_frame_desc *f, *f_tmp;
+	struct win_engine *engine =
+		container_of(w, struct win_engine, frame_done_work);
+
+	if (engine->frame_done == NULL) {
+		dla_error("error:%s %d frame_done is null!\n", __func__,
+			  __LINE__);
+		return;
+	}
+
+	while (true) {
+		f = engine->frame_done;
+		ret = __atomic_compare_exchange_n(&engine->frame_done, &f, NULL,
+						  true, __ATOMIC_RELAXED,
+						  __ATOMIC_RELAXED);
+		if (ret) {
+			break;
+		}
+	}
+
+	if (f == NULL) {
+		dla_error("error:%s %d frame_done is null!\n", __func__,
+			  __LINE__);
+		return;
+	}
+
+	while (f) {
+		f_tmp = f;
+		f = f->next;
+		destroy_frame(f_tmp);
+	}
+
+	return;
+}
+
+static void npu_task_complete_work(struct work_struct *work)
+{
+	struct win_engine *engine =
+		container_of(work, struct win_engine, complete_work);
+	unsigned long flags;
+	struct list_head tmp_list;
+
+	INIT_LIST_HEAD(&tmp_list);
+	spin_lock_irqsave(&engine->complete_lock, flags);
+	list_replace_init(&engine->frame_complete_list, &tmp_list);
+	spin_unlock_irqrestore(&engine->complete_lock, flags);
+
+	while (!list_empty(&tmp_list)) {
+		struct host_frame_desc *f;
+		f = list_first_entry(&tmp_list, struct host_frame_desc,
+				     complete_entry);
+		list_del(&f->complete_entry);
+		if (f->dump_dtim) {
+			dump_dtim_to_file(engine, f->tiktok);
+		}
+		kernel_handle_decref(&f->handle);
+	}
+}
+
+static void npu_put_dsp_dev(struct win_engine *engine)
+{
+	int i;
+
+	for (i = 0; i < DSP_MAX_CORE_NUM; i++) {
+		if (engine->dsp_dev[i] == NULL) {
+			continue;
+		}
+
+#if (NPU_DEV_SIM == NPU_REAL_ENV)
+		dsp_detach_sram_dmabuf(engine->dsp_dev[i]);
+#endif
+		engine->dsp_dev[i] = NULL;
+	}
+}
+
+static int npu_get_dsp_dev(struct win_engine *engine)
+{
+	struct nvdla_device *nvdla_dev =
+		(struct nvdla_device *)engine->nvdla_dev;
+	struct device *npu_dev = &nvdla_dev->pdev->dev;
+	int ret;
+	int i;
+
+	for (i = 0; i < DSP_MAX_CORE_NUM; i++) {
+		ret = subscribe_dsp_device(nvdla_dev->numa_id, i, npu_dev,
+					   &engine->dsp_dev[i]);
+		if (ret == -EPROBE_DEFER) {
+			engine->dsp_dev[i] = NULL;
+			goto err;
+		}
+
+#if (NPU_DEV_SIM == NPU_REAL_ENV)
+		if (!ret) {
+			ret = dsp_attach_sram_dmabuf(
+				engine->dsp_dev[i],
+				nvdla_dev->spram_bobj->dmabuf);
+			if (ret) {
+				dla_error(
+					"%s, %d, attach dsp sram failed, ret=%d.\n",
+					__func__, __LINE__, ret);
+				goto err;
+			}
+		}
+#endif
+	}
+	return 0;
+
+err:
+	npu_put_dsp_dev(engine);
+	return ret;
+}
+
+extern void npu_frame_timeout_tok(struct timer_list *t);
+extern void npu_frame_timeout_tik(struct timer_list *t);
+
+#define HOST_NODE_IOVA 0xf0000000
+int npu_init_ipc(struct nvdla_device *ndev)
+{
+	struct win_engine *engine = (struct win_engine *)ndev->win_engine;
+
+#if (NPU_DEV_SIM == NPU_REAL_ENV)
+	engine->host_node_iova = HOST_NODE_IOVA;
+	engine->host_node = iommu_map_rsv_iova(&ndev->pdev->dev, HOST_NODE_IOVA,
+					       sizeof(host_node_t), GFP_KERNEL,
+					       IOMMU_MMIO);
+	dla_debug("%s, %d, host_node_iova=0x%llx.\n", __func__, __LINE__,
+		  engine->host_node_iova);
+
+#else
+	engine->host_node =
+		dma_alloc_coherent(&ndev->pdev->dev, sizeof(host_node_t),
+				   &engine->host_node_iova, GFP_KERNEL);
+	dla_debug("%s, %d, host_node_iova=0x%llx.\n", __func__, __LINE__,
+		  engine->host_node_iova);
+#endif
+
+	if (!engine->host_node) {
+		return -ENOMEM;
+	}
+	host_ipc_initialize((u64)engine->host_node, (u32)engine->host_node_iova,
+			    (u64)ndev->emission_base, (u64)ndev->program_base);
+	return 0;
+}
+
+int npu_uninit_ipc(struct nvdla_device *ndev)
+{
+	struct win_engine *engine = (struct win_engine *)ndev->win_engine;
+
+	if (!engine) {
+		return -EINVAL;
+	}
+#if (NPU_DEV_SIM == NPU_REAL_ENV)
+	iommu_unmap_rsv_iova(&ndev->pdev->dev, engine->host_node,
+			     engine->host_node_iova, sizeof(host_node_t));
+#else
+	dma_free_coherent(&ndev->pdev->dev, sizeof(host_node_t),
+			  engine->host_node, engine->host_node_iova);
+#endif
+	return 0;
+}
+
+int win_engine_init(struct nvdla_device *nvdla_dev, void **arg_engine)
+{
+	struct win_engine *engine;
+	int ret;
+
+#if (NPU_DEV_SIM != NPU_MCU_HOST)
+	u32 i;
+#endif
+
+	if (nvdla_dev->win_engine != NULL) {
+		dla_error("%s %d engine inited\n", __func__, __LINE__);
+		return -1;
+	}
+	engine = kzalloc(sizeof(struct win_engine), GFP_KERNEL);
+	if (engine == NULL) {
+		dla_error("%s %d nomem\n", __func__, __LINE__);
+		return -ENOMEM;
+	}
+	engine->nvdla_dev = (void *)nvdla_dev;
+	engine->processors[IDX_EDMA] = &edma_interface;
+	engine->processors[IDX_CONV] = &conv_interface;
+	engine->processors[IDX_SDP] = &sdp_interface;
+	engine->processors[IDX_PDP] = &pdp_interface;
+	engine->processors[IDX_RUBIK] = &rubik_interface;
+	engine->processors[IDX_KMD_DSP0] = &dsp0_interface;
+	engine->processors[IDX_KMD_DSP1] = &dsp1_interface;
+	engine->processors[IDX_KMD_DSP2] = &dsp2_interface;
+	engine->processors[IDX_KMD_DSP3] = &dsp3_interface;
+	engine->processors[IDX_EVENT_SINK] = &event_sink_interface;
+	engine->processors[IDX_EVENT_SOURCE] = &event_source_interface;
+#if (NPU_DEV_SIM == NPU_MCU_ALONE)
+	engine->work_queue = alloc_ordered_workqueue("dump_file", 0);
+	for (i = 0; i < NUM_TIKTOK; i++) {
+		engine->dump_file_work[i].tiktok = i;
+		INIT_WORK(&engine->dump_file_work[i].work, dump_data_to_file);
+	}
+#elif (NPU_DEV_SIM == NPU_REAL_ENV)
+	engine->dump_op_work_queue =
+		alloc_ordered_workqueue("dump_op_to_file", 0);
+	for (i = 0; i < NUM_OP_TYPE; i++) {
+		INIT_WORK(&engine->dump_op_work[i].work, dump_data_to_file);
+	}
+#endif
+
+	INIT_WORK(&engine->frame_done_work, frame_done_handler);
+	INIT_LIST_HEAD(&engine->sched_frame_list);
+	sema_init(&engine->runtime_sem, 1);
+	spin_lock_init(&engine->executor_lock);
+	atomic_set(&engine->is_sending, 0);
+	mutex_init(&engine->reset_mutex);
+
+	engine->engine_is_alive = true;
+	*arg_engine = (void *)engine;
+	INIT_WORK(&engine->complete_work, npu_task_complete_work);
+	spin_lock_init(&engine->complete_lock);
+	INIT_LIST_HEAD(&engine->frame_complete_list);
+	timer_setup(&engine->timer[0], npu_frame_timeout_tik, 0);
+	timer_setup(&engine->timer[1], npu_frame_timeout_tok, 0);
+
+	engine->is_event_source_done[0] =
+		(u8 *)kzalloc((COMPLETE_EVENT_ID / 8) * NUM_TIKTOK, GFP_KERNEL);
+	engine->is_event_source_done[1] =
+		engine->is_event_source_done[0] + (COMPLETE_EVENT_ID / 8);
+	if (engine->is_event_source_done[0] == NULL) {
+		kfree(engine);
+		return -ENOMEM;
+	}
+
+	ret = npu_get_dsp_dev(engine);
+	if (ret) {
+		dla_error("%s, %d, get dsp device err, ret=%d.\n", __func__,
+			  __LINE__, ret);
+		kfree(engine->is_event_source_done[0]);
+		kfree(engine);
+		return -ENOMEM;
+	}
+#if NPU_PERF_STATS > 1
+	engine->perf_data_buf =
+		kzalloc(sizeof(npu_e31_perf_t) * MAX_OP_NUM, GFP_KERNEL);
+	if (engine->perf_data_buf == NULL) {
+		kfree(engine->is_event_source_done[0]);
+		kfree(engine);
+		return -ENOMEM;
+	}
+#endif
+	ret = npu_init_ipc(nvdla_dev);
+#if (NPU_DEV_SIM == NPU_REAL_ENV)
+	if (ret) {
+		destroy_workqueue(engine->dump_op_work_queue);
+		kfree(engine);
+		return -ENOMEM;
+	}
+	for (i = 0; i < NUM_MAJOR_CORES; i++) {
+		engine->major_shm[i] =
+			ioremap(E31_MAJOR_DTIM_BASE(i), E31_MAJOR_DTIM_SIZE);
+		if (engine->major_shm[i] == NULL) {
+			ret = -EIO;
+			goto err_ioremap;
+		}
+		engine->major_mem[i] = kzalloc(E31_MAJOR_DTIM_SIZE, GFP_KERNEL);
+		if (engine->major_mem[i] == NULL) {
+			ret = -ENOMEM;
+			goto err_ioremap;
+		}
+	}
+	engine->aux_mem = kzalloc(E31_PROGRAM_DTIM_SIZE * 2, GFP_KERNEL);
+	if (!engine->aux_mem) {
+		ret = -ENOMEM;
+		goto err_aux_mem;
+	}
+	engine->master_mem = engine->aux_mem + E31_EMISSION_DTIM_SIZE;
+
+	engine->master_shm = nvdla_dev->emission_base;
+	engine->aux_shm = nvdla_dev->program_base;
+
+#else
+	if (ret) {
+#if (NPU_DEV_SIM == NPU_MCU_ALONE)
+		destroy_workqueue(engine->work_queue);
+#endif
+		kfree(engine);
+		return -ENOMEM;
+	}
+#endif
+
+	return 0;
+#if (NPU_DEV_SIM == NPU_REAL_ENV)
+err_aux_mem:
+err_ioremap:
+	for (i = 0; i < NUM_MAJOR_CORES; i++) {
+		if (engine->major_shm[i] != NULL) {
+			iounmap(engine->major_shm[i]);
+			engine->major_shm[i] = NULL;
+		}
+		if (engine->major_mem[i] != NULL) {
+			kfree(engine->major_mem[i]);
+			engine->major_mem[i] = NULL;
+		}
+	}
+	if (engine->aux_mem) {
+		kfree(engine->aux_mem);
+		engine->master_mem = NULL;
+		engine->aux_mem = NULL;
+	}
+	if (!engine->host_node) {
+		npu_uninit_ipc(nvdla_dev);
+		engine->host_node = NULL;
+	}
+	destroy_workqueue(engine->dump_op_work_queue);
+	kfree(engine);
+	return ret;
+#endif
+}
+
+void win_engine_destroy(struct nvdla_device *nvdla_dev)
+{
+	struct win_engine *engine = (struct win_engine *)nvdla_dev->win_engine;
+#if (NPU_DEV_SIM == NPU_REAL_ENV)
+	int i;
+#endif
+
+	if (engine) {
+		npu_put_dsp_dev(engine);
+#if (NPU_DEV_SIM == NPU_MCU_ALONE)
+		flush_workqueue(engine->work_queue);
+		destroy_workqueue(engine->work_queue);
+#elif (NPU_DEV_SIM == NPU_REAL_ENV)
+		flush_workqueue(engine->dump_op_work_queue);
+		destroy_workqueue(engine->dump_op_work_queue);
+		for (i = 0; i < NUM_MAJOR_CORES; i++) {
+			if (engine->major_shm[i] != NULL) {
+				iounmap(engine->major_shm[i]);
+				engine->major_shm[i] = NULL;
+			}
+			if (engine->major_mem[i] != NULL) {
+				kfree(engine->major_mem[i]);
+				engine->major_mem[i] = NULL;
+			}
+		}
+#endif
+		flush_work(&engine->frame_done_work);
+		npu_uninit_ipc(nvdla_dev);
+
+		if (engine->is_event_source_done[0] != NULL) {
+			kfree(engine->is_event_source_done[0]);
+			engine->is_event_source_done[0] = NULL;
+		}
+		if (engine->perf_data_buf != NULL) {
+			kfree(engine->perf_data_buf);
+			engine->perf_data_buf = NULL;
+		}
+		kfree(engine);
+		engine = NULL;
+	}
+	return;
+}
+
+static void free_executor_tensor_data(struct win_executor *executor)
+{
+	int i;
+
+	for (i = IDX_START; i < NUM_OP_TYPE; i++) {
+		if (executor->prog_data_buf_bobj[i] != NULL) {
+			npu_free_dma_addr(executor, i);
+			executor->prog_data_buf_bobj[i] = NULL;
+			executor->prog_data_size[i] = 0;
+		}
+		if (executor->tensor_set[i] != NULL) {
+			kfree(executor->tensor_set[i]);
+			executor->tensor_set[i] = NULL;
+		}
+	}
+}
+
+#define alloc_op_tensor_set(op)                                              \
+	({                                                                   \
+		if (cnt[i] < 1) {                                            \
+			continue;                                            \
+		}                                                            \
+		executor->tensor_set[i] =                                    \
+			kzalloc(cnt[i] * sizeof(op##_tensor_t), GFP_KERNEL); \
+		size[i] = cnt[i] * sizeof(op##_dev_t);                       \
+		if (executor->tensor_set[i] == NULL) {                       \
+			size[i] = 0;                                         \
+			dla_error("%s %d no mem\n", __func__, __LINE__);     \
+			ret = -ENOMEM;                                       \
+			goto err_tensor;                                     \
+		}                                                            \
+	})
+
+static int pre_setup_op_tensor(void *pexecutor, struct dla_task *task,
+			       u16 input_num, u16 output_num, u16 op_num)
+{
+	int ret = 0, i, cnt[NUM_OP_TYPE];
+	u8 pcer;
+	struct win_executor *executor = pexecutor;
+	u32 size[NUM_OP_TYPE];
+
+	if (input_num > 0) {
+		executor->input_num = input_num;
+	} else {
+		dla_error("%s %d no input\n", __func__, __LINE__);
+		return -EINVAL;
+	}
+	if (output_num > 0) {
+		executor->output_num = output_num;
+	} else {
+		dla_error("%s %d no output\n", __func__, __LINE__);
+		ret = -EINVAL;
+		return ret;
+	}
+	executor->io_mem_handle_size =
+		(executor->input_num + executor->output_num) *
+		sizeof(addrDesc_t);
+	executor->frame_size =
+		sizeof(struct host_frame_desc) + executor->io_mem_handle_size +
+		(executor->input_num + executor->output_num) * sizeof(u64);
+	memset(cnt, 0, sizeof(cnt));
+	memset(size, 0, sizeof(size));
+
+	for (i = 0; i < op_num; i++) {
+		dla_detail("i=%d, op_type=%d.\n", i,
+			   task->common_desc[i].op_type);
+		pcer = processor_dla_convert[task->common_desc[i].op_type];
+		//the same processor have how many op.
+		cnt[pcer]++;
+	}
+
+	for (i = IDX_START; i < NUM_OP_TYPE; i++) {
+		dla_info("%s, %d, i=%d, cnt=%d.\n", __func__, __LINE__, i,
+			 cnt[i]);
+	}
+
+	for (i = IDX_START; i < NUM_OP_TYPE; i++) {
+		switch (i) {
+		case IDX_EDMA:
+			alloc_op_tensor_set(edma);
+			break;
+		case IDX_CONV:
+			alloc_op_tensor_set(conv);
+			break;
+		case IDX_SDP:
+			alloc_op_tensor_set(sdp);
+			break;
+		case IDX_PDP:
+			alloc_op_tensor_set(pdp);
+			break;
+		case IDX_RUBIK:
+			alloc_op_tensor_set(rubik);
+			break;
+		case IDX_KMD_DSP0:
+		case IDX_KMD_DSP1:
+		case IDX_KMD_DSP2:
+		case IDX_KMD_DSP3:
+			alloc_op_tensor_set(dsp);
+			break;
+		case IDX_EVENT_SINK:
+			alloc_op_tensor_set(event_sink);
+			break;
+		case IDX_EVENT_SOURCE:
+			alloc_op_tensor_set(event_source);
+			break;
+		default:
+			ret = -EINVAL;
+			dla_info("invalid idx, i = %d.\n", i);
+		}
+	}
+
+	if (ret) {
+		goto err_tensor;
+	}
+
+	// alloc dma memory.
+	for (i = IDX_START; i < NUM_OP_TYPE; i++) {
+		if (size[i] <= 0) {
+			continue;
+		}
+		if (i == IDX_CONV) {
+			size[i] = cnt[i] * MAX_CONV_PROG_DATA_SIZE;
+			dla_debug("single MAX_CONV_PROG_SIZE=%u.\n",
+				  MAX_CONV_PROG_SIZE);
+		}
+
+		executor->prog_data_size[i] = size[i];
+		executor->prog_data_buf_bobj[i] = npu_alloc_dma_addr(
+			executor, size[i], &executor->dma_addr[i], i,
+			GFP_KERNEL);
+
+		if (executor->prog_data_buf_bobj[i] == NULL) {
+			dla_error("%s, %d, i=%d.\n", __func__, __LINE__, i);
+			ret = -ENOMEM;
+			goto dma_err;
+		}
+	}
+	return 0;
+
+dma_err:
+err_tensor:
+	free_executor_tensor_data(executor);
+	dla_debug("%s, %d.\n", __func__, __LINE__);
+	return ret;
+}
+
+static int extract_input_output_address(struct win_executor *executor)
+{
+	int i, input_num = 0, output_num = 0;
+	addrDesc_t *address = executor->mem_handles->addrlist->addrDesc;
+
+	dla_debug("num_addresses=%d\n",
+		  executor->mem_handles->addrlist->numAddress);
+	for (i = 0; i < executor->mem_handles->addrlist->numAddress; i++) {
+		if (address[i].flag == mem_flag_input) {
+			dla_debug("i=%d,input\n", i);
+			input_num++;
+		}
+		if (address[i].flag == mem_flag_output) {
+			dla_debug("i=%d,output\n", i);
+			output_num++;
+		}
+	}
+
+	return pre_setup_op_tensor(executor, executor->task, input_num,
+				   output_num,
+				   executor->network->num_operations);
+}
+
+int create_executor(struct dla_task *task, struct dla_network_desc *network,
+		    void **m_executor, struct nvdla_task *mem_handles,
+		    void *engine, void *dev, struct user_model *model)
+{
+	struct win_executor *executor;
+	int ret, i;
+
+	executor = kzalloc(sizeof(struct win_executor), GFP_KERNEL);
+	if (executor == NULL) {
+		dla_error("%s %d no mem\n", __func__, __LINE__);
+		return -ENOMEM;
+	}
+
+	dla_debug("executor=0x%px executor_size=%ld\n", executor,
+		  sizeof(struct win_executor));
+
+	executor->dependency_count =
+		kzalloc(network->num_operations, GFP_KERNEL);
+	if (executor->dependency_count == NULL) {
+		dla_error("%s %d no mem\n", __func__, __LINE__);
+		ret = -ENOMEM;
+		goto err_free0;
+	}
+
+	executor->dump_info.op_idx_list =
+		kzalloc(MAX_OP_NUM * sizeof(u16), GFP_KERNEL);
+	if (executor->dump_info.op_idx_list == NULL) {
+		dla_error("%s %d no mem\n", __func__, __LINE__);
+		ret = -ENOMEM;
+		goto err_free1;
+	}
+
+	executor->task = task;
+	for (i = 0; i < network->num_operations; i++) {
+		executor->dependency_count[i] =
+			task->common_desc[i].dependency_count;
+		dla_debug("%s,%d, i=%d, cnt=%d.\n", __func__, __LINE__, i,
+			  executor->dependency_count[i]);
+	}
+
+	executor->network = network;
+	executor->mem_handles = mem_handles;
+	mem_handles->executor = executor;
+	executor->engine = (struct win_engine *)engine;
+	executor->model = model;
+	executor->driver_context = dev;
+	memcpy(executor->dsp_fd, model->model_shm->dspFd,
+	       sizeof(s32) * DSP_MAX_CORE_NUM);
+
+	ret = extract_input_output_address(executor);
+	if (ret < 0) {
+		dla_error("Failed to extract input output\n");
+		goto err_free2;
+	}
+	ret = resolve_dsp_data(executor);
+	if (ret < 0) {
+		dla_error("Failed to resolve dsp, ret = %d.\n", ret);
+		goto err_free3;
+	}
+
+	ret = generate_small_program(executor);
+	if (ret < 0) {
+		goto err_free4;
+	}
+	ret = generate_event_map(executor);
+	if (ret < 0) {
+		goto err_event;
+	}
+
+	executor->state = executor_state_live;
+
+	*m_executor = executor;
+	return 0;
+
+err_event:
+	kfree(executor->cfg_seq[IDX_START]);
+	executor->cfg_seq[IDX_START] = NULL;
+err_free4:
+	dsp_resource_destroy(executor);
+err_free3:
+	free_executor_tensor_data(executor);
+err_free2:
+	kfree(executor->dump_info.op_idx_list);
+err_free1:
+	kfree(executor->dependency_count);
+err_free0:
+	kfree(executor);
+	*m_executor = NULL;
+	return ret;
+}
+
+void executor_clearup(void *arg_executor)
+{
+	struct win_executor *executor = arg_executor;
+	int i = 0;
+
+	if (executor->dependency_count != NULL) {
+		kfree(executor->dependency_count);
+		executor->dependency_count = NULL;
+	}
+	if (executor->dump_info.op_idx_list != NULL) {
+		kfree(executor->dump_info.op_idx_list);
+		executor->dump_info.op_idx_list = NULL;
+	}
+	if (executor->cfg_seq[IDX_START]) {
+		kfree(executor->cfg_seq[IDX_START]);
+		for (i = IDX_START; i < NUM_OP_TYPE; i++) {
+			executor->cfg_seq[i] = NULL;
+		}
+	}
+	if (executor->event_sink_map != NULL) {
+		kfree(executor->event_sink_map);
+		executor->event_sink_map = NULL;
+	}
+	if (executor->event_source_map != NULL) {
+		kfree(executor->event_source_map);
+		executor->event_source_map = NULL;
+	}
+	dsp_resource_destroy(executor);
+	free_executor_tensor_data(executor);
+
+	kfree(executor);
+	dla_debug("%s, %d. done.\n", __func__, __LINE__);
+}
diff --git a/drivers/soc/eswin/ai_driver/npu/event.c b/drivers/soc/eswin/ai_driver/npu/event.c
new file mode 100644
index 000000000000..59847508c74d
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/npu/event.c
@@ -0,0 +1,104 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#include <linux/slab.h>
+#include <opendla.h>
+#include <dla_err.h>
+#include <dla_interface.h>
+#include "common.h"
+#include "dla_engine_internal.h"
+#include "internal_interface.h"
+
+int dla_event_sink_rdma_check(struct dla_processor_group *group,
+			 union dla_operation_container *op,
+			 union dla_surface_container *surface)
+{
+	return 0;
+}
+
+int event_sink_tensor_unfold(struct win_executor *executor, int op_idx,
+			union dla_operation_container *operation_desc,
+			union dla_surface_container *surface_desc, void *tensor,
+			int idx)
+{
+	event_sink_dev_t *event_sink = NULL;
+	event_sink_dev_t *event_sink_data = NULL;
+
+	event_sink =
+		(event_sink_dev_t *)executor->prog_data_buf_bobj[IDX_EVENT_SINK];
+	event_sink_data = (event_sink_dev_t *)&event_sink[idx];
+	event_sink_data->npu_info.current_op_idx = op_idx;
+
+	dla_detail("op_idx:%d idx:%d\n", op_idx, idx);
+
+	return 0;
+}
+
+int event_sink_prepare_io_tensor(struct win_executor *executor, int seq,
+			    struct host_frame_desc *f,
+			    union dla_surface_container *surface_desc)
+{
+	return 0;
+}
+
+void dla_event_sink_dump_config(struct dla_processor_group *group)
+{
+}
+
+int dla_event_sink_prepare_prog_data(struct win_executor *executor, int rdma,
+				int tensor_idx, u16 op_idx,
+				union dla_operation_container *operation_desc,
+				union dla_surface_container *surface_desc)
+{
+	return 0;
+}
+
+int dla_event_source_rdma_check(struct dla_processor_group *group,
+			 union dla_operation_container *op,
+			 union dla_surface_container *surface)
+{
+	return 0;
+}
+
+int event_source_tensor_unfold(struct win_executor *executor, int op_idx,
+			union dla_operation_container *operation_desc,
+			union dla_surface_container *surface_desc, void *tensor,
+			int idx)
+{
+	event_sink_dev_t *event_sink = NULL;
+	event_sink_dev_t *event_sink_data = NULL;
+
+	event_sink =
+		(event_sink_dev_t *)executor->prog_data_buf_bobj[IDX_EVENT_SOURCE];
+	event_sink_data = (event_sink_dev_t *)&event_sink[idx];
+	event_sink_data->npu_info.current_op_idx = op_idx;
+
+	dla_detail("op_idx:%d idx:%d\n", op_idx, idx);
+
+	return 0;
+}
+
+int event_source_prepare_io_tensor(struct win_executor *executor, int seq,
+			    struct host_frame_desc *f,
+			    union dla_surface_container *surface_desc)
+{
+	return 0;
+}
+
+void dla_event_source_dump_config(struct dla_processor_group *group)
+{
+}
+
+int dla_event_source_prepare_prog_data(struct win_executor *executor, int rdma,
+				int tensor_idx, u16 op_idx,
+				union dla_operation_container *operation_desc,
+				union dla_surface_container *surface_desc)
+{
+	return 0;
+}
+
+
diff --git a/drivers/soc/eswin/ai_driver/npu/include/dla_engine.h b/drivers/soc/eswin/ai_driver/npu/include/dla_engine.h
new file mode 100644
index 000000000000..544e216d7981
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/npu/include/dla_engine.h
@@ -0,0 +1,94 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#ifndef DLA_ENGINE_H
+#define DLA_ENGINE_H
+
+#include <linux/types.h>
+#include <linux/time.h>
+#include <dla_interface.h>
+#include <dla_sched.h>
+
+/**
+ * @ingroup Processors
+ * @name Number of groups
+ * @brief Each processor has 2 groups of registers
+ * @{
+ */
+#define DLA_NUM_GROUPS 2
+
+struct win_executor;
+struct dla_processor_group {
+	uint8_t id;
+	uint8_t rdma_id;
+	uint8_t active;
+	uint8_t events;
+	uint8_t is_rdma_needed;
+	uint8_t pending;
+	int32_t lut_index;
+	uint8_t programming;
+	uint64_t start_time;
+	struct list_head edma_programed_jobs;
+	struct win_executor *executor;
+
+	struct dla_common_op_desc *op_desc;
+	struct dla_common_op_desc *consumers[HW_OP_NUM];
+	struct dla_common_op_desc *fused_parent;
+	union dla_operation_container *operation_desc;
+	union dla_surface_container *surface_desc;
+};
+
+struct dla_processor {
+	const char *name;
+	uint8_t op_type;
+	uint8_t consumer_ptr;
+	uint8_t group_status;
+	uint8_t rdma_status;
+	uint8_t last_group;
+	uint8_t ping_pong;
+
+	struct dla_common_op_desc *tail_op;
+	struct dla_processor_group groups[DLA_NUM_GROUPS];
+
+	int32_t (*enable)(struct dla_processor_group *group);
+	void (*set_producer)(int32_t group_id, int32_t rdma_id);
+	void (*dump_config)(struct dla_processor_group *group);
+	int (*rdma_check)(struct dla_processor_group *group,
+			  union dla_operation_container *op,
+			  union dla_surface_container *surface);
+	void (*get_stat_data)(struct dla_processor *processor,
+			      struct dla_processor_group *group);
+	void (*dump_stat)(struct dla_processor *processor);
+};
+
+struct op_stats_t {
+	uint32_t op_start;
+	uint32_t op_end_comp;
+	uint32_t pg_start;
+	uint32_t pg_end;
+	uint32_t op_end_intr;
+	uint8_t op_type;
+};
+
+#define OP_TYPE_MAX 8
+#define OP_INDEX_MAX 512
+struct dla_engine {
+	struct dla_task task;
+	struct dla_network_desc network;
+	struct dla_processor processors[HW_OP_NUM];
+	uint16_t num_proc_hwl;
+	int32_t status;
+	uint32_t stat_enable;
+	void *driver_context;
+	/*
+	 * op_index used to index element.
+	 */
+	struct op_stats_t op_stats[OP_INDEX_MAX];
+	uint32_t npu_saved_time;
+	uint32_t dla_saved_time;
+};
+#endif
diff --git a/drivers/soc/eswin/ai_driver/npu/include/dla_err.h b/drivers/soc/eswin/ai_driver/npu/include/dla_err.h
new file mode 100644
index 000000000000..4b16eb549722
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/npu/include/dla_err.h
@@ -0,0 +1,50 @@
+/*
+ * Copyright (c) 2017, NVIDIA CORPORATION. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *  * Neither the name of NVIDIA CORPORATION nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+ * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __FIRMWARE_DLA_ERR_H_
+#define __FIRMWARE_DLA_ERR_H_
+
+#define ERR(code) -DLA_ERR_##code
+
+#define DLA_ERR_NONE 0
+#define DLA_ERR_INVALID_METHOD 1
+#define DLA_ERR_INVALID_TASK 2
+#define DLA_ERR_INVALID_INPUT 3
+#define DLA_ERR_INVALID_FALC_DMA 4
+#define DLA_ERR_INVALID_QUEUE 5
+#define DLA_ERR_INVALID_PREACTION 6
+#define DLA_ERR_INVALID_POSTACTION 7
+#define DLA_ERR_NO_MEM 8
+#define DLA_ERR_INVALID_DESC_VER 9
+#define DLA_ERR_INVALID_ENGINE_ID 10
+#define DLA_ERR_INVALID_REGION 11
+#define DLA_ERR_PROCESSOR_BUSY 12
+#define DLA_ERR_RETRY 13
+#define DLA_ERR_TASK_STATUS_MISMATCH 14
+
+#endif
diff --git a/drivers/soc/eswin/ai_driver/npu/include/dla_sched.h b/drivers/soc/eswin/ai_driver/npu/include/dla_sched.h
new file mode 100644
index 000000000000..71afd1064ec3
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/npu/include/dla_sched.h
@@ -0,0 +1,61 @@
+/*
+ * Copyright (c) 2017-2018, NVIDIA CORPORATION. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *  * Neither the name of NVIDIA CORPORATION nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+ * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __DLA_SCHED_H_
+#define __DLA_SCHED_H_
+
+#include <linux/dma-buf.h>
+#include <linux/dma-mapping.h>
+struct dla_task {
+	/* platform specific data to communicate with portability layer */
+	void *task_data;
+	/* task state */
+	uint32_t state;
+	/* Task base address */
+	uint64_t base;
+	struct dla_common_op_desc *common_desc;
+	union dla_surface_container *surface_desc;
+	union dla_operation_container *op_desc;
+} __attribute__((packed, aligned(256)));
+
+/**
+ * @brief			Configuration parameters supported by the engine
+ *
+ * atom_size			Memory smallest access size
+ * bdma_enable			Defines whether bdma is supported
+ * rubik_enable			Defines whether rubik is supported
+ * weight_compress_support	Defines whether weight data compression is supported
+ */
+struct dla_config {
+	uint32_t atom_size;
+	bool bdma_enable;
+	bool rubik_enable;
+	bool weight_compress_support;
+};
+
+#endif
diff --git a/drivers/soc/eswin/ai_driver/npu/include/npu_top_csr.h b/drivers/soc/eswin/ai_driver/npu/include/npu_top_csr.h
new file mode 100644
index 000000000000..13391ad7f551
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/npu/include/npu_top_csr.h
@@ -0,0 +1,51 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+/*
+ * npu_top_csr
+ */
+
+#ifndef __NPU_TOP_CSR_H_
+#define __NPU_TOP_CSR_H_
+
+// define npu top csr base addr
+#define NPU_TOP_CSR_BASE 0x198000
+
+// define offset of module
+#define E31_TASK0_PING_OFFSET 0
+#define E31_TASK1_PONG_OFFSET 1
+#define RDMA_TASK0_PING_OFFSET 2
+#define RDMA_TASK0_PONG_OFFSET 3
+#define RDMA_ERROR_OFFSET 4
+#define PEC_TASK0_PING_OFFSET 5
+#define PEC_TASK0_PONG_OFFSET 6
+#define PEC_ERROR_OFFSET 7
+#define PRE_DRP_PING_OFFSET 8
+#define PRE_DRP_PONG_OFFSET 9
+#define PRE_DRP_ERROR_OFFSET 10
+#define EDMA_INTR0_OFFSET 11
+#define EDMA_INTR1_OFFSET 12
+#define EDMA_ERROR_OFFSET 13
+#define EDMA_IRQ_MASK                                          \
+	((1 << EDMA_INTR0_OFFSET) + (1 << EDMA_INTR1_OFFSET) + \
+	 (1 << EDMA_ERROR_OFFSET))
+
+typedef enum {
+	REG_NPU_CTRL = 0x0,
+	REG_NPU_INT_STATUS = 0x10,
+	REG_NPU_INT_CLEAR = 0x14,
+	REG_NPU_INT_ENABLE = 0x18,
+	REG_NPU_QQS_0 = 0x20,
+	REG_NPU_QQS_1 = 0x24,
+	REG_NPU_QQS_2 = 0x28,
+	REG_NPU_QQS_3 = 0x2c,
+	REG_NPU_QQS_SEL = 0x30,
+	REG_NPU_MMU_RID = 0x34,
+	REG_NPU_MMU_WID = 0x38,
+} REG_NPU_TOP;
+
+#endif /* __NPU_TOP_CSR_H_ */
diff --git a/drivers/soc/eswin/ai_driver/npu/include/nvdla_interface.h b/drivers/soc/eswin/ai_driver/npu/include/nvdla_interface.h
new file mode 100644
index 000000000000..c93fa38366fd
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/npu/include/nvdla_interface.h
@@ -0,0 +1,113 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#ifndef NVDLA_INTERFACE_H
+#define NVDLA_INTERFACE_H
+
+#include <linux/types.h>
+
+/**
+ * @brief			Register driver to firmware
+ *
+ * Implementation in firmware, called by portability layer
+ *
+ * This function must be called once during boot to initialize DLA
+ * engine scheduler and register driver with firmware before submitting
+ * any task. Pass pointer to driver context in @param driver_context
+ * which is passed as param when firmware calls any function
+ * of portability layer. It also updates pointer to engine context
+ * which must be passed in any function call to firmware after this point.
+ *
+ * @param engine_context	Pointer to engine specific data
+ * @param driver_context	Pointer to driver specific data
+ *
+ * @return			0 on success and negative on error
+ */
+int32_t dla_register_driver(void **engine_context, void *driver_context);
+
+/**
+ * @brief			Read data from DMA mapped memory in local buffer
+ *
+ * Implementation in portability layer, called by firmware
+ *
+ * This function reads data from buffers passed by UMD in local memory.
+ * Addresses for buffers passed by are shared in address list and network
+ * descriptor contains index in address list for those buffers. Firmware
+ * reads this data from buffer shared by UMD into local buffer to consume
+ * the information.
+ *
+ * @param driver_context	Driver specific data received in dla_register_driver
+ * @param task_data		Task specific data received in dla_execute_task
+ * @param src			Index in address list
+ * @param dst			Pointer to local memory
+ * @param size			Size of data to copy
+ * @param offset		Offset from start of UMD buffer
+ *
+ * @return			0 on success and negative on error
+ *
+ */
+int32_t dla_data_read(void *driver_context, void *task_data, void *handle,
+		      uint16_t index, void *dst, uint32_t size,
+		      uint64_t offset);
+int32_t dla_data_get_vaddr(void *task_data, uint16_t index, void **vaddr);
+
+/**
+ * @brief			Read DMA address
+ *
+ * Implementation in portability layer, called by firmware
+ *
+ * Some buffers shared by UMD are accessed by processor responsible for
+ * programming DLA HW. It would be companion micro-controller in case of
+ * headed config while main CPU in case of headless config. Also, some
+ * buffers are accessed by DLA DMA engines inside sub-engines. This function
+ * should return proper address accessible by destination user depending
+ * on config.
+ *
+ * @param driver_context	Driver specific data received in dla_register_driver
+ * @param task_data		Task specific data received in dla_execute_task
+ * @param index			Index in address list
+ * @param dst_ptr		Pointer to update address
+ * @param destination		Destination user for DMA address
+ *
+ * @return			0 on success and negative on error
+ *
+ */
+int32_t dla_get_dma_address(void *driver_context, void *task_data,
+			    int16_t index, void *dst_ptr, u32 *is_io_tensor);
+
+/**
+ * @brief			Read time value in micro-seconds
+ *
+ * Implementation in portability layer, called by firmware
+ *
+ * Read system time in micro-seconds
+ *
+ * @return			Time value in micro-seconds
+ *
+ */
+
+int32_t dla_get_sram_address(void *driver_context, void *task_data,
+			     int16_t index, uint64_t *dst_ptr,
+			     u32 *is_io_tensor);
+
+int64_t dla_get_time_us(void);
+
+/* KMD and DSP ops register */
+struct module_public_life_cycle_interface {
+	int die_seq;
+	void *priv;
+	int (*setup)(void *p);
+	int (*release)(void *p);
+	int (*reset)(void *p);
+};
+struct module_public_interface {
+	int (*enable)(int (*done_callback)(void *group), void *group);
+	int (*program)(void *group);
+	void (*dump_config)(void *group);
+};
+
+#endif
diff --git a/drivers/soc/eswin/ai_driver/npu/include/nvdla_linux.h b/drivers/soc/eswin/ai_driver/npu/include/nvdla_linux.h
new file mode 100644
index 000000000000..b69353d66d8c
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/npu/include/nvdla_linux.h
@@ -0,0 +1,46 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#ifndef NVDLA_LINUX_H
+#define NVDLA_LINUX_H
+
+#include <linux/completion.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/spinlock.h>
+#include "dla_driver.h"
+#include "hetero_ioctl.h"
+
+/**
+ * @brief			Task information submitted from user space
+ *
+ * ref				Reference count for task
+ * num_addresses		Number of addresses in address list
+ * nvdla_dev			Pointer to NVDLA device
+ * address_list			Address list
+ * file				DRM file instance
+ */
+struct nvdla_task {
+	addrListDesc_t *addrlist;
+	struct dla_buffer_object *bobjs;
+	void *executor;
+};
+
+/**
+ * @brief			Submit task
+ *
+ * This function submits task to NVDLA engine.
+ *
+ * @param nvdla_dev		Pointer to NVDLA device
+ * @param task			Pointer to task
+ * @return			0 on success and negative on error
+ *
+ */
+int32_t nvdla_task_submit(struct nvdla_device *nvdla_dev,
+			  struct nvdla_task *task);
+
+#endif
diff --git a/drivers/soc/eswin/ai_driver/npu/include/opendla.h b/drivers/soc/eswin/ai_driver/npu/include/opendla.h
new file mode 100644
index 000000000000..e58e29aa2321
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/npu/include/opendla.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright (c) 2018, NVIDIA CORPORATION. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *  * Neither the name of NVIDIA CORPORATION nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+ * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __OPENDLA_H_
+#define __OPENDLA_H_
+
+// #define DLA_2_CONFIG
+
+#ifdef DLA_2_CONFIG
+#include <opendla_small.h>
+#else
+#include <opendla_initial.h>
+#endif
+
+#endif
diff --git a/drivers/soc/eswin/ai_driver/npu/include/opendla_initial.h b/drivers/soc/eswin/ai_driver/npu/include/opendla_initial.h
new file mode 100644
index 000000000000..aa2b5d7702b9
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/npu/include/opendla_initial.h
@@ -0,0 +1,15426 @@
+/*
+ * Copyright (c) 2017, NVIDIA CORPORATION. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *  * Neither the name of NVIDIA CORPORATION nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+ * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __ARNVDLA_H_
+#define __ARNVDLA_H_
+
+#define OFFSET_ADDRESS_NPU_NVDLA 0x150000
+
+// Register GLB_S_NVDLA_HW_VERSION_0
+#define GLB_S_NVDLA_HW_VERSION_0 (_MK_ADDR_CONST(0x0))
+#define GLB_S_NVDLA_HW_VERSION_0_SECURE (0x0)
+#define GLB_S_NVDLA_HW_VERSION_0_DUAL (0x0)
+#define GLB_S_NVDLA_HW_VERSION_0_SCR (0)
+#define GLB_S_NVDLA_HW_VERSION_0_WORD_COUNT (0x1)
+#define GLB_S_NVDLA_HW_VERSION_0_RESET_VAL (_MK_MASK_CONST(0x303031))
+#define GLB_S_NVDLA_HW_VERSION_0_RESET_MASK (_MK_MASK_CONST(0xffffff))
+#define GLB_S_NVDLA_HW_VERSION_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define GLB_S_NVDLA_HW_VERSION_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define GLB_S_NVDLA_HW_VERSION_0_READ_MASK (_MK_MASK_CONST(0xffffff))
+#define GLB_S_NVDLA_HW_VERSION_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define GLB_S_NVDLA_HW_VERSION_0_MAJOR_SHIFT (_MK_SHIFT_CONST(0))
+#define GLB_S_NVDLA_HW_VERSION_0_MAJOR_FIELD \
+	(_MK_FIELD_CONST(0xff, GLB_S_NVDLA_HW_VERSION_0_MAJOR_SHIFT))
+#define GLB_S_NVDLA_HW_VERSION_0_MAJOR_RANGE (7 : 0)
+#define GLB_S_NVDLA_HW_VERSION_0_MAJOR_WOFFSET (0x0)
+#define GLB_S_NVDLA_HW_VERSION_0_MAJOR_DEFAULT (_MK_MASK_CONST(0x31))
+#define GLB_S_NVDLA_HW_VERSION_0_MAJOR_DEFAULT_MASK (_MK_MASK_CONST(0xff))
+#define GLB_S_NVDLA_HW_VERSION_0_MAJOR_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_NVDLA_HW_VERSION_0_MAJOR_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define GLB_S_NVDLA_HW_VERSION_0_MAJOR_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define GLB_S_NVDLA_HW_VERSION_0_MAJOR_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+#define GLB_S_NVDLA_HW_VERSION_0_MINOR_SHIFT (_MK_SHIFT_CONST(8))
+#define GLB_S_NVDLA_HW_VERSION_0_MINOR_FIELD \
+	(_MK_FIELD_CONST(0xffff, GLB_S_NVDLA_HW_VERSION_0_MINOR_SHIFT))
+#define GLB_S_NVDLA_HW_VERSION_0_MINOR_RANGE (23 : 8)
+#define GLB_S_NVDLA_HW_VERSION_0_MINOR_WOFFSET (0x0)
+#define GLB_S_NVDLA_HW_VERSION_0_MINOR_DEFAULT (_MK_MASK_CONST(0x3030))
+#define GLB_S_NVDLA_HW_VERSION_0_MINOR_DEFAULT_MASK (_MK_MASK_CONST(0xffff))
+#define GLB_S_NVDLA_HW_VERSION_0_MINOR_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_NVDLA_HW_VERSION_0_MINOR_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define GLB_S_NVDLA_HW_VERSION_0_MINOR_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define GLB_S_NVDLA_HW_VERSION_0_MINOR_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+// Register GLB_S_INTR_MASK_0
+#define GLB_S_INTR_MASK_0 (_MK_ADDR_CONST(0x4))
+#define GLB_S_INTR_MASK_0_SECURE (0x0)
+#define GLB_S_INTR_MASK_0_DUAL (0x0)
+#define GLB_S_INTR_MASK_0_SCR (0)
+#define GLB_S_INTR_MASK_0_WORD_COUNT (0x1)
+#define GLB_S_INTR_MASK_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_RESET_MASK (_MK_MASK_CONST(0x3f03ff))
+#define GLB_S_INTR_MASK_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_READ_MASK (_MK_MASK_CONST(0x3f03ff))
+#define GLB_S_INTR_MASK_0_WRITE_MASK (_MK_MASK_CONST(0x3f03ff))
+#define GLB_S_INTR_MASK_0_SDP_DONE_MASK0_SHIFT (_MK_SHIFT_CONST(0))
+#define GLB_S_INTR_MASK_0_SDP_DONE_MASK0_FIELD \
+	(_MK_FIELD_CONST(0x1, GLB_S_INTR_MASK_0_SDP_DONE_MASK0_SHIFT))
+#define GLB_S_INTR_MASK_0_SDP_DONE_MASK0_RANGE (0 : 0)
+#define GLB_S_INTR_MASK_0_SDP_DONE_MASK0_WOFFSET (0x0)
+#define GLB_S_INTR_MASK_0_SDP_DONE_MASK0_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_SDP_DONE_MASK0_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define GLB_S_INTR_MASK_0_SDP_DONE_MASK0_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_SDP_DONE_MASK0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_SDP_DONE_MASK0_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_SDP_DONE_MASK0_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define GLB_S_INTR_MASK_0_SDP_DONE_MASK1_SHIFT (_MK_SHIFT_CONST(1))
+#define GLB_S_INTR_MASK_0_SDP_DONE_MASK1_FIELD \
+	(_MK_FIELD_CONST(0x1, GLB_S_INTR_MASK_0_SDP_DONE_MASK1_SHIFT))
+#define GLB_S_INTR_MASK_0_SDP_DONE_MASK1_RANGE (1 : 1)
+#define GLB_S_INTR_MASK_0_SDP_DONE_MASK1_WOFFSET (0x0)
+#define GLB_S_INTR_MASK_0_SDP_DONE_MASK1_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_SDP_DONE_MASK1_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define GLB_S_INTR_MASK_0_SDP_DONE_MASK1_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_SDP_DONE_MASK1_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_SDP_DONE_MASK1_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_SDP_DONE_MASK1_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define GLB_S_INTR_MASK_0_CDP_DONE_MASK0_SHIFT (_MK_SHIFT_CONST(2))
+#define GLB_S_INTR_MASK_0_CDP_DONE_MASK0_FIELD \
+	(_MK_FIELD_CONST(0x1, GLB_S_INTR_MASK_0_CDP_DONE_MASK0_SHIFT))
+#define GLB_S_INTR_MASK_0_CDP_DONE_MASK0_RANGE (2 : 2)
+#define GLB_S_INTR_MASK_0_CDP_DONE_MASK0_WOFFSET (0x0)
+#define GLB_S_INTR_MASK_0_CDP_DONE_MASK0_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_CDP_DONE_MASK0_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define GLB_S_INTR_MASK_0_CDP_DONE_MASK0_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_CDP_DONE_MASK0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_CDP_DONE_MASK0_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_CDP_DONE_MASK0_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define GLB_S_INTR_MASK_0_CDP_DONE_MASK1_SHIFT (_MK_SHIFT_CONST(3))
+#define GLB_S_INTR_MASK_0_CDP_DONE_MASK1_FIELD \
+	(_MK_FIELD_CONST(0x1, GLB_S_INTR_MASK_0_CDP_DONE_MASK1_SHIFT))
+#define GLB_S_INTR_MASK_0_CDP_DONE_MASK1_RANGE (3 : 3)
+#define GLB_S_INTR_MASK_0_CDP_DONE_MASK1_WOFFSET (0x0)
+#define GLB_S_INTR_MASK_0_CDP_DONE_MASK1_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_CDP_DONE_MASK1_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define GLB_S_INTR_MASK_0_CDP_DONE_MASK1_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_CDP_DONE_MASK1_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_CDP_DONE_MASK1_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_CDP_DONE_MASK1_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define GLB_S_INTR_MASK_0_PDP_DONE_MASK0_SHIFT (_MK_SHIFT_CONST(4))
+#define GLB_S_INTR_MASK_0_PDP_DONE_MASK0_FIELD \
+	(_MK_FIELD_CONST(0x1, GLB_S_INTR_MASK_0_PDP_DONE_MASK0_SHIFT))
+#define GLB_S_INTR_MASK_0_PDP_DONE_MASK0_RANGE (4 : 4)
+#define GLB_S_INTR_MASK_0_PDP_DONE_MASK0_WOFFSET (0x0)
+#define GLB_S_INTR_MASK_0_PDP_DONE_MASK0_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_PDP_DONE_MASK0_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define GLB_S_INTR_MASK_0_PDP_DONE_MASK0_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_PDP_DONE_MASK0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_PDP_DONE_MASK0_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_PDP_DONE_MASK0_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define GLB_S_INTR_MASK_0_PDP_DONE_MASK1_SHIFT (_MK_SHIFT_CONST(5))
+#define GLB_S_INTR_MASK_0_PDP_DONE_MASK1_FIELD \
+	(_MK_FIELD_CONST(0x1, GLB_S_INTR_MASK_0_PDP_DONE_MASK1_SHIFT))
+#define GLB_S_INTR_MASK_0_PDP_DONE_MASK1_RANGE (5 : 5)
+#define GLB_S_INTR_MASK_0_PDP_DONE_MASK1_WOFFSET (0x0)
+#define GLB_S_INTR_MASK_0_PDP_DONE_MASK1_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_PDP_DONE_MASK1_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define GLB_S_INTR_MASK_0_PDP_DONE_MASK1_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_PDP_DONE_MASK1_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_PDP_DONE_MASK1_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_PDP_DONE_MASK1_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define GLB_S_INTR_MASK_0_BDMA_DONE_MASK0_SHIFT (_MK_SHIFT_CONST(6))
+#define GLB_S_INTR_MASK_0_BDMA_DONE_MASK0_FIELD \
+	(_MK_FIELD_CONST(0x1, GLB_S_INTR_MASK_0_BDMA_DONE_MASK0_SHIFT))
+#define GLB_S_INTR_MASK_0_BDMA_DONE_MASK0_RANGE (6 : 6)
+#define GLB_S_INTR_MASK_0_BDMA_DONE_MASK0_WOFFSET (0x0)
+#define GLB_S_INTR_MASK_0_BDMA_DONE_MASK0_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_BDMA_DONE_MASK0_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define GLB_S_INTR_MASK_0_BDMA_DONE_MASK0_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_BDMA_DONE_MASK0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_BDMA_DONE_MASK0_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_BDMA_DONE_MASK0_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define GLB_S_INTR_MASK_0_BDMA_DONE_MASK1_SHIFT (_MK_SHIFT_CONST(7))
+#define GLB_S_INTR_MASK_0_BDMA_DONE_MASK1_FIELD \
+	(_MK_FIELD_CONST(0x1, GLB_S_INTR_MASK_0_BDMA_DONE_MASK1_SHIFT))
+#define GLB_S_INTR_MASK_0_BDMA_DONE_MASK1_RANGE (7 : 7)
+#define GLB_S_INTR_MASK_0_BDMA_DONE_MASK1_WOFFSET (0x0)
+#define GLB_S_INTR_MASK_0_BDMA_DONE_MASK1_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_BDMA_DONE_MASK1_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define GLB_S_INTR_MASK_0_BDMA_DONE_MASK1_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_BDMA_DONE_MASK1_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_BDMA_DONE_MASK1_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_BDMA_DONE_MASK1_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define GLB_S_INTR_MASK_0_RUBIK_DONE_MASK0_SHIFT (_MK_SHIFT_CONST(8))
+#define GLB_S_INTR_MASK_0_RUBIK_DONE_MASK0_FIELD \
+	(_MK_FIELD_CONST(0x1, GLB_S_INTR_MASK_0_RUBIK_DONE_MASK0_SHIFT))
+#define GLB_S_INTR_MASK_0_RUBIK_DONE_MASK0_RANGE (8 : 8)
+#define GLB_S_INTR_MASK_0_RUBIK_DONE_MASK0_WOFFSET (0x0)
+#define GLB_S_INTR_MASK_0_RUBIK_DONE_MASK0_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_RUBIK_DONE_MASK0_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define GLB_S_INTR_MASK_0_RUBIK_DONE_MASK0_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_RUBIK_DONE_MASK0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_RUBIK_DONE_MASK0_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_RUBIK_DONE_MASK0_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define GLB_S_INTR_MASK_0_RUBIK_DONE_MASK1_SHIFT (_MK_SHIFT_CONST(9))
+#define GLB_S_INTR_MASK_0_RUBIK_DONE_MASK1_FIELD \
+	(_MK_FIELD_CONST(0x1, GLB_S_INTR_MASK_0_RUBIK_DONE_MASK1_SHIFT))
+#define GLB_S_INTR_MASK_0_RUBIK_DONE_MASK1_RANGE (9 : 9)
+#define GLB_S_INTR_MASK_0_RUBIK_DONE_MASK1_WOFFSET (0x0)
+#define GLB_S_INTR_MASK_0_RUBIK_DONE_MASK1_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_RUBIK_DONE_MASK1_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define GLB_S_INTR_MASK_0_RUBIK_DONE_MASK1_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_RUBIK_DONE_MASK1_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_RUBIK_DONE_MASK1_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_RUBIK_DONE_MASK1_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define GLB_S_INTR_MASK_0_CDMA_DAT_DONE_MASK0_SHIFT (_MK_SHIFT_CONST(16))
+#define GLB_S_INTR_MASK_0_CDMA_DAT_DONE_MASK0_FIELD \
+	(_MK_FIELD_CONST(0x1, GLB_S_INTR_MASK_0_CDMA_DAT_DONE_MASK0_SHIFT))
+#define GLB_S_INTR_MASK_0_CDMA_DAT_DONE_MASK0_RANGE (16 : 16)
+#define GLB_S_INTR_MASK_0_CDMA_DAT_DONE_MASK0_WOFFSET (0x0)
+#define GLB_S_INTR_MASK_0_CDMA_DAT_DONE_MASK0_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_CDMA_DAT_DONE_MASK0_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define GLB_S_INTR_MASK_0_CDMA_DAT_DONE_MASK0_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_CDMA_DAT_DONE_MASK0_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_CDMA_DAT_DONE_MASK0_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_CDMA_DAT_DONE_MASK0_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define GLB_S_INTR_MASK_0_CDMA_DAT_DONE_MASK1_SHIFT (_MK_SHIFT_CONST(17))
+#define GLB_S_INTR_MASK_0_CDMA_DAT_DONE_MASK1_FIELD \
+	(_MK_FIELD_CONST(0x1, GLB_S_INTR_MASK_0_CDMA_DAT_DONE_MASK1_SHIFT))
+#define GLB_S_INTR_MASK_0_CDMA_DAT_DONE_MASK1_RANGE (17 : 17)
+#define GLB_S_INTR_MASK_0_CDMA_DAT_DONE_MASK1_WOFFSET (0x0)
+#define GLB_S_INTR_MASK_0_CDMA_DAT_DONE_MASK1_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_CDMA_DAT_DONE_MASK1_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define GLB_S_INTR_MASK_0_CDMA_DAT_DONE_MASK1_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_CDMA_DAT_DONE_MASK1_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_CDMA_DAT_DONE_MASK1_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_CDMA_DAT_DONE_MASK1_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define GLB_S_INTR_MASK_0_CDMA_WT_DONE_MASK0_SHIFT (_MK_SHIFT_CONST(18))
+#define GLB_S_INTR_MASK_0_CDMA_WT_DONE_MASK0_FIELD \
+	(_MK_FIELD_CONST(0x1, GLB_S_INTR_MASK_0_CDMA_WT_DONE_MASK0_SHIFT))
+#define GLB_S_INTR_MASK_0_CDMA_WT_DONE_MASK0_RANGE (18 : 18)
+#define GLB_S_INTR_MASK_0_CDMA_WT_DONE_MASK0_WOFFSET (0x0)
+#define GLB_S_INTR_MASK_0_CDMA_WT_DONE_MASK0_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_CDMA_WT_DONE_MASK0_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define GLB_S_INTR_MASK_0_CDMA_WT_DONE_MASK0_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_CDMA_WT_DONE_MASK0_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_CDMA_WT_DONE_MASK0_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_CDMA_WT_DONE_MASK0_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define GLB_S_INTR_MASK_0_CDMA_WT_DONE_MASK1_SHIFT (_MK_SHIFT_CONST(19))
+#define GLB_S_INTR_MASK_0_CDMA_WT_DONE_MASK1_FIELD \
+	(_MK_FIELD_CONST(0x1, GLB_S_INTR_MASK_0_CDMA_WT_DONE_MASK1_SHIFT))
+#define GLB_S_INTR_MASK_0_CDMA_WT_DONE_MASK1_RANGE (19 : 19)
+#define GLB_S_INTR_MASK_0_CDMA_WT_DONE_MASK1_WOFFSET (0x0)
+#define GLB_S_INTR_MASK_0_CDMA_WT_DONE_MASK1_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_CDMA_WT_DONE_MASK1_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define GLB_S_INTR_MASK_0_CDMA_WT_DONE_MASK1_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_CDMA_WT_DONE_MASK1_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_CDMA_WT_DONE_MASK1_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_CDMA_WT_DONE_MASK1_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define GLB_S_INTR_MASK_0_CACC_DONE_MASK0_SHIFT (_MK_SHIFT_CONST(20))
+#define GLB_S_INTR_MASK_0_CACC_DONE_MASK0_FIELD \
+	(_MK_FIELD_CONST(0x1, GLB_S_INTR_MASK_0_CACC_DONE_MASK0_SHIFT))
+#define GLB_S_INTR_MASK_0_CACC_DONE_MASK0_RANGE (20 : 20)
+#define GLB_S_INTR_MASK_0_CACC_DONE_MASK0_WOFFSET (0x0)
+#define GLB_S_INTR_MASK_0_CACC_DONE_MASK0_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_CACC_DONE_MASK0_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define GLB_S_INTR_MASK_0_CACC_DONE_MASK0_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_CACC_DONE_MASK0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_CACC_DONE_MASK0_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_CACC_DONE_MASK0_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define GLB_S_INTR_MASK_0_CACC_DONE_MASK1_SHIFT (_MK_SHIFT_CONST(21))
+#define GLB_S_INTR_MASK_0_CACC_DONE_MASK1_FIELD \
+	(_MK_FIELD_CONST(0x1, GLB_S_INTR_MASK_0_CACC_DONE_MASK1_SHIFT))
+#define GLB_S_INTR_MASK_0_CACC_DONE_MASK1_RANGE (21 : 21)
+#define GLB_S_INTR_MASK_0_CACC_DONE_MASK1_WOFFSET (0x0)
+#define GLB_S_INTR_MASK_0_CACC_DONE_MASK1_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_CACC_DONE_MASK1_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define GLB_S_INTR_MASK_0_CACC_DONE_MASK1_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_CACC_DONE_MASK1_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_CACC_DONE_MASK1_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_MASK_0_CACC_DONE_MASK1_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register GLB_S_INTR_SET_0
+#define GLB_S_INTR_SET_0 (_MK_ADDR_CONST(0x8))
+#define GLB_S_INTR_SET_0_SECURE (0x0)
+#define GLB_S_INTR_SET_0_DUAL (0x0)
+#define GLB_S_INTR_SET_0_SCR (0)
+#define GLB_S_INTR_SET_0_WORD_COUNT (0x1)
+#define GLB_S_INTR_SET_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_RESET_MASK (_MK_MASK_CONST(0x3f03ff))
+#define GLB_S_INTR_SET_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_READ_MASK (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_WRITE_MASK (_MK_MASK_CONST(0x3f03ff))
+#define GLB_S_INTR_SET_0_SDP_DONE_SET0_SHIFT (_MK_SHIFT_CONST(0))
+#define GLB_S_INTR_SET_0_SDP_DONE_SET0_FIELD \
+	(_MK_FIELD_CONST(0x1, GLB_S_INTR_SET_0_SDP_DONE_SET0_SHIFT))
+#define GLB_S_INTR_SET_0_SDP_DONE_SET0_RANGE (0 : 0)
+#define GLB_S_INTR_SET_0_SDP_DONE_SET0_WOFFSET (0x0)
+#define GLB_S_INTR_SET_0_SDP_DONE_SET0_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_SDP_DONE_SET0_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define GLB_S_INTR_SET_0_SDP_DONE_SET0_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_SDP_DONE_SET0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_SDP_DONE_SET0_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_SDP_DONE_SET0_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+#define GLB_S_INTR_SET_0_SDP_DONE_SET1_SHIFT (_MK_SHIFT_CONST(1))
+#define GLB_S_INTR_SET_0_SDP_DONE_SET1_FIELD \
+	(_MK_FIELD_CONST(0x1, GLB_S_INTR_SET_0_SDP_DONE_SET1_SHIFT))
+#define GLB_S_INTR_SET_0_SDP_DONE_SET1_RANGE (1 : 1)
+#define GLB_S_INTR_SET_0_SDP_DONE_SET1_WOFFSET (0x0)
+#define GLB_S_INTR_SET_0_SDP_DONE_SET1_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_SDP_DONE_SET1_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define GLB_S_INTR_SET_0_SDP_DONE_SET1_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_SDP_DONE_SET1_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_SDP_DONE_SET1_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_SDP_DONE_SET1_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+#define GLB_S_INTR_SET_0_CDP_DONE_SET0_SHIFT (_MK_SHIFT_CONST(2))
+#define GLB_S_INTR_SET_0_CDP_DONE_SET0_FIELD \
+	(_MK_FIELD_CONST(0x1, GLB_S_INTR_SET_0_CDP_DONE_SET0_SHIFT))
+#define GLB_S_INTR_SET_0_CDP_DONE_SET0_RANGE (2 : 2)
+#define GLB_S_INTR_SET_0_CDP_DONE_SET0_WOFFSET (0x0)
+#define GLB_S_INTR_SET_0_CDP_DONE_SET0_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_CDP_DONE_SET0_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define GLB_S_INTR_SET_0_CDP_DONE_SET0_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_CDP_DONE_SET0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_CDP_DONE_SET0_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_CDP_DONE_SET0_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+#define GLB_S_INTR_SET_0_CDP_DONE_SET1_SHIFT (_MK_SHIFT_CONST(3))
+#define GLB_S_INTR_SET_0_CDP_DONE_SET1_FIELD \
+	(_MK_FIELD_CONST(0x1, GLB_S_INTR_SET_0_CDP_DONE_SET1_SHIFT))
+#define GLB_S_INTR_SET_0_CDP_DONE_SET1_RANGE (3 : 3)
+#define GLB_S_INTR_SET_0_CDP_DONE_SET1_WOFFSET (0x0)
+#define GLB_S_INTR_SET_0_CDP_DONE_SET1_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_CDP_DONE_SET1_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define GLB_S_INTR_SET_0_CDP_DONE_SET1_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_CDP_DONE_SET1_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_CDP_DONE_SET1_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_CDP_DONE_SET1_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+#define GLB_S_INTR_SET_0_PDP_DONE_SET0_SHIFT (_MK_SHIFT_CONST(4))
+#define GLB_S_INTR_SET_0_PDP_DONE_SET0_FIELD \
+	(_MK_FIELD_CONST(0x1, GLB_S_INTR_SET_0_PDP_DONE_SET0_SHIFT))
+#define GLB_S_INTR_SET_0_PDP_DONE_SET0_RANGE (4 : 4)
+#define GLB_S_INTR_SET_0_PDP_DONE_SET0_WOFFSET (0x0)
+#define GLB_S_INTR_SET_0_PDP_DONE_SET0_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_PDP_DONE_SET0_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define GLB_S_INTR_SET_0_PDP_DONE_SET0_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_PDP_DONE_SET0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_PDP_DONE_SET0_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_PDP_DONE_SET0_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+#define GLB_S_INTR_SET_0_PDP_DONE_SET1_SHIFT (_MK_SHIFT_CONST(5))
+#define GLB_S_INTR_SET_0_PDP_DONE_SET1_FIELD \
+	(_MK_FIELD_CONST(0x1, GLB_S_INTR_SET_0_PDP_DONE_SET1_SHIFT))
+#define GLB_S_INTR_SET_0_PDP_DONE_SET1_RANGE (5 : 5)
+#define GLB_S_INTR_SET_0_PDP_DONE_SET1_WOFFSET (0x0)
+#define GLB_S_INTR_SET_0_PDP_DONE_SET1_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_PDP_DONE_SET1_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define GLB_S_INTR_SET_0_PDP_DONE_SET1_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_PDP_DONE_SET1_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_PDP_DONE_SET1_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_PDP_DONE_SET1_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+#define GLB_S_INTR_SET_0_BDMA_DONE_SET0_SHIFT (_MK_SHIFT_CONST(6))
+#define GLB_S_INTR_SET_0_BDMA_DONE_SET0_FIELD \
+	(_MK_FIELD_CONST(0x1, GLB_S_INTR_SET_0_BDMA_DONE_SET0_SHIFT))
+#define GLB_S_INTR_SET_0_BDMA_DONE_SET0_RANGE (6 : 6)
+#define GLB_S_INTR_SET_0_BDMA_DONE_SET0_WOFFSET (0x0)
+#define GLB_S_INTR_SET_0_BDMA_DONE_SET0_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_BDMA_DONE_SET0_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define GLB_S_INTR_SET_0_BDMA_DONE_SET0_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_BDMA_DONE_SET0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_BDMA_DONE_SET0_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_BDMA_DONE_SET0_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+#define GLB_S_INTR_SET_0_BDMA_DONE_SET1_SHIFT (_MK_SHIFT_CONST(7))
+#define GLB_S_INTR_SET_0_BDMA_DONE_SET1_FIELD \
+	(_MK_FIELD_CONST(0x1, GLB_S_INTR_SET_0_BDMA_DONE_SET1_SHIFT))
+#define GLB_S_INTR_SET_0_BDMA_DONE_SET1_RANGE (7 : 7)
+#define GLB_S_INTR_SET_0_BDMA_DONE_SET1_WOFFSET (0x0)
+#define GLB_S_INTR_SET_0_BDMA_DONE_SET1_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_BDMA_DONE_SET1_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define GLB_S_INTR_SET_0_BDMA_DONE_SET1_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_BDMA_DONE_SET1_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_BDMA_DONE_SET1_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_BDMA_DONE_SET1_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+#define GLB_S_INTR_SET_0_RUBIK_DONE_SET0_SHIFT (_MK_SHIFT_CONST(8))
+#define GLB_S_INTR_SET_0_RUBIK_DONE_SET0_FIELD \
+	(_MK_FIELD_CONST(0x1, GLB_S_INTR_SET_0_RUBIK_DONE_SET0_SHIFT))
+#define GLB_S_INTR_SET_0_RUBIK_DONE_SET0_RANGE (8 : 8)
+#define GLB_S_INTR_SET_0_RUBIK_DONE_SET0_WOFFSET (0x0)
+#define GLB_S_INTR_SET_0_RUBIK_DONE_SET0_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_RUBIK_DONE_SET0_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define GLB_S_INTR_SET_0_RUBIK_DONE_SET0_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_RUBIK_DONE_SET0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_RUBIK_DONE_SET0_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_RUBIK_DONE_SET0_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define GLB_S_INTR_SET_0_RUBIK_DONE_SET1_SHIFT (_MK_SHIFT_CONST(9))
+#define GLB_S_INTR_SET_0_RUBIK_DONE_SET1_FIELD \
+	(_MK_FIELD_CONST(0x1, GLB_S_INTR_SET_0_RUBIK_DONE_SET1_SHIFT))
+#define GLB_S_INTR_SET_0_RUBIK_DONE_SET1_RANGE (9 : 9)
+#define GLB_S_INTR_SET_0_RUBIK_DONE_SET1_WOFFSET (0x0)
+#define GLB_S_INTR_SET_0_RUBIK_DONE_SET1_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_RUBIK_DONE_SET1_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define GLB_S_INTR_SET_0_RUBIK_DONE_SET1_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_RUBIK_DONE_SET1_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_RUBIK_DONE_SET1_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_RUBIK_DONE_SET1_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define GLB_S_INTR_SET_0_CDMA_DAT_DONE_SET0_SHIFT (_MK_SHIFT_CONST(16))
+#define GLB_S_INTR_SET_0_CDMA_DAT_DONE_SET0_FIELD \
+	(_MK_FIELD_CONST(0x1, GLB_S_INTR_SET_0_CDMA_DAT_DONE_SET0_SHIFT))
+#define GLB_S_INTR_SET_0_CDMA_DAT_DONE_SET0_RANGE (16 : 16)
+#define GLB_S_INTR_SET_0_CDMA_DAT_DONE_SET0_WOFFSET (0x0)
+#define GLB_S_INTR_SET_0_CDMA_DAT_DONE_SET0_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_CDMA_DAT_DONE_SET0_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define GLB_S_INTR_SET_0_CDMA_DAT_DONE_SET0_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_CDMA_DAT_DONE_SET0_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_CDMA_DAT_DONE_SET0_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_CDMA_DAT_DONE_SET0_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define GLB_S_INTR_SET_0_CDMA_DAT_DONE_SET1_SHIFT (_MK_SHIFT_CONST(17))
+#define GLB_S_INTR_SET_0_CDMA_DAT_DONE_SET1_FIELD \
+	(_MK_FIELD_CONST(0x1, GLB_S_INTR_SET_0_CDMA_DAT_DONE_SET1_SHIFT))
+#define GLB_S_INTR_SET_0_CDMA_DAT_DONE_SET1_RANGE (17 : 17)
+#define GLB_S_INTR_SET_0_CDMA_DAT_DONE_SET1_WOFFSET (0x0)
+#define GLB_S_INTR_SET_0_CDMA_DAT_DONE_SET1_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_CDMA_DAT_DONE_SET1_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define GLB_S_INTR_SET_0_CDMA_DAT_DONE_SET1_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_CDMA_DAT_DONE_SET1_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_CDMA_DAT_DONE_SET1_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_CDMA_DAT_DONE_SET1_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define GLB_S_INTR_SET_0_CDMA_WT_DONE_SET0_SHIFT (_MK_SHIFT_CONST(18))
+#define GLB_S_INTR_SET_0_CDMA_WT_DONE_SET0_FIELD \
+	(_MK_FIELD_CONST(0x1, GLB_S_INTR_SET_0_CDMA_WT_DONE_SET0_SHIFT))
+#define GLB_S_INTR_SET_0_CDMA_WT_DONE_SET0_RANGE (18 : 18)
+#define GLB_S_INTR_SET_0_CDMA_WT_DONE_SET0_WOFFSET (0x0)
+#define GLB_S_INTR_SET_0_CDMA_WT_DONE_SET0_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_CDMA_WT_DONE_SET0_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define GLB_S_INTR_SET_0_CDMA_WT_DONE_SET0_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_CDMA_WT_DONE_SET0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_CDMA_WT_DONE_SET0_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_CDMA_WT_DONE_SET0_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define GLB_S_INTR_SET_0_CDMA_WT_DONE_SET1_SHIFT (_MK_SHIFT_CONST(19))
+#define GLB_S_INTR_SET_0_CDMA_WT_DONE_SET1_FIELD \
+	(_MK_FIELD_CONST(0x1, GLB_S_INTR_SET_0_CDMA_WT_DONE_SET1_SHIFT))
+#define GLB_S_INTR_SET_0_CDMA_WT_DONE_SET1_RANGE (19 : 19)
+#define GLB_S_INTR_SET_0_CDMA_WT_DONE_SET1_WOFFSET (0x0)
+#define GLB_S_INTR_SET_0_CDMA_WT_DONE_SET1_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_CDMA_WT_DONE_SET1_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define GLB_S_INTR_SET_0_CDMA_WT_DONE_SET1_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_CDMA_WT_DONE_SET1_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_CDMA_WT_DONE_SET1_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_CDMA_WT_DONE_SET1_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define GLB_S_INTR_SET_0_CACC_DONE_SET0_SHIFT (_MK_SHIFT_CONST(20))
+#define GLB_S_INTR_SET_0_CACC_DONE_SET0_FIELD \
+	(_MK_FIELD_CONST(0x1, GLB_S_INTR_SET_0_CACC_DONE_SET0_SHIFT))
+#define GLB_S_INTR_SET_0_CACC_DONE_SET0_RANGE (20 : 20)
+#define GLB_S_INTR_SET_0_CACC_DONE_SET0_WOFFSET (0x0)
+#define GLB_S_INTR_SET_0_CACC_DONE_SET0_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_CACC_DONE_SET0_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define GLB_S_INTR_SET_0_CACC_DONE_SET0_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_CACC_DONE_SET0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_CACC_DONE_SET0_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_CACC_DONE_SET0_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+#define GLB_S_INTR_SET_0_CACC_DONE_SET1_SHIFT (_MK_SHIFT_CONST(21))
+#define GLB_S_INTR_SET_0_CACC_DONE_SET1_FIELD \
+	(_MK_FIELD_CONST(0x1, GLB_S_INTR_SET_0_CACC_DONE_SET1_SHIFT))
+#define GLB_S_INTR_SET_0_CACC_DONE_SET1_RANGE (21 : 21)
+#define GLB_S_INTR_SET_0_CACC_DONE_SET1_WOFFSET (0x0)
+#define GLB_S_INTR_SET_0_CACC_DONE_SET1_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_CACC_DONE_SET1_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define GLB_S_INTR_SET_0_CACC_DONE_SET1_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_CACC_DONE_SET1_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_CACC_DONE_SET1_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_SET_0_CACC_DONE_SET1_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+// Register GLB_S_INTR_STATUS_0
+#define GLB_S_INTR_STATUS_0 (_MK_ADDR_CONST(0xc))
+#define GLB_S_INTR_STATUS_0_SECURE (0x0)
+#define GLB_S_INTR_STATUS_0_DUAL (0x0)
+#define GLB_S_INTR_STATUS_0_SCR (0)
+#define GLB_S_INTR_STATUS_0_WORD_COUNT (0x1)
+#define GLB_S_INTR_STATUS_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_RESET_MASK (_MK_MASK_CONST(0x3f03ff))
+#define GLB_S_INTR_STATUS_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_READ_MASK (_MK_MASK_CONST(0x3f03ff))
+#define GLB_S_INTR_STATUS_0_WRITE_MASK (_MK_MASK_CONST(0x3f03ff))
+#define GLB_S_INTR_STATUS_0_SDP_DONE_STATUS0_SHIFT (_MK_SHIFT_CONST(0))
+#define GLB_S_INTR_STATUS_0_SDP_DONE_STATUS0_FIELD \
+	(_MK_FIELD_CONST(0x1, GLB_S_INTR_STATUS_0_SDP_DONE_STATUS0_SHIFT))
+#define GLB_S_INTR_STATUS_0_SDP_DONE_STATUS0_RANGE (0 : 0)
+#define GLB_S_INTR_STATUS_0_SDP_DONE_STATUS0_WOFFSET (0x0)
+#define GLB_S_INTR_STATUS_0_SDP_DONE_STATUS0_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_SDP_DONE_STATUS0_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define GLB_S_INTR_STATUS_0_SDP_DONE_STATUS0_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_SDP_DONE_STATUS0_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_SDP_DONE_STATUS0_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_SDP_DONE_STATUS0_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define GLB_S_INTR_STATUS_0_SDP_DONE_STATUS1_SHIFT (_MK_SHIFT_CONST(1))
+#define GLB_S_INTR_STATUS_0_SDP_DONE_STATUS1_FIELD \
+	(_MK_FIELD_CONST(0x1, GLB_S_INTR_STATUS_0_SDP_DONE_STATUS1_SHIFT))
+#define GLB_S_INTR_STATUS_0_SDP_DONE_STATUS1_RANGE (1 : 1)
+#define GLB_S_INTR_STATUS_0_SDP_DONE_STATUS1_WOFFSET (0x0)
+#define GLB_S_INTR_STATUS_0_SDP_DONE_STATUS1_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_SDP_DONE_STATUS1_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define GLB_S_INTR_STATUS_0_SDP_DONE_STATUS1_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_SDP_DONE_STATUS1_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_SDP_DONE_STATUS1_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_SDP_DONE_STATUS1_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define GLB_S_INTR_STATUS_0_CDP_DONE_STATUS0_SHIFT (_MK_SHIFT_CONST(2))
+#define GLB_S_INTR_STATUS_0_CDP_DONE_STATUS0_FIELD \
+	(_MK_FIELD_CONST(0x1, GLB_S_INTR_STATUS_0_CDP_DONE_STATUS0_SHIFT))
+#define GLB_S_INTR_STATUS_0_CDP_DONE_STATUS0_RANGE (2 : 2)
+#define GLB_S_INTR_STATUS_0_CDP_DONE_STATUS0_WOFFSET (0x0)
+#define GLB_S_INTR_STATUS_0_CDP_DONE_STATUS0_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_CDP_DONE_STATUS0_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define GLB_S_INTR_STATUS_0_CDP_DONE_STATUS0_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_CDP_DONE_STATUS0_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_CDP_DONE_STATUS0_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_CDP_DONE_STATUS0_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define GLB_S_INTR_STATUS_0_CDP_DONE_STATUS1_SHIFT (_MK_SHIFT_CONST(3))
+#define GLB_S_INTR_STATUS_0_CDP_DONE_STATUS1_FIELD \
+	(_MK_FIELD_CONST(0x1, GLB_S_INTR_STATUS_0_CDP_DONE_STATUS1_SHIFT))
+#define GLB_S_INTR_STATUS_0_CDP_DONE_STATUS1_RANGE (3 : 3)
+#define GLB_S_INTR_STATUS_0_CDP_DONE_STATUS1_WOFFSET (0x0)
+#define GLB_S_INTR_STATUS_0_CDP_DONE_STATUS1_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_CDP_DONE_STATUS1_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define GLB_S_INTR_STATUS_0_CDP_DONE_STATUS1_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_CDP_DONE_STATUS1_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_CDP_DONE_STATUS1_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_CDP_DONE_STATUS1_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define GLB_S_INTR_STATUS_0_PDP_DONE_STATUS0_SHIFT (_MK_SHIFT_CONST(4))
+#define GLB_S_INTR_STATUS_0_PDP_DONE_STATUS0_FIELD \
+	(_MK_FIELD_CONST(0x1, GLB_S_INTR_STATUS_0_PDP_DONE_STATUS0_SHIFT))
+#define GLB_S_INTR_STATUS_0_PDP_DONE_STATUS0_RANGE (4 : 4)
+#define GLB_S_INTR_STATUS_0_PDP_DONE_STATUS0_WOFFSET (0x0)
+#define GLB_S_INTR_STATUS_0_PDP_DONE_STATUS0_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_PDP_DONE_STATUS0_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define GLB_S_INTR_STATUS_0_PDP_DONE_STATUS0_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_PDP_DONE_STATUS0_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_PDP_DONE_STATUS0_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_PDP_DONE_STATUS0_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define GLB_S_INTR_STATUS_0_PDP_DONE_STATUS1_SHIFT (_MK_SHIFT_CONST(5))
+#define GLB_S_INTR_STATUS_0_PDP_DONE_STATUS1_FIELD \
+	(_MK_FIELD_CONST(0x1, GLB_S_INTR_STATUS_0_PDP_DONE_STATUS1_SHIFT))
+#define GLB_S_INTR_STATUS_0_PDP_DONE_STATUS1_RANGE (5 : 5)
+#define GLB_S_INTR_STATUS_0_PDP_DONE_STATUS1_WOFFSET (0x0)
+#define GLB_S_INTR_STATUS_0_PDP_DONE_STATUS1_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_PDP_DONE_STATUS1_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define GLB_S_INTR_STATUS_0_PDP_DONE_STATUS1_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_PDP_DONE_STATUS1_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_PDP_DONE_STATUS1_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_PDP_DONE_STATUS1_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define GLB_S_INTR_STATUS_0_BDMA_DONE_STATUS0_SHIFT (_MK_SHIFT_CONST(6))
+#define GLB_S_INTR_STATUS_0_BDMA_DONE_STATUS0_FIELD \
+	(_MK_FIELD_CONST(0x1, GLB_S_INTR_STATUS_0_BDMA_DONE_STATUS0_SHIFT))
+#define GLB_S_INTR_STATUS_0_BDMA_DONE_STATUS0_RANGE (6 : 6)
+#define GLB_S_INTR_STATUS_0_BDMA_DONE_STATUS0_WOFFSET (0x0)
+#define GLB_S_INTR_STATUS_0_BDMA_DONE_STATUS0_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_BDMA_DONE_STATUS0_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define GLB_S_INTR_STATUS_0_BDMA_DONE_STATUS0_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_BDMA_DONE_STATUS0_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_BDMA_DONE_STATUS0_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_BDMA_DONE_STATUS0_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define GLB_S_INTR_STATUS_0_BDMA_DONE_STATUS1_SHIFT (_MK_SHIFT_CONST(7))
+#define GLB_S_INTR_STATUS_0_BDMA_DONE_STATUS1_FIELD \
+	(_MK_FIELD_CONST(0x1, GLB_S_INTR_STATUS_0_BDMA_DONE_STATUS1_SHIFT))
+#define GLB_S_INTR_STATUS_0_BDMA_DONE_STATUS1_RANGE (7 : 7)
+#define GLB_S_INTR_STATUS_0_BDMA_DONE_STATUS1_WOFFSET (0x0)
+#define GLB_S_INTR_STATUS_0_BDMA_DONE_STATUS1_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_BDMA_DONE_STATUS1_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define GLB_S_INTR_STATUS_0_BDMA_DONE_STATUS1_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_BDMA_DONE_STATUS1_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_BDMA_DONE_STATUS1_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_BDMA_DONE_STATUS1_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define GLB_S_INTR_STATUS_0_RUBIK_DONE_STATUS0_SHIFT (_MK_SHIFT_CONST(8))
+#define GLB_S_INTR_STATUS_0_RUBIK_DONE_STATUS0_FIELD \
+	(_MK_FIELD_CONST(0x1, GLB_S_INTR_STATUS_0_RUBIK_DONE_STATUS0_SHIFT))
+#define GLB_S_INTR_STATUS_0_RUBIK_DONE_STATUS0_RANGE (8 : 8)
+#define GLB_S_INTR_STATUS_0_RUBIK_DONE_STATUS0_WOFFSET (0x0)
+#define GLB_S_INTR_STATUS_0_RUBIK_DONE_STATUS0_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_RUBIK_DONE_STATUS0_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1))
+#define GLB_S_INTR_STATUS_0_RUBIK_DONE_STATUS0_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_RUBIK_DONE_STATUS0_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_RUBIK_DONE_STATUS0_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_RUBIK_DONE_STATUS0_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define GLB_S_INTR_STATUS_0_RUBIK_DONE_STATUS1_SHIFT (_MK_SHIFT_CONST(9))
+#define GLB_S_INTR_STATUS_0_RUBIK_DONE_STATUS1_FIELD \
+	(_MK_FIELD_CONST(0x1, GLB_S_INTR_STATUS_0_RUBIK_DONE_STATUS1_SHIFT))
+#define GLB_S_INTR_STATUS_0_RUBIK_DONE_STATUS1_RANGE (9 : 9)
+#define GLB_S_INTR_STATUS_0_RUBIK_DONE_STATUS1_WOFFSET (0x0)
+#define GLB_S_INTR_STATUS_0_RUBIK_DONE_STATUS1_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_RUBIK_DONE_STATUS1_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1))
+#define GLB_S_INTR_STATUS_0_RUBIK_DONE_STATUS1_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_RUBIK_DONE_STATUS1_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_RUBIK_DONE_STATUS1_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_RUBIK_DONE_STATUS1_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define GLB_S_INTR_STATUS_0_CDMA_DAT_DONE_STATUS0_SHIFT (_MK_SHIFT_CONST(16))
+#define GLB_S_INTR_STATUS_0_CDMA_DAT_DONE_STATUS0_FIELD \
+	(_MK_FIELD_CONST(0x1, GLB_S_INTR_STATUS_0_CDMA_DAT_DONE_STATUS0_SHIFT))
+#define GLB_S_INTR_STATUS_0_CDMA_DAT_DONE_STATUS0_RANGE (16 : 16)
+#define GLB_S_INTR_STATUS_0_CDMA_DAT_DONE_STATUS0_WOFFSET (0x0)
+#define GLB_S_INTR_STATUS_0_CDMA_DAT_DONE_STATUS0_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_CDMA_DAT_DONE_STATUS0_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1))
+#define GLB_S_INTR_STATUS_0_CDMA_DAT_DONE_STATUS0_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_CDMA_DAT_DONE_STATUS0_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_CDMA_DAT_DONE_STATUS0_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_CDMA_DAT_DONE_STATUS0_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define GLB_S_INTR_STATUS_0_CDMA_DAT_DONE_STATUS1_SHIFT (_MK_SHIFT_CONST(17))
+#define GLB_S_INTR_STATUS_0_CDMA_DAT_DONE_STATUS1_FIELD \
+	(_MK_FIELD_CONST(0x1, GLB_S_INTR_STATUS_0_CDMA_DAT_DONE_STATUS1_SHIFT))
+#define GLB_S_INTR_STATUS_0_CDMA_DAT_DONE_STATUS1_RANGE (17 : 17)
+#define GLB_S_INTR_STATUS_0_CDMA_DAT_DONE_STATUS1_WOFFSET (0x0)
+#define GLB_S_INTR_STATUS_0_CDMA_DAT_DONE_STATUS1_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_CDMA_DAT_DONE_STATUS1_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1))
+#define GLB_S_INTR_STATUS_0_CDMA_DAT_DONE_STATUS1_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_CDMA_DAT_DONE_STATUS1_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_CDMA_DAT_DONE_STATUS1_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_CDMA_DAT_DONE_STATUS1_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define GLB_S_INTR_STATUS_0_CDMA_WT_DONE_STATUS0_SHIFT (_MK_SHIFT_CONST(18))
+#define GLB_S_INTR_STATUS_0_CDMA_WT_DONE_STATUS0_FIELD \
+	(_MK_FIELD_CONST(0x1, GLB_S_INTR_STATUS_0_CDMA_WT_DONE_STATUS0_SHIFT))
+#define GLB_S_INTR_STATUS_0_CDMA_WT_DONE_STATUS0_RANGE (18 : 18)
+#define GLB_S_INTR_STATUS_0_CDMA_WT_DONE_STATUS0_WOFFSET (0x0)
+#define GLB_S_INTR_STATUS_0_CDMA_WT_DONE_STATUS0_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_CDMA_WT_DONE_STATUS0_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1))
+#define GLB_S_INTR_STATUS_0_CDMA_WT_DONE_STATUS0_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_CDMA_WT_DONE_STATUS0_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_CDMA_WT_DONE_STATUS0_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_CDMA_WT_DONE_STATUS0_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define GLB_S_INTR_STATUS_0_CDMA_WT_DONE_STATUS1_SHIFT (_MK_SHIFT_CONST(19))
+#define GLB_S_INTR_STATUS_0_CDMA_WT_DONE_STATUS1_FIELD \
+	(_MK_FIELD_CONST(0x1, GLB_S_INTR_STATUS_0_CDMA_WT_DONE_STATUS1_SHIFT))
+#define GLB_S_INTR_STATUS_0_CDMA_WT_DONE_STATUS1_RANGE (19 : 19)
+#define GLB_S_INTR_STATUS_0_CDMA_WT_DONE_STATUS1_WOFFSET (0x0)
+#define GLB_S_INTR_STATUS_0_CDMA_WT_DONE_STATUS1_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_CDMA_WT_DONE_STATUS1_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1))
+#define GLB_S_INTR_STATUS_0_CDMA_WT_DONE_STATUS1_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_CDMA_WT_DONE_STATUS1_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_CDMA_WT_DONE_STATUS1_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_CDMA_WT_DONE_STATUS1_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define GLB_S_INTR_STATUS_0_CACC_DONE_STATUS0_SHIFT (_MK_SHIFT_CONST(20))
+#define GLB_S_INTR_STATUS_0_CACC_DONE_STATUS0_FIELD \
+	(_MK_FIELD_CONST(0x1, GLB_S_INTR_STATUS_0_CACC_DONE_STATUS0_SHIFT))
+#define GLB_S_INTR_STATUS_0_CACC_DONE_STATUS0_RANGE (20 : 20)
+#define GLB_S_INTR_STATUS_0_CACC_DONE_STATUS0_WOFFSET (0x0)
+#define GLB_S_INTR_STATUS_0_CACC_DONE_STATUS0_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_CACC_DONE_STATUS0_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define GLB_S_INTR_STATUS_0_CACC_DONE_STATUS0_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_CACC_DONE_STATUS0_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_CACC_DONE_STATUS0_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_CACC_DONE_STATUS0_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define GLB_S_INTR_STATUS_0_CACC_DONE_STATUS1_SHIFT (_MK_SHIFT_CONST(21))
+#define GLB_S_INTR_STATUS_0_CACC_DONE_STATUS1_FIELD \
+	(_MK_FIELD_CONST(0x1, GLB_S_INTR_STATUS_0_CACC_DONE_STATUS1_SHIFT))
+#define GLB_S_INTR_STATUS_0_CACC_DONE_STATUS1_RANGE (21 : 21)
+#define GLB_S_INTR_STATUS_0_CACC_DONE_STATUS1_WOFFSET (0x0)
+#define GLB_S_INTR_STATUS_0_CACC_DONE_STATUS1_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_CACC_DONE_STATUS1_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define GLB_S_INTR_STATUS_0_CACC_DONE_STATUS1_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_CACC_DONE_STATUS1_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_CACC_DONE_STATUS1_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define GLB_S_INTR_STATUS_0_CACC_DONE_STATUS1_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register MCIF_CFG_RD_WEIGHT_0_0
+#define MCIF_CFG_RD_WEIGHT_0_0 (_MK_ADDR_CONST(0x2000))
+#define MCIF_CFG_RD_WEIGHT_0_0_SECURE (0x0)
+#define MCIF_CFG_RD_WEIGHT_0_0_DUAL (0x0)
+#define MCIF_CFG_RD_WEIGHT_0_0_SCR (0)
+#define MCIF_CFG_RD_WEIGHT_0_0_WORD_COUNT (0x1)
+#define MCIF_CFG_RD_WEIGHT_0_0_RESET_VAL (_MK_MASK_CONST(0x1010101))
+#define MCIF_CFG_RD_WEIGHT_0_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define MCIF_CFG_RD_WEIGHT_0_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define MCIF_CFG_RD_WEIGHT_0_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define MCIF_CFG_RD_WEIGHT_0_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define MCIF_CFG_RD_WEIGHT_0_0_WRITE_MASK (_MK_MASK_CONST(0xffffffff))
+#define MCIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_BDMA_SHIFT (_MK_SHIFT_CONST(0))
+#define MCIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_BDMA_FIELD \
+	(_MK_FIELD_CONST(0xff, MCIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_BDMA_SHIFT))
+#define MCIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_BDMA_RANGE (7 : 0)
+#define MCIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_BDMA_WOFFSET (0x0)
+#define MCIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_BDMA_DEFAULT (_MK_MASK_CONST(0x1))
+#define MCIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_BDMA_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xff))
+#define MCIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_BDMA_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define MCIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_BDMA_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define MCIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_BDMA_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define MCIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_BDMA_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define MCIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_SDP_SHIFT (_MK_SHIFT_CONST(8))
+#define MCIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_SDP_FIELD \
+	(_MK_FIELD_CONST(0xff, MCIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_SDP_SHIFT))
+#define MCIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_SDP_RANGE (15 : 8)
+#define MCIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_SDP_WOFFSET (0x0)
+#define MCIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_SDP_DEFAULT (_MK_MASK_CONST(0x1))
+#define MCIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_SDP_DEFAULT_MASK (_MK_MASK_CONST(0xff))
+#define MCIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_SDP_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define MCIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_SDP_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define MCIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_SDP_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define MCIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_SDP_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define MCIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_PDP_SHIFT (_MK_SHIFT_CONST(16))
+#define MCIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_PDP_FIELD \
+	(_MK_FIELD_CONST(0xff, MCIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_PDP_SHIFT))
+#define MCIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_PDP_RANGE (23 : 16)
+#define MCIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_PDP_WOFFSET (0x0)
+#define MCIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_PDP_DEFAULT (_MK_MASK_CONST(0x1))
+#define MCIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_PDP_DEFAULT_MASK (_MK_MASK_CONST(0xff))
+#define MCIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_PDP_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define MCIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_PDP_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define MCIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_PDP_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define MCIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_PDP_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define MCIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_CDP_SHIFT (_MK_SHIFT_CONST(24))
+#define MCIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_CDP_FIELD \
+	(_MK_FIELD_CONST(0xff, MCIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_CDP_SHIFT))
+#define MCIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_CDP_RANGE (31 : 24)
+#define MCIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_CDP_WOFFSET (0x0)
+#define MCIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_CDP_DEFAULT (_MK_MASK_CONST(0x1))
+#define MCIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_CDP_DEFAULT_MASK (_MK_MASK_CONST(0xff))
+#define MCIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_CDP_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define MCIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_CDP_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define MCIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_CDP_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define MCIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_CDP_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register MCIF_CFG_RD_WEIGHT_1_0
+#define MCIF_CFG_RD_WEIGHT_1_0 (_MK_ADDR_CONST(0x2004))
+#define MCIF_CFG_RD_WEIGHT_1_0_SECURE (0x0)
+#define MCIF_CFG_RD_WEIGHT_1_0_DUAL (0x0)
+#define MCIF_CFG_RD_WEIGHT_1_0_SCR (0)
+#define MCIF_CFG_RD_WEIGHT_1_0_WORD_COUNT (0x1)
+#define MCIF_CFG_RD_WEIGHT_1_0_RESET_VAL (_MK_MASK_CONST(0x1010101))
+#define MCIF_CFG_RD_WEIGHT_1_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define MCIF_CFG_RD_WEIGHT_1_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define MCIF_CFG_RD_WEIGHT_1_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define MCIF_CFG_RD_WEIGHT_1_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define MCIF_CFG_RD_WEIGHT_1_0_WRITE_MASK (_MK_MASK_CONST(0xffffffff))
+#define MCIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_B_SHIFT (_MK_SHIFT_CONST(0))
+#define MCIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_B_FIELD \
+	(_MK_FIELD_CONST(0xff, MCIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_B_SHIFT))
+#define MCIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_B_RANGE (7 : 0)
+#define MCIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_B_WOFFSET (0x0)
+#define MCIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_B_DEFAULT (_MK_MASK_CONST(0x1))
+#define MCIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_B_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xff))
+#define MCIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_B_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define MCIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_B_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define MCIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_B_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define MCIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_B_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define MCIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_N_SHIFT (_MK_SHIFT_CONST(8))
+#define MCIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_N_FIELD \
+	(_MK_FIELD_CONST(0xff, MCIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_N_SHIFT))
+#define MCIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_N_RANGE (15 : 8)
+#define MCIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_N_WOFFSET (0x0)
+#define MCIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_N_DEFAULT (_MK_MASK_CONST(0x1))
+#define MCIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_N_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xff))
+#define MCIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_N_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define MCIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_N_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define MCIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_N_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define MCIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_N_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define MCIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_E_SHIFT (_MK_SHIFT_CONST(16))
+#define MCIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_E_FIELD \
+	(_MK_FIELD_CONST(0xff, MCIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_E_SHIFT))
+#define MCIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_E_RANGE (23 : 16)
+#define MCIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_E_WOFFSET (0x0)
+#define MCIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_E_DEFAULT (_MK_MASK_CONST(0x1))
+#define MCIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_E_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xff))
+#define MCIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_E_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define MCIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_E_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define MCIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_E_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define MCIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_E_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define MCIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_CDMA_DAT_SHIFT (_MK_SHIFT_CONST(24))
+#define MCIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_CDMA_DAT_FIELD \
+	(_MK_FIELD_CONST(0xff, MCIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_CDMA_DAT_SHIFT))
+#define MCIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_CDMA_DAT_RANGE (31 : 24)
+#define MCIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_CDMA_DAT_WOFFSET (0x0)
+#define MCIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_CDMA_DAT_DEFAULT (_MK_MASK_CONST(0x1))
+#define MCIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_CDMA_DAT_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xff))
+#define MCIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_CDMA_DAT_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define MCIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_CDMA_DAT_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define MCIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_CDMA_DAT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define MCIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_CDMA_DAT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register MCIF_CFG_RD_WEIGHT_2_0
+#define MCIF_CFG_RD_WEIGHT_2_0 (_MK_ADDR_CONST(0x2008))
+#define MCIF_CFG_RD_WEIGHT_2_0_SECURE (0x0)
+#define MCIF_CFG_RD_WEIGHT_2_0_DUAL (0x0)
+#define MCIF_CFG_RD_WEIGHT_2_0_SCR (0)
+#define MCIF_CFG_RD_WEIGHT_2_0_WORD_COUNT (0x1)
+#define MCIF_CFG_RD_WEIGHT_2_0_RESET_VAL (_MK_MASK_CONST(0x1010101))
+#define MCIF_CFG_RD_WEIGHT_2_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define MCIF_CFG_RD_WEIGHT_2_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define MCIF_CFG_RD_WEIGHT_2_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define MCIF_CFG_RD_WEIGHT_2_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define MCIF_CFG_RD_WEIGHT_2_0_WRITE_MASK (_MK_MASK_CONST(0xffffffff))
+#define MCIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_CDMA_WT_SHIFT (_MK_SHIFT_CONST(0))
+#define MCIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_CDMA_WT_FIELD \
+	(_MK_FIELD_CONST(0xff, MCIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_CDMA_WT_SHIFT))
+#define MCIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_CDMA_WT_RANGE (7 : 0)
+#define MCIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_CDMA_WT_WOFFSET (0x0)
+#define MCIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_CDMA_WT_DEFAULT (_MK_MASK_CONST(0x1))
+#define MCIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_CDMA_WT_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xff))
+#define MCIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_CDMA_WT_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define MCIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_CDMA_WT_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define MCIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_CDMA_WT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define MCIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_CDMA_WT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define MCIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RBK_SHIFT (_MK_SHIFT_CONST(8))
+#define MCIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RBK_FIELD \
+	(_MK_FIELD_CONST(0xff, MCIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RBK_SHIFT))
+#define MCIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RBK_RANGE (15 : 8)
+#define MCIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RBK_WOFFSET (0x0)
+#define MCIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RBK_DEFAULT (_MK_MASK_CONST(0x1))
+#define MCIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RBK_DEFAULT_MASK (_MK_MASK_CONST(0xff))
+#define MCIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RBK_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define MCIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RBK_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define MCIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RBK_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define MCIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RBK_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define MCIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RSV_1_SHIFT (_MK_SHIFT_CONST(16))
+#define MCIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RSV_1_FIELD \
+	(_MK_FIELD_CONST(0xff, MCIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RSV_1_SHIFT))
+#define MCIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RSV_1_RANGE (23 : 16)
+#define MCIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RSV_1_WOFFSET (0x0)
+#define MCIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RSV_1_DEFAULT (_MK_MASK_CONST(0x1))
+#define MCIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RSV_1_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xff))
+#define MCIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RSV_1_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define MCIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RSV_1_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define MCIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RSV_1_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define MCIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RSV_1_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define MCIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RSV_0_SHIFT (_MK_SHIFT_CONST(24))
+#define MCIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RSV_0_FIELD \
+	(_MK_FIELD_CONST(0xff, MCIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RSV_0_SHIFT))
+#define MCIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RSV_0_RANGE (31 : 24)
+#define MCIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RSV_0_WOFFSET (0x0)
+#define MCIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RSV_0_DEFAULT (_MK_MASK_CONST(0x1))
+#define MCIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RSV_0_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xff))
+#define MCIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RSV_0_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define MCIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RSV_0_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define MCIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RSV_0_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define MCIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RSV_0_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register MCIF_CFG_WR_WEIGHT_0_0
+#define MCIF_CFG_WR_WEIGHT_0_0 (_MK_ADDR_CONST(0x200c))
+#define MCIF_CFG_WR_WEIGHT_0_0_SECURE (0x0)
+#define MCIF_CFG_WR_WEIGHT_0_0_DUAL (0x0)
+#define MCIF_CFG_WR_WEIGHT_0_0_SCR (0)
+#define MCIF_CFG_WR_WEIGHT_0_0_WORD_COUNT (0x1)
+#define MCIF_CFG_WR_WEIGHT_0_0_RESET_VAL (_MK_MASK_CONST(0x1010101))
+#define MCIF_CFG_WR_WEIGHT_0_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define MCIF_CFG_WR_WEIGHT_0_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define MCIF_CFG_WR_WEIGHT_0_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define MCIF_CFG_WR_WEIGHT_0_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define MCIF_CFG_WR_WEIGHT_0_0_WRITE_MASK (_MK_MASK_CONST(0xffffffff))
+#define MCIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_BDMA_SHIFT (_MK_SHIFT_CONST(0))
+#define MCIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_BDMA_FIELD \
+	(_MK_FIELD_CONST(0xff, MCIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_BDMA_SHIFT))
+#define MCIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_BDMA_RANGE (7 : 0)
+#define MCIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_BDMA_WOFFSET (0x0)
+#define MCIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_BDMA_DEFAULT (_MK_MASK_CONST(0x1))
+#define MCIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_BDMA_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xff))
+#define MCIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_BDMA_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define MCIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_BDMA_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define MCIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_BDMA_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define MCIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_BDMA_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define MCIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_SDP_SHIFT (_MK_SHIFT_CONST(8))
+#define MCIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_SDP_FIELD \
+	(_MK_FIELD_CONST(0xff, MCIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_SDP_SHIFT))
+#define MCIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_SDP_RANGE (15 : 8)
+#define MCIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_SDP_WOFFSET (0x0)
+#define MCIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_SDP_DEFAULT (_MK_MASK_CONST(0x1))
+#define MCIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_SDP_DEFAULT_MASK (_MK_MASK_CONST(0xff))
+#define MCIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_SDP_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define MCIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_SDP_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define MCIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_SDP_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define MCIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_SDP_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define MCIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_PDP_SHIFT (_MK_SHIFT_CONST(16))
+#define MCIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_PDP_FIELD \
+	(_MK_FIELD_CONST(0xff, MCIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_PDP_SHIFT))
+#define MCIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_PDP_RANGE (23 : 16)
+#define MCIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_PDP_WOFFSET (0x0)
+#define MCIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_PDP_DEFAULT (_MK_MASK_CONST(0x1))
+#define MCIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_PDP_DEFAULT_MASK (_MK_MASK_CONST(0xff))
+#define MCIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_PDP_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define MCIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_PDP_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define MCIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_PDP_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define MCIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_PDP_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define MCIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_CDP_SHIFT (_MK_SHIFT_CONST(24))
+#define MCIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_CDP_FIELD \
+	(_MK_FIELD_CONST(0xff, MCIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_CDP_SHIFT))
+#define MCIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_CDP_RANGE (31 : 24)
+#define MCIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_CDP_WOFFSET (0x0)
+#define MCIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_CDP_DEFAULT (_MK_MASK_CONST(0x1))
+#define MCIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_CDP_DEFAULT_MASK (_MK_MASK_CONST(0xff))
+#define MCIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_CDP_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define MCIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_CDP_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define MCIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_CDP_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define MCIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_CDP_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register MCIF_CFG_WR_WEIGHT_1_0
+#define MCIF_CFG_WR_WEIGHT_1_0 (_MK_ADDR_CONST(0x2010))
+#define MCIF_CFG_WR_WEIGHT_1_0_SECURE (0x0)
+#define MCIF_CFG_WR_WEIGHT_1_0_DUAL (0x0)
+#define MCIF_CFG_WR_WEIGHT_1_0_SCR (0)
+#define MCIF_CFG_WR_WEIGHT_1_0_WORD_COUNT (0x1)
+#define MCIF_CFG_WR_WEIGHT_1_0_RESET_VAL (_MK_MASK_CONST(0x1010101))
+#define MCIF_CFG_WR_WEIGHT_1_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define MCIF_CFG_WR_WEIGHT_1_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define MCIF_CFG_WR_WEIGHT_1_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define MCIF_CFG_WR_WEIGHT_1_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define MCIF_CFG_WR_WEIGHT_1_0_WRITE_MASK (_MK_MASK_CONST(0xffffffff))
+#define MCIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RBK_SHIFT (_MK_SHIFT_CONST(0))
+#define MCIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RBK_FIELD \
+	(_MK_FIELD_CONST(0xff, MCIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RBK_SHIFT))
+#define MCIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RBK_RANGE (7 : 0)
+#define MCIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RBK_WOFFSET (0x0)
+#define MCIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RBK_DEFAULT (_MK_MASK_CONST(0x1))
+#define MCIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RBK_DEFAULT_MASK (_MK_MASK_CONST(0xff))
+#define MCIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RBK_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define MCIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RBK_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define MCIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RBK_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define MCIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RBK_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define MCIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_2_SHIFT (_MK_SHIFT_CONST(8))
+#define MCIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_2_FIELD \
+	(_MK_FIELD_CONST(0xff, MCIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_2_SHIFT))
+#define MCIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_2_RANGE (15 : 8)
+#define MCIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_2_WOFFSET (0x0)
+#define MCIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_2_DEFAULT (_MK_MASK_CONST(0x1))
+#define MCIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_2_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xff))
+#define MCIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_2_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define MCIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_2_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define MCIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_2_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define MCIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_2_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define MCIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_1_SHIFT (_MK_SHIFT_CONST(16))
+#define MCIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_1_FIELD \
+	(_MK_FIELD_CONST(0xff, MCIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_1_SHIFT))
+#define MCIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_1_RANGE (23 : 16)
+#define MCIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_1_WOFFSET (0x0)
+#define MCIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_1_DEFAULT (_MK_MASK_CONST(0x1))
+#define MCIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_1_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xff))
+#define MCIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_1_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define MCIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_1_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define MCIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_1_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define MCIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_1_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define MCIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_0_SHIFT (_MK_SHIFT_CONST(24))
+#define MCIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_0_FIELD \
+	(_MK_FIELD_CONST(0xff, MCIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_0_SHIFT))
+#define MCIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_0_RANGE (31 : 24)
+#define MCIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_0_WOFFSET (0x0)
+#define MCIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_0_DEFAULT (_MK_MASK_CONST(0x1))
+#define MCIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_0_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xff))
+#define MCIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_0_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define MCIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_0_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define MCIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_0_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define MCIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_0_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register MCIF_CFG_OUTSTANDING_CNT_0
+#define MCIF_CFG_OUTSTANDING_CNT_0 (_MK_ADDR_CONST(0x2014))
+#define MCIF_CFG_OUTSTANDING_CNT_0_SECURE (0x0)
+#define MCIF_CFG_OUTSTANDING_CNT_0_DUAL (0x0)
+#define MCIF_CFG_OUTSTANDING_CNT_0_SCR (0)
+#define MCIF_CFG_OUTSTANDING_CNT_0_WORD_COUNT (0x1)
+#define MCIF_CFG_OUTSTANDING_CNT_0_RESET_VAL (_MK_MASK_CONST(0xffff))
+#define MCIF_CFG_OUTSTANDING_CNT_0_RESET_MASK (_MK_MASK_CONST(0xffff))
+#define MCIF_CFG_OUTSTANDING_CNT_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define MCIF_CFG_OUTSTANDING_CNT_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define MCIF_CFG_OUTSTANDING_CNT_0_READ_MASK (_MK_MASK_CONST(0xffff))
+#define MCIF_CFG_OUTSTANDING_CNT_0_WRITE_MASK (_MK_MASK_CONST(0xffff))
+#define MCIF_CFG_OUTSTANDING_CNT_0_RD_OS_CNT_SHIFT (_MK_SHIFT_CONST(0))
+#define MCIF_CFG_OUTSTANDING_CNT_0_RD_OS_CNT_FIELD \
+	(_MK_FIELD_CONST(0xff, MCIF_CFG_OUTSTANDING_CNT_0_RD_OS_CNT_SHIFT))
+#define MCIF_CFG_OUTSTANDING_CNT_0_RD_OS_CNT_RANGE (7 : 0)
+#define MCIF_CFG_OUTSTANDING_CNT_0_RD_OS_CNT_WOFFSET (0x0)
+#define MCIF_CFG_OUTSTANDING_CNT_0_RD_OS_CNT_DEFAULT (_MK_MASK_CONST(0xff))
+#define MCIF_CFG_OUTSTANDING_CNT_0_RD_OS_CNT_DEFAULT_MASK (_MK_MASK_CONST(0xff))
+#define MCIF_CFG_OUTSTANDING_CNT_0_RD_OS_CNT_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define MCIF_CFG_OUTSTANDING_CNT_0_RD_OS_CNT_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define MCIF_CFG_OUTSTANDING_CNT_0_RD_OS_CNT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define MCIF_CFG_OUTSTANDING_CNT_0_RD_OS_CNT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define MCIF_CFG_OUTSTANDING_CNT_0_WR_OS_CNT_SHIFT (_MK_SHIFT_CONST(8))
+#define MCIF_CFG_OUTSTANDING_CNT_0_WR_OS_CNT_FIELD \
+	(_MK_FIELD_CONST(0xff, MCIF_CFG_OUTSTANDING_CNT_0_WR_OS_CNT_SHIFT))
+#define MCIF_CFG_OUTSTANDING_CNT_0_WR_OS_CNT_RANGE (15 : 8)
+#define MCIF_CFG_OUTSTANDING_CNT_0_WR_OS_CNT_WOFFSET (0x0)
+#define MCIF_CFG_OUTSTANDING_CNT_0_WR_OS_CNT_DEFAULT (_MK_MASK_CONST(0xff))
+#define MCIF_CFG_OUTSTANDING_CNT_0_WR_OS_CNT_DEFAULT_MASK (_MK_MASK_CONST(0xff))
+#define MCIF_CFG_OUTSTANDING_CNT_0_WR_OS_CNT_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define MCIF_CFG_OUTSTANDING_CNT_0_WR_OS_CNT_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define MCIF_CFG_OUTSTANDING_CNT_0_WR_OS_CNT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define MCIF_CFG_OUTSTANDING_CNT_0_WR_OS_CNT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register MCIF_STATUS_0
+#define MCIF_STATUS_0 (_MK_ADDR_CONST(0x2018))
+#define MCIF_STATUS_0_SECURE (0x0)
+#define MCIF_STATUS_0_DUAL (0x0)
+#define MCIF_STATUS_0_SCR (0)
+#define MCIF_STATUS_0_WORD_COUNT (0x1)
+#define MCIF_STATUS_0_RESET_VAL (_MK_MASK_CONST(0x100))
+#define MCIF_STATUS_0_RESET_MASK (_MK_MASK_CONST(0x100))
+#define MCIF_STATUS_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define MCIF_STATUS_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define MCIF_STATUS_0_READ_MASK (_MK_MASK_CONST(0x100))
+#define MCIF_STATUS_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define MCIF_STATUS_0_IDLE_SHIFT (_MK_SHIFT_CONST(8))
+#define MCIF_STATUS_0_IDLE_FIELD \
+	(_MK_FIELD_CONST(0x1, MCIF_STATUS_0_IDLE_SHIFT))
+#define MCIF_STATUS_0_IDLE_RANGE (8 : 8)
+#define MCIF_STATUS_0_IDLE_WOFFSET (0x0)
+#define MCIF_STATUS_0_IDLE_DEFAULT (_MK_MASK_CONST(0x1))
+#define MCIF_STATUS_0_IDLE_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define MCIF_STATUS_0_IDLE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define MCIF_STATUS_0_IDLE_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define MCIF_STATUS_0_IDLE_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define MCIF_STATUS_0_IDLE_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define MCIF_STATUS_0_IDLE_INIT_ENUM (YES)
+#define MCIF_STATUS_0_IDLE_NO (_MK_ENUM_CONST(0))
+#define MCIF_STATUS_0_IDLE_YES (_MK_ENUM_CONST(1))
+
+// Register CVIF_CFG_RD_WEIGHT_0_0
+#define CVIF_CFG_RD_WEIGHT_0_0 (_MK_ADDR_CONST(0x3000))
+#define CVIF_CFG_RD_WEIGHT_0_0_SECURE (0x0)
+#define CVIF_CFG_RD_WEIGHT_0_0_DUAL (0x0)
+#define CVIF_CFG_RD_WEIGHT_0_0_SCR (0)
+#define CVIF_CFG_RD_WEIGHT_0_0_WORD_COUNT (0x1)
+#define CVIF_CFG_RD_WEIGHT_0_0_RESET_VAL (_MK_MASK_CONST(0x1010101))
+#define CVIF_CFG_RD_WEIGHT_0_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define CVIF_CFG_RD_WEIGHT_0_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CVIF_CFG_RD_WEIGHT_0_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CVIF_CFG_RD_WEIGHT_0_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define CVIF_CFG_RD_WEIGHT_0_0_WRITE_MASK (_MK_MASK_CONST(0xffffffff))
+#define CVIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_BDMA_SHIFT (_MK_SHIFT_CONST(0))
+#define CVIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_BDMA_FIELD \
+	(_MK_FIELD_CONST(0xff, CVIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_BDMA_SHIFT))
+#define CVIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_BDMA_RANGE (7 : 0)
+#define CVIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_BDMA_WOFFSET (0x0)
+#define CVIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_BDMA_DEFAULT (_MK_MASK_CONST(0x1))
+#define CVIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_BDMA_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xff))
+#define CVIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_BDMA_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CVIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_BDMA_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CVIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_BDMA_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CVIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_BDMA_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define CVIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_SDP_SHIFT (_MK_SHIFT_CONST(8))
+#define CVIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_SDP_FIELD \
+	(_MK_FIELD_CONST(0xff, CVIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_SDP_SHIFT))
+#define CVIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_SDP_RANGE (15 : 8)
+#define CVIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_SDP_WOFFSET (0x0)
+#define CVIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_SDP_DEFAULT (_MK_MASK_CONST(0x1))
+#define CVIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_SDP_DEFAULT_MASK (_MK_MASK_CONST(0xff))
+#define CVIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_SDP_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CVIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_SDP_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CVIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_SDP_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CVIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_SDP_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define CVIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_PDP_SHIFT (_MK_SHIFT_CONST(16))
+#define CVIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_PDP_FIELD \
+	(_MK_FIELD_CONST(0xff, CVIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_PDP_SHIFT))
+#define CVIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_PDP_RANGE (23 : 16)
+#define CVIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_PDP_WOFFSET (0x0)
+#define CVIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_PDP_DEFAULT (_MK_MASK_CONST(0x1))
+#define CVIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_PDP_DEFAULT_MASK (_MK_MASK_CONST(0xff))
+#define CVIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_PDP_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CVIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_PDP_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CVIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_PDP_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CVIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_PDP_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define CVIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_CDP_SHIFT (_MK_SHIFT_CONST(24))
+#define CVIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_CDP_FIELD \
+	(_MK_FIELD_CONST(0xff, CVIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_CDP_SHIFT))
+#define CVIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_CDP_RANGE (31 : 24)
+#define CVIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_CDP_WOFFSET (0x0)
+#define CVIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_CDP_DEFAULT (_MK_MASK_CONST(0x1))
+#define CVIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_CDP_DEFAULT_MASK (_MK_MASK_CONST(0xff))
+#define CVIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_CDP_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CVIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_CDP_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CVIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_CDP_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CVIF_CFG_RD_WEIGHT_0_0_RD_WEIGHT_CDP_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CVIF_CFG_RD_WEIGHT_1_0
+#define CVIF_CFG_RD_WEIGHT_1_0 (_MK_ADDR_CONST(0x3004))
+#define CVIF_CFG_RD_WEIGHT_1_0_SECURE (0x0)
+#define CVIF_CFG_RD_WEIGHT_1_0_DUAL (0x0)
+#define CVIF_CFG_RD_WEIGHT_1_0_SCR (0)
+#define CVIF_CFG_RD_WEIGHT_1_0_WORD_COUNT (0x1)
+#define CVIF_CFG_RD_WEIGHT_1_0_RESET_VAL (_MK_MASK_CONST(0x1010101))
+#define CVIF_CFG_RD_WEIGHT_1_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define CVIF_CFG_RD_WEIGHT_1_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CVIF_CFG_RD_WEIGHT_1_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CVIF_CFG_RD_WEIGHT_1_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define CVIF_CFG_RD_WEIGHT_1_0_WRITE_MASK (_MK_MASK_CONST(0xffffffff))
+#define CVIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_B_SHIFT (_MK_SHIFT_CONST(0))
+#define CVIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_B_FIELD \
+	(_MK_FIELD_CONST(0xff, CVIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_B_SHIFT))
+#define CVIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_B_RANGE (7 : 0)
+#define CVIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_B_WOFFSET (0x0)
+#define CVIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_B_DEFAULT (_MK_MASK_CONST(0x1))
+#define CVIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_B_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xff))
+#define CVIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_B_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CVIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_B_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CVIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_B_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CVIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_B_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define CVIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_N_SHIFT (_MK_SHIFT_CONST(8))
+#define CVIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_N_FIELD \
+	(_MK_FIELD_CONST(0xff, CVIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_N_SHIFT))
+#define CVIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_N_RANGE (15 : 8)
+#define CVIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_N_WOFFSET (0x0)
+#define CVIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_N_DEFAULT (_MK_MASK_CONST(0x1))
+#define CVIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_N_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xff))
+#define CVIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_N_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CVIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_N_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CVIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_N_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CVIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_N_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define CVIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_E_SHIFT (_MK_SHIFT_CONST(16))
+#define CVIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_E_FIELD \
+	(_MK_FIELD_CONST(0xff, CVIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_E_SHIFT))
+#define CVIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_E_RANGE (23 : 16)
+#define CVIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_E_WOFFSET (0x0)
+#define CVIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_E_DEFAULT (_MK_MASK_CONST(0x1))
+#define CVIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_E_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xff))
+#define CVIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_E_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CVIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_E_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CVIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_E_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CVIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_SDP_E_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define CVIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_CDMA_DAT_SHIFT (_MK_SHIFT_CONST(24))
+#define CVIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_CDMA_DAT_FIELD \
+	(_MK_FIELD_CONST(0xff, CVIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_CDMA_DAT_SHIFT))
+#define CVIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_CDMA_DAT_RANGE (31 : 24)
+#define CVIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_CDMA_DAT_WOFFSET (0x0)
+#define CVIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_CDMA_DAT_DEFAULT (_MK_MASK_CONST(0x1))
+#define CVIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_CDMA_DAT_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xff))
+#define CVIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_CDMA_DAT_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CVIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_CDMA_DAT_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CVIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_CDMA_DAT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CVIF_CFG_RD_WEIGHT_1_0_RD_WEIGHT_CDMA_DAT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CVIF_CFG_RD_WEIGHT_2_0
+#define CVIF_CFG_RD_WEIGHT_2_0 (_MK_ADDR_CONST(0x3008))
+#define CVIF_CFG_RD_WEIGHT_2_0_SECURE (0x0)
+#define CVIF_CFG_RD_WEIGHT_2_0_DUAL (0x0)
+#define CVIF_CFG_RD_WEIGHT_2_0_SCR (0)
+#define CVIF_CFG_RD_WEIGHT_2_0_WORD_COUNT (0x1)
+#define CVIF_CFG_RD_WEIGHT_2_0_RESET_VAL (_MK_MASK_CONST(0x1010101))
+#define CVIF_CFG_RD_WEIGHT_2_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define CVIF_CFG_RD_WEIGHT_2_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CVIF_CFG_RD_WEIGHT_2_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CVIF_CFG_RD_WEIGHT_2_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define CVIF_CFG_RD_WEIGHT_2_0_WRITE_MASK (_MK_MASK_CONST(0xffffffff))
+#define CVIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_CDMA_WT_SHIFT (_MK_SHIFT_CONST(0))
+#define CVIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_CDMA_WT_FIELD \
+	(_MK_FIELD_CONST(0xff, CVIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_CDMA_WT_SHIFT))
+#define CVIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_CDMA_WT_RANGE (7 : 0)
+#define CVIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_CDMA_WT_WOFFSET (0x0)
+#define CVIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_CDMA_WT_DEFAULT (_MK_MASK_CONST(0x1))
+#define CVIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_CDMA_WT_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xff))
+#define CVIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_CDMA_WT_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CVIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_CDMA_WT_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CVIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_CDMA_WT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CVIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_CDMA_WT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define CVIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RBK_SHIFT (_MK_SHIFT_CONST(8))
+#define CVIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RBK_FIELD \
+	(_MK_FIELD_CONST(0xff, CVIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RBK_SHIFT))
+#define CVIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RBK_RANGE (15 : 8)
+#define CVIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RBK_WOFFSET (0x0)
+#define CVIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RBK_DEFAULT (_MK_MASK_CONST(0x1))
+#define CVIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RBK_DEFAULT_MASK (_MK_MASK_CONST(0xff))
+#define CVIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RBK_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CVIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RBK_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CVIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RBK_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CVIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RBK_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define CVIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RSV_1_SHIFT (_MK_SHIFT_CONST(16))
+#define CVIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RSV_1_FIELD \
+	(_MK_FIELD_CONST(0xff, CVIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RSV_1_SHIFT))
+#define CVIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RSV_1_RANGE (23 : 16)
+#define CVIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RSV_1_WOFFSET (0x0)
+#define CVIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RSV_1_DEFAULT (_MK_MASK_CONST(0x1))
+#define CVIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RSV_1_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xff))
+#define CVIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RSV_1_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CVIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RSV_1_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CVIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RSV_1_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CVIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RSV_1_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define CVIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RSV_0_SHIFT (_MK_SHIFT_CONST(24))
+#define CVIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RSV_0_FIELD \
+	(_MK_FIELD_CONST(0xff, CVIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RSV_0_SHIFT))
+#define CVIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RSV_0_RANGE (31 : 24)
+#define CVIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RSV_0_WOFFSET (0x0)
+#define CVIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RSV_0_DEFAULT (_MK_MASK_CONST(0x1))
+#define CVIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RSV_0_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xff))
+#define CVIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RSV_0_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CVIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RSV_0_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CVIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RSV_0_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CVIF_CFG_RD_WEIGHT_2_0_RD_WEIGHT_RSV_0_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CVIF_CFG_WR_WEIGHT_0_0
+#define CVIF_CFG_WR_WEIGHT_0_0 (_MK_ADDR_CONST(0x300c))
+#define CVIF_CFG_WR_WEIGHT_0_0_SECURE (0x0)
+#define CVIF_CFG_WR_WEIGHT_0_0_DUAL (0x0)
+#define CVIF_CFG_WR_WEIGHT_0_0_SCR (0)
+#define CVIF_CFG_WR_WEIGHT_0_0_WORD_COUNT (0x1)
+#define CVIF_CFG_WR_WEIGHT_0_0_RESET_VAL (_MK_MASK_CONST(0x1010101))
+#define CVIF_CFG_WR_WEIGHT_0_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define CVIF_CFG_WR_WEIGHT_0_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CVIF_CFG_WR_WEIGHT_0_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CVIF_CFG_WR_WEIGHT_0_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define CVIF_CFG_WR_WEIGHT_0_0_WRITE_MASK (_MK_MASK_CONST(0xffffffff))
+#define CVIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_BDMA_SHIFT (_MK_SHIFT_CONST(0))
+#define CVIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_BDMA_FIELD \
+	(_MK_FIELD_CONST(0xff, CVIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_BDMA_SHIFT))
+#define CVIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_BDMA_RANGE (7 : 0)
+#define CVIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_BDMA_WOFFSET (0x0)
+#define CVIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_BDMA_DEFAULT (_MK_MASK_CONST(0x1))
+#define CVIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_BDMA_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xff))
+#define CVIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_BDMA_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CVIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_BDMA_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CVIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_BDMA_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CVIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_BDMA_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define CVIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_SDP_SHIFT (_MK_SHIFT_CONST(8))
+#define CVIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_SDP_FIELD \
+	(_MK_FIELD_CONST(0xff, CVIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_SDP_SHIFT))
+#define CVIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_SDP_RANGE (15 : 8)
+#define CVIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_SDP_WOFFSET (0x0)
+#define CVIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_SDP_DEFAULT (_MK_MASK_CONST(0x1))
+#define CVIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_SDP_DEFAULT_MASK (_MK_MASK_CONST(0xff))
+#define CVIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_SDP_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CVIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_SDP_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CVIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_SDP_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CVIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_SDP_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define CVIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_PDP_SHIFT (_MK_SHIFT_CONST(16))
+#define CVIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_PDP_FIELD \
+	(_MK_FIELD_CONST(0xff, CVIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_PDP_SHIFT))
+#define CVIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_PDP_RANGE (23 : 16)
+#define CVIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_PDP_WOFFSET (0x0)
+#define CVIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_PDP_DEFAULT (_MK_MASK_CONST(0x1))
+#define CVIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_PDP_DEFAULT_MASK (_MK_MASK_CONST(0xff))
+#define CVIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_PDP_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CVIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_PDP_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CVIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_PDP_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CVIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_PDP_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define CVIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_CDP_SHIFT (_MK_SHIFT_CONST(24))
+#define CVIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_CDP_FIELD \
+	(_MK_FIELD_CONST(0xff, CVIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_CDP_SHIFT))
+#define CVIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_CDP_RANGE (31 : 24)
+#define CVIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_CDP_WOFFSET (0x0)
+#define CVIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_CDP_DEFAULT (_MK_MASK_CONST(0x1))
+#define CVIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_CDP_DEFAULT_MASK (_MK_MASK_CONST(0xff))
+#define CVIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_CDP_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CVIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_CDP_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CVIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_CDP_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CVIF_CFG_WR_WEIGHT_0_0_WR_WEIGHT_CDP_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CVIF_CFG_WR_WEIGHT_1_0
+#define CVIF_CFG_WR_WEIGHT_1_0 (_MK_ADDR_CONST(0x3010))
+#define CVIF_CFG_WR_WEIGHT_1_0_SECURE (0x0)
+#define CVIF_CFG_WR_WEIGHT_1_0_DUAL (0x0)
+#define CVIF_CFG_WR_WEIGHT_1_0_SCR (0)
+#define CVIF_CFG_WR_WEIGHT_1_0_WORD_COUNT (0x1)
+#define CVIF_CFG_WR_WEIGHT_1_0_RESET_VAL (_MK_MASK_CONST(0x1010101))
+#define CVIF_CFG_WR_WEIGHT_1_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define CVIF_CFG_WR_WEIGHT_1_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CVIF_CFG_WR_WEIGHT_1_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CVIF_CFG_WR_WEIGHT_1_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define CVIF_CFG_WR_WEIGHT_1_0_WRITE_MASK (_MK_MASK_CONST(0xffffffff))
+#define CVIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RBK_SHIFT (_MK_SHIFT_CONST(0))
+#define CVIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RBK_FIELD \
+	(_MK_FIELD_CONST(0xff, CVIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RBK_SHIFT))
+#define CVIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RBK_RANGE (7 : 0)
+#define CVIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RBK_WOFFSET (0x0)
+#define CVIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RBK_DEFAULT (_MK_MASK_CONST(0x1))
+#define CVIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RBK_DEFAULT_MASK (_MK_MASK_CONST(0xff))
+#define CVIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RBK_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CVIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RBK_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CVIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RBK_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CVIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RBK_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define CVIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_2_SHIFT (_MK_SHIFT_CONST(8))
+#define CVIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_2_FIELD \
+	(_MK_FIELD_CONST(0xff, CVIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_2_SHIFT))
+#define CVIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_2_RANGE (15 : 8)
+#define CVIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_2_WOFFSET (0x0)
+#define CVIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_2_DEFAULT (_MK_MASK_CONST(0x1))
+#define CVIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_2_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xff))
+#define CVIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_2_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CVIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_2_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CVIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_2_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CVIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_2_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define CVIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_1_SHIFT (_MK_SHIFT_CONST(16))
+#define CVIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_1_FIELD \
+	(_MK_FIELD_CONST(0xff, CVIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_1_SHIFT))
+#define CVIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_1_RANGE (23 : 16)
+#define CVIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_1_WOFFSET (0x0)
+#define CVIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_1_DEFAULT (_MK_MASK_CONST(0x1))
+#define CVIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_1_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xff))
+#define CVIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_1_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CVIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_1_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CVIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_1_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CVIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_1_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define CVIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_0_SHIFT (_MK_SHIFT_CONST(24))
+#define CVIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_0_FIELD \
+	(_MK_FIELD_CONST(0xff, CVIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_0_SHIFT))
+#define CVIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_0_RANGE (31 : 24)
+#define CVIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_0_WOFFSET (0x0)
+#define CVIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_0_DEFAULT (_MK_MASK_CONST(0x1))
+#define CVIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_0_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xff))
+#define CVIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_0_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CVIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_0_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CVIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_0_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CVIF_CFG_WR_WEIGHT_1_0_WR_WEIGHT_RSV_0_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CVIF_CFG_OUTSTANDING_CNT_0
+#define CVIF_CFG_OUTSTANDING_CNT_0 (_MK_ADDR_CONST(0x3014))
+#define CVIF_CFG_OUTSTANDING_CNT_0_SECURE (0x0)
+#define CVIF_CFG_OUTSTANDING_CNT_0_DUAL (0x0)
+#define CVIF_CFG_OUTSTANDING_CNT_0_SCR (0)
+#define CVIF_CFG_OUTSTANDING_CNT_0_WORD_COUNT (0x1)
+#define CVIF_CFG_OUTSTANDING_CNT_0_RESET_VAL (_MK_MASK_CONST(0xffff))
+#define CVIF_CFG_OUTSTANDING_CNT_0_RESET_MASK (_MK_MASK_CONST(0xffff))
+#define CVIF_CFG_OUTSTANDING_CNT_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CVIF_CFG_OUTSTANDING_CNT_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CVIF_CFG_OUTSTANDING_CNT_0_READ_MASK (_MK_MASK_CONST(0xffff))
+#define CVIF_CFG_OUTSTANDING_CNT_0_WRITE_MASK (_MK_MASK_CONST(0xffff))
+#define CVIF_CFG_OUTSTANDING_CNT_0_RD_OS_CNT_SHIFT (_MK_SHIFT_CONST(0))
+#define CVIF_CFG_OUTSTANDING_CNT_0_RD_OS_CNT_FIELD \
+	(_MK_FIELD_CONST(0xff, CVIF_CFG_OUTSTANDING_CNT_0_RD_OS_CNT_SHIFT))
+#define CVIF_CFG_OUTSTANDING_CNT_0_RD_OS_CNT_RANGE (7 : 0)
+#define CVIF_CFG_OUTSTANDING_CNT_0_RD_OS_CNT_WOFFSET (0x0)
+#define CVIF_CFG_OUTSTANDING_CNT_0_RD_OS_CNT_DEFAULT (_MK_MASK_CONST(0xff))
+#define CVIF_CFG_OUTSTANDING_CNT_0_RD_OS_CNT_DEFAULT_MASK (_MK_MASK_CONST(0xff))
+#define CVIF_CFG_OUTSTANDING_CNT_0_RD_OS_CNT_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CVIF_CFG_OUTSTANDING_CNT_0_RD_OS_CNT_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CVIF_CFG_OUTSTANDING_CNT_0_RD_OS_CNT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CVIF_CFG_OUTSTANDING_CNT_0_RD_OS_CNT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define CVIF_CFG_OUTSTANDING_CNT_0_WR_OS_CNT_SHIFT (_MK_SHIFT_CONST(8))
+#define CVIF_CFG_OUTSTANDING_CNT_0_WR_OS_CNT_FIELD \
+	(_MK_FIELD_CONST(0xff, CVIF_CFG_OUTSTANDING_CNT_0_WR_OS_CNT_SHIFT))
+#define CVIF_CFG_OUTSTANDING_CNT_0_WR_OS_CNT_RANGE (15 : 8)
+#define CVIF_CFG_OUTSTANDING_CNT_0_WR_OS_CNT_WOFFSET (0x0)
+#define CVIF_CFG_OUTSTANDING_CNT_0_WR_OS_CNT_DEFAULT (_MK_MASK_CONST(0xff))
+#define CVIF_CFG_OUTSTANDING_CNT_0_WR_OS_CNT_DEFAULT_MASK (_MK_MASK_CONST(0xff))
+#define CVIF_CFG_OUTSTANDING_CNT_0_WR_OS_CNT_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CVIF_CFG_OUTSTANDING_CNT_0_WR_OS_CNT_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CVIF_CFG_OUTSTANDING_CNT_0_WR_OS_CNT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CVIF_CFG_OUTSTANDING_CNT_0_WR_OS_CNT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CVIF_STATUS_0
+#define CVIF_STATUS_0 (_MK_ADDR_CONST(0x3018))
+#define CVIF_STATUS_0_SECURE (0x0)
+#define CVIF_STATUS_0_DUAL (0x0)
+#define CVIF_STATUS_0_SCR (0)
+#define CVIF_STATUS_0_WORD_COUNT (0x1)
+#define CVIF_STATUS_0_RESET_VAL (_MK_MASK_CONST(0x100))
+#define CVIF_STATUS_0_RESET_MASK (_MK_MASK_CONST(0x100))
+#define CVIF_STATUS_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CVIF_STATUS_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CVIF_STATUS_0_READ_MASK (_MK_MASK_CONST(0x100))
+#define CVIF_STATUS_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define CVIF_STATUS_0_IDLE_SHIFT (_MK_SHIFT_CONST(8))
+#define CVIF_STATUS_0_IDLE_FIELD \
+	(_MK_FIELD_CONST(0x1, CVIF_STATUS_0_IDLE_SHIFT))
+#define CVIF_STATUS_0_IDLE_RANGE (8 : 8)
+#define CVIF_STATUS_0_IDLE_WOFFSET (0x0)
+#define CVIF_STATUS_0_IDLE_DEFAULT (_MK_MASK_CONST(0x1))
+#define CVIF_STATUS_0_IDLE_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CVIF_STATUS_0_IDLE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CVIF_STATUS_0_IDLE_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CVIF_STATUS_0_IDLE_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CVIF_STATUS_0_IDLE_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define CVIF_STATUS_0_IDLE_INIT_ENUM (YES)
+#define CVIF_STATUS_0_IDLE_NO (_MK_ENUM_CONST(0))
+#define CVIF_STATUS_0_IDLE_YES (_MK_ENUM_CONST(1))
+
+// Register BDMA_CFG_SRC_ADDR_LOW_0
+#define BDMA_CFG_SRC_ADDR_LOW_0 (_MK_ADDR_CONST(0x4000))
+#define BDMA_CFG_SRC_ADDR_LOW_0_SECURE (0x0)
+#define BDMA_CFG_SRC_ADDR_LOW_0_DUAL (0x0)
+#define BDMA_CFG_SRC_ADDR_LOW_0_SCR (0)
+#define BDMA_CFG_SRC_ADDR_LOW_0_WORD_COUNT (0x1)
+#define BDMA_CFG_SRC_ADDR_LOW_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_SRC_ADDR_LOW_0_RESET_MASK (_MK_MASK_CONST(0xffffffe0))
+#define BDMA_CFG_SRC_ADDR_LOW_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_SRC_ADDR_LOW_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_SRC_ADDR_LOW_0_READ_MASK (_MK_MASK_CONST(0xffffffe0))
+#define BDMA_CFG_SRC_ADDR_LOW_0_WRITE_MASK (_MK_MASK_CONST(0xffffffe0))
+#define BDMA_CFG_SRC_ADDR_LOW_0_V32_SHIFT (_MK_SHIFT_CONST(5))
+#define BDMA_CFG_SRC_ADDR_LOW_0_V32_FIELD \
+	(_MK_FIELD_CONST(0x7ffffff, BDMA_CFG_SRC_ADDR_LOW_0_V32_SHIFT))
+#define BDMA_CFG_SRC_ADDR_LOW_0_V32_RANGE (31 : 5)
+#define BDMA_CFG_SRC_ADDR_LOW_0_V32_WOFFSET (0x0)
+#define BDMA_CFG_SRC_ADDR_LOW_0_V32_DEFAULT (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_SRC_ADDR_LOW_0_V32_DEFAULT_MASK (_MK_MASK_CONST(0x7ffffff))
+#define BDMA_CFG_SRC_ADDR_LOW_0_V32_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_SRC_ADDR_LOW_0_V32_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_SRC_ADDR_LOW_0_V32_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_SRC_ADDR_LOW_0_V32_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+// Register BDMA_CFG_SRC_ADDR_HIGH_0
+#define BDMA_CFG_SRC_ADDR_HIGH_0 (_MK_ADDR_CONST(0x4004))
+#define BDMA_CFG_SRC_ADDR_HIGH_0_SECURE (0x0)
+#define BDMA_CFG_SRC_ADDR_HIGH_0_DUAL (0x0)
+#define BDMA_CFG_SRC_ADDR_HIGH_0_SCR (0)
+#define BDMA_CFG_SRC_ADDR_HIGH_0_WORD_COUNT (0x1)
+#define BDMA_CFG_SRC_ADDR_HIGH_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_SRC_ADDR_HIGH_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define BDMA_CFG_SRC_ADDR_HIGH_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_SRC_ADDR_HIGH_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_SRC_ADDR_HIGH_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define BDMA_CFG_SRC_ADDR_HIGH_0_WRITE_MASK (_MK_MASK_CONST(0xffffffff))
+#define BDMA_CFG_SRC_ADDR_HIGH_0_V8_SHIFT (_MK_SHIFT_CONST(0))
+#define BDMA_CFG_SRC_ADDR_HIGH_0_V8_FIELD \
+	(_MK_FIELD_CONST(0xffffffff, BDMA_CFG_SRC_ADDR_HIGH_0_V8_SHIFT))
+#define BDMA_CFG_SRC_ADDR_HIGH_0_V8_RANGE (31 : 0)
+#define BDMA_CFG_SRC_ADDR_HIGH_0_V8_WOFFSET (0x0)
+#define BDMA_CFG_SRC_ADDR_HIGH_0_V8_DEFAULT (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_SRC_ADDR_HIGH_0_V8_DEFAULT_MASK (_MK_MASK_CONST(0xffffffff))
+#define BDMA_CFG_SRC_ADDR_HIGH_0_V8_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_SRC_ADDR_HIGH_0_V8_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_SRC_ADDR_HIGH_0_V8_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_SRC_ADDR_HIGH_0_V8_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+// Register BDMA_CFG_DST_ADDR_LOW_0
+#define BDMA_CFG_DST_ADDR_LOW_0 (_MK_ADDR_CONST(0x4008))
+#define BDMA_CFG_DST_ADDR_LOW_0_SECURE (0x0)
+#define BDMA_CFG_DST_ADDR_LOW_0_DUAL (0x0)
+#define BDMA_CFG_DST_ADDR_LOW_0_SCR (0)
+#define BDMA_CFG_DST_ADDR_LOW_0_WORD_COUNT (0x1)
+#define BDMA_CFG_DST_ADDR_LOW_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_DST_ADDR_LOW_0_RESET_MASK (_MK_MASK_CONST(0xffffffe0))
+#define BDMA_CFG_DST_ADDR_LOW_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_DST_ADDR_LOW_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_DST_ADDR_LOW_0_READ_MASK (_MK_MASK_CONST(0xffffffe0))
+#define BDMA_CFG_DST_ADDR_LOW_0_WRITE_MASK (_MK_MASK_CONST(0xffffffe0))
+#define BDMA_CFG_DST_ADDR_LOW_0_V32_SHIFT (_MK_SHIFT_CONST(5))
+#define BDMA_CFG_DST_ADDR_LOW_0_V32_FIELD \
+	(_MK_FIELD_CONST(0x7ffffff, BDMA_CFG_DST_ADDR_LOW_0_V32_SHIFT))
+#define BDMA_CFG_DST_ADDR_LOW_0_V32_RANGE (31 : 5)
+#define BDMA_CFG_DST_ADDR_LOW_0_V32_WOFFSET (0x0)
+#define BDMA_CFG_DST_ADDR_LOW_0_V32_DEFAULT (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_DST_ADDR_LOW_0_V32_DEFAULT_MASK (_MK_MASK_CONST(0x7ffffff))
+#define BDMA_CFG_DST_ADDR_LOW_0_V32_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_DST_ADDR_LOW_0_V32_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_DST_ADDR_LOW_0_V32_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_DST_ADDR_LOW_0_V32_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+// Register BDMA_CFG_DST_ADDR_HIGH_0
+#define BDMA_CFG_DST_ADDR_HIGH_0 (_MK_ADDR_CONST(0x400c))
+#define BDMA_CFG_DST_ADDR_HIGH_0_SECURE (0x0)
+#define BDMA_CFG_DST_ADDR_HIGH_0_DUAL (0x0)
+#define BDMA_CFG_DST_ADDR_HIGH_0_SCR (0)
+#define BDMA_CFG_DST_ADDR_HIGH_0_WORD_COUNT (0x1)
+#define BDMA_CFG_DST_ADDR_HIGH_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_DST_ADDR_HIGH_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define BDMA_CFG_DST_ADDR_HIGH_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_DST_ADDR_HIGH_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_DST_ADDR_HIGH_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define BDMA_CFG_DST_ADDR_HIGH_0_WRITE_MASK (_MK_MASK_CONST(0xffffffff))
+#define BDMA_CFG_DST_ADDR_HIGH_0_V8_SHIFT (_MK_SHIFT_CONST(0))
+#define BDMA_CFG_DST_ADDR_HIGH_0_V8_FIELD \
+	(_MK_FIELD_CONST(0xffffffff, BDMA_CFG_DST_ADDR_HIGH_0_V8_SHIFT))
+#define BDMA_CFG_DST_ADDR_HIGH_0_V8_RANGE (31 : 0)
+#define BDMA_CFG_DST_ADDR_HIGH_0_V8_WOFFSET (0x0)
+#define BDMA_CFG_DST_ADDR_HIGH_0_V8_DEFAULT (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_DST_ADDR_HIGH_0_V8_DEFAULT_MASK (_MK_MASK_CONST(0xffffffff))
+#define BDMA_CFG_DST_ADDR_HIGH_0_V8_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_DST_ADDR_HIGH_0_V8_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_DST_ADDR_HIGH_0_V8_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_DST_ADDR_HIGH_0_V8_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+// Register BDMA_CFG_LINE_0
+#define BDMA_CFG_LINE_0 (_MK_ADDR_CONST(0x4010))
+#define BDMA_CFG_LINE_0_SECURE (0x0)
+#define BDMA_CFG_LINE_0_DUAL (0x0)
+#define BDMA_CFG_LINE_0_SCR (0)
+#define BDMA_CFG_LINE_0_WORD_COUNT (0x1)
+#define BDMA_CFG_LINE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_LINE_0_RESET_MASK (_MK_MASK_CONST(0x1fff))
+#define BDMA_CFG_LINE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_LINE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_LINE_0_READ_MASK (_MK_MASK_CONST(0x1fff))
+#define BDMA_CFG_LINE_0_WRITE_MASK (_MK_MASK_CONST(0x1fff))
+#define BDMA_CFG_LINE_0_SIZE_SHIFT (_MK_SHIFT_CONST(0))
+#define BDMA_CFG_LINE_0_SIZE_FIELD \
+	(_MK_FIELD_CONST(0x1fff, BDMA_CFG_LINE_0_SIZE_SHIFT))
+#define BDMA_CFG_LINE_0_SIZE_RANGE (12 : 0)
+#define BDMA_CFG_LINE_0_SIZE_WOFFSET (0x0)
+#define BDMA_CFG_LINE_0_SIZE_DEFAULT (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_LINE_0_SIZE_DEFAULT_MASK (_MK_MASK_CONST(0x1fff))
+#define BDMA_CFG_LINE_0_SIZE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_LINE_0_SIZE_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_LINE_0_SIZE_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_LINE_0_SIZE_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+// Register BDMA_CFG_CMD_0
+#define BDMA_CFG_CMD_0 (_MK_ADDR_CONST(0x4014))
+#define BDMA_CFG_CMD_0_SECURE (0x0)
+#define BDMA_CFG_CMD_0_DUAL (0x0)
+#define BDMA_CFG_CMD_0_SCR (0)
+#define BDMA_CFG_CMD_0_WORD_COUNT (0x1)
+#define BDMA_CFG_CMD_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_CMD_0_RESET_MASK (_MK_MASK_CONST(0x3))
+#define BDMA_CFG_CMD_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_CMD_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_CMD_0_READ_MASK (_MK_MASK_CONST(0x3))
+#define BDMA_CFG_CMD_0_WRITE_MASK (_MK_MASK_CONST(0x3))
+#define BDMA_CFG_CMD_0_SRC_RAM_TYPE_SHIFT (_MK_SHIFT_CONST(0))
+#define BDMA_CFG_CMD_0_SRC_RAM_TYPE_FIELD \
+	(_MK_FIELD_CONST(0x1, BDMA_CFG_CMD_0_SRC_RAM_TYPE_SHIFT))
+#define BDMA_CFG_CMD_0_SRC_RAM_TYPE_RANGE (0 : 0)
+#define BDMA_CFG_CMD_0_SRC_RAM_TYPE_WOFFSET (0x0)
+#define BDMA_CFG_CMD_0_SRC_RAM_TYPE_DEFAULT (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_CMD_0_SRC_RAM_TYPE_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define BDMA_CFG_CMD_0_SRC_RAM_TYPE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_CMD_0_SRC_RAM_TYPE_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_CMD_0_SRC_RAM_TYPE_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_CMD_0_SRC_RAM_TYPE_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define BDMA_CFG_CMD_0_SRC_RAM_TYPE_CVSRAM (_MK_ENUM_CONST(0))
+#define BDMA_CFG_CMD_0_SRC_RAM_TYPE_MC (_MK_ENUM_CONST(1))
+
+#define BDMA_CFG_CMD_0_DST_RAM_TYPE_SHIFT (_MK_SHIFT_CONST(1))
+#define BDMA_CFG_CMD_0_DST_RAM_TYPE_FIELD \
+	(_MK_FIELD_CONST(0x1, BDMA_CFG_CMD_0_DST_RAM_TYPE_SHIFT))
+#define BDMA_CFG_CMD_0_DST_RAM_TYPE_RANGE (1 : 1)
+#define BDMA_CFG_CMD_0_DST_RAM_TYPE_WOFFSET (0x0)
+#define BDMA_CFG_CMD_0_DST_RAM_TYPE_DEFAULT (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_CMD_0_DST_RAM_TYPE_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define BDMA_CFG_CMD_0_DST_RAM_TYPE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_CMD_0_DST_RAM_TYPE_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_CMD_0_DST_RAM_TYPE_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_CMD_0_DST_RAM_TYPE_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define BDMA_CFG_CMD_0_DST_RAM_TYPE_CVSRAM (_MK_ENUM_CONST(0))
+#define BDMA_CFG_CMD_0_DST_RAM_TYPE_MC (_MK_ENUM_CONST(1))
+
+// Register BDMA_CFG_LINE_REPEAT_0
+#define BDMA_CFG_LINE_REPEAT_0 (_MK_ADDR_CONST(0x4018))
+#define BDMA_CFG_LINE_REPEAT_0_SECURE (0x0)
+#define BDMA_CFG_LINE_REPEAT_0_DUAL (0x0)
+#define BDMA_CFG_LINE_REPEAT_0_SCR (0)
+#define BDMA_CFG_LINE_REPEAT_0_WORD_COUNT (0x1)
+#define BDMA_CFG_LINE_REPEAT_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_LINE_REPEAT_0_RESET_MASK (_MK_MASK_CONST(0xffffff))
+#define BDMA_CFG_LINE_REPEAT_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_LINE_REPEAT_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_LINE_REPEAT_0_READ_MASK (_MK_MASK_CONST(0xffffff))
+#define BDMA_CFG_LINE_REPEAT_0_WRITE_MASK (_MK_MASK_CONST(0xffffff))
+#define BDMA_CFG_LINE_REPEAT_0_NUMBER_SHIFT (_MK_SHIFT_CONST(0))
+#define BDMA_CFG_LINE_REPEAT_0_NUMBER_FIELD \
+	(_MK_FIELD_CONST(0xffffff, BDMA_CFG_LINE_REPEAT_0_NUMBER_SHIFT))
+#define BDMA_CFG_LINE_REPEAT_0_NUMBER_RANGE (23 : 0)
+#define BDMA_CFG_LINE_REPEAT_0_NUMBER_WOFFSET (0x0)
+#define BDMA_CFG_LINE_REPEAT_0_NUMBER_DEFAULT (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_LINE_REPEAT_0_NUMBER_DEFAULT_MASK (_MK_MASK_CONST(0xffffff))
+#define BDMA_CFG_LINE_REPEAT_0_NUMBER_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_LINE_REPEAT_0_NUMBER_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_LINE_REPEAT_0_NUMBER_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_LINE_REPEAT_0_NUMBER_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+// Register BDMA_CFG_SRC_LINE_0
+#define BDMA_CFG_SRC_LINE_0 (_MK_ADDR_CONST(0x401c))
+#define BDMA_CFG_SRC_LINE_0_SECURE (0x0)
+#define BDMA_CFG_SRC_LINE_0_DUAL (0x0)
+#define BDMA_CFG_SRC_LINE_0_SCR (0)
+#define BDMA_CFG_SRC_LINE_0_WORD_COUNT (0x1)
+#define BDMA_CFG_SRC_LINE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_SRC_LINE_0_RESET_MASK (_MK_MASK_CONST(0xffffffe0))
+#define BDMA_CFG_SRC_LINE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_SRC_LINE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_SRC_LINE_0_READ_MASK (_MK_MASK_CONST(0xffffffe0))
+#define BDMA_CFG_SRC_LINE_0_WRITE_MASK (_MK_MASK_CONST(0xffffffe0))
+#define BDMA_CFG_SRC_LINE_0_STRIDE_SHIFT (_MK_SHIFT_CONST(5))
+#define BDMA_CFG_SRC_LINE_0_STRIDE_FIELD \
+	(_MK_FIELD_CONST(0x7ffffff, BDMA_CFG_SRC_LINE_0_STRIDE_SHIFT))
+#define BDMA_CFG_SRC_LINE_0_STRIDE_RANGE (31 : 5)
+#define BDMA_CFG_SRC_LINE_0_STRIDE_WOFFSET (0x0)
+#define BDMA_CFG_SRC_LINE_0_STRIDE_DEFAULT (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_SRC_LINE_0_STRIDE_DEFAULT_MASK (_MK_MASK_CONST(0x7ffffff))
+#define BDMA_CFG_SRC_LINE_0_STRIDE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_SRC_LINE_0_STRIDE_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_SRC_LINE_0_STRIDE_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_SRC_LINE_0_STRIDE_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+// Register BDMA_CFG_DST_LINE_0
+#define BDMA_CFG_DST_LINE_0 (_MK_ADDR_CONST(0x4020))
+#define BDMA_CFG_DST_LINE_0_SECURE (0x0)
+#define BDMA_CFG_DST_LINE_0_DUAL (0x0)
+#define BDMA_CFG_DST_LINE_0_SCR (0)
+#define BDMA_CFG_DST_LINE_0_WORD_COUNT (0x1)
+#define BDMA_CFG_DST_LINE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_DST_LINE_0_RESET_MASK (_MK_MASK_CONST(0xffffffe0))
+#define BDMA_CFG_DST_LINE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_DST_LINE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_DST_LINE_0_READ_MASK (_MK_MASK_CONST(0xffffffe0))
+#define BDMA_CFG_DST_LINE_0_WRITE_MASK (_MK_MASK_CONST(0xffffffe0))
+#define BDMA_CFG_DST_LINE_0_STRIDE_SHIFT (_MK_SHIFT_CONST(5))
+#define BDMA_CFG_DST_LINE_0_STRIDE_FIELD \
+	(_MK_FIELD_CONST(0x7ffffff, BDMA_CFG_DST_LINE_0_STRIDE_SHIFT))
+#define BDMA_CFG_DST_LINE_0_STRIDE_RANGE (31 : 5)
+#define BDMA_CFG_DST_LINE_0_STRIDE_WOFFSET (0x0)
+#define BDMA_CFG_DST_LINE_0_STRIDE_DEFAULT (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_DST_LINE_0_STRIDE_DEFAULT_MASK (_MK_MASK_CONST(0x7ffffff))
+#define BDMA_CFG_DST_LINE_0_STRIDE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_DST_LINE_0_STRIDE_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_DST_LINE_0_STRIDE_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_DST_LINE_0_STRIDE_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+// Register BDMA_CFG_SURF_REPEAT_0
+#define BDMA_CFG_SURF_REPEAT_0 (_MK_ADDR_CONST(0x4024))
+#define BDMA_CFG_SURF_REPEAT_0_SECURE (0x0)
+#define BDMA_CFG_SURF_REPEAT_0_DUAL (0x0)
+#define BDMA_CFG_SURF_REPEAT_0_SCR (0)
+#define BDMA_CFG_SURF_REPEAT_0_WORD_COUNT (0x1)
+#define BDMA_CFG_SURF_REPEAT_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_SURF_REPEAT_0_RESET_MASK (_MK_MASK_CONST(0xffffff))
+#define BDMA_CFG_SURF_REPEAT_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_SURF_REPEAT_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_SURF_REPEAT_0_READ_MASK (_MK_MASK_CONST(0xffffff))
+#define BDMA_CFG_SURF_REPEAT_0_WRITE_MASK (_MK_MASK_CONST(0xffffff))
+#define BDMA_CFG_SURF_REPEAT_0_NUMBER_SHIFT (_MK_SHIFT_CONST(0))
+#define BDMA_CFG_SURF_REPEAT_0_NUMBER_FIELD \
+	(_MK_FIELD_CONST(0xffffff, BDMA_CFG_SURF_REPEAT_0_NUMBER_SHIFT))
+#define BDMA_CFG_SURF_REPEAT_0_NUMBER_RANGE (23 : 0)
+#define BDMA_CFG_SURF_REPEAT_0_NUMBER_WOFFSET (0x0)
+#define BDMA_CFG_SURF_REPEAT_0_NUMBER_DEFAULT (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_SURF_REPEAT_0_NUMBER_DEFAULT_MASK (_MK_MASK_CONST(0xffffff))
+#define BDMA_CFG_SURF_REPEAT_0_NUMBER_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_SURF_REPEAT_0_NUMBER_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_SURF_REPEAT_0_NUMBER_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_SURF_REPEAT_0_NUMBER_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+// Register BDMA_CFG_SRC_SURF_0
+#define BDMA_CFG_SRC_SURF_0 (_MK_ADDR_CONST(0x4028))
+#define BDMA_CFG_SRC_SURF_0_SECURE (0x0)
+#define BDMA_CFG_SRC_SURF_0_DUAL (0x0)
+#define BDMA_CFG_SRC_SURF_0_SCR (0)
+#define BDMA_CFG_SRC_SURF_0_WORD_COUNT (0x1)
+#define BDMA_CFG_SRC_SURF_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_SRC_SURF_0_RESET_MASK (_MK_MASK_CONST(0xffffffe0))
+#define BDMA_CFG_SRC_SURF_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_SRC_SURF_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_SRC_SURF_0_READ_MASK (_MK_MASK_CONST(0xffffffe0))
+#define BDMA_CFG_SRC_SURF_0_WRITE_MASK (_MK_MASK_CONST(0xffffffe0))
+#define BDMA_CFG_SRC_SURF_0_STRIDE_SHIFT (_MK_SHIFT_CONST(5))
+#define BDMA_CFG_SRC_SURF_0_STRIDE_FIELD \
+	(_MK_FIELD_CONST(0x7ffffff, BDMA_CFG_SRC_SURF_0_STRIDE_SHIFT))
+#define BDMA_CFG_SRC_SURF_0_STRIDE_RANGE (31 : 5)
+#define BDMA_CFG_SRC_SURF_0_STRIDE_WOFFSET (0x0)
+#define BDMA_CFG_SRC_SURF_0_STRIDE_DEFAULT (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_SRC_SURF_0_STRIDE_DEFAULT_MASK (_MK_MASK_CONST(0x7ffffff))
+#define BDMA_CFG_SRC_SURF_0_STRIDE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_SRC_SURF_0_STRIDE_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_SRC_SURF_0_STRIDE_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_SRC_SURF_0_STRIDE_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+// Register BDMA_CFG_DST_SURF_0
+#define BDMA_CFG_DST_SURF_0 (_MK_ADDR_CONST(0x402c))
+#define BDMA_CFG_DST_SURF_0_SECURE (0x0)
+#define BDMA_CFG_DST_SURF_0_DUAL (0x0)
+#define BDMA_CFG_DST_SURF_0_SCR (0)
+#define BDMA_CFG_DST_SURF_0_WORD_COUNT (0x1)
+#define BDMA_CFG_DST_SURF_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_DST_SURF_0_RESET_MASK (_MK_MASK_CONST(0xffffffe0))
+#define BDMA_CFG_DST_SURF_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_DST_SURF_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_DST_SURF_0_READ_MASK (_MK_MASK_CONST(0xffffffe0))
+#define BDMA_CFG_DST_SURF_0_WRITE_MASK (_MK_MASK_CONST(0xffffffe0))
+#define BDMA_CFG_DST_SURF_0_STRIDE_SHIFT (_MK_SHIFT_CONST(5))
+#define BDMA_CFG_DST_SURF_0_STRIDE_FIELD \
+	(_MK_FIELD_CONST(0x7ffffff, BDMA_CFG_DST_SURF_0_STRIDE_SHIFT))
+#define BDMA_CFG_DST_SURF_0_STRIDE_RANGE (31 : 5)
+#define BDMA_CFG_DST_SURF_0_STRIDE_WOFFSET (0x0)
+#define BDMA_CFG_DST_SURF_0_STRIDE_DEFAULT (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_DST_SURF_0_STRIDE_DEFAULT_MASK (_MK_MASK_CONST(0x7ffffff))
+#define BDMA_CFG_DST_SURF_0_STRIDE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_DST_SURF_0_STRIDE_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_DST_SURF_0_STRIDE_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_DST_SURF_0_STRIDE_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+// Register BDMA_CFG_OP_0
+#define BDMA_CFG_OP_0 (_MK_ADDR_CONST(0x4030))
+#define BDMA_CFG_OP_0_SECURE (0x0)
+#define BDMA_CFG_OP_0_DUAL (0x0)
+#define BDMA_CFG_OP_0_SCR (0)
+#define BDMA_CFG_OP_0_WORD_COUNT (0x1)
+#define BDMA_CFG_OP_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_OP_0_RESET_MASK (_MK_MASK_CONST(0x1))
+#define BDMA_CFG_OP_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_OP_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_OP_0_READ_MASK (_MK_MASK_CONST(0x1))
+#define BDMA_CFG_OP_0_WRITE_MASK (_MK_MASK_CONST(0x1))
+#define BDMA_CFG_OP_0_EN_SHIFT (_MK_SHIFT_CONST(0))
+#define BDMA_CFG_OP_0_EN_FIELD (_MK_FIELD_CONST(0x1, BDMA_CFG_OP_0_EN_SHIFT))
+#define BDMA_CFG_OP_0_EN_RANGE (0 : 0)
+#define BDMA_CFG_OP_0_EN_WOFFSET (0x0)
+#define BDMA_CFG_OP_0_EN_DEFAULT (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_OP_0_EN_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define BDMA_CFG_OP_0_EN_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_OP_0_EN_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_OP_0_EN_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_OP_0_EN_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define BDMA_CFG_OP_0_EN_DISABLE (_MK_ENUM_CONST(0))
+#define BDMA_CFG_OP_0_EN_ENABLE (_MK_ENUM_CONST(1))
+
+// Register BDMA_CFG_LAUNCH0_0
+#define BDMA_CFG_LAUNCH0_0 (_MK_ADDR_CONST(0x4034))
+#define BDMA_CFG_LAUNCH0_0_SECURE (0x0)
+#define BDMA_CFG_LAUNCH0_0_DUAL (0x0)
+#define BDMA_CFG_LAUNCH0_0_SCR (0)
+#define BDMA_CFG_LAUNCH0_0_WORD_COUNT (0x1)
+#define BDMA_CFG_LAUNCH0_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_LAUNCH0_0_RESET_MASK (_MK_MASK_CONST(0x1))
+#define BDMA_CFG_LAUNCH0_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_LAUNCH0_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_LAUNCH0_0_READ_MASK (_MK_MASK_CONST(0x1))
+#define BDMA_CFG_LAUNCH0_0_WRITE_MASK (_MK_MASK_CONST(0x1))
+#define BDMA_CFG_LAUNCH0_0_GRP0_LAUNCH_SHIFT (_MK_SHIFT_CONST(0))
+#define BDMA_CFG_LAUNCH0_0_GRP0_LAUNCH_FIELD \
+	(_MK_FIELD_CONST(0x1, BDMA_CFG_LAUNCH0_0_GRP0_LAUNCH_SHIFT))
+#define BDMA_CFG_LAUNCH0_0_GRP0_LAUNCH_RANGE (0 : 0)
+#define BDMA_CFG_LAUNCH0_0_GRP0_LAUNCH_WOFFSET (0x0)
+#define BDMA_CFG_LAUNCH0_0_GRP0_LAUNCH_DEFAULT (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_LAUNCH0_0_GRP0_LAUNCH_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define BDMA_CFG_LAUNCH0_0_GRP0_LAUNCH_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_LAUNCH0_0_GRP0_LAUNCH_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_LAUNCH0_0_GRP0_LAUNCH_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_LAUNCH0_0_GRP0_LAUNCH_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define BDMA_CFG_LAUNCH0_0_GRP0_LAUNCH_NO (_MK_ENUM_CONST(0))
+#define BDMA_CFG_LAUNCH0_0_GRP0_LAUNCH_YES (_MK_ENUM_CONST(1))
+
+// Register BDMA_CFG_LAUNCH1_0
+#define BDMA_CFG_LAUNCH1_0 (_MK_ADDR_CONST(0x4038))
+#define BDMA_CFG_LAUNCH1_0_SECURE (0x0)
+#define BDMA_CFG_LAUNCH1_0_DUAL (0x0)
+#define BDMA_CFG_LAUNCH1_0_SCR (0)
+#define BDMA_CFG_LAUNCH1_0_WORD_COUNT (0x1)
+#define BDMA_CFG_LAUNCH1_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_LAUNCH1_0_RESET_MASK (_MK_MASK_CONST(0x1))
+#define BDMA_CFG_LAUNCH1_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_LAUNCH1_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_LAUNCH1_0_READ_MASK (_MK_MASK_CONST(0x1))
+#define BDMA_CFG_LAUNCH1_0_WRITE_MASK (_MK_MASK_CONST(0x1))
+#define BDMA_CFG_LAUNCH1_0_GRP1_LAUNCH_SHIFT (_MK_SHIFT_CONST(0))
+#define BDMA_CFG_LAUNCH1_0_GRP1_LAUNCH_FIELD \
+	(_MK_FIELD_CONST(0x1, BDMA_CFG_LAUNCH1_0_GRP1_LAUNCH_SHIFT))
+#define BDMA_CFG_LAUNCH1_0_GRP1_LAUNCH_RANGE (0 : 0)
+#define BDMA_CFG_LAUNCH1_0_GRP1_LAUNCH_WOFFSET (0x0)
+#define BDMA_CFG_LAUNCH1_0_GRP1_LAUNCH_DEFAULT (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_LAUNCH1_0_GRP1_LAUNCH_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define BDMA_CFG_LAUNCH1_0_GRP1_LAUNCH_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_LAUNCH1_0_GRP1_LAUNCH_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_LAUNCH1_0_GRP1_LAUNCH_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_LAUNCH1_0_GRP1_LAUNCH_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define BDMA_CFG_LAUNCH1_0_GRP1_LAUNCH_NO (_MK_ENUM_CONST(0))
+#define BDMA_CFG_LAUNCH1_0_GRP1_LAUNCH_YES (_MK_ENUM_CONST(1))
+
+// Register BDMA_CFG_STATUS_0
+#define BDMA_CFG_STATUS_0 (_MK_ADDR_CONST(0x403c))
+#define BDMA_CFG_STATUS_0_SECURE (0x0)
+#define BDMA_CFG_STATUS_0_DUAL (0x0)
+#define BDMA_CFG_STATUS_0_SCR (0)
+#define BDMA_CFG_STATUS_0_WORD_COUNT (0x1)
+#define BDMA_CFG_STATUS_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_STATUS_0_RESET_MASK (_MK_MASK_CONST(0x1))
+#define BDMA_CFG_STATUS_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_STATUS_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_STATUS_0_READ_MASK (_MK_MASK_CONST(0x1))
+#define BDMA_CFG_STATUS_0_WRITE_MASK (_MK_MASK_CONST(0x1))
+#define BDMA_CFG_STATUS_0_STALL_COUNT_EN_SHIFT (_MK_SHIFT_CONST(0))
+#define BDMA_CFG_STATUS_0_STALL_COUNT_EN_FIELD \
+	(_MK_FIELD_CONST(0x1, BDMA_CFG_STATUS_0_STALL_COUNT_EN_SHIFT))
+#define BDMA_CFG_STATUS_0_STALL_COUNT_EN_RANGE (0 : 0)
+#define BDMA_CFG_STATUS_0_STALL_COUNT_EN_WOFFSET (0x0)
+#define BDMA_CFG_STATUS_0_STALL_COUNT_EN_DEFAULT (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_STATUS_0_STALL_COUNT_EN_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define BDMA_CFG_STATUS_0_STALL_COUNT_EN_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_STATUS_0_STALL_COUNT_EN_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_STATUS_0_STALL_COUNT_EN_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define BDMA_CFG_STATUS_0_STALL_COUNT_EN_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define BDMA_CFG_STATUS_0_STALL_COUNT_EN_INIT_ENUM (NO)
+#define BDMA_CFG_STATUS_0_STALL_COUNT_EN_NO (_MK_ENUM_CONST(0))
+#define BDMA_CFG_STATUS_0_STALL_COUNT_EN_YES (_MK_ENUM_CONST(1))
+
+// Register BDMA_STATUS_0
+#define BDMA_STATUS_0 (_MK_ADDR_CONST(0x4040))
+#define BDMA_STATUS_0_SECURE (0x0)
+#define BDMA_STATUS_0_DUAL (0x0)
+#define BDMA_STATUS_0_SCR (0)
+#define BDMA_STATUS_0_WORD_COUNT (0x1)
+#define BDMA_STATUS_0_RESET_VAL (_MK_MASK_CONST(0x114))
+#define BDMA_STATUS_0_RESET_MASK (_MK_MASK_CONST(0x7ff))
+#define BDMA_STATUS_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define BDMA_STATUS_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define BDMA_STATUS_0_READ_MASK (_MK_MASK_CONST(0x7ff))
+#define BDMA_STATUS_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define BDMA_STATUS_0_FREE_SLOT_SHIFT (_MK_SHIFT_CONST(0))
+#define BDMA_STATUS_0_FREE_SLOT_FIELD \
+	(_MK_FIELD_CONST(0xff, BDMA_STATUS_0_FREE_SLOT_SHIFT))
+#define BDMA_STATUS_0_FREE_SLOT_RANGE (7 : 0)
+#define BDMA_STATUS_0_FREE_SLOT_WOFFSET (0x0)
+#define BDMA_STATUS_0_FREE_SLOT_DEFAULT (_MK_MASK_CONST(0x14))
+#define BDMA_STATUS_0_FREE_SLOT_DEFAULT_MASK (_MK_MASK_CONST(0xff))
+#define BDMA_STATUS_0_FREE_SLOT_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define BDMA_STATUS_0_FREE_SLOT_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define BDMA_STATUS_0_FREE_SLOT_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define BDMA_STATUS_0_FREE_SLOT_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+#define BDMA_STATUS_0_IDLE_SHIFT (_MK_SHIFT_CONST(8))
+#define BDMA_STATUS_0_IDLE_FIELD \
+	(_MK_FIELD_CONST(0x1, BDMA_STATUS_0_IDLE_SHIFT))
+#define BDMA_STATUS_0_IDLE_RANGE (8 : 8)
+#define BDMA_STATUS_0_IDLE_WOFFSET (0x0)
+#define BDMA_STATUS_0_IDLE_DEFAULT (_MK_MASK_CONST(0x1))
+#define BDMA_STATUS_0_IDLE_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define BDMA_STATUS_0_IDLE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define BDMA_STATUS_0_IDLE_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define BDMA_STATUS_0_IDLE_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define BDMA_STATUS_0_IDLE_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define BDMA_STATUS_0_IDLE_INIT_ENUM (YES)
+#define BDMA_STATUS_0_IDLE_NO (_MK_ENUM_CONST(0))
+#define BDMA_STATUS_0_IDLE_YES (_MK_ENUM_CONST(1))
+
+#define BDMA_STATUS_0_GRP0_BUSY_SHIFT (_MK_SHIFT_CONST(9))
+#define BDMA_STATUS_0_GRP0_BUSY_FIELD \
+	(_MK_FIELD_CONST(0x1, BDMA_STATUS_0_GRP0_BUSY_SHIFT))
+#define BDMA_STATUS_0_GRP0_BUSY_RANGE (9 : 9)
+#define BDMA_STATUS_0_GRP0_BUSY_WOFFSET (0x0)
+#define BDMA_STATUS_0_GRP0_BUSY_DEFAULT (_MK_MASK_CONST(0x0))
+#define BDMA_STATUS_0_GRP0_BUSY_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define BDMA_STATUS_0_GRP0_BUSY_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define BDMA_STATUS_0_GRP0_BUSY_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define BDMA_STATUS_0_GRP0_BUSY_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define BDMA_STATUS_0_GRP0_BUSY_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define BDMA_STATUS_0_GRP0_BUSY_INIT_ENUM (NO)
+#define BDMA_STATUS_0_GRP0_BUSY_NO (_MK_ENUM_CONST(0))
+#define BDMA_STATUS_0_GRP0_BUSY_YES (_MK_ENUM_CONST(1))
+
+#define BDMA_STATUS_0_GRP1_BUSY_SHIFT (_MK_SHIFT_CONST(10))
+#define BDMA_STATUS_0_GRP1_BUSY_FIELD \
+	(_MK_FIELD_CONST(0x1, BDMA_STATUS_0_GRP1_BUSY_SHIFT))
+#define BDMA_STATUS_0_GRP1_BUSY_RANGE (10 : 10)
+#define BDMA_STATUS_0_GRP1_BUSY_WOFFSET (0x0)
+#define BDMA_STATUS_0_GRP1_BUSY_DEFAULT (_MK_MASK_CONST(0x0))
+#define BDMA_STATUS_0_GRP1_BUSY_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define BDMA_STATUS_0_GRP1_BUSY_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define BDMA_STATUS_0_GRP1_BUSY_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define BDMA_STATUS_0_GRP1_BUSY_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define BDMA_STATUS_0_GRP1_BUSY_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define BDMA_STATUS_0_GRP1_BUSY_INIT_ENUM (NO)
+#define BDMA_STATUS_0_GRP1_BUSY_NO (_MK_ENUM_CONST(0))
+#define BDMA_STATUS_0_GRP1_BUSY_YES (_MK_ENUM_CONST(1))
+
+// Register BDMA_STATUS_GRP0_READ_STALL_0
+#define BDMA_STATUS_GRP0_READ_STALL_0 (_MK_ADDR_CONST(0x4044))
+#define BDMA_STATUS_GRP0_READ_STALL_0_SECURE (0x0)
+#define BDMA_STATUS_GRP0_READ_STALL_0_DUAL (0x0)
+#define BDMA_STATUS_GRP0_READ_STALL_0_SCR (0)
+#define BDMA_STATUS_GRP0_READ_STALL_0_WORD_COUNT (0x1)
+#define BDMA_STATUS_GRP0_READ_STALL_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define BDMA_STATUS_GRP0_READ_STALL_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define BDMA_STATUS_GRP0_READ_STALL_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define BDMA_STATUS_GRP0_READ_STALL_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define BDMA_STATUS_GRP0_READ_STALL_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define BDMA_STATUS_GRP0_READ_STALL_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define BDMA_STATUS_GRP0_READ_STALL_0_COUNT_SHIFT (_MK_SHIFT_CONST(0))
+#define BDMA_STATUS_GRP0_READ_STALL_0_COUNT_FIELD \
+	(_MK_FIELD_CONST(0xffffffff, BDMA_STATUS_GRP0_READ_STALL_0_COUNT_SHIFT))
+#define BDMA_STATUS_GRP0_READ_STALL_0_COUNT_RANGE (31 : 0)
+#define BDMA_STATUS_GRP0_READ_STALL_0_COUNT_WOFFSET (0x0)
+#define BDMA_STATUS_GRP0_READ_STALL_0_COUNT_DEFAULT (_MK_MASK_CONST(0x0))
+#define BDMA_STATUS_GRP0_READ_STALL_0_COUNT_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define BDMA_STATUS_GRP0_READ_STALL_0_COUNT_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define BDMA_STATUS_GRP0_READ_STALL_0_COUNT_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define BDMA_STATUS_GRP0_READ_STALL_0_COUNT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define BDMA_STATUS_GRP0_READ_STALL_0_COUNT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register BDMA_STATUS_GRP0_WRITE_STALL_0
+#define BDMA_STATUS_GRP0_WRITE_STALL_0 (_MK_ADDR_CONST(0x4048))
+#define BDMA_STATUS_GRP0_WRITE_STALL_0_SECURE (0x0)
+#define BDMA_STATUS_GRP0_WRITE_STALL_0_DUAL (0x0)
+#define BDMA_STATUS_GRP0_WRITE_STALL_0_SCR (0)
+#define BDMA_STATUS_GRP0_WRITE_STALL_0_WORD_COUNT (0x1)
+#define BDMA_STATUS_GRP0_WRITE_STALL_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define BDMA_STATUS_GRP0_WRITE_STALL_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define BDMA_STATUS_GRP0_WRITE_STALL_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define BDMA_STATUS_GRP0_WRITE_STALL_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define BDMA_STATUS_GRP0_WRITE_STALL_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define BDMA_STATUS_GRP0_WRITE_STALL_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define BDMA_STATUS_GRP0_WRITE_STALL_0_COUNT_SHIFT (_MK_SHIFT_CONST(0))
+#define BDMA_STATUS_GRP0_WRITE_STALL_0_COUNT_FIELD \
+	(_MK_FIELD_CONST(0xffffffff,               \
+			 BDMA_STATUS_GRP0_WRITE_STALL_0_COUNT_SHIFT))
+#define BDMA_STATUS_GRP0_WRITE_STALL_0_COUNT_RANGE (31 : 0)
+#define BDMA_STATUS_GRP0_WRITE_STALL_0_COUNT_WOFFSET (0x0)
+#define BDMA_STATUS_GRP0_WRITE_STALL_0_COUNT_DEFAULT (_MK_MASK_CONST(0x0))
+#define BDMA_STATUS_GRP0_WRITE_STALL_0_COUNT_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define BDMA_STATUS_GRP0_WRITE_STALL_0_COUNT_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define BDMA_STATUS_GRP0_WRITE_STALL_0_COUNT_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define BDMA_STATUS_GRP0_WRITE_STALL_0_COUNT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define BDMA_STATUS_GRP0_WRITE_STALL_0_COUNT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register BDMA_STATUS_GRP1_READ_STALL_0
+#define BDMA_STATUS_GRP1_READ_STALL_0 (_MK_ADDR_CONST(0x404c))
+#define BDMA_STATUS_GRP1_READ_STALL_0_SECURE (0x0)
+#define BDMA_STATUS_GRP1_READ_STALL_0_DUAL (0x0)
+#define BDMA_STATUS_GRP1_READ_STALL_0_SCR (0)
+#define BDMA_STATUS_GRP1_READ_STALL_0_WORD_COUNT (0x1)
+#define BDMA_STATUS_GRP1_READ_STALL_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define BDMA_STATUS_GRP1_READ_STALL_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define BDMA_STATUS_GRP1_READ_STALL_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define BDMA_STATUS_GRP1_READ_STALL_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define BDMA_STATUS_GRP1_READ_STALL_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define BDMA_STATUS_GRP1_READ_STALL_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define BDMA_STATUS_GRP1_READ_STALL_0_COUNT_SHIFT (_MK_SHIFT_CONST(0))
+#define BDMA_STATUS_GRP1_READ_STALL_0_COUNT_FIELD \
+	(_MK_FIELD_CONST(0xffffffff, BDMA_STATUS_GRP1_READ_STALL_0_COUNT_SHIFT))
+#define BDMA_STATUS_GRP1_READ_STALL_0_COUNT_RANGE (31 : 0)
+#define BDMA_STATUS_GRP1_READ_STALL_0_COUNT_WOFFSET (0x0)
+#define BDMA_STATUS_GRP1_READ_STALL_0_COUNT_DEFAULT (_MK_MASK_CONST(0x0))
+#define BDMA_STATUS_GRP1_READ_STALL_0_COUNT_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define BDMA_STATUS_GRP1_READ_STALL_0_COUNT_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define BDMA_STATUS_GRP1_READ_STALL_0_COUNT_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define BDMA_STATUS_GRP1_READ_STALL_0_COUNT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define BDMA_STATUS_GRP1_READ_STALL_0_COUNT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register BDMA_STATUS_GRP1_WRITE_STALL_0
+#define BDMA_STATUS_GRP1_WRITE_STALL_0 (_MK_ADDR_CONST(0x4050))
+#define BDMA_STATUS_GRP1_WRITE_STALL_0_SECURE (0x0)
+#define BDMA_STATUS_GRP1_WRITE_STALL_0_DUAL (0x0)
+#define BDMA_STATUS_GRP1_WRITE_STALL_0_SCR (0)
+#define BDMA_STATUS_GRP1_WRITE_STALL_0_WORD_COUNT (0x1)
+#define BDMA_STATUS_GRP1_WRITE_STALL_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define BDMA_STATUS_GRP1_WRITE_STALL_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define BDMA_STATUS_GRP1_WRITE_STALL_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define BDMA_STATUS_GRP1_WRITE_STALL_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define BDMA_STATUS_GRP1_WRITE_STALL_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define BDMA_STATUS_GRP1_WRITE_STALL_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define BDMA_STATUS_GRP1_WRITE_STALL_0_COUNT_SHIFT (_MK_SHIFT_CONST(0))
+#define BDMA_STATUS_GRP1_WRITE_STALL_0_COUNT_FIELD \
+	(_MK_FIELD_CONST(0xffffffff,               \
+			 BDMA_STATUS_GRP1_WRITE_STALL_0_COUNT_SHIFT))
+#define BDMA_STATUS_GRP1_WRITE_STALL_0_COUNT_RANGE (31 : 0)
+#define BDMA_STATUS_GRP1_WRITE_STALL_0_COUNT_WOFFSET (0x0)
+#define BDMA_STATUS_GRP1_WRITE_STALL_0_COUNT_DEFAULT (_MK_MASK_CONST(0x0))
+#define BDMA_STATUS_GRP1_WRITE_STALL_0_COUNT_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define BDMA_STATUS_GRP1_WRITE_STALL_0_COUNT_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define BDMA_STATUS_GRP1_WRITE_STALL_0_COUNT_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define BDMA_STATUS_GRP1_WRITE_STALL_0_COUNT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define BDMA_STATUS_GRP1_WRITE_STALL_0_COUNT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDMA_S_STATUS_0
+#define CDMA_S_STATUS_0 (_MK_ADDR_CONST(0x5000))
+#define CDMA_S_STATUS_0_SECURE (0x0)
+#define CDMA_S_STATUS_0_DUAL (0x0)
+#define CDMA_S_STATUS_0_SCR (0)
+#define CDMA_S_STATUS_0_WORD_COUNT (0x1)
+#define CDMA_S_STATUS_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_S_STATUS_0_RESET_MASK (_MK_MASK_CONST(0x30003))
+#define CDMA_S_STATUS_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_S_STATUS_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_S_STATUS_0_READ_MASK (_MK_MASK_CONST(0x30003))
+#define CDMA_S_STATUS_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_S_STATUS_0_STATUS_0_SHIFT (_MK_SHIFT_CONST(0))
+#define CDMA_S_STATUS_0_STATUS_0_FIELD \
+	(_MK_FIELD_CONST(0x3, CDMA_S_STATUS_0_STATUS_0_SHIFT))
+#define CDMA_S_STATUS_0_STATUS_0_RANGE (1 : 0)
+#define CDMA_S_STATUS_0_STATUS_0_WOFFSET (0x0)
+#define CDMA_S_STATUS_0_STATUS_0_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_S_STATUS_0_STATUS_0_DEFAULT_MASK (_MK_MASK_CONST(0x3))
+#define CDMA_S_STATUS_0_STATUS_0_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_S_STATUS_0_STATUS_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_S_STATUS_0_STATUS_0_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDMA_S_STATUS_0_STATUS_0_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define CDMA_S_STATUS_0_STATUS_0_INIT_ENUM (IDLE)
+#define CDMA_S_STATUS_0_STATUS_0_IDLE (_MK_ENUM_CONST(0))
+#define CDMA_S_STATUS_0_STATUS_0_RUNNING (_MK_ENUM_CONST(1))
+#define CDMA_S_STATUS_0_STATUS_0_PENDING (_MK_ENUM_CONST(2))
+
+#define CDMA_S_STATUS_0_STATUS_1_SHIFT (_MK_SHIFT_CONST(16))
+#define CDMA_S_STATUS_0_STATUS_1_FIELD \
+	(_MK_FIELD_CONST(0x3, CDMA_S_STATUS_0_STATUS_1_SHIFT))
+#define CDMA_S_STATUS_0_STATUS_1_RANGE (17 : 16)
+#define CDMA_S_STATUS_0_STATUS_1_WOFFSET (0x0)
+#define CDMA_S_STATUS_0_STATUS_1_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_S_STATUS_0_STATUS_1_DEFAULT_MASK (_MK_MASK_CONST(0x3))
+#define CDMA_S_STATUS_0_STATUS_1_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_S_STATUS_0_STATUS_1_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_S_STATUS_0_STATUS_1_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDMA_S_STATUS_0_STATUS_1_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define CDMA_S_STATUS_0_STATUS_1_INIT_ENUM (IDLE)
+#define CDMA_S_STATUS_0_STATUS_1_IDLE (_MK_ENUM_CONST(0))
+#define CDMA_S_STATUS_0_STATUS_1_RUNNING (_MK_ENUM_CONST(1))
+#define CDMA_S_STATUS_0_STATUS_1_PENDING (_MK_ENUM_CONST(2))
+
+// Register CDMA_S_POINTER_0
+#define CDMA_S_POINTER_0 (_MK_ADDR_CONST(0x5004))
+#define CDMA_S_POINTER_0_SECURE (0x0)
+#define CDMA_S_POINTER_0_DUAL (0x0)
+#define CDMA_S_POINTER_0_SCR (0)
+#define CDMA_S_POINTER_0_WORD_COUNT (0x1)
+#define CDMA_S_POINTER_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_S_POINTER_0_RESET_MASK (_MK_MASK_CONST(0x10001))
+#define CDMA_S_POINTER_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_S_POINTER_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_S_POINTER_0_READ_MASK (_MK_MASK_CONST(0x10001))
+#define CDMA_S_POINTER_0_WRITE_MASK (_MK_MASK_CONST(0x1))
+#define CDMA_S_POINTER_0_PRODUCER_SHIFT (_MK_SHIFT_CONST(0))
+#define CDMA_S_POINTER_0_PRODUCER_FIELD \
+	(_MK_FIELD_CONST(0x1, CDMA_S_POINTER_0_PRODUCER_SHIFT))
+#define CDMA_S_POINTER_0_PRODUCER_RANGE (0 : 0)
+#define CDMA_S_POINTER_0_PRODUCER_WOFFSET (0x0)
+#define CDMA_S_POINTER_0_PRODUCER_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_S_POINTER_0_PRODUCER_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CDMA_S_POINTER_0_PRODUCER_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_S_POINTER_0_PRODUCER_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_S_POINTER_0_PRODUCER_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDMA_S_POINTER_0_PRODUCER_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define CDMA_S_POINTER_0_PRODUCER_INIT_ENUM (GROUP_0)
+#define CDMA_S_POINTER_0_PRODUCER_GROUP_0 (_MK_ENUM_CONST(0))
+#define CDMA_S_POINTER_0_PRODUCER_GROUP_1 (_MK_ENUM_CONST(1))
+
+#define CDMA_S_POINTER_0_CONSUMER_SHIFT (_MK_SHIFT_CONST(16))
+#define CDMA_S_POINTER_0_CONSUMER_FIELD \
+	(_MK_FIELD_CONST(0x1, CDMA_S_POINTER_0_CONSUMER_SHIFT))
+#define CDMA_S_POINTER_0_CONSUMER_RANGE (16 : 16)
+#define CDMA_S_POINTER_0_CONSUMER_WOFFSET (0x0)
+#define CDMA_S_POINTER_0_CONSUMER_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_S_POINTER_0_CONSUMER_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CDMA_S_POINTER_0_CONSUMER_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_S_POINTER_0_CONSUMER_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_S_POINTER_0_CONSUMER_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDMA_S_POINTER_0_CONSUMER_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define CDMA_S_POINTER_0_CONSUMER_INIT_ENUM (GROUP_0)
+#define CDMA_S_POINTER_0_CONSUMER_GROUP_0 (_MK_ENUM_CONST(0))
+#define CDMA_S_POINTER_0_CONSUMER_GROUP_1 (_MK_ENUM_CONST(1))
+
+// Register CDMA_S_ARBITER_0
+#define CDMA_S_ARBITER_0 (_MK_ADDR_CONST(0x5008))
+#define CDMA_S_ARBITER_0_SECURE (0x0)
+#define CDMA_S_ARBITER_0_DUAL (0x0)
+#define CDMA_S_ARBITER_0_SCR (0)
+#define CDMA_S_ARBITER_0_WORD_COUNT (0x1)
+#define CDMA_S_ARBITER_0_RESET_VAL (_MK_MASK_CONST(0x3000f))
+#define CDMA_S_ARBITER_0_RESET_MASK (_MK_MASK_CONST(0xf000f))
+#define CDMA_S_ARBITER_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_S_ARBITER_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_S_ARBITER_0_READ_MASK (_MK_MASK_CONST(0xf000f))
+#define CDMA_S_ARBITER_0_WRITE_MASK (_MK_MASK_CONST(0xf000f))
+#define CDMA_S_ARBITER_0_ARB_WEIGHT_SHIFT (_MK_SHIFT_CONST(0))
+#define CDMA_S_ARBITER_0_ARB_WEIGHT_FIELD \
+	(_MK_FIELD_CONST(0xf, CDMA_S_ARBITER_0_ARB_WEIGHT_SHIFT))
+#define CDMA_S_ARBITER_0_ARB_WEIGHT_RANGE (3 : 0)
+#define CDMA_S_ARBITER_0_ARB_WEIGHT_WOFFSET (0x0)
+#define CDMA_S_ARBITER_0_ARB_WEIGHT_DEFAULT (_MK_MASK_CONST(0xf))
+#define CDMA_S_ARBITER_0_ARB_WEIGHT_DEFAULT_MASK (_MK_MASK_CONST(0xf))
+#define CDMA_S_ARBITER_0_ARB_WEIGHT_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_S_ARBITER_0_ARB_WEIGHT_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_S_ARBITER_0_ARB_WEIGHT_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDMA_S_ARBITER_0_ARB_WEIGHT_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+#define CDMA_S_ARBITER_0_ARB_WMB_SHIFT (_MK_SHIFT_CONST(16))
+#define CDMA_S_ARBITER_0_ARB_WMB_FIELD \
+	(_MK_FIELD_CONST(0xf, CDMA_S_ARBITER_0_ARB_WMB_SHIFT))
+#define CDMA_S_ARBITER_0_ARB_WMB_RANGE (19 : 16)
+#define CDMA_S_ARBITER_0_ARB_WMB_WOFFSET (0x0)
+#define CDMA_S_ARBITER_0_ARB_WMB_DEFAULT (_MK_MASK_CONST(0x3))
+#define CDMA_S_ARBITER_0_ARB_WMB_DEFAULT_MASK (_MK_MASK_CONST(0xf))
+#define CDMA_S_ARBITER_0_ARB_WMB_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_S_ARBITER_0_ARB_WMB_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_S_ARBITER_0_ARB_WMB_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDMA_S_ARBITER_0_ARB_WMB_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+// Register CDMA_S_CBUF_FLUSH_STATUS_0
+#define CDMA_S_CBUF_FLUSH_STATUS_0 (_MK_ADDR_CONST(0x500c))
+#define CDMA_S_CBUF_FLUSH_STATUS_0_SECURE (0x0)
+#define CDMA_S_CBUF_FLUSH_STATUS_0_DUAL (0x0)
+#define CDMA_S_CBUF_FLUSH_STATUS_0_SCR (0)
+#define CDMA_S_CBUF_FLUSH_STATUS_0_WORD_COUNT (0x1)
+#define CDMA_S_CBUF_FLUSH_STATUS_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_S_CBUF_FLUSH_STATUS_0_RESET_MASK (_MK_MASK_CONST(0x1))
+#define CDMA_S_CBUF_FLUSH_STATUS_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_S_CBUF_FLUSH_STATUS_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_S_CBUF_FLUSH_STATUS_0_READ_MASK (_MK_MASK_CONST(0x1))
+#define CDMA_S_CBUF_FLUSH_STATUS_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_S_CBUF_FLUSH_STATUS_0_FLUSH_DONE_SHIFT (_MK_SHIFT_CONST(0))
+#define CDMA_S_CBUF_FLUSH_STATUS_0_FLUSH_DONE_FIELD \
+	(_MK_FIELD_CONST(0x1, CDMA_S_CBUF_FLUSH_STATUS_0_FLUSH_DONE_SHIFT))
+#define CDMA_S_CBUF_FLUSH_STATUS_0_FLUSH_DONE_RANGE (0 : 0)
+#define CDMA_S_CBUF_FLUSH_STATUS_0_FLUSH_DONE_WOFFSET (0x0)
+#define CDMA_S_CBUF_FLUSH_STATUS_0_FLUSH_DONE_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_S_CBUF_FLUSH_STATUS_0_FLUSH_DONE_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CDMA_S_CBUF_FLUSH_STATUS_0_FLUSH_DONE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_S_CBUF_FLUSH_STATUS_0_FLUSH_DONE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_S_CBUF_FLUSH_STATUS_0_FLUSH_DONE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_S_CBUF_FLUSH_STATUS_0_FLUSH_DONE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDMA_D_OP_ENABLE_0
+#define CDMA_D_OP_ENABLE_0 (_MK_ADDR_CONST(0x5010))
+#define CDMA_D_OP_ENABLE_0_SECURE (0x0)
+#define CDMA_D_OP_ENABLE_0_DUAL (0x0)
+#define CDMA_D_OP_ENABLE_0_SCR (0)
+#define CDMA_D_OP_ENABLE_0_WORD_COUNT (0x1)
+#define CDMA_D_OP_ENABLE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_OP_ENABLE_0_RESET_MASK (_MK_MASK_CONST(0x1))
+#define CDMA_D_OP_ENABLE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_OP_ENABLE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_OP_ENABLE_0_READ_MASK (_MK_MASK_CONST(0x1))
+#define CDMA_D_OP_ENABLE_0_WRITE_MASK (_MK_MASK_CONST(0x1))
+#define CDMA_D_OP_ENABLE_0_OP_EN_SHIFT (_MK_SHIFT_CONST(0))
+#define CDMA_D_OP_ENABLE_0_OP_EN_FIELD \
+	(_MK_FIELD_CONST(0x1, CDMA_D_OP_ENABLE_0_OP_EN_SHIFT))
+#define CDMA_D_OP_ENABLE_0_OP_EN_RANGE (0 : 0)
+#define CDMA_D_OP_ENABLE_0_OP_EN_WOFFSET (0x0)
+#define CDMA_D_OP_ENABLE_0_OP_EN_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_OP_ENABLE_0_OP_EN_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CDMA_D_OP_ENABLE_0_OP_EN_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_OP_ENABLE_0_OP_EN_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_OP_ENABLE_0_OP_EN_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDMA_D_OP_ENABLE_0_OP_EN_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define CDMA_D_OP_ENABLE_0_OP_EN_INIT_ENUM (DISABLE)
+#define CDMA_D_OP_ENABLE_0_OP_EN_DISABLE (_MK_ENUM_CONST(0))
+#define CDMA_D_OP_ENABLE_0_OP_EN_ENABLE (_MK_ENUM_CONST(1))
+
+// Register CDMA_D_MISC_CFG_0
+#define CDMA_D_MISC_CFG_0 (_MK_ADDR_CONST(0x5014))
+#define CDMA_D_MISC_CFG_0_SECURE (0x0)
+#define CDMA_D_MISC_CFG_0_DUAL (0x0)
+#define CDMA_D_MISC_CFG_0_SCR (0)
+#define CDMA_D_MISC_CFG_0_WORD_COUNT (0x1)
+#define CDMA_D_MISC_CFG_0_RESET_VAL (_MK_MASK_CONST(0x1100))
+#define CDMA_D_MISC_CFG_0_RESET_MASK (_MK_MASK_CONST(0x11113301))
+#define CDMA_D_MISC_CFG_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_MISC_CFG_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_MISC_CFG_0_READ_MASK (_MK_MASK_CONST(0x11113301))
+#define CDMA_D_MISC_CFG_0_WRITE_MASK (_MK_MASK_CONST(0x11113301))
+#define CDMA_D_MISC_CFG_0_CONV_MODE_SHIFT (_MK_SHIFT_CONST(0))
+#define CDMA_D_MISC_CFG_0_CONV_MODE_FIELD \
+	(_MK_FIELD_CONST(0x1, CDMA_D_MISC_CFG_0_CONV_MODE_SHIFT))
+#define CDMA_D_MISC_CFG_0_CONV_MODE_RANGE (0 : 0)
+#define CDMA_D_MISC_CFG_0_CONV_MODE_WOFFSET (0x0)
+#define CDMA_D_MISC_CFG_0_CONV_MODE_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_MISC_CFG_0_CONV_MODE_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CDMA_D_MISC_CFG_0_CONV_MODE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_MISC_CFG_0_CONV_MODE_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_MISC_CFG_0_CONV_MODE_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDMA_D_MISC_CFG_0_CONV_MODE_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define CDMA_D_MISC_CFG_0_CONV_MODE_INIT_ENUM (DIRECT)
+#define CDMA_D_MISC_CFG_0_CONV_MODE_DIRECT (_MK_ENUM_CONST(0))
+#define CDMA_D_MISC_CFG_0_CONV_MODE_WINOGRAD (_MK_ENUM_CONST(1))
+
+#define CDMA_D_MISC_CFG_0_IN_PRECISION_SHIFT (_MK_SHIFT_CONST(8))
+#define CDMA_D_MISC_CFG_0_IN_PRECISION_FIELD \
+	(_MK_FIELD_CONST(0x3, CDMA_D_MISC_CFG_0_IN_PRECISION_SHIFT))
+#define CDMA_D_MISC_CFG_0_IN_PRECISION_RANGE (9 : 8)
+#define CDMA_D_MISC_CFG_0_IN_PRECISION_WOFFSET (0x0)
+#define CDMA_D_MISC_CFG_0_IN_PRECISION_DEFAULT (_MK_MASK_CONST(0x1))
+#define CDMA_D_MISC_CFG_0_IN_PRECISION_DEFAULT_MASK (_MK_MASK_CONST(0x3))
+#define CDMA_D_MISC_CFG_0_IN_PRECISION_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_MISC_CFG_0_IN_PRECISION_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_MISC_CFG_0_IN_PRECISION_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDMA_D_MISC_CFG_0_IN_PRECISION_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define CDMA_D_MISC_CFG_0_IN_PRECISION_INIT_ENUM (INT16)
+#define CDMA_D_MISC_CFG_0_IN_PRECISION_INT8 (_MK_ENUM_CONST(0))
+#define CDMA_D_MISC_CFG_0_IN_PRECISION_INT16 (_MK_ENUM_CONST(1))
+#define CDMA_D_MISC_CFG_0_IN_PRECISION_FP16 (_MK_ENUM_CONST(2))
+
+#define CDMA_D_MISC_CFG_0_PROC_PRECISION_SHIFT (_MK_SHIFT_CONST(12))
+#define CDMA_D_MISC_CFG_0_PROC_PRECISION_FIELD \
+	(_MK_FIELD_CONST(0x3, CDMA_D_MISC_CFG_0_PROC_PRECISION_SHIFT))
+#define CDMA_D_MISC_CFG_0_PROC_PRECISION_RANGE (13 : 12)
+#define CDMA_D_MISC_CFG_0_PROC_PRECISION_WOFFSET (0x0)
+#define CDMA_D_MISC_CFG_0_PROC_PRECISION_DEFAULT (_MK_MASK_CONST(0x1))
+#define CDMA_D_MISC_CFG_0_PROC_PRECISION_DEFAULT_MASK (_MK_MASK_CONST(0x3))
+#define CDMA_D_MISC_CFG_0_PROC_PRECISION_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_MISC_CFG_0_PROC_PRECISION_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_MISC_CFG_0_PROC_PRECISION_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDMA_D_MISC_CFG_0_PROC_PRECISION_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define CDMA_D_MISC_CFG_0_PROC_PRECISION_INIT_ENUM (INT16)
+#define CDMA_D_MISC_CFG_0_PROC_PRECISION_INT8 (_MK_ENUM_CONST(0))
+#define CDMA_D_MISC_CFG_0_PROC_PRECISION_INT16 (_MK_ENUM_CONST(1))
+#define CDMA_D_MISC_CFG_0_PROC_PRECISION_FP16 (_MK_ENUM_CONST(2))
+
+#define CDMA_D_MISC_CFG_0_DATA_REUSE_SHIFT (_MK_SHIFT_CONST(16))
+#define CDMA_D_MISC_CFG_0_DATA_REUSE_FIELD \
+	(_MK_FIELD_CONST(0x1, CDMA_D_MISC_CFG_0_DATA_REUSE_SHIFT))
+#define CDMA_D_MISC_CFG_0_DATA_REUSE_RANGE (16 : 16)
+#define CDMA_D_MISC_CFG_0_DATA_REUSE_WOFFSET (0x0)
+#define CDMA_D_MISC_CFG_0_DATA_REUSE_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_MISC_CFG_0_DATA_REUSE_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CDMA_D_MISC_CFG_0_DATA_REUSE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_MISC_CFG_0_DATA_REUSE_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_MISC_CFG_0_DATA_REUSE_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDMA_D_MISC_CFG_0_DATA_REUSE_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define CDMA_D_MISC_CFG_0_DATA_REUSE_INIT_ENUM (DISABLE)
+#define CDMA_D_MISC_CFG_0_DATA_REUSE_DISABLE (_MK_ENUM_CONST(0))
+#define CDMA_D_MISC_CFG_0_DATA_REUSE_ENABLE (_MK_ENUM_CONST(1))
+
+#define CDMA_D_MISC_CFG_0_WEIGHT_REUSE_SHIFT (_MK_SHIFT_CONST(20))
+#define CDMA_D_MISC_CFG_0_WEIGHT_REUSE_FIELD \
+	(_MK_FIELD_CONST(0x1, CDMA_D_MISC_CFG_0_WEIGHT_REUSE_SHIFT))
+#define CDMA_D_MISC_CFG_0_WEIGHT_REUSE_RANGE (20 : 20)
+#define CDMA_D_MISC_CFG_0_WEIGHT_REUSE_WOFFSET (0x0)
+#define CDMA_D_MISC_CFG_0_WEIGHT_REUSE_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_MISC_CFG_0_WEIGHT_REUSE_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CDMA_D_MISC_CFG_0_WEIGHT_REUSE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_MISC_CFG_0_WEIGHT_REUSE_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_MISC_CFG_0_WEIGHT_REUSE_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDMA_D_MISC_CFG_0_WEIGHT_REUSE_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define CDMA_D_MISC_CFG_0_WEIGHT_REUSE_INIT_ENUM (DISABLE)
+#define CDMA_D_MISC_CFG_0_WEIGHT_REUSE_DISABLE (_MK_ENUM_CONST(0))
+#define CDMA_D_MISC_CFG_0_WEIGHT_REUSE_ENABLE (_MK_ENUM_CONST(1))
+
+#define CDMA_D_MISC_CFG_0_SKIP_DATA_RLS_SHIFT (_MK_SHIFT_CONST(24))
+#define CDMA_D_MISC_CFG_0_SKIP_DATA_RLS_FIELD \
+	(_MK_FIELD_CONST(0x1, CDMA_D_MISC_CFG_0_SKIP_DATA_RLS_SHIFT))
+#define CDMA_D_MISC_CFG_0_SKIP_DATA_RLS_RANGE (24 : 24)
+#define CDMA_D_MISC_CFG_0_SKIP_DATA_RLS_WOFFSET (0x0)
+#define CDMA_D_MISC_CFG_0_SKIP_DATA_RLS_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_MISC_CFG_0_SKIP_DATA_RLS_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CDMA_D_MISC_CFG_0_SKIP_DATA_RLS_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_MISC_CFG_0_SKIP_DATA_RLS_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_MISC_CFG_0_SKIP_DATA_RLS_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDMA_D_MISC_CFG_0_SKIP_DATA_RLS_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define CDMA_D_MISC_CFG_0_SKIP_DATA_RLS_INIT_ENUM (DISABLE)
+#define CDMA_D_MISC_CFG_0_SKIP_DATA_RLS_DISABLE (_MK_ENUM_CONST(0))
+#define CDMA_D_MISC_CFG_0_SKIP_DATA_RLS_ENABLE (_MK_ENUM_CONST(1))
+
+#define CDMA_D_MISC_CFG_0_SKIP_WEIGHT_RLS_SHIFT (_MK_SHIFT_CONST(28))
+#define CDMA_D_MISC_CFG_0_SKIP_WEIGHT_RLS_FIELD \
+	(_MK_FIELD_CONST(0x1, CDMA_D_MISC_CFG_0_SKIP_WEIGHT_RLS_SHIFT))
+#define CDMA_D_MISC_CFG_0_SKIP_WEIGHT_RLS_RANGE (28 : 28)
+#define CDMA_D_MISC_CFG_0_SKIP_WEIGHT_RLS_WOFFSET (0x0)
+#define CDMA_D_MISC_CFG_0_SKIP_WEIGHT_RLS_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_MISC_CFG_0_SKIP_WEIGHT_RLS_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CDMA_D_MISC_CFG_0_SKIP_WEIGHT_RLS_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_MISC_CFG_0_SKIP_WEIGHT_RLS_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_MISC_CFG_0_SKIP_WEIGHT_RLS_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_MISC_CFG_0_SKIP_WEIGHT_RLS_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define CDMA_D_MISC_CFG_0_SKIP_WEIGHT_RLS_INIT_ENUM (DISABLE)
+#define CDMA_D_MISC_CFG_0_SKIP_WEIGHT_RLS_DISABLE (_MK_ENUM_CONST(0))
+#define CDMA_D_MISC_CFG_0_SKIP_WEIGHT_RLS_ENABLE (_MK_ENUM_CONST(1))
+
+// Register CDMA_D_DATAIN_FORMAT_0
+#define CDMA_D_DATAIN_FORMAT_0 (_MK_ADDR_CONST(0x5018))
+#define CDMA_D_DATAIN_FORMAT_0_SECURE (0x0)
+#define CDMA_D_DATAIN_FORMAT_0_DUAL (0x0)
+#define CDMA_D_DATAIN_FORMAT_0_SCR (0)
+#define CDMA_D_DATAIN_FORMAT_0_WORD_COUNT (0x1)
+#define CDMA_D_DATAIN_FORMAT_0_RESET_VAL (_MK_MASK_CONST(0xc00))
+#define CDMA_D_DATAIN_FORMAT_0_RESET_MASK (_MK_MASK_CONST(0x113f01))
+#define CDMA_D_DATAIN_FORMAT_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_DATAIN_FORMAT_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_DATAIN_FORMAT_0_READ_MASK (_MK_MASK_CONST(0x113f01))
+#define CDMA_D_DATAIN_FORMAT_0_WRITE_MASK (_MK_MASK_CONST(0x113f01))
+#define CDMA_D_DATAIN_FORMAT_0_DATAIN_FORMAT_SHIFT (_MK_SHIFT_CONST(0))
+#define CDMA_D_DATAIN_FORMAT_0_DATAIN_FORMAT_FIELD \
+	(_MK_FIELD_CONST(0x1, CDMA_D_DATAIN_FORMAT_0_DATAIN_FORMAT_SHIFT))
+#define CDMA_D_DATAIN_FORMAT_0_DATAIN_FORMAT_RANGE (0 : 0)
+#define CDMA_D_DATAIN_FORMAT_0_DATAIN_FORMAT_WOFFSET (0x0)
+#define CDMA_D_DATAIN_FORMAT_0_DATAIN_FORMAT_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_DATAIN_FORMAT_0_DATAIN_FORMAT_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CDMA_D_DATAIN_FORMAT_0_DATAIN_FORMAT_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_DATAIN_FORMAT_0_DATAIN_FORMAT_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_DATAIN_FORMAT_0_DATAIN_FORMAT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_DATAIN_FORMAT_0_DATAIN_FORMAT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define CDMA_D_DATAIN_FORMAT_0_DATAIN_FORMAT_INIT_ENUM (FEATURE)
+#define CDMA_D_DATAIN_FORMAT_0_DATAIN_FORMAT_FEATURE (_MK_ENUM_CONST(0))
+#define CDMA_D_DATAIN_FORMAT_0_DATAIN_FORMAT_PIXEL (_MK_ENUM_CONST(1))
+
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_FORMAT_SHIFT (_MK_SHIFT_CONST(8))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_FORMAT_FIELD \
+	(_MK_FIELD_CONST(0x3f, CDMA_D_DATAIN_FORMAT_0_PIXEL_FORMAT_SHIFT))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_FORMAT_RANGE (13 : 8)
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_FORMAT_WOFFSET (0x0)
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_FORMAT_DEFAULT (_MK_MASK_CONST(0xc))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_FORMAT_DEFAULT_MASK (_MK_MASK_CONST(0x3f))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_FORMAT_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_FORMAT_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_FORMAT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_FORMAT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_FORMAT_INIT_ENUM (T_A8B8G8R8)
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_FORMAT_T_R8 (_MK_ENUM_CONST(0))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_FORMAT_T_R10 (_MK_ENUM_CONST(1))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_FORMAT_T_R12 (_MK_ENUM_CONST(2))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_FORMAT_T_R16 (_MK_ENUM_CONST(3))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_FORMAT_T_R16_I (_MK_ENUM_CONST(4))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_FORMAT_T_R16_F (_MK_ENUM_CONST(5))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_FORMAT_T_A16B16G16R16 (_MK_ENUM_CONST(6))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_FORMAT_T_X16B16G16R16 (_MK_ENUM_CONST(7))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_FORMAT_T_A16B16G16R16_F (_MK_ENUM_CONST(8))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_FORMAT_T_A16Y16U16V16 (_MK_ENUM_CONST(9))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_FORMAT_T_V16U16Y16A16 (_MK_ENUM_CONST(10))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_FORMAT_T_A16Y16U16V16_F \
+	(_MK_ENUM_CONST(11))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_FORMAT_T_A8B8G8R8 (_MK_ENUM_CONST(12))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_FORMAT_T_A8R8G8B8 (_MK_ENUM_CONST(13))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_FORMAT_T_B8G8R8A8 (_MK_ENUM_CONST(14))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_FORMAT_T_R8G8B8A8 (_MK_ENUM_CONST(15))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_FORMAT_T_X8B8G8R8 (_MK_ENUM_CONST(16))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_FORMAT_T_X8R8G8B8 (_MK_ENUM_CONST(17))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_FORMAT_T_B8G8R8X8 (_MK_ENUM_CONST(18))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_FORMAT_T_R8G8B8X8 (_MK_ENUM_CONST(19))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_FORMAT_T_A2B10G10R10 (_MK_ENUM_CONST(20))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_FORMAT_T_A2R10G10B10 (_MK_ENUM_CONST(21))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_FORMAT_T_B10G10R10A2 (_MK_ENUM_CONST(22))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_FORMAT_T_R10G10B10A2 (_MK_ENUM_CONST(23))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_FORMAT_T_A2Y10U10V10 (_MK_ENUM_CONST(24))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_FORMAT_T_V10U10Y10A2 (_MK_ENUM_CONST(25))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_FORMAT_T_A8Y8U8V8 (_MK_ENUM_CONST(26))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_FORMAT_T_V8U8Y8A8 (_MK_ENUM_CONST(27))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_FORMAT_T_Y8___U8V8_N444 \
+	(_MK_ENUM_CONST(28))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_FORMAT_T_Y8___V8U8_N444 \
+	(_MK_ENUM_CONST(29))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_FORMAT_T_Y10___U10V10_N444 \
+	(_MK_ENUM_CONST(30))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_FORMAT_T_Y10___V10U10_N444 \
+	(_MK_ENUM_CONST(31))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_FORMAT_T_Y12___U12V12_N444 \
+	(_MK_ENUM_CONST(32))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_FORMAT_T_Y12___V12U12_N444 \
+	(_MK_ENUM_CONST(33))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_FORMAT_T_Y16___U16V16_N444 \
+	(_MK_ENUM_CONST(34))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_FORMAT_T_Y16___V16U16_N444 \
+	(_MK_ENUM_CONST(35))
+
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_MAPPING_SHIFT (_MK_SHIFT_CONST(16))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_MAPPING_FIELD \
+	(_MK_FIELD_CONST(0x1, CDMA_D_DATAIN_FORMAT_0_PIXEL_MAPPING_SHIFT))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_MAPPING_RANGE (16 : 16)
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_MAPPING_WOFFSET (0x0)
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_MAPPING_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_MAPPING_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_MAPPING_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_MAPPING_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_MAPPING_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_MAPPING_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_MAPPING_INIT_ENUM (PITCH_LINEAR)
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_MAPPING_PITCH_LINEAR (_MK_ENUM_CONST(0))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_MAPPING_RESERVED_LINEAR (_MK_ENUM_CONST(1))
+
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_SIGN_OVERRIDE_SHIFT (_MK_SHIFT_CONST(20))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_SIGN_OVERRIDE_FIELD \
+	(_MK_FIELD_CONST(0x1, CDMA_D_DATAIN_FORMAT_0_PIXEL_SIGN_OVERRIDE_SHIFT))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_SIGN_OVERRIDE_RANGE (20 : 20)
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_SIGN_OVERRIDE_WOFFSET (0x0)
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_SIGN_OVERRIDE_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_SIGN_OVERRIDE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_SIGN_OVERRIDE_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_SIGN_OVERRIDE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_SIGN_OVERRIDE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_SIGN_OVERRIDE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_SIGN_OVERRIDE_INIT_ENUM (UNSIGNED_INT)
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_SIGN_OVERRIDE_UNSIGNED_INT \
+	(_MK_ENUM_CONST(0))
+#define CDMA_D_DATAIN_FORMAT_0_PIXEL_SIGN_OVERRIDE_SIGNED_INT \
+	(_MK_ENUM_CONST(1))
+
+// Register CDMA_D_DATAIN_SIZE_0_0
+#define CDMA_D_DATAIN_SIZE_0_0 (_MK_ADDR_CONST(0x501c))
+#define CDMA_D_DATAIN_SIZE_0_0_SECURE (0x0)
+#define CDMA_D_DATAIN_SIZE_0_0_DUAL (0x0)
+#define CDMA_D_DATAIN_SIZE_0_0_SCR (0)
+#define CDMA_D_DATAIN_SIZE_0_0_WORD_COUNT (0x1)
+#define CDMA_D_DATAIN_SIZE_0_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_DATAIN_SIZE_0_0_RESET_MASK (_MK_MASK_CONST(0x1fff1fff))
+#define CDMA_D_DATAIN_SIZE_0_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_DATAIN_SIZE_0_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_DATAIN_SIZE_0_0_READ_MASK (_MK_MASK_CONST(0x1fff1fff))
+#define CDMA_D_DATAIN_SIZE_0_0_WRITE_MASK (_MK_MASK_CONST(0x1fff1fff))
+#define CDMA_D_DATAIN_SIZE_0_0_DATAIN_WIDTH_SHIFT (_MK_SHIFT_CONST(0))
+#define CDMA_D_DATAIN_SIZE_0_0_DATAIN_WIDTH_FIELD \
+	(_MK_FIELD_CONST(0x1fff, CDMA_D_DATAIN_SIZE_0_0_DATAIN_WIDTH_SHIFT))
+#define CDMA_D_DATAIN_SIZE_0_0_DATAIN_WIDTH_RANGE (12 : 0)
+#define CDMA_D_DATAIN_SIZE_0_0_DATAIN_WIDTH_WOFFSET (0x0)
+#define CDMA_D_DATAIN_SIZE_0_0_DATAIN_WIDTH_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_DATAIN_SIZE_0_0_DATAIN_WIDTH_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1fff))
+#define CDMA_D_DATAIN_SIZE_0_0_DATAIN_WIDTH_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_DATAIN_SIZE_0_0_DATAIN_WIDTH_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_DATAIN_SIZE_0_0_DATAIN_WIDTH_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_DATAIN_SIZE_0_0_DATAIN_WIDTH_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define CDMA_D_DATAIN_SIZE_0_0_DATAIN_HEIGHT_SHIFT (_MK_SHIFT_CONST(16))
+#define CDMA_D_DATAIN_SIZE_0_0_DATAIN_HEIGHT_FIELD \
+	(_MK_FIELD_CONST(0x1fff, CDMA_D_DATAIN_SIZE_0_0_DATAIN_HEIGHT_SHIFT))
+#define CDMA_D_DATAIN_SIZE_0_0_DATAIN_HEIGHT_RANGE (28 : 16)
+#define CDMA_D_DATAIN_SIZE_0_0_DATAIN_HEIGHT_WOFFSET (0x0)
+#define CDMA_D_DATAIN_SIZE_0_0_DATAIN_HEIGHT_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_DATAIN_SIZE_0_0_DATAIN_HEIGHT_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1fff))
+#define CDMA_D_DATAIN_SIZE_0_0_DATAIN_HEIGHT_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_DATAIN_SIZE_0_0_DATAIN_HEIGHT_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_DATAIN_SIZE_0_0_DATAIN_HEIGHT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_DATAIN_SIZE_0_0_DATAIN_HEIGHT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDMA_D_DATAIN_SIZE_1_0
+#define CDMA_D_DATAIN_SIZE_1_0 (_MK_ADDR_CONST(0x5020))
+#define CDMA_D_DATAIN_SIZE_1_0_SECURE (0x0)
+#define CDMA_D_DATAIN_SIZE_1_0_DUAL (0x0)
+#define CDMA_D_DATAIN_SIZE_1_0_SCR (0)
+#define CDMA_D_DATAIN_SIZE_1_0_WORD_COUNT (0x1)
+#define CDMA_D_DATAIN_SIZE_1_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_DATAIN_SIZE_1_0_RESET_MASK (_MK_MASK_CONST(0x1fff))
+#define CDMA_D_DATAIN_SIZE_1_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_DATAIN_SIZE_1_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_DATAIN_SIZE_1_0_READ_MASK (_MK_MASK_CONST(0x1fff))
+#define CDMA_D_DATAIN_SIZE_1_0_WRITE_MASK (_MK_MASK_CONST(0x1fff))
+#define CDMA_D_DATAIN_SIZE_1_0_DATAIN_CHANNEL_SHIFT (_MK_SHIFT_CONST(0))
+#define CDMA_D_DATAIN_SIZE_1_0_DATAIN_CHANNEL_FIELD \
+	(_MK_FIELD_CONST(0x1fff, CDMA_D_DATAIN_SIZE_1_0_DATAIN_CHANNEL_SHIFT))
+#define CDMA_D_DATAIN_SIZE_1_0_DATAIN_CHANNEL_RANGE (12 : 0)
+#define CDMA_D_DATAIN_SIZE_1_0_DATAIN_CHANNEL_WOFFSET (0x0)
+#define CDMA_D_DATAIN_SIZE_1_0_DATAIN_CHANNEL_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_DATAIN_SIZE_1_0_DATAIN_CHANNEL_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1fff))
+#define CDMA_D_DATAIN_SIZE_1_0_DATAIN_CHANNEL_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_DATAIN_SIZE_1_0_DATAIN_CHANNEL_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_DATAIN_SIZE_1_0_DATAIN_CHANNEL_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_DATAIN_SIZE_1_0_DATAIN_CHANNEL_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDMA_D_DATAIN_SIZE_EXT_0_0
+#define CDMA_D_DATAIN_SIZE_EXT_0_0 (_MK_ADDR_CONST(0x5024))
+#define CDMA_D_DATAIN_SIZE_EXT_0_0_SECURE (0x0)
+#define CDMA_D_DATAIN_SIZE_EXT_0_0_DUAL (0x0)
+#define CDMA_D_DATAIN_SIZE_EXT_0_0_SCR (0)
+#define CDMA_D_DATAIN_SIZE_EXT_0_0_WORD_COUNT (0x1)
+#define CDMA_D_DATAIN_SIZE_EXT_0_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_DATAIN_SIZE_EXT_0_0_RESET_MASK (_MK_MASK_CONST(0x1fff1fff))
+#define CDMA_D_DATAIN_SIZE_EXT_0_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_DATAIN_SIZE_EXT_0_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_DATAIN_SIZE_EXT_0_0_READ_MASK (_MK_MASK_CONST(0x1fff1fff))
+#define CDMA_D_DATAIN_SIZE_EXT_0_0_WRITE_MASK (_MK_MASK_CONST(0x1fff1fff))
+#define CDMA_D_DATAIN_SIZE_EXT_0_0_DATAIN_WIDTH_EXT_SHIFT (_MK_SHIFT_CONST(0))
+#define CDMA_D_DATAIN_SIZE_EXT_0_0_DATAIN_WIDTH_EXT_FIELD \
+	(_MK_FIELD_CONST(0x1fff,                          \
+			 CDMA_D_DATAIN_SIZE_EXT_0_0_DATAIN_WIDTH_EXT_SHIFT))
+#define CDMA_D_DATAIN_SIZE_EXT_0_0_DATAIN_WIDTH_EXT_RANGE (12 : 0)
+#define CDMA_D_DATAIN_SIZE_EXT_0_0_DATAIN_WIDTH_EXT_WOFFSET (0x0)
+#define CDMA_D_DATAIN_SIZE_EXT_0_0_DATAIN_WIDTH_EXT_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_DATAIN_SIZE_EXT_0_0_DATAIN_WIDTH_EXT_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1fff))
+#define CDMA_D_DATAIN_SIZE_EXT_0_0_DATAIN_WIDTH_EXT_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_DATAIN_SIZE_EXT_0_0_DATAIN_WIDTH_EXT_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_DATAIN_SIZE_EXT_0_0_DATAIN_WIDTH_EXT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_DATAIN_SIZE_EXT_0_0_DATAIN_WIDTH_EXT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define CDMA_D_DATAIN_SIZE_EXT_0_0_DATAIN_HEIGHT_EXT_SHIFT (_MK_SHIFT_CONST(16))
+#define CDMA_D_DATAIN_SIZE_EXT_0_0_DATAIN_HEIGHT_EXT_FIELD \
+	(_MK_FIELD_CONST(0x1fff,                           \
+			 CDMA_D_DATAIN_SIZE_EXT_0_0_DATAIN_HEIGHT_EXT_SHIFT))
+#define CDMA_D_DATAIN_SIZE_EXT_0_0_DATAIN_HEIGHT_EXT_RANGE (28 : 16)
+#define CDMA_D_DATAIN_SIZE_EXT_0_0_DATAIN_HEIGHT_EXT_WOFFSET (0x0)
+#define CDMA_D_DATAIN_SIZE_EXT_0_0_DATAIN_HEIGHT_EXT_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_DATAIN_SIZE_EXT_0_0_DATAIN_HEIGHT_EXT_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1fff))
+#define CDMA_D_DATAIN_SIZE_EXT_0_0_DATAIN_HEIGHT_EXT_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_DATAIN_SIZE_EXT_0_0_DATAIN_HEIGHT_EXT_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_DATAIN_SIZE_EXT_0_0_DATAIN_HEIGHT_EXT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_DATAIN_SIZE_EXT_0_0_DATAIN_HEIGHT_EXT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDMA_D_PIXEL_OFFSET_0
+#define CDMA_D_PIXEL_OFFSET_0 (_MK_ADDR_CONST(0x5028))
+#define CDMA_D_PIXEL_OFFSET_0_SECURE (0x0)
+#define CDMA_D_PIXEL_OFFSET_0_DUAL (0x0)
+#define CDMA_D_PIXEL_OFFSET_0_SCR (0)
+#define CDMA_D_PIXEL_OFFSET_0_WORD_COUNT (0x1)
+#define CDMA_D_PIXEL_OFFSET_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_PIXEL_OFFSET_0_RESET_MASK (_MK_MASK_CONST(0x7001f))
+#define CDMA_D_PIXEL_OFFSET_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_PIXEL_OFFSET_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_PIXEL_OFFSET_0_READ_MASK (_MK_MASK_CONST(0x7001f))
+#define CDMA_D_PIXEL_OFFSET_0_WRITE_MASK (_MK_MASK_CONST(0x7001f))
+#define CDMA_D_PIXEL_OFFSET_0_PIXEL_X_OFFSET_SHIFT (_MK_SHIFT_CONST(0))
+#define CDMA_D_PIXEL_OFFSET_0_PIXEL_X_OFFSET_FIELD \
+	(_MK_FIELD_CONST(0x1f, CDMA_D_PIXEL_OFFSET_0_PIXEL_X_OFFSET_SHIFT))
+#define CDMA_D_PIXEL_OFFSET_0_PIXEL_X_OFFSET_RANGE (4 : 0)
+#define CDMA_D_PIXEL_OFFSET_0_PIXEL_X_OFFSET_WOFFSET (0x0)
+#define CDMA_D_PIXEL_OFFSET_0_PIXEL_X_OFFSET_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_PIXEL_OFFSET_0_PIXEL_X_OFFSET_DEFAULT_MASK (_MK_MASK_CONST(0x1f))
+#define CDMA_D_PIXEL_OFFSET_0_PIXEL_X_OFFSET_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_PIXEL_OFFSET_0_PIXEL_X_OFFSET_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_PIXEL_OFFSET_0_PIXEL_X_OFFSET_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_PIXEL_OFFSET_0_PIXEL_X_OFFSET_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define CDMA_D_PIXEL_OFFSET_0_PIXEL_Y_OFFSET_SHIFT (_MK_SHIFT_CONST(16))
+#define CDMA_D_PIXEL_OFFSET_0_PIXEL_Y_OFFSET_FIELD \
+	(_MK_FIELD_CONST(0x7, CDMA_D_PIXEL_OFFSET_0_PIXEL_Y_OFFSET_SHIFT))
+#define CDMA_D_PIXEL_OFFSET_0_PIXEL_Y_OFFSET_RANGE (18 : 16)
+#define CDMA_D_PIXEL_OFFSET_0_PIXEL_Y_OFFSET_WOFFSET (0x0)
+#define CDMA_D_PIXEL_OFFSET_0_PIXEL_Y_OFFSET_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_PIXEL_OFFSET_0_PIXEL_Y_OFFSET_DEFAULT_MASK (_MK_MASK_CONST(0x7))
+#define CDMA_D_PIXEL_OFFSET_0_PIXEL_Y_OFFSET_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_PIXEL_OFFSET_0_PIXEL_Y_OFFSET_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_PIXEL_OFFSET_0_PIXEL_Y_OFFSET_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_PIXEL_OFFSET_0_PIXEL_Y_OFFSET_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDMA_D_DAIN_RAM_TYPE_0
+#define CDMA_D_DAIN_RAM_TYPE_0 (_MK_ADDR_CONST(0x502c))
+#define CDMA_D_DAIN_RAM_TYPE_0_SECURE (0x0)
+#define CDMA_D_DAIN_RAM_TYPE_0_DUAL (0x0)
+#define CDMA_D_DAIN_RAM_TYPE_0_SCR (0)
+#define CDMA_D_DAIN_RAM_TYPE_0_WORD_COUNT (0x1)
+#define CDMA_D_DAIN_RAM_TYPE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_DAIN_RAM_TYPE_0_RESET_MASK (_MK_MASK_CONST(0x1))
+#define CDMA_D_DAIN_RAM_TYPE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_DAIN_RAM_TYPE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_DAIN_RAM_TYPE_0_READ_MASK (_MK_MASK_CONST(0x1))
+#define CDMA_D_DAIN_RAM_TYPE_0_WRITE_MASK (_MK_MASK_CONST(0x1))
+#define CDMA_D_DAIN_RAM_TYPE_0_DATAIN_RAM_TYPE_SHIFT (_MK_SHIFT_CONST(0))
+#define CDMA_D_DAIN_RAM_TYPE_0_DATAIN_RAM_TYPE_FIELD \
+	(_MK_FIELD_CONST(0x1, CDMA_D_DAIN_RAM_TYPE_0_DATAIN_RAM_TYPE_SHIFT))
+#define CDMA_D_DAIN_RAM_TYPE_0_DATAIN_RAM_TYPE_RANGE (0 : 0)
+#define CDMA_D_DAIN_RAM_TYPE_0_DATAIN_RAM_TYPE_WOFFSET (0x0)
+#define CDMA_D_DAIN_RAM_TYPE_0_DATAIN_RAM_TYPE_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_DAIN_RAM_TYPE_0_DATAIN_RAM_TYPE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1))
+#define CDMA_D_DAIN_RAM_TYPE_0_DATAIN_RAM_TYPE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_DAIN_RAM_TYPE_0_DATAIN_RAM_TYPE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_DAIN_RAM_TYPE_0_DATAIN_RAM_TYPE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_DAIN_RAM_TYPE_0_DATAIN_RAM_TYPE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define CDMA_D_DAIN_RAM_TYPE_0_DATAIN_RAM_TYPE_INIT_ENUM (CVIF)
+#define CDMA_D_DAIN_RAM_TYPE_0_DATAIN_RAM_TYPE_CVIF (_MK_ENUM_CONST(0))
+#define CDMA_D_DAIN_RAM_TYPE_0_DATAIN_RAM_TYPE_MCIF (_MK_ENUM_CONST(1))
+
+// Register CDMA_D_DAIN_ADDR_HIGH_0_0
+#define CDMA_D_DAIN_ADDR_HIGH_0_0 (_MK_ADDR_CONST(0x5030))
+#define CDMA_D_DAIN_ADDR_HIGH_0_0_SECURE (0x0)
+#define CDMA_D_DAIN_ADDR_HIGH_0_0_DUAL (0x0)
+#define CDMA_D_DAIN_ADDR_HIGH_0_0_SCR (0)
+#define CDMA_D_DAIN_ADDR_HIGH_0_0_WORD_COUNT (0x1)
+#define CDMA_D_DAIN_ADDR_HIGH_0_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_DAIN_ADDR_HIGH_0_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDMA_D_DAIN_ADDR_HIGH_0_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_DAIN_ADDR_HIGH_0_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_DAIN_ADDR_HIGH_0_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDMA_D_DAIN_ADDR_HIGH_0_0_WRITE_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDMA_D_DAIN_ADDR_HIGH_0_0_DATAIN_ADDR_HIGH_0_SHIFT (_MK_SHIFT_CONST(0))
+#define CDMA_D_DAIN_ADDR_HIGH_0_0_DATAIN_ADDR_HIGH_0_FIELD \
+	(_MK_FIELD_CONST(0xffffffff,                       \
+			 CDMA_D_DAIN_ADDR_HIGH_0_0_DATAIN_ADDR_HIGH_0_SHIFT))
+#define CDMA_D_DAIN_ADDR_HIGH_0_0_DATAIN_ADDR_HIGH_0_RANGE (31 : 0)
+#define CDMA_D_DAIN_ADDR_HIGH_0_0_DATAIN_ADDR_HIGH_0_WOFFSET (0x0)
+#define CDMA_D_DAIN_ADDR_HIGH_0_0_DATAIN_ADDR_HIGH_0_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_DAIN_ADDR_HIGH_0_0_DATAIN_ADDR_HIGH_0_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define CDMA_D_DAIN_ADDR_HIGH_0_0_DATAIN_ADDR_HIGH_0_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_DAIN_ADDR_HIGH_0_0_DATAIN_ADDR_HIGH_0_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_DAIN_ADDR_HIGH_0_0_DATAIN_ADDR_HIGH_0_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_DAIN_ADDR_HIGH_0_0_DATAIN_ADDR_HIGH_0_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDMA_D_DAIN_ADDR_LOW_0_0
+#define CDMA_D_DAIN_ADDR_LOW_0_0 (_MK_ADDR_CONST(0x5034))
+#define CDMA_D_DAIN_ADDR_LOW_0_0_SECURE (0x0)
+#define CDMA_D_DAIN_ADDR_LOW_0_0_DUAL (0x0)
+#define CDMA_D_DAIN_ADDR_LOW_0_0_SCR (0)
+#define CDMA_D_DAIN_ADDR_LOW_0_0_WORD_COUNT (0x1)
+#define CDMA_D_DAIN_ADDR_LOW_0_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_DAIN_ADDR_LOW_0_0_RESET_MASK (_MK_MASK_CONST(0xffffffe0))
+#define CDMA_D_DAIN_ADDR_LOW_0_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_DAIN_ADDR_LOW_0_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_DAIN_ADDR_LOW_0_0_READ_MASK (_MK_MASK_CONST(0xffffffe0))
+#define CDMA_D_DAIN_ADDR_LOW_0_0_WRITE_MASK (_MK_MASK_CONST(0xffffffe0))
+#define CDMA_D_DAIN_ADDR_LOW_0_0_DATAIN_ADDR_LOW_0_SHIFT (_MK_SHIFT_CONST(5))
+#define CDMA_D_DAIN_ADDR_LOW_0_0_DATAIN_ADDR_LOW_0_FIELD \
+	(_MK_FIELD_CONST(0x7ffffff,                      \
+			 CDMA_D_DAIN_ADDR_LOW_0_0_DATAIN_ADDR_LOW_0_SHIFT))
+#define CDMA_D_DAIN_ADDR_LOW_0_0_DATAIN_ADDR_LOW_0_RANGE (31 : 5)
+#define CDMA_D_DAIN_ADDR_LOW_0_0_DATAIN_ADDR_LOW_0_WOFFSET (0x0)
+#define CDMA_D_DAIN_ADDR_LOW_0_0_DATAIN_ADDR_LOW_0_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_DAIN_ADDR_LOW_0_0_DATAIN_ADDR_LOW_0_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffffff))
+#define CDMA_D_DAIN_ADDR_LOW_0_0_DATAIN_ADDR_LOW_0_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_DAIN_ADDR_LOW_0_0_DATAIN_ADDR_LOW_0_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_DAIN_ADDR_LOW_0_0_DATAIN_ADDR_LOW_0_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_DAIN_ADDR_LOW_0_0_DATAIN_ADDR_LOW_0_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDMA_D_DAIN_ADDR_HIGH_1_0
+#define CDMA_D_DAIN_ADDR_HIGH_1_0 (_MK_ADDR_CONST(0x5038))
+#define CDMA_D_DAIN_ADDR_HIGH_1_0_SECURE (0x0)
+#define CDMA_D_DAIN_ADDR_HIGH_1_0_DUAL (0x0)
+#define CDMA_D_DAIN_ADDR_HIGH_1_0_SCR (0)
+#define CDMA_D_DAIN_ADDR_HIGH_1_0_WORD_COUNT (0x1)
+#define CDMA_D_DAIN_ADDR_HIGH_1_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_DAIN_ADDR_HIGH_1_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDMA_D_DAIN_ADDR_HIGH_1_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_DAIN_ADDR_HIGH_1_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_DAIN_ADDR_HIGH_1_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDMA_D_DAIN_ADDR_HIGH_1_0_WRITE_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDMA_D_DAIN_ADDR_HIGH_1_0_DATAIN_ADDR_HIGH_1_SHIFT (_MK_SHIFT_CONST(0))
+#define CDMA_D_DAIN_ADDR_HIGH_1_0_DATAIN_ADDR_HIGH_1_FIELD \
+	(_MK_FIELD_CONST(0xffffffff,                       \
+			 CDMA_D_DAIN_ADDR_HIGH_1_0_DATAIN_ADDR_HIGH_1_SHIFT))
+#define CDMA_D_DAIN_ADDR_HIGH_1_0_DATAIN_ADDR_HIGH_1_RANGE (31 : 0)
+#define CDMA_D_DAIN_ADDR_HIGH_1_0_DATAIN_ADDR_HIGH_1_WOFFSET (0x0)
+#define CDMA_D_DAIN_ADDR_HIGH_1_0_DATAIN_ADDR_HIGH_1_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_DAIN_ADDR_HIGH_1_0_DATAIN_ADDR_HIGH_1_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define CDMA_D_DAIN_ADDR_HIGH_1_0_DATAIN_ADDR_HIGH_1_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_DAIN_ADDR_HIGH_1_0_DATAIN_ADDR_HIGH_1_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_DAIN_ADDR_HIGH_1_0_DATAIN_ADDR_HIGH_1_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_DAIN_ADDR_HIGH_1_0_DATAIN_ADDR_HIGH_1_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDMA_D_DAIN_ADDR_LOW_1_0
+#define CDMA_D_DAIN_ADDR_LOW_1_0 (_MK_ADDR_CONST(0x503c))
+#define CDMA_D_DAIN_ADDR_LOW_1_0_SECURE (0x0)
+#define CDMA_D_DAIN_ADDR_LOW_1_0_DUAL (0x0)
+#define CDMA_D_DAIN_ADDR_LOW_1_0_SCR (0)
+#define CDMA_D_DAIN_ADDR_LOW_1_0_WORD_COUNT (0x1)
+#define CDMA_D_DAIN_ADDR_LOW_1_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_DAIN_ADDR_LOW_1_0_RESET_MASK (_MK_MASK_CONST(0xffffffe0))
+#define CDMA_D_DAIN_ADDR_LOW_1_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_DAIN_ADDR_LOW_1_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_DAIN_ADDR_LOW_1_0_READ_MASK (_MK_MASK_CONST(0xffffffe0))
+#define CDMA_D_DAIN_ADDR_LOW_1_0_WRITE_MASK (_MK_MASK_CONST(0xffffffe0))
+#define CDMA_D_DAIN_ADDR_LOW_1_0_DATAIN_ADDR_LOW_1_SHIFT (_MK_SHIFT_CONST(5))
+#define CDMA_D_DAIN_ADDR_LOW_1_0_DATAIN_ADDR_LOW_1_FIELD \
+	(_MK_FIELD_CONST(0x7ffffff,                      \
+			 CDMA_D_DAIN_ADDR_LOW_1_0_DATAIN_ADDR_LOW_1_SHIFT))
+#define CDMA_D_DAIN_ADDR_LOW_1_0_DATAIN_ADDR_LOW_1_RANGE (31 : 5)
+#define CDMA_D_DAIN_ADDR_LOW_1_0_DATAIN_ADDR_LOW_1_WOFFSET (0x0)
+#define CDMA_D_DAIN_ADDR_LOW_1_0_DATAIN_ADDR_LOW_1_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_DAIN_ADDR_LOW_1_0_DATAIN_ADDR_LOW_1_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffffff))
+#define CDMA_D_DAIN_ADDR_LOW_1_0_DATAIN_ADDR_LOW_1_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_DAIN_ADDR_LOW_1_0_DATAIN_ADDR_LOW_1_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_DAIN_ADDR_LOW_1_0_DATAIN_ADDR_LOW_1_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_DAIN_ADDR_LOW_1_0_DATAIN_ADDR_LOW_1_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDMA_D_LINE_STRIDE_0
+#define CDMA_D_LINE_STRIDE_0 (_MK_ADDR_CONST(0x5040))
+#define CDMA_D_LINE_STRIDE_0_SECURE (0x0)
+#define CDMA_D_LINE_STRIDE_0_DUAL (0x0)
+#define CDMA_D_LINE_STRIDE_0_SCR (0)
+#define CDMA_D_LINE_STRIDE_0_WORD_COUNT (0x1)
+#define CDMA_D_LINE_STRIDE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_LINE_STRIDE_0_RESET_MASK (_MK_MASK_CONST(0xffffffe0))
+#define CDMA_D_LINE_STRIDE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_LINE_STRIDE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_LINE_STRIDE_0_READ_MASK (_MK_MASK_CONST(0xffffffe0))
+#define CDMA_D_LINE_STRIDE_0_WRITE_MASK (_MK_MASK_CONST(0xffffffe0))
+#define CDMA_D_LINE_STRIDE_0_LINE_STRIDE_SHIFT (_MK_SHIFT_CONST(5))
+#define CDMA_D_LINE_STRIDE_0_LINE_STRIDE_FIELD \
+	(_MK_FIELD_CONST(0x7ffffff, CDMA_D_LINE_STRIDE_0_LINE_STRIDE_SHIFT))
+#define CDMA_D_LINE_STRIDE_0_LINE_STRIDE_RANGE (31 : 5)
+#define CDMA_D_LINE_STRIDE_0_LINE_STRIDE_WOFFSET (0x0)
+#define CDMA_D_LINE_STRIDE_0_LINE_STRIDE_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_LINE_STRIDE_0_LINE_STRIDE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffffff))
+#define CDMA_D_LINE_STRIDE_0_LINE_STRIDE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_LINE_STRIDE_0_LINE_STRIDE_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_LINE_STRIDE_0_LINE_STRIDE_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDMA_D_LINE_STRIDE_0_LINE_STRIDE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDMA_D_LINE_UV_STRIDE_0
+#define CDMA_D_LINE_UV_STRIDE_0 (_MK_ADDR_CONST(0x5044))
+#define CDMA_D_LINE_UV_STRIDE_0_SECURE (0x0)
+#define CDMA_D_LINE_UV_STRIDE_0_DUAL (0x0)
+#define CDMA_D_LINE_UV_STRIDE_0_SCR (0)
+#define CDMA_D_LINE_UV_STRIDE_0_WORD_COUNT (0x1)
+#define CDMA_D_LINE_UV_STRIDE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_LINE_UV_STRIDE_0_RESET_MASK (_MK_MASK_CONST(0xffffffe0))
+#define CDMA_D_LINE_UV_STRIDE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_LINE_UV_STRIDE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_LINE_UV_STRIDE_0_READ_MASK (_MK_MASK_CONST(0xffffffe0))
+#define CDMA_D_LINE_UV_STRIDE_0_WRITE_MASK (_MK_MASK_CONST(0xffffffe0))
+#define CDMA_D_LINE_UV_STRIDE_0_UV_LINE_STRIDE_SHIFT (_MK_SHIFT_CONST(5))
+#define CDMA_D_LINE_UV_STRIDE_0_UV_LINE_STRIDE_FIELD \
+	(_MK_FIELD_CONST(0x7ffffff,                  \
+			 CDMA_D_LINE_UV_STRIDE_0_UV_LINE_STRIDE_SHIFT))
+#define CDMA_D_LINE_UV_STRIDE_0_UV_LINE_STRIDE_RANGE (31 : 5)
+#define CDMA_D_LINE_UV_STRIDE_0_UV_LINE_STRIDE_WOFFSET (0x0)
+#define CDMA_D_LINE_UV_STRIDE_0_UV_LINE_STRIDE_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_LINE_UV_STRIDE_0_UV_LINE_STRIDE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffffff))
+#define CDMA_D_LINE_UV_STRIDE_0_UV_LINE_STRIDE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_LINE_UV_STRIDE_0_UV_LINE_STRIDE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_LINE_UV_STRIDE_0_UV_LINE_STRIDE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_LINE_UV_STRIDE_0_UV_LINE_STRIDE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDMA_D_SURF_STRIDE_0
+#define CDMA_D_SURF_STRIDE_0 (_MK_ADDR_CONST(0x5048))
+#define CDMA_D_SURF_STRIDE_0_SECURE (0x0)
+#define CDMA_D_SURF_STRIDE_0_DUAL (0x0)
+#define CDMA_D_SURF_STRIDE_0_SCR (0)
+#define CDMA_D_SURF_STRIDE_0_WORD_COUNT (0x1)
+#define CDMA_D_SURF_STRIDE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_SURF_STRIDE_0_RESET_MASK (_MK_MASK_CONST(0xffffffe0))
+#define CDMA_D_SURF_STRIDE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_SURF_STRIDE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_SURF_STRIDE_0_READ_MASK (_MK_MASK_CONST(0xffffffe0))
+#define CDMA_D_SURF_STRIDE_0_WRITE_MASK (_MK_MASK_CONST(0xffffffe0))
+#define CDMA_D_SURF_STRIDE_0_SURF_STRIDE_SHIFT (_MK_SHIFT_CONST(5))
+#define CDMA_D_SURF_STRIDE_0_SURF_STRIDE_FIELD \
+	(_MK_FIELD_CONST(0x7ffffff, CDMA_D_SURF_STRIDE_0_SURF_STRIDE_SHIFT))
+#define CDMA_D_SURF_STRIDE_0_SURF_STRIDE_RANGE (31 : 5)
+#define CDMA_D_SURF_STRIDE_0_SURF_STRIDE_WOFFSET (0x0)
+#define CDMA_D_SURF_STRIDE_0_SURF_STRIDE_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_SURF_STRIDE_0_SURF_STRIDE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffffff))
+#define CDMA_D_SURF_STRIDE_0_SURF_STRIDE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_SURF_STRIDE_0_SURF_STRIDE_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_SURF_STRIDE_0_SURF_STRIDE_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDMA_D_SURF_STRIDE_0_SURF_STRIDE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDMA_D_DAIN_MAP_0
+#define CDMA_D_DAIN_MAP_0 (_MK_ADDR_CONST(0x504c))
+#define CDMA_D_DAIN_MAP_0_SECURE (0x0)
+#define CDMA_D_DAIN_MAP_0_DUAL (0x0)
+#define CDMA_D_DAIN_MAP_0_SCR (0)
+#define CDMA_D_DAIN_MAP_0_WORD_COUNT (0x1)
+#define CDMA_D_DAIN_MAP_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_DAIN_MAP_0_RESET_MASK (_MK_MASK_CONST(0x10001))
+#define CDMA_D_DAIN_MAP_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_DAIN_MAP_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_DAIN_MAP_0_READ_MASK (_MK_MASK_CONST(0x10001))
+#define CDMA_D_DAIN_MAP_0_WRITE_MASK (_MK_MASK_CONST(0x10001))
+#define CDMA_D_DAIN_MAP_0_LINE_PACKED_SHIFT (_MK_SHIFT_CONST(0))
+#define CDMA_D_DAIN_MAP_0_LINE_PACKED_FIELD \
+	(_MK_FIELD_CONST(0x1, CDMA_D_DAIN_MAP_0_LINE_PACKED_SHIFT))
+#define CDMA_D_DAIN_MAP_0_LINE_PACKED_RANGE (0 : 0)
+#define CDMA_D_DAIN_MAP_0_LINE_PACKED_WOFFSET (0x0)
+#define CDMA_D_DAIN_MAP_0_LINE_PACKED_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_DAIN_MAP_0_LINE_PACKED_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CDMA_D_DAIN_MAP_0_LINE_PACKED_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_DAIN_MAP_0_LINE_PACKED_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_DAIN_MAP_0_LINE_PACKED_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDMA_D_DAIN_MAP_0_LINE_PACKED_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define CDMA_D_DAIN_MAP_0_LINE_PACKED_INIT_ENUM (FALSE)
+#define CDMA_D_DAIN_MAP_0_LINE_PACKED_FALSE (_MK_ENUM_CONST(0))
+#define CDMA_D_DAIN_MAP_0_LINE_PACKED_TRUE (_MK_ENUM_CONST(1))
+
+#define CDMA_D_DAIN_MAP_0_SURF_PACKED_SHIFT (_MK_SHIFT_CONST(16))
+#define CDMA_D_DAIN_MAP_0_SURF_PACKED_FIELD \
+	(_MK_FIELD_CONST(0x1, CDMA_D_DAIN_MAP_0_SURF_PACKED_SHIFT))
+#define CDMA_D_DAIN_MAP_0_SURF_PACKED_RANGE (16 : 16)
+#define CDMA_D_DAIN_MAP_0_SURF_PACKED_WOFFSET (0x0)
+#define CDMA_D_DAIN_MAP_0_SURF_PACKED_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_DAIN_MAP_0_SURF_PACKED_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CDMA_D_DAIN_MAP_0_SURF_PACKED_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_DAIN_MAP_0_SURF_PACKED_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_DAIN_MAP_0_SURF_PACKED_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDMA_D_DAIN_MAP_0_SURF_PACKED_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define CDMA_D_DAIN_MAP_0_SURF_PACKED_INIT_ENUM (FALSE)
+#define CDMA_D_DAIN_MAP_0_SURF_PACKED_FALSE (_MK_ENUM_CONST(0))
+#define CDMA_D_DAIN_MAP_0_SURF_PACKED_TRUE (_MK_ENUM_CONST(1))
+
+// Register CDMA_D_RESERVED_X_CFG_0
+#define CDMA_D_RESERVED_X_CFG_0 (_MK_ADDR_CONST(0x5050))
+#define CDMA_D_RESERVED_X_CFG_0_SECURE (0x0)
+#define CDMA_D_RESERVED_X_CFG_0_DUAL (0x0)
+#define CDMA_D_RESERVED_X_CFG_0_SCR (0)
+#define CDMA_D_RESERVED_X_CFG_0_WORD_COUNT (0x1)
+#define CDMA_D_RESERVED_X_CFG_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_RESERVED_X_CFG_0_RESET_MASK (_MK_MASK_CONST(0x3ff03ff))
+#define CDMA_D_RESERVED_X_CFG_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_RESERVED_X_CFG_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_RESERVED_X_CFG_0_READ_MASK (_MK_MASK_CONST(0x3ff03ff))
+#define CDMA_D_RESERVED_X_CFG_0_WRITE_MASK (_MK_MASK_CONST(0x3ff03ff))
+#define CDMA_D_RESERVED_X_CFG_0_RSV_PER_LINE_SHIFT (_MK_SHIFT_CONST(0))
+#define CDMA_D_RESERVED_X_CFG_0_RSV_PER_LINE_FIELD \
+	(_MK_FIELD_CONST(0x3ff, CDMA_D_RESERVED_X_CFG_0_RSV_PER_LINE_SHIFT))
+#define CDMA_D_RESERVED_X_CFG_0_RSV_PER_LINE_RANGE (9 : 0)
+#define CDMA_D_RESERVED_X_CFG_0_RSV_PER_LINE_WOFFSET (0x0)
+#define CDMA_D_RESERVED_X_CFG_0_RSV_PER_LINE_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_RESERVED_X_CFG_0_RSV_PER_LINE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x3ff))
+#define CDMA_D_RESERVED_X_CFG_0_RSV_PER_LINE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_RESERVED_X_CFG_0_RSV_PER_LINE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_RESERVED_X_CFG_0_RSV_PER_LINE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_RESERVED_X_CFG_0_RSV_PER_LINE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define CDMA_D_RESERVED_X_CFG_0_RSV_PER_UV_LINE_SHIFT (_MK_SHIFT_CONST(16))
+#define CDMA_D_RESERVED_X_CFG_0_RSV_PER_UV_LINE_FIELD \
+	(_MK_FIELD_CONST(0x3ff, CDMA_D_RESERVED_X_CFG_0_RSV_PER_UV_LINE_SHIFT))
+#define CDMA_D_RESERVED_X_CFG_0_RSV_PER_UV_LINE_RANGE (25 : 16)
+#define CDMA_D_RESERVED_X_CFG_0_RSV_PER_UV_LINE_WOFFSET (0x0)
+#define CDMA_D_RESERVED_X_CFG_0_RSV_PER_UV_LINE_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_RESERVED_X_CFG_0_RSV_PER_UV_LINE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x3ff))
+#define CDMA_D_RESERVED_X_CFG_0_RSV_PER_UV_LINE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_RESERVED_X_CFG_0_RSV_PER_UV_LINE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_RESERVED_X_CFG_0_RSV_PER_UV_LINE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_RESERVED_X_CFG_0_RSV_PER_UV_LINE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDMA_D_RESERVED_Y_CFG_0
+#define CDMA_D_RESERVED_Y_CFG_0 (_MK_ADDR_CONST(0x5054))
+#define CDMA_D_RESERVED_Y_CFG_0_SECURE (0x0)
+#define CDMA_D_RESERVED_Y_CFG_0_DUAL (0x0)
+#define CDMA_D_RESERVED_Y_CFG_0_SCR (0)
+#define CDMA_D_RESERVED_Y_CFG_0_WORD_COUNT (0x1)
+#define CDMA_D_RESERVED_Y_CFG_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_RESERVED_Y_CFG_0_RESET_MASK (_MK_MASK_CONST(0x1f0007))
+#define CDMA_D_RESERVED_Y_CFG_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_RESERVED_Y_CFG_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_RESERVED_Y_CFG_0_READ_MASK (_MK_MASK_CONST(0x1f0007))
+#define CDMA_D_RESERVED_Y_CFG_0_WRITE_MASK (_MK_MASK_CONST(0x1f0007))
+#define CDMA_D_RESERVED_Y_CFG_0_RSV_HEIGHT_SHIFT (_MK_SHIFT_CONST(0))
+#define CDMA_D_RESERVED_Y_CFG_0_RSV_HEIGHT_FIELD \
+	(_MK_FIELD_CONST(0x7, CDMA_D_RESERVED_Y_CFG_0_RSV_HEIGHT_SHIFT))
+#define CDMA_D_RESERVED_Y_CFG_0_RSV_HEIGHT_RANGE (2 : 0)
+#define CDMA_D_RESERVED_Y_CFG_0_RSV_HEIGHT_WOFFSET (0x0)
+#define CDMA_D_RESERVED_Y_CFG_0_RSV_HEIGHT_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_RESERVED_Y_CFG_0_RSV_HEIGHT_DEFAULT_MASK (_MK_MASK_CONST(0x7))
+#define CDMA_D_RESERVED_Y_CFG_0_RSV_HEIGHT_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_RESERVED_Y_CFG_0_RSV_HEIGHT_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_RESERVED_Y_CFG_0_RSV_HEIGHT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_RESERVED_Y_CFG_0_RSV_HEIGHT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define CDMA_D_RESERVED_Y_CFG_0_RSV_Y_INDEX_SHIFT (_MK_SHIFT_CONST(16))
+#define CDMA_D_RESERVED_Y_CFG_0_RSV_Y_INDEX_FIELD \
+	(_MK_FIELD_CONST(0x1f, CDMA_D_RESERVED_Y_CFG_0_RSV_Y_INDEX_SHIFT))
+#define CDMA_D_RESERVED_Y_CFG_0_RSV_Y_INDEX_RANGE (20 : 16)
+#define CDMA_D_RESERVED_Y_CFG_0_RSV_Y_INDEX_WOFFSET (0x0)
+#define CDMA_D_RESERVED_Y_CFG_0_RSV_Y_INDEX_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_RESERVED_Y_CFG_0_RSV_Y_INDEX_DEFAULT_MASK (_MK_MASK_CONST(0x1f))
+#define CDMA_D_RESERVED_Y_CFG_0_RSV_Y_INDEX_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_RESERVED_Y_CFG_0_RSV_Y_INDEX_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_RESERVED_Y_CFG_0_RSV_Y_INDEX_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_RESERVED_Y_CFG_0_RSV_Y_INDEX_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDMA_D_BATCH_NUMBER_0
+#define CDMA_D_BATCH_NUMBER_0 (_MK_ADDR_CONST(0x5058))
+#define CDMA_D_BATCH_NUMBER_0_SECURE (0x0)
+#define CDMA_D_BATCH_NUMBER_0_DUAL (0x0)
+#define CDMA_D_BATCH_NUMBER_0_SCR (0)
+#define CDMA_D_BATCH_NUMBER_0_WORD_COUNT (0x1)
+#define CDMA_D_BATCH_NUMBER_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_BATCH_NUMBER_0_RESET_MASK (_MK_MASK_CONST(0x1f))
+#define CDMA_D_BATCH_NUMBER_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_BATCH_NUMBER_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_BATCH_NUMBER_0_READ_MASK (_MK_MASK_CONST(0x1f))
+#define CDMA_D_BATCH_NUMBER_0_WRITE_MASK (_MK_MASK_CONST(0x1f))
+#define CDMA_D_BATCH_NUMBER_0_BATCHES_SHIFT (_MK_SHIFT_CONST(0))
+#define CDMA_D_BATCH_NUMBER_0_BATCHES_FIELD \
+	(_MK_FIELD_CONST(0x1f, CDMA_D_BATCH_NUMBER_0_BATCHES_SHIFT))
+#define CDMA_D_BATCH_NUMBER_0_BATCHES_RANGE (4 : 0)
+#define CDMA_D_BATCH_NUMBER_0_BATCHES_WOFFSET (0x0)
+#define CDMA_D_BATCH_NUMBER_0_BATCHES_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_BATCH_NUMBER_0_BATCHES_DEFAULT_MASK (_MK_MASK_CONST(0x1f))
+#define CDMA_D_BATCH_NUMBER_0_BATCHES_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_BATCH_NUMBER_0_BATCHES_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_BATCH_NUMBER_0_BATCHES_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDMA_D_BATCH_NUMBER_0_BATCHES_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+// Register CDMA_D_BATCH_STRIDE_0
+#define CDMA_D_BATCH_STRIDE_0 (_MK_ADDR_CONST(0x505c))
+#define CDMA_D_BATCH_STRIDE_0_SECURE (0x0)
+#define CDMA_D_BATCH_STRIDE_0_DUAL (0x0)
+#define CDMA_D_BATCH_STRIDE_0_SCR (0)
+#define CDMA_D_BATCH_STRIDE_0_WORD_COUNT (0x1)
+#define CDMA_D_BATCH_STRIDE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_BATCH_STRIDE_0_RESET_MASK (_MK_MASK_CONST(0xffffffe0))
+#define CDMA_D_BATCH_STRIDE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_BATCH_STRIDE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_BATCH_STRIDE_0_READ_MASK (_MK_MASK_CONST(0xffffffe0))
+#define CDMA_D_BATCH_STRIDE_0_WRITE_MASK (_MK_MASK_CONST(0xffffffe0))
+#define CDMA_D_BATCH_STRIDE_0_BATCH_STRIDE_SHIFT (_MK_SHIFT_CONST(5))
+#define CDMA_D_BATCH_STRIDE_0_BATCH_STRIDE_FIELD \
+	(_MK_FIELD_CONST(0x7ffffff, CDMA_D_BATCH_STRIDE_0_BATCH_STRIDE_SHIFT))
+#define CDMA_D_BATCH_STRIDE_0_BATCH_STRIDE_RANGE (31 : 5)
+#define CDMA_D_BATCH_STRIDE_0_BATCH_STRIDE_WOFFSET (0x0)
+#define CDMA_D_BATCH_STRIDE_0_BATCH_STRIDE_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_BATCH_STRIDE_0_BATCH_STRIDE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffffff))
+#define CDMA_D_BATCH_STRIDE_0_BATCH_STRIDE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_BATCH_STRIDE_0_BATCH_STRIDE_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_BATCH_STRIDE_0_BATCH_STRIDE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_BATCH_STRIDE_0_BATCH_STRIDE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDMA_D_ENTRY_PER_SLICE_0
+#define CDMA_D_ENTRY_PER_SLICE_0 (_MK_ADDR_CONST(0x5060))
+#define CDMA_D_ENTRY_PER_SLICE_0_SECURE (0x0)
+#define CDMA_D_ENTRY_PER_SLICE_0_DUAL (0x0)
+#define CDMA_D_ENTRY_PER_SLICE_0_SCR (0)
+#define CDMA_D_ENTRY_PER_SLICE_0_WORD_COUNT (0x1)
+#define CDMA_D_ENTRY_PER_SLICE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_ENTRY_PER_SLICE_0_RESET_MASK (_MK_MASK_CONST(0xfff))
+#define CDMA_D_ENTRY_PER_SLICE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_ENTRY_PER_SLICE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_ENTRY_PER_SLICE_0_READ_MASK (_MK_MASK_CONST(0xfff))
+#define CDMA_D_ENTRY_PER_SLICE_0_WRITE_MASK (_MK_MASK_CONST(0xfff))
+#define CDMA_D_ENTRY_PER_SLICE_0_ENTRIES_SHIFT (_MK_SHIFT_CONST(0))
+#define CDMA_D_ENTRY_PER_SLICE_0_ENTRIES_FIELD \
+	(_MK_FIELD_CONST(0xfff, CDMA_D_ENTRY_PER_SLICE_0_ENTRIES_SHIFT))
+#define CDMA_D_ENTRY_PER_SLICE_0_ENTRIES_RANGE (11 : 0)
+#define CDMA_D_ENTRY_PER_SLICE_0_ENTRIES_WOFFSET (0x0)
+#define CDMA_D_ENTRY_PER_SLICE_0_ENTRIES_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_ENTRY_PER_SLICE_0_ENTRIES_DEFAULT_MASK (_MK_MASK_CONST(0xfff))
+#define CDMA_D_ENTRY_PER_SLICE_0_ENTRIES_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_ENTRY_PER_SLICE_0_ENTRIES_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_ENTRY_PER_SLICE_0_ENTRIES_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDMA_D_ENTRY_PER_SLICE_0_ENTRIES_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDMA_D_FETCH_GRAIN_0
+#define CDMA_D_FETCH_GRAIN_0 (_MK_ADDR_CONST(0x5064))
+#define CDMA_D_FETCH_GRAIN_0_SECURE (0x0)
+#define CDMA_D_FETCH_GRAIN_0_DUAL (0x0)
+#define CDMA_D_FETCH_GRAIN_0_SCR (0)
+#define CDMA_D_FETCH_GRAIN_0_WORD_COUNT (0x1)
+#define CDMA_D_FETCH_GRAIN_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_FETCH_GRAIN_0_RESET_MASK (_MK_MASK_CONST(0xfff))
+#define CDMA_D_FETCH_GRAIN_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_FETCH_GRAIN_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_FETCH_GRAIN_0_READ_MASK (_MK_MASK_CONST(0xfff))
+#define CDMA_D_FETCH_GRAIN_0_WRITE_MASK (_MK_MASK_CONST(0xfff))
+#define CDMA_D_FETCH_GRAIN_0_GRAINS_SHIFT (_MK_SHIFT_CONST(0))
+#define CDMA_D_FETCH_GRAIN_0_GRAINS_FIELD \
+	(_MK_FIELD_CONST(0xfff, CDMA_D_FETCH_GRAIN_0_GRAINS_SHIFT))
+#define CDMA_D_FETCH_GRAIN_0_GRAINS_RANGE (11 : 0)
+#define CDMA_D_FETCH_GRAIN_0_GRAINS_WOFFSET (0x0)
+#define CDMA_D_FETCH_GRAIN_0_GRAINS_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_FETCH_GRAIN_0_GRAINS_DEFAULT_MASK (_MK_MASK_CONST(0xfff))
+#define CDMA_D_FETCH_GRAIN_0_GRAINS_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_FETCH_GRAIN_0_GRAINS_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_FETCH_GRAIN_0_GRAINS_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDMA_D_FETCH_GRAIN_0_GRAINS_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+// Register CDMA_D_WEIGHT_FORMAT_0
+#define CDMA_D_WEIGHT_FORMAT_0 (_MK_ADDR_CONST(0x5068))
+#define CDMA_D_WEIGHT_FORMAT_0_SECURE (0x0)
+#define CDMA_D_WEIGHT_FORMAT_0_DUAL (0x0)
+#define CDMA_D_WEIGHT_FORMAT_0_SCR (0)
+#define CDMA_D_WEIGHT_FORMAT_0_WORD_COUNT (0x1)
+#define CDMA_D_WEIGHT_FORMAT_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_WEIGHT_FORMAT_0_RESET_MASK (_MK_MASK_CONST(0x1))
+#define CDMA_D_WEIGHT_FORMAT_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_WEIGHT_FORMAT_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_WEIGHT_FORMAT_0_READ_MASK (_MK_MASK_CONST(0x1))
+#define CDMA_D_WEIGHT_FORMAT_0_WRITE_MASK (_MK_MASK_CONST(0x1))
+#define CDMA_D_WEIGHT_FORMAT_0_WEIGHT_FORMAT_SHIFT (_MK_SHIFT_CONST(0))
+#define CDMA_D_WEIGHT_FORMAT_0_WEIGHT_FORMAT_FIELD \
+	(_MK_FIELD_CONST(0x1, CDMA_D_WEIGHT_FORMAT_0_WEIGHT_FORMAT_SHIFT))
+#define CDMA_D_WEIGHT_FORMAT_0_WEIGHT_FORMAT_RANGE (0 : 0)
+#define CDMA_D_WEIGHT_FORMAT_0_WEIGHT_FORMAT_WOFFSET (0x0)
+#define CDMA_D_WEIGHT_FORMAT_0_WEIGHT_FORMAT_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_WEIGHT_FORMAT_0_WEIGHT_FORMAT_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CDMA_D_WEIGHT_FORMAT_0_WEIGHT_FORMAT_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_WEIGHT_FORMAT_0_WEIGHT_FORMAT_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_WEIGHT_FORMAT_0_WEIGHT_FORMAT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_WEIGHT_FORMAT_0_WEIGHT_FORMAT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define CDMA_D_WEIGHT_FORMAT_0_WEIGHT_FORMAT_INIT_ENUM (UNCOMPRESSED)
+#define CDMA_D_WEIGHT_FORMAT_0_WEIGHT_FORMAT_UNCOMPRESSED (_MK_ENUM_CONST(0))
+#define CDMA_D_WEIGHT_FORMAT_0_WEIGHT_FORMAT_COMPRESSED (_MK_ENUM_CONST(1))
+
+// Register CDMA_D_WEIGHT_SIZE_0_0
+#define CDMA_D_WEIGHT_SIZE_0_0 (_MK_ADDR_CONST(0x506c))
+#define CDMA_D_WEIGHT_SIZE_0_0_SECURE (0x0)
+#define CDMA_D_WEIGHT_SIZE_0_0_DUAL (0x0)
+#define CDMA_D_WEIGHT_SIZE_0_0_SCR (0)
+#define CDMA_D_WEIGHT_SIZE_0_0_WORD_COUNT (0x1)
+#define CDMA_D_WEIGHT_SIZE_0_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_WEIGHT_SIZE_0_0_RESET_MASK (_MK_MASK_CONST(0x3ffff))
+#define CDMA_D_WEIGHT_SIZE_0_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_WEIGHT_SIZE_0_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_WEIGHT_SIZE_0_0_READ_MASK (_MK_MASK_CONST(0x3ffff))
+#define CDMA_D_WEIGHT_SIZE_0_0_WRITE_MASK (_MK_MASK_CONST(0x3ffff))
+#define CDMA_D_WEIGHT_SIZE_0_0_BYTE_PER_KERNEL_SHIFT (_MK_SHIFT_CONST(0))
+#define CDMA_D_WEIGHT_SIZE_0_0_BYTE_PER_KERNEL_FIELD \
+	(_MK_FIELD_CONST(0x3ffff, CDMA_D_WEIGHT_SIZE_0_0_BYTE_PER_KERNEL_SHIFT))
+#define CDMA_D_WEIGHT_SIZE_0_0_BYTE_PER_KERNEL_RANGE (17 : 0)
+#define CDMA_D_WEIGHT_SIZE_0_0_BYTE_PER_KERNEL_WOFFSET (0x0)
+#define CDMA_D_WEIGHT_SIZE_0_0_BYTE_PER_KERNEL_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_WEIGHT_SIZE_0_0_BYTE_PER_KERNEL_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x3ffff))
+#define CDMA_D_WEIGHT_SIZE_0_0_BYTE_PER_KERNEL_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_WEIGHT_SIZE_0_0_BYTE_PER_KERNEL_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_WEIGHT_SIZE_0_0_BYTE_PER_KERNEL_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_WEIGHT_SIZE_0_0_BYTE_PER_KERNEL_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDMA_D_WEIGHT_SIZE_1_0
+#define CDMA_D_WEIGHT_SIZE_1_0 (_MK_ADDR_CONST(0x5070))
+#define CDMA_D_WEIGHT_SIZE_1_0_SECURE (0x0)
+#define CDMA_D_WEIGHT_SIZE_1_0_DUAL (0x0)
+#define CDMA_D_WEIGHT_SIZE_1_0_SCR (0)
+#define CDMA_D_WEIGHT_SIZE_1_0_WORD_COUNT (0x1)
+#define CDMA_D_WEIGHT_SIZE_1_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_WEIGHT_SIZE_1_0_RESET_MASK (_MK_MASK_CONST(0x1fff))
+#define CDMA_D_WEIGHT_SIZE_1_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_WEIGHT_SIZE_1_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_WEIGHT_SIZE_1_0_READ_MASK (_MK_MASK_CONST(0x1fff))
+#define CDMA_D_WEIGHT_SIZE_1_0_WRITE_MASK (_MK_MASK_CONST(0x1fff))
+#define CDMA_D_WEIGHT_SIZE_1_0_WEIGHT_KERNEL_SHIFT (_MK_SHIFT_CONST(0))
+#define CDMA_D_WEIGHT_SIZE_1_0_WEIGHT_KERNEL_FIELD \
+	(_MK_FIELD_CONST(0x1fff, CDMA_D_WEIGHT_SIZE_1_0_WEIGHT_KERNEL_SHIFT))
+#define CDMA_D_WEIGHT_SIZE_1_0_WEIGHT_KERNEL_RANGE (12 : 0)
+#define CDMA_D_WEIGHT_SIZE_1_0_WEIGHT_KERNEL_WOFFSET (0x0)
+#define CDMA_D_WEIGHT_SIZE_1_0_WEIGHT_KERNEL_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_WEIGHT_SIZE_1_0_WEIGHT_KERNEL_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1fff))
+#define CDMA_D_WEIGHT_SIZE_1_0_WEIGHT_KERNEL_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_WEIGHT_SIZE_1_0_WEIGHT_KERNEL_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_WEIGHT_SIZE_1_0_WEIGHT_KERNEL_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_WEIGHT_SIZE_1_0_WEIGHT_KERNEL_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDMA_D_WEIGHT_RAM_TYPE_0
+#define CDMA_D_WEIGHT_RAM_TYPE_0 (_MK_ADDR_CONST(0x5074))
+#define CDMA_D_WEIGHT_RAM_TYPE_0_SECURE (0x0)
+#define CDMA_D_WEIGHT_RAM_TYPE_0_DUAL (0x0)
+#define CDMA_D_WEIGHT_RAM_TYPE_0_SCR (0)
+#define CDMA_D_WEIGHT_RAM_TYPE_0_WORD_COUNT (0x1)
+#define CDMA_D_WEIGHT_RAM_TYPE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_WEIGHT_RAM_TYPE_0_RESET_MASK (_MK_MASK_CONST(0x1))
+#define CDMA_D_WEIGHT_RAM_TYPE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_WEIGHT_RAM_TYPE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_WEIGHT_RAM_TYPE_0_READ_MASK (_MK_MASK_CONST(0x1))
+#define CDMA_D_WEIGHT_RAM_TYPE_0_WRITE_MASK (_MK_MASK_CONST(0x1))
+#define CDMA_D_WEIGHT_RAM_TYPE_0_WEIGHT_RAM_TYPE_SHIFT (_MK_SHIFT_CONST(0))
+#define CDMA_D_WEIGHT_RAM_TYPE_0_WEIGHT_RAM_TYPE_FIELD \
+	(_MK_FIELD_CONST(0x1, CDMA_D_WEIGHT_RAM_TYPE_0_WEIGHT_RAM_TYPE_SHIFT))
+#define CDMA_D_WEIGHT_RAM_TYPE_0_WEIGHT_RAM_TYPE_RANGE (0 : 0)
+#define CDMA_D_WEIGHT_RAM_TYPE_0_WEIGHT_RAM_TYPE_WOFFSET (0x0)
+#define CDMA_D_WEIGHT_RAM_TYPE_0_WEIGHT_RAM_TYPE_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_WEIGHT_RAM_TYPE_0_WEIGHT_RAM_TYPE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1))
+#define CDMA_D_WEIGHT_RAM_TYPE_0_WEIGHT_RAM_TYPE_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_WEIGHT_RAM_TYPE_0_WEIGHT_RAM_TYPE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_WEIGHT_RAM_TYPE_0_WEIGHT_RAM_TYPE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_WEIGHT_RAM_TYPE_0_WEIGHT_RAM_TYPE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define CDMA_D_WEIGHT_RAM_TYPE_0_WEIGHT_RAM_TYPE_INIT_ENUM (CVIF)
+#define CDMA_D_WEIGHT_RAM_TYPE_0_WEIGHT_RAM_TYPE_CVIF (_MK_ENUM_CONST(0))
+#define CDMA_D_WEIGHT_RAM_TYPE_0_WEIGHT_RAM_TYPE_MCIF (_MK_ENUM_CONST(1))
+
+// Register CDMA_D_WEIGHT_ADDR_HIGH_0
+#define CDMA_D_WEIGHT_ADDR_HIGH_0 (_MK_ADDR_CONST(0x5078))
+#define CDMA_D_WEIGHT_ADDR_HIGH_0_SECURE (0x0)
+#define CDMA_D_WEIGHT_ADDR_HIGH_0_DUAL (0x0)
+#define CDMA_D_WEIGHT_ADDR_HIGH_0_SCR (0)
+#define CDMA_D_WEIGHT_ADDR_HIGH_0_WORD_COUNT (0x1)
+#define CDMA_D_WEIGHT_ADDR_HIGH_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_WEIGHT_ADDR_HIGH_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDMA_D_WEIGHT_ADDR_HIGH_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_WEIGHT_ADDR_HIGH_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_WEIGHT_ADDR_HIGH_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDMA_D_WEIGHT_ADDR_HIGH_0_WRITE_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDMA_D_WEIGHT_ADDR_HIGH_0_WEIGHT_ADDR_HIGH_SHIFT (_MK_SHIFT_CONST(0))
+#define CDMA_D_WEIGHT_ADDR_HIGH_0_WEIGHT_ADDR_HIGH_FIELD \
+	(_MK_FIELD_CONST(0xffffffff,                     \
+			 CDMA_D_WEIGHT_ADDR_HIGH_0_WEIGHT_ADDR_HIGH_SHIFT))
+#define CDMA_D_WEIGHT_ADDR_HIGH_0_WEIGHT_ADDR_HIGH_RANGE (31 : 0)
+#define CDMA_D_WEIGHT_ADDR_HIGH_0_WEIGHT_ADDR_HIGH_WOFFSET (0x0)
+#define CDMA_D_WEIGHT_ADDR_HIGH_0_WEIGHT_ADDR_HIGH_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_WEIGHT_ADDR_HIGH_0_WEIGHT_ADDR_HIGH_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define CDMA_D_WEIGHT_ADDR_HIGH_0_WEIGHT_ADDR_HIGH_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_WEIGHT_ADDR_HIGH_0_WEIGHT_ADDR_HIGH_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_WEIGHT_ADDR_HIGH_0_WEIGHT_ADDR_HIGH_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_WEIGHT_ADDR_HIGH_0_WEIGHT_ADDR_HIGH_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDMA_D_WEIGHT_ADDR_LOW_0
+#define CDMA_D_WEIGHT_ADDR_LOW_0 (_MK_ADDR_CONST(0x507c))
+#define CDMA_D_WEIGHT_ADDR_LOW_0_SECURE (0x0)
+#define CDMA_D_WEIGHT_ADDR_LOW_0_DUAL (0x0)
+#define CDMA_D_WEIGHT_ADDR_LOW_0_SCR (0)
+#define CDMA_D_WEIGHT_ADDR_LOW_0_WORD_COUNT (0x1)
+#define CDMA_D_WEIGHT_ADDR_LOW_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_WEIGHT_ADDR_LOW_0_RESET_MASK (_MK_MASK_CONST(0xffffffe0))
+#define CDMA_D_WEIGHT_ADDR_LOW_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_WEIGHT_ADDR_LOW_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_WEIGHT_ADDR_LOW_0_READ_MASK (_MK_MASK_CONST(0xffffffe0))
+#define CDMA_D_WEIGHT_ADDR_LOW_0_WRITE_MASK (_MK_MASK_CONST(0xffffffe0))
+#define CDMA_D_WEIGHT_ADDR_LOW_0_WEIGHT_ADDR_LOW_SHIFT (_MK_SHIFT_CONST(5))
+#define CDMA_D_WEIGHT_ADDR_LOW_0_WEIGHT_ADDR_LOW_FIELD \
+	(_MK_FIELD_CONST(0x7ffffff,                    \
+			 CDMA_D_WEIGHT_ADDR_LOW_0_WEIGHT_ADDR_LOW_SHIFT))
+#define CDMA_D_WEIGHT_ADDR_LOW_0_WEIGHT_ADDR_LOW_RANGE (31 : 5)
+#define CDMA_D_WEIGHT_ADDR_LOW_0_WEIGHT_ADDR_LOW_WOFFSET (0x0)
+#define CDMA_D_WEIGHT_ADDR_LOW_0_WEIGHT_ADDR_LOW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_WEIGHT_ADDR_LOW_0_WEIGHT_ADDR_LOW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffffff))
+#define CDMA_D_WEIGHT_ADDR_LOW_0_WEIGHT_ADDR_LOW_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_WEIGHT_ADDR_LOW_0_WEIGHT_ADDR_LOW_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_WEIGHT_ADDR_LOW_0_WEIGHT_ADDR_LOW_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_WEIGHT_ADDR_LOW_0_WEIGHT_ADDR_LOW_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDMA_D_WEIGHT_BYTES_0
+#define CDMA_D_WEIGHT_BYTES_0 (_MK_ADDR_CONST(0x5080))
+#define CDMA_D_WEIGHT_BYTES_0_SECURE (0x0)
+#define CDMA_D_WEIGHT_BYTES_0_DUAL (0x0)
+#define CDMA_D_WEIGHT_BYTES_0_SCR (0)
+#define CDMA_D_WEIGHT_BYTES_0_WORD_COUNT (0x1)
+#define CDMA_D_WEIGHT_BYTES_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_WEIGHT_BYTES_0_RESET_MASK (_MK_MASK_CONST(0xffffff80))
+#define CDMA_D_WEIGHT_BYTES_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_WEIGHT_BYTES_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_WEIGHT_BYTES_0_READ_MASK (_MK_MASK_CONST(0xffffff80))
+#define CDMA_D_WEIGHT_BYTES_0_WRITE_MASK (_MK_MASK_CONST(0xffffff80))
+#define CDMA_D_WEIGHT_BYTES_0_WEIGHT_BYTES_SHIFT (_MK_SHIFT_CONST(7))
+#define CDMA_D_WEIGHT_BYTES_0_WEIGHT_BYTES_FIELD \
+	(_MK_FIELD_CONST(0x1ffffff, CDMA_D_WEIGHT_BYTES_0_WEIGHT_BYTES_SHIFT))
+#define CDMA_D_WEIGHT_BYTES_0_WEIGHT_BYTES_RANGE (31 : 7)
+#define CDMA_D_WEIGHT_BYTES_0_WEIGHT_BYTES_WOFFSET (0x0)
+#define CDMA_D_WEIGHT_BYTES_0_WEIGHT_BYTES_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_WEIGHT_BYTES_0_WEIGHT_BYTES_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1ffffff))
+#define CDMA_D_WEIGHT_BYTES_0_WEIGHT_BYTES_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_WEIGHT_BYTES_0_WEIGHT_BYTES_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_WEIGHT_BYTES_0_WEIGHT_BYTES_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_WEIGHT_BYTES_0_WEIGHT_BYTES_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDMA_D_WGS_ADDR_HIGH_0
+#define CDMA_D_WGS_ADDR_HIGH_0 (_MK_ADDR_CONST(0x5084))
+#define CDMA_D_WGS_ADDR_HIGH_0_SECURE (0x0)
+#define CDMA_D_WGS_ADDR_HIGH_0_DUAL (0x0)
+#define CDMA_D_WGS_ADDR_HIGH_0_SCR (0)
+#define CDMA_D_WGS_ADDR_HIGH_0_WORD_COUNT (0x1)
+#define CDMA_D_WGS_ADDR_HIGH_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_WGS_ADDR_HIGH_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDMA_D_WGS_ADDR_HIGH_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_WGS_ADDR_HIGH_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_WGS_ADDR_HIGH_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDMA_D_WGS_ADDR_HIGH_0_WRITE_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDMA_D_WGS_ADDR_HIGH_0_WGS_ADDR_HIGH_SHIFT (_MK_SHIFT_CONST(0))
+#define CDMA_D_WGS_ADDR_HIGH_0_WGS_ADDR_HIGH_FIELD \
+	(_MK_FIELD_CONST(0xffffffff,               \
+			 CDMA_D_WGS_ADDR_HIGH_0_WGS_ADDR_HIGH_SHIFT))
+#define CDMA_D_WGS_ADDR_HIGH_0_WGS_ADDR_HIGH_RANGE (31 : 0)
+#define CDMA_D_WGS_ADDR_HIGH_0_WGS_ADDR_HIGH_WOFFSET (0x0)
+#define CDMA_D_WGS_ADDR_HIGH_0_WGS_ADDR_HIGH_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_WGS_ADDR_HIGH_0_WGS_ADDR_HIGH_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define CDMA_D_WGS_ADDR_HIGH_0_WGS_ADDR_HIGH_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_WGS_ADDR_HIGH_0_WGS_ADDR_HIGH_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_WGS_ADDR_HIGH_0_WGS_ADDR_HIGH_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_WGS_ADDR_HIGH_0_WGS_ADDR_HIGH_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDMA_D_WGS_ADDR_LOW_0
+#define CDMA_D_WGS_ADDR_LOW_0 (_MK_ADDR_CONST(0x5088))
+#define CDMA_D_WGS_ADDR_LOW_0_SECURE (0x0)
+#define CDMA_D_WGS_ADDR_LOW_0_DUAL (0x0)
+#define CDMA_D_WGS_ADDR_LOW_0_SCR (0)
+#define CDMA_D_WGS_ADDR_LOW_0_WORD_COUNT (0x1)
+#define CDMA_D_WGS_ADDR_LOW_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_WGS_ADDR_LOW_0_RESET_MASK (_MK_MASK_CONST(0xffffffe0))
+#define CDMA_D_WGS_ADDR_LOW_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_WGS_ADDR_LOW_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_WGS_ADDR_LOW_0_READ_MASK (_MK_MASK_CONST(0xffffffe0))
+#define CDMA_D_WGS_ADDR_LOW_0_WRITE_MASK (_MK_MASK_CONST(0xffffffe0))
+#define CDMA_D_WGS_ADDR_LOW_0_WGS_ADDR_LOW_SHIFT (_MK_SHIFT_CONST(5))
+#define CDMA_D_WGS_ADDR_LOW_0_WGS_ADDR_LOW_FIELD \
+	(_MK_FIELD_CONST(0x7ffffff, CDMA_D_WGS_ADDR_LOW_0_WGS_ADDR_LOW_SHIFT))
+#define CDMA_D_WGS_ADDR_LOW_0_WGS_ADDR_LOW_RANGE (31 : 5)
+#define CDMA_D_WGS_ADDR_LOW_0_WGS_ADDR_LOW_WOFFSET (0x0)
+#define CDMA_D_WGS_ADDR_LOW_0_WGS_ADDR_LOW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_WGS_ADDR_LOW_0_WGS_ADDR_LOW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffffff))
+#define CDMA_D_WGS_ADDR_LOW_0_WGS_ADDR_LOW_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_WGS_ADDR_LOW_0_WGS_ADDR_LOW_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_WGS_ADDR_LOW_0_WGS_ADDR_LOW_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_WGS_ADDR_LOW_0_WGS_ADDR_LOW_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDMA_D_WMB_ADDR_HIGH_0
+#define CDMA_D_WMB_ADDR_HIGH_0 (_MK_ADDR_CONST(0x508c))
+#define CDMA_D_WMB_ADDR_HIGH_0_SECURE (0x0)
+#define CDMA_D_WMB_ADDR_HIGH_0_DUAL (0x0)
+#define CDMA_D_WMB_ADDR_HIGH_0_SCR (0)
+#define CDMA_D_WMB_ADDR_HIGH_0_WORD_COUNT (0x1)
+#define CDMA_D_WMB_ADDR_HIGH_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_WMB_ADDR_HIGH_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDMA_D_WMB_ADDR_HIGH_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_WMB_ADDR_HIGH_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_WMB_ADDR_HIGH_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDMA_D_WMB_ADDR_HIGH_0_WRITE_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDMA_D_WMB_ADDR_HIGH_0_WMB_ADDR_HIGH_SHIFT (_MK_SHIFT_CONST(0))
+#define CDMA_D_WMB_ADDR_HIGH_0_WMB_ADDR_HIGH_FIELD \
+	(_MK_FIELD_CONST(0xffffffff,               \
+			 CDMA_D_WMB_ADDR_HIGH_0_WMB_ADDR_HIGH_SHIFT))
+#define CDMA_D_WMB_ADDR_HIGH_0_WMB_ADDR_HIGH_RANGE (31 : 0)
+#define CDMA_D_WMB_ADDR_HIGH_0_WMB_ADDR_HIGH_WOFFSET (0x0)
+#define CDMA_D_WMB_ADDR_HIGH_0_WMB_ADDR_HIGH_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_WMB_ADDR_HIGH_0_WMB_ADDR_HIGH_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define CDMA_D_WMB_ADDR_HIGH_0_WMB_ADDR_HIGH_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_WMB_ADDR_HIGH_0_WMB_ADDR_HIGH_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_WMB_ADDR_HIGH_0_WMB_ADDR_HIGH_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_WMB_ADDR_HIGH_0_WMB_ADDR_HIGH_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDMA_D_WMB_ADDR_LOW_0
+#define CDMA_D_WMB_ADDR_LOW_0 (_MK_ADDR_CONST(0x5090))
+#define CDMA_D_WMB_ADDR_LOW_0_SECURE (0x0)
+#define CDMA_D_WMB_ADDR_LOW_0_DUAL (0x0)
+#define CDMA_D_WMB_ADDR_LOW_0_SCR (0)
+#define CDMA_D_WMB_ADDR_LOW_0_WORD_COUNT (0x1)
+#define CDMA_D_WMB_ADDR_LOW_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_WMB_ADDR_LOW_0_RESET_MASK (_MK_MASK_CONST(0xffffffe0))
+#define CDMA_D_WMB_ADDR_LOW_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_WMB_ADDR_LOW_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_WMB_ADDR_LOW_0_READ_MASK (_MK_MASK_CONST(0xffffffe0))
+#define CDMA_D_WMB_ADDR_LOW_0_WRITE_MASK (_MK_MASK_CONST(0xffffffe0))
+#define CDMA_D_WMB_ADDR_LOW_0_WMB_ADDR_LOW_SHIFT (_MK_SHIFT_CONST(5))
+#define CDMA_D_WMB_ADDR_LOW_0_WMB_ADDR_LOW_FIELD \
+	(_MK_FIELD_CONST(0x7ffffff, CDMA_D_WMB_ADDR_LOW_0_WMB_ADDR_LOW_SHIFT))
+#define CDMA_D_WMB_ADDR_LOW_0_WMB_ADDR_LOW_RANGE (31 : 5)
+#define CDMA_D_WMB_ADDR_LOW_0_WMB_ADDR_LOW_WOFFSET (0x0)
+#define CDMA_D_WMB_ADDR_LOW_0_WMB_ADDR_LOW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_WMB_ADDR_LOW_0_WMB_ADDR_LOW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffffff))
+#define CDMA_D_WMB_ADDR_LOW_0_WMB_ADDR_LOW_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_WMB_ADDR_LOW_0_WMB_ADDR_LOW_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_WMB_ADDR_LOW_0_WMB_ADDR_LOW_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_WMB_ADDR_LOW_0_WMB_ADDR_LOW_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDMA_D_WMB_BYTES_0
+#define CDMA_D_WMB_BYTES_0 (_MK_ADDR_CONST(0x5094))
+#define CDMA_D_WMB_BYTES_0_SECURE (0x0)
+#define CDMA_D_WMB_BYTES_0_DUAL (0x0)
+#define CDMA_D_WMB_BYTES_0_SCR (0)
+#define CDMA_D_WMB_BYTES_0_WORD_COUNT (0x1)
+#define CDMA_D_WMB_BYTES_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_WMB_BYTES_0_RESET_MASK (_MK_MASK_CONST(0xfffff80))
+#define CDMA_D_WMB_BYTES_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_WMB_BYTES_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_WMB_BYTES_0_READ_MASK (_MK_MASK_CONST(0xfffff80))
+#define CDMA_D_WMB_BYTES_0_WRITE_MASK (_MK_MASK_CONST(0xfffff80))
+#define CDMA_D_WMB_BYTES_0_WMB_BYTES_SHIFT (_MK_SHIFT_CONST(7))
+#define CDMA_D_WMB_BYTES_0_WMB_BYTES_FIELD \
+	(_MK_FIELD_CONST(0x1fffff, CDMA_D_WMB_BYTES_0_WMB_BYTES_SHIFT))
+#define CDMA_D_WMB_BYTES_0_WMB_BYTES_RANGE (27 : 7)
+#define CDMA_D_WMB_BYTES_0_WMB_BYTES_WOFFSET (0x0)
+#define CDMA_D_WMB_BYTES_0_WMB_BYTES_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_WMB_BYTES_0_WMB_BYTES_DEFAULT_MASK (_MK_MASK_CONST(0x1fffff))
+#define CDMA_D_WMB_BYTES_0_WMB_BYTES_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_WMB_BYTES_0_WMB_BYTES_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_WMB_BYTES_0_WMB_BYTES_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDMA_D_WMB_BYTES_0_WMB_BYTES_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+// Register CDMA_D_MEAN_FORMAT_0
+#define CDMA_D_MEAN_FORMAT_0 (_MK_ADDR_CONST(0x5098))
+#define CDMA_D_MEAN_FORMAT_0_SECURE (0x0)
+#define CDMA_D_MEAN_FORMAT_0_DUAL (0x0)
+#define CDMA_D_MEAN_FORMAT_0_SCR (0)
+#define CDMA_D_MEAN_FORMAT_0_WORD_COUNT (0x1)
+#define CDMA_D_MEAN_FORMAT_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_MEAN_FORMAT_0_RESET_MASK (_MK_MASK_CONST(0x1))
+#define CDMA_D_MEAN_FORMAT_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_MEAN_FORMAT_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_MEAN_FORMAT_0_READ_MASK (_MK_MASK_CONST(0x1))
+#define CDMA_D_MEAN_FORMAT_0_WRITE_MASK (_MK_MASK_CONST(0x1))
+#define CDMA_D_MEAN_FORMAT_0_MEAN_FORMAT_SHIFT (_MK_SHIFT_CONST(0))
+#define CDMA_D_MEAN_FORMAT_0_MEAN_FORMAT_FIELD \
+	(_MK_FIELD_CONST(0x1, CDMA_D_MEAN_FORMAT_0_MEAN_FORMAT_SHIFT))
+#define CDMA_D_MEAN_FORMAT_0_MEAN_FORMAT_RANGE (0 : 0)
+#define CDMA_D_MEAN_FORMAT_0_MEAN_FORMAT_WOFFSET (0x0)
+#define CDMA_D_MEAN_FORMAT_0_MEAN_FORMAT_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_MEAN_FORMAT_0_MEAN_FORMAT_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CDMA_D_MEAN_FORMAT_0_MEAN_FORMAT_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_MEAN_FORMAT_0_MEAN_FORMAT_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_MEAN_FORMAT_0_MEAN_FORMAT_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDMA_D_MEAN_FORMAT_0_MEAN_FORMAT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define CDMA_D_MEAN_FORMAT_0_MEAN_FORMAT_INIT_ENUM (DISABLE)
+#define CDMA_D_MEAN_FORMAT_0_MEAN_FORMAT_DISABLE (_MK_ENUM_CONST(0))
+#define CDMA_D_MEAN_FORMAT_0_MEAN_FORMAT_ENABLE (_MK_ENUM_CONST(1))
+
+// Register CDMA_D_MEAN_GLOBAL_0_0
+#define CDMA_D_MEAN_GLOBAL_0_0 (_MK_ADDR_CONST(0x509c))
+#define CDMA_D_MEAN_GLOBAL_0_0_SECURE (0x0)
+#define CDMA_D_MEAN_GLOBAL_0_0_DUAL (0x0)
+#define CDMA_D_MEAN_GLOBAL_0_0_SCR (0)
+#define CDMA_D_MEAN_GLOBAL_0_0_WORD_COUNT (0x1)
+#define CDMA_D_MEAN_GLOBAL_0_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_MEAN_GLOBAL_0_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDMA_D_MEAN_GLOBAL_0_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_MEAN_GLOBAL_0_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_MEAN_GLOBAL_0_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDMA_D_MEAN_GLOBAL_0_0_WRITE_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDMA_D_MEAN_GLOBAL_0_0_MEAN_RY_SHIFT (_MK_SHIFT_CONST(0))
+#define CDMA_D_MEAN_GLOBAL_0_0_MEAN_RY_FIELD \
+	(_MK_FIELD_CONST(0xffff, CDMA_D_MEAN_GLOBAL_0_0_MEAN_RY_SHIFT))
+#define CDMA_D_MEAN_GLOBAL_0_0_MEAN_RY_RANGE (15 : 0)
+#define CDMA_D_MEAN_GLOBAL_0_0_MEAN_RY_WOFFSET (0x0)
+#define CDMA_D_MEAN_GLOBAL_0_0_MEAN_RY_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_MEAN_GLOBAL_0_0_MEAN_RY_DEFAULT_MASK (_MK_MASK_CONST(0xffff))
+#define CDMA_D_MEAN_GLOBAL_0_0_MEAN_RY_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_MEAN_GLOBAL_0_0_MEAN_RY_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_MEAN_GLOBAL_0_0_MEAN_RY_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDMA_D_MEAN_GLOBAL_0_0_MEAN_RY_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+#define CDMA_D_MEAN_GLOBAL_0_0_MEAN_GU_SHIFT (_MK_SHIFT_CONST(16))
+#define CDMA_D_MEAN_GLOBAL_0_0_MEAN_GU_FIELD \
+	(_MK_FIELD_CONST(0xffff, CDMA_D_MEAN_GLOBAL_0_0_MEAN_GU_SHIFT))
+#define CDMA_D_MEAN_GLOBAL_0_0_MEAN_GU_RANGE (31 : 16)
+#define CDMA_D_MEAN_GLOBAL_0_0_MEAN_GU_WOFFSET (0x0)
+#define CDMA_D_MEAN_GLOBAL_0_0_MEAN_GU_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_MEAN_GLOBAL_0_0_MEAN_GU_DEFAULT_MASK (_MK_MASK_CONST(0xffff))
+#define CDMA_D_MEAN_GLOBAL_0_0_MEAN_GU_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_MEAN_GLOBAL_0_0_MEAN_GU_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_MEAN_GLOBAL_0_0_MEAN_GU_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDMA_D_MEAN_GLOBAL_0_0_MEAN_GU_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+// Register CDMA_D_MEAN_GLOBAL_1_0
+#define CDMA_D_MEAN_GLOBAL_1_0 (_MK_ADDR_CONST(0x50a0))
+#define CDMA_D_MEAN_GLOBAL_1_0_SECURE (0x0)
+#define CDMA_D_MEAN_GLOBAL_1_0_DUAL (0x0)
+#define CDMA_D_MEAN_GLOBAL_1_0_SCR (0)
+#define CDMA_D_MEAN_GLOBAL_1_0_WORD_COUNT (0x1)
+#define CDMA_D_MEAN_GLOBAL_1_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_MEAN_GLOBAL_1_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDMA_D_MEAN_GLOBAL_1_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_MEAN_GLOBAL_1_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_MEAN_GLOBAL_1_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDMA_D_MEAN_GLOBAL_1_0_WRITE_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDMA_D_MEAN_GLOBAL_1_0_MEAN_BV_SHIFT (_MK_SHIFT_CONST(0))
+#define CDMA_D_MEAN_GLOBAL_1_0_MEAN_BV_FIELD \
+	(_MK_FIELD_CONST(0xffff, CDMA_D_MEAN_GLOBAL_1_0_MEAN_BV_SHIFT))
+#define CDMA_D_MEAN_GLOBAL_1_0_MEAN_BV_RANGE (15 : 0)
+#define CDMA_D_MEAN_GLOBAL_1_0_MEAN_BV_WOFFSET (0x0)
+#define CDMA_D_MEAN_GLOBAL_1_0_MEAN_BV_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_MEAN_GLOBAL_1_0_MEAN_BV_DEFAULT_MASK (_MK_MASK_CONST(0xffff))
+#define CDMA_D_MEAN_GLOBAL_1_0_MEAN_BV_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_MEAN_GLOBAL_1_0_MEAN_BV_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_MEAN_GLOBAL_1_0_MEAN_BV_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDMA_D_MEAN_GLOBAL_1_0_MEAN_BV_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+#define CDMA_D_MEAN_GLOBAL_1_0_MEAN_AX_SHIFT (_MK_SHIFT_CONST(16))
+#define CDMA_D_MEAN_GLOBAL_1_0_MEAN_AX_FIELD \
+	(_MK_FIELD_CONST(0xffff, CDMA_D_MEAN_GLOBAL_1_0_MEAN_AX_SHIFT))
+#define CDMA_D_MEAN_GLOBAL_1_0_MEAN_AX_RANGE (31 : 16)
+#define CDMA_D_MEAN_GLOBAL_1_0_MEAN_AX_WOFFSET (0x0)
+#define CDMA_D_MEAN_GLOBAL_1_0_MEAN_AX_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_MEAN_GLOBAL_1_0_MEAN_AX_DEFAULT_MASK (_MK_MASK_CONST(0xffff))
+#define CDMA_D_MEAN_GLOBAL_1_0_MEAN_AX_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_MEAN_GLOBAL_1_0_MEAN_AX_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_MEAN_GLOBAL_1_0_MEAN_AX_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDMA_D_MEAN_GLOBAL_1_0_MEAN_AX_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+// Register CDMA_D_CVT_CFG_0
+#define CDMA_D_CVT_CFG_0 (_MK_ADDR_CONST(0x50a4))
+#define CDMA_D_CVT_CFG_0_SECURE (0x0)
+#define CDMA_D_CVT_CFG_0_DUAL (0x0)
+#define CDMA_D_CVT_CFG_0_SCR (0)
+#define CDMA_D_CVT_CFG_0_WORD_COUNT (0x1)
+#define CDMA_D_CVT_CFG_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_CVT_CFG_0_RESET_MASK (_MK_MASK_CONST(0x3f1))
+#define CDMA_D_CVT_CFG_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_CVT_CFG_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_CVT_CFG_0_READ_MASK (_MK_MASK_CONST(0x3f1))
+#define CDMA_D_CVT_CFG_0_WRITE_MASK (_MK_MASK_CONST(0x3f1))
+#define CDMA_D_CVT_CFG_0_CVT_EN_SHIFT (_MK_SHIFT_CONST(0))
+#define CDMA_D_CVT_CFG_0_CVT_EN_FIELD \
+	(_MK_FIELD_CONST(0x1, CDMA_D_CVT_CFG_0_CVT_EN_SHIFT))
+#define CDMA_D_CVT_CFG_0_CVT_EN_RANGE (0 : 0)
+#define CDMA_D_CVT_CFG_0_CVT_EN_WOFFSET (0x0)
+#define CDMA_D_CVT_CFG_0_CVT_EN_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_CVT_CFG_0_CVT_EN_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CDMA_D_CVT_CFG_0_CVT_EN_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_CVT_CFG_0_CVT_EN_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_CVT_CFG_0_CVT_EN_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDMA_D_CVT_CFG_0_CVT_EN_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define CDMA_D_CVT_CFG_0_CVT_EN_INIT_ENUM (DISABLE)
+#define CDMA_D_CVT_CFG_0_CVT_EN_DISABLE (_MK_ENUM_CONST(0))
+#define CDMA_D_CVT_CFG_0_CVT_EN_ENABLE (_MK_ENUM_CONST(1))
+
+#define CDMA_D_CVT_CFG_0_CVT_TRUNCATE_SHIFT (_MK_SHIFT_CONST(4))
+#define CDMA_D_CVT_CFG_0_CVT_TRUNCATE_FIELD \
+	(_MK_FIELD_CONST(0x3f, CDMA_D_CVT_CFG_0_CVT_TRUNCATE_SHIFT))
+#define CDMA_D_CVT_CFG_0_CVT_TRUNCATE_RANGE (9 : 4)
+#define CDMA_D_CVT_CFG_0_CVT_TRUNCATE_WOFFSET (0x0)
+#define CDMA_D_CVT_CFG_0_CVT_TRUNCATE_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_CVT_CFG_0_CVT_TRUNCATE_DEFAULT_MASK (_MK_MASK_CONST(0x3f))
+#define CDMA_D_CVT_CFG_0_CVT_TRUNCATE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_CVT_CFG_0_CVT_TRUNCATE_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_CVT_CFG_0_CVT_TRUNCATE_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDMA_D_CVT_CFG_0_CVT_TRUNCATE_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+// Register CDMA_D_CVT_OFFSET_0
+#define CDMA_D_CVT_OFFSET_0 (_MK_ADDR_CONST(0x50a8))
+#define CDMA_D_CVT_OFFSET_0_SECURE (0x0)
+#define CDMA_D_CVT_OFFSET_0_DUAL (0x0)
+#define CDMA_D_CVT_OFFSET_0_SCR (0)
+#define CDMA_D_CVT_OFFSET_0_WORD_COUNT (0x1)
+#define CDMA_D_CVT_OFFSET_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_CVT_OFFSET_0_RESET_MASK (_MK_MASK_CONST(0xffff))
+#define CDMA_D_CVT_OFFSET_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_CVT_OFFSET_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_CVT_OFFSET_0_READ_MASK (_MK_MASK_CONST(0xffff))
+#define CDMA_D_CVT_OFFSET_0_WRITE_MASK (_MK_MASK_CONST(0xffff))
+#define CDMA_D_CVT_OFFSET_0_CVT_OFFSET_SHIFT (_MK_SHIFT_CONST(0))
+#define CDMA_D_CVT_OFFSET_0_CVT_OFFSET_FIELD \
+	(_MK_FIELD_CONST(0xffff, CDMA_D_CVT_OFFSET_0_CVT_OFFSET_SHIFT))
+#define CDMA_D_CVT_OFFSET_0_CVT_OFFSET_RANGE (15 : 0)
+#define CDMA_D_CVT_OFFSET_0_CVT_OFFSET_WOFFSET (0x0)
+#define CDMA_D_CVT_OFFSET_0_CVT_OFFSET_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_CVT_OFFSET_0_CVT_OFFSET_DEFAULT_MASK (_MK_MASK_CONST(0xffff))
+#define CDMA_D_CVT_OFFSET_0_CVT_OFFSET_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_CVT_OFFSET_0_CVT_OFFSET_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_CVT_OFFSET_0_CVT_OFFSET_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDMA_D_CVT_OFFSET_0_CVT_OFFSET_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+// Register CDMA_D_CVT_SCALE_0
+#define CDMA_D_CVT_SCALE_0 (_MK_ADDR_CONST(0x50ac))
+#define CDMA_D_CVT_SCALE_0_SECURE (0x0)
+#define CDMA_D_CVT_SCALE_0_DUAL (0x0)
+#define CDMA_D_CVT_SCALE_0_SCR (0)
+#define CDMA_D_CVT_SCALE_0_WORD_COUNT (0x1)
+#define CDMA_D_CVT_SCALE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_CVT_SCALE_0_RESET_MASK (_MK_MASK_CONST(0xffff))
+#define CDMA_D_CVT_SCALE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_CVT_SCALE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_CVT_SCALE_0_READ_MASK (_MK_MASK_CONST(0xffff))
+#define CDMA_D_CVT_SCALE_0_WRITE_MASK (_MK_MASK_CONST(0xffff))
+#define CDMA_D_CVT_SCALE_0_CVT_SCALE_SHIFT (_MK_SHIFT_CONST(0))
+#define CDMA_D_CVT_SCALE_0_CVT_SCALE_FIELD \
+	(_MK_FIELD_CONST(0xffff, CDMA_D_CVT_SCALE_0_CVT_SCALE_SHIFT))
+#define CDMA_D_CVT_SCALE_0_CVT_SCALE_RANGE (15 : 0)
+#define CDMA_D_CVT_SCALE_0_CVT_SCALE_WOFFSET (0x0)
+#define CDMA_D_CVT_SCALE_0_CVT_SCALE_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_CVT_SCALE_0_CVT_SCALE_DEFAULT_MASK (_MK_MASK_CONST(0xffff))
+#define CDMA_D_CVT_SCALE_0_CVT_SCALE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_CVT_SCALE_0_CVT_SCALE_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_CVT_SCALE_0_CVT_SCALE_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDMA_D_CVT_SCALE_0_CVT_SCALE_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+// Register CDMA_D_CONV_STRIDE_0
+#define CDMA_D_CONV_STRIDE_0 (_MK_ADDR_CONST(0x50b0))
+#define CDMA_D_CONV_STRIDE_0_SECURE (0x0)
+#define CDMA_D_CONV_STRIDE_0_DUAL (0x0)
+#define CDMA_D_CONV_STRIDE_0_SCR (0)
+#define CDMA_D_CONV_STRIDE_0_WORD_COUNT (0x1)
+#define CDMA_D_CONV_STRIDE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_CONV_STRIDE_0_RESET_MASK (_MK_MASK_CONST(0x70007))
+#define CDMA_D_CONV_STRIDE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_CONV_STRIDE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_CONV_STRIDE_0_READ_MASK (_MK_MASK_CONST(0x70007))
+#define CDMA_D_CONV_STRIDE_0_WRITE_MASK (_MK_MASK_CONST(0x70007))
+#define CDMA_D_CONV_STRIDE_0_CONV_X_STRIDE_SHIFT (_MK_SHIFT_CONST(0))
+#define CDMA_D_CONV_STRIDE_0_CONV_X_STRIDE_FIELD \
+	(_MK_FIELD_CONST(0x7, CDMA_D_CONV_STRIDE_0_CONV_X_STRIDE_SHIFT))
+#define CDMA_D_CONV_STRIDE_0_CONV_X_STRIDE_RANGE (2 : 0)
+#define CDMA_D_CONV_STRIDE_0_CONV_X_STRIDE_WOFFSET (0x0)
+#define CDMA_D_CONV_STRIDE_0_CONV_X_STRIDE_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_CONV_STRIDE_0_CONV_X_STRIDE_DEFAULT_MASK (_MK_MASK_CONST(0x7))
+#define CDMA_D_CONV_STRIDE_0_CONV_X_STRIDE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_CONV_STRIDE_0_CONV_X_STRIDE_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_CONV_STRIDE_0_CONV_X_STRIDE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_CONV_STRIDE_0_CONV_X_STRIDE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define CDMA_D_CONV_STRIDE_0_CONV_Y_STRIDE_SHIFT (_MK_SHIFT_CONST(16))
+#define CDMA_D_CONV_STRIDE_0_CONV_Y_STRIDE_FIELD \
+	(_MK_FIELD_CONST(0x7, CDMA_D_CONV_STRIDE_0_CONV_Y_STRIDE_SHIFT))
+#define CDMA_D_CONV_STRIDE_0_CONV_Y_STRIDE_RANGE (18 : 16)
+#define CDMA_D_CONV_STRIDE_0_CONV_Y_STRIDE_WOFFSET (0x0)
+#define CDMA_D_CONV_STRIDE_0_CONV_Y_STRIDE_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_CONV_STRIDE_0_CONV_Y_STRIDE_DEFAULT_MASK (_MK_MASK_CONST(0x7))
+#define CDMA_D_CONV_STRIDE_0_CONV_Y_STRIDE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_CONV_STRIDE_0_CONV_Y_STRIDE_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_CONV_STRIDE_0_CONV_Y_STRIDE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_CONV_STRIDE_0_CONV_Y_STRIDE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDMA_D_ZERO_PADDING_0
+#define CDMA_D_ZERO_PADDING_0 (_MK_ADDR_CONST(0x50b4))
+#define CDMA_D_ZERO_PADDING_0_SECURE (0x0)
+#define CDMA_D_ZERO_PADDING_0_DUAL (0x0)
+#define CDMA_D_ZERO_PADDING_0_SCR (0)
+#define CDMA_D_ZERO_PADDING_0_WORD_COUNT (0x1)
+#define CDMA_D_ZERO_PADDING_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_ZERO_PADDING_0_RESET_MASK (_MK_MASK_CONST(0x3f1f3f1f))
+#define CDMA_D_ZERO_PADDING_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_ZERO_PADDING_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_ZERO_PADDING_0_READ_MASK (_MK_MASK_CONST(0x3f1f3f1f))
+#define CDMA_D_ZERO_PADDING_0_WRITE_MASK (_MK_MASK_CONST(0x3f1f3f1f))
+#define CDMA_D_ZERO_PADDING_0_PAD_LEFT_SHIFT (_MK_SHIFT_CONST(0))
+#define CDMA_D_ZERO_PADDING_0_PAD_LEFT_FIELD \
+	(_MK_FIELD_CONST(0x1f, CDMA_D_ZERO_PADDING_0_PAD_LEFT_SHIFT))
+#define CDMA_D_ZERO_PADDING_0_PAD_LEFT_RANGE (4 : 0)
+#define CDMA_D_ZERO_PADDING_0_PAD_LEFT_WOFFSET (0x0)
+#define CDMA_D_ZERO_PADDING_0_PAD_LEFT_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_ZERO_PADDING_0_PAD_LEFT_DEFAULT_MASK (_MK_MASK_CONST(0x1f))
+#define CDMA_D_ZERO_PADDING_0_PAD_LEFT_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_ZERO_PADDING_0_PAD_LEFT_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_ZERO_PADDING_0_PAD_LEFT_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDMA_D_ZERO_PADDING_0_PAD_LEFT_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+#define CDMA_D_ZERO_PADDING_0_PAD_RIGHT_SHIFT (_MK_SHIFT_CONST(8))
+#define CDMA_D_ZERO_PADDING_0_PAD_RIGHT_FIELD \
+	(_MK_FIELD_CONST(0x3f, CDMA_D_ZERO_PADDING_0_PAD_RIGHT_SHIFT))
+#define CDMA_D_ZERO_PADDING_0_PAD_RIGHT_RANGE (13 : 8)
+#define CDMA_D_ZERO_PADDING_0_PAD_RIGHT_WOFFSET (0x0)
+#define CDMA_D_ZERO_PADDING_0_PAD_RIGHT_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_ZERO_PADDING_0_PAD_RIGHT_DEFAULT_MASK (_MK_MASK_CONST(0x3f))
+#define CDMA_D_ZERO_PADDING_0_PAD_RIGHT_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_ZERO_PADDING_0_PAD_RIGHT_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_ZERO_PADDING_0_PAD_RIGHT_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDMA_D_ZERO_PADDING_0_PAD_RIGHT_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+#define CDMA_D_ZERO_PADDING_0_PAD_TOP_SHIFT (_MK_SHIFT_CONST(16))
+#define CDMA_D_ZERO_PADDING_0_PAD_TOP_FIELD \
+	(_MK_FIELD_CONST(0x1f, CDMA_D_ZERO_PADDING_0_PAD_TOP_SHIFT))
+#define CDMA_D_ZERO_PADDING_0_PAD_TOP_RANGE (20 : 16)
+#define CDMA_D_ZERO_PADDING_0_PAD_TOP_WOFFSET (0x0)
+#define CDMA_D_ZERO_PADDING_0_PAD_TOP_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_ZERO_PADDING_0_PAD_TOP_DEFAULT_MASK (_MK_MASK_CONST(0x1f))
+#define CDMA_D_ZERO_PADDING_0_PAD_TOP_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_ZERO_PADDING_0_PAD_TOP_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_ZERO_PADDING_0_PAD_TOP_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDMA_D_ZERO_PADDING_0_PAD_TOP_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+#define CDMA_D_ZERO_PADDING_0_PAD_BOTTOM_SHIFT (_MK_SHIFT_CONST(24))
+#define CDMA_D_ZERO_PADDING_0_PAD_BOTTOM_FIELD \
+	(_MK_FIELD_CONST(0x3f, CDMA_D_ZERO_PADDING_0_PAD_BOTTOM_SHIFT))
+#define CDMA_D_ZERO_PADDING_0_PAD_BOTTOM_RANGE (29 : 24)
+#define CDMA_D_ZERO_PADDING_0_PAD_BOTTOM_WOFFSET (0x0)
+#define CDMA_D_ZERO_PADDING_0_PAD_BOTTOM_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_ZERO_PADDING_0_PAD_BOTTOM_DEFAULT_MASK (_MK_MASK_CONST(0x3f))
+#define CDMA_D_ZERO_PADDING_0_PAD_BOTTOM_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_ZERO_PADDING_0_PAD_BOTTOM_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_ZERO_PADDING_0_PAD_BOTTOM_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDMA_D_ZERO_PADDING_0_PAD_BOTTOM_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDMA_D_ZERO_PADDING_VALUE_0
+#define CDMA_D_ZERO_PADDING_VALUE_0 (_MK_ADDR_CONST(0x50b8))
+#define CDMA_D_ZERO_PADDING_VALUE_0_SECURE (0x0)
+#define CDMA_D_ZERO_PADDING_VALUE_0_DUAL (0x0)
+#define CDMA_D_ZERO_PADDING_VALUE_0_SCR (0)
+#define CDMA_D_ZERO_PADDING_VALUE_0_WORD_COUNT (0x1)
+#define CDMA_D_ZERO_PADDING_VALUE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_ZERO_PADDING_VALUE_0_RESET_MASK (_MK_MASK_CONST(0xffff))
+#define CDMA_D_ZERO_PADDING_VALUE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_ZERO_PADDING_VALUE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_ZERO_PADDING_VALUE_0_READ_MASK (_MK_MASK_CONST(0xffff))
+#define CDMA_D_ZERO_PADDING_VALUE_0_WRITE_MASK (_MK_MASK_CONST(0xffff))
+#define CDMA_D_ZERO_PADDING_VALUE_0_PAD_VALUE_SHIFT (_MK_SHIFT_CONST(0))
+#define CDMA_D_ZERO_PADDING_VALUE_0_PAD_VALUE_FIELD \
+	(_MK_FIELD_CONST(0xffff, CDMA_D_ZERO_PADDING_VALUE_0_PAD_VALUE_SHIFT))
+#define CDMA_D_ZERO_PADDING_VALUE_0_PAD_VALUE_RANGE (15 : 0)
+#define CDMA_D_ZERO_PADDING_VALUE_0_PAD_VALUE_WOFFSET (0x0)
+#define CDMA_D_ZERO_PADDING_VALUE_0_PAD_VALUE_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_ZERO_PADDING_VALUE_0_PAD_VALUE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffff))
+#define CDMA_D_ZERO_PADDING_VALUE_0_PAD_VALUE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_ZERO_PADDING_VALUE_0_PAD_VALUE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_ZERO_PADDING_VALUE_0_PAD_VALUE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_ZERO_PADDING_VALUE_0_PAD_VALUE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDMA_D_BANK_0
+#define CDMA_D_BANK_0 (_MK_ADDR_CONST(0x50bc))
+#define CDMA_D_BANK_0_SECURE (0x0)
+#define CDMA_D_BANK_0_DUAL (0x0)
+#define CDMA_D_BANK_0_SCR (0)
+#define CDMA_D_BANK_0_WORD_COUNT (0x1)
+#define CDMA_D_BANK_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_BANK_0_RESET_MASK (_MK_MASK_CONST(0xf000f))
+#define CDMA_D_BANK_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_BANK_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_BANK_0_READ_MASK (_MK_MASK_CONST(0xf000f))
+#define CDMA_D_BANK_0_WRITE_MASK (_MK_MASK_CONST(0xf000f))
+#define CDMA_D_BANK_0_DATA_BANK_SHIFT (_MK_SHIFT_CONST(0))
+#define CDMA_D_BANK_0_DATA_BANK_FIELD \
+	(_MK_FIELD_CONST(0xf, CDMA_D_BANK_0_DATA_BANK_SHIFT))
+#define CDMA_D_BANK_0_DATA_BANK_RANGE (3 : 0)
+#define CDMA_D_BANK_0_DATA_BANK_WOFFSET (0x0)
+#define CDMA_D_BANK_0_DATA_BANK_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_BANK_0_DATA_BANK_DEFAULT_MASK (_MK_MASK_CONST(0xf))
+#define CDMA_D_BANK_0_DATA_BANK_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_BANK_0_DATA_BANK_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_BANK_0_DATA_BANK_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDMA_D_BANK_0_DATA_BANK_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+#define CDMA_D_BANK_0_WEIGHT_BANK_SHIFT (_MK_SHIFT_CONST(16))
+#define CDMA_D_BANK_0_WEIGHT_BANK_FIELD \
+	(_MK_FIELD_CONST(0xf, CDMA_D_BANK_0_WEIGHT_BANK_SHIFT))
+#define CDMA_D_BANK_0_WEIGHT_BANK_RANGE (19 : 16)
+#define CDMA_D_BANK_0_WEIGHT_BANK_WOFFSET (0x0)
+#define CDMA_D_BANK_0_WEIGHT_BANK_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_BANK_0_WEIGHT_BANK_DEFAULT_MASK (_MK_MASK_CONST(0xf))
+#define CDMA_D_BANK_0_WEIGHT_BANK_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_BANK_0_WEIGHT_BANK_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_BANK_0_WEIGHT_BANK_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDMA_D_BANK_0_WEIGHT_BANK_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+// Register CDMA_D_NAN_FLUSH_TO_ZERO_0
+#define CDMA_D_NAN_FLUSH_TO_ZERO_0 (_MK_ADDR_CONST(0x50c0))
+#define CDMA_D_NAN_FLUSH_TO_ZERO_0_SECURE (0x0)
+#define CDMA_D_NAN_FLUSH_TO_ZERO_0_DUAL (0x0)
+#define CDMA_D_NAN_FLUSH_TO_ZERO_0_SCR (0)
+#define CDMA_D_NAN_FLUSH_TO_ZERO_0_WORD_COUNT (0x1)
+#define CDMA_D_NAN_FLUSH_TO_ZERO_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_NAN_FLUSH_TO_ZERO_0_RESET_MASK (_MK_MASK_CONST(0x1))
+#define CDMA_D_NAN_FLUSH_TO_ZERO_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_NAN_FLUSH_TO_ZERO_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_NAN_FLUSH_TO_ZERO_0_READ_MASK (_MK_MASK_CONST(0x1))
+#define CDMA_D_NAN_FLUSH_TO_ZERO_0_WRITE_MASK (_MK_MASK_CONST(0x1))
+#define CDMA_D_NAN_FLUSH_TO_ZERO_0_NAN_TO_ZERO_SHIFT (_MK_SHIFT_CONST(0))
+#define CDMA_D_NAN_FLUSH_TO_ZERO_0_NAN_TO_ZERO_FIELD \
+	(_MK_FIELD_CONST(0x1, CDMA_D_NAN_FLUSH_TO_ZERO_0_NAN_TO_ZERO_SHIFT))
+#define CDMA_D_NAN_FLUSH_TO_ZERO_0_NAN_TO_ZERO_RANGE (0 : 0)
+#define CDMA_D_NAN_FLUSH_TO_ZERO_0_NAN_TO_ZERO_WOFFSET (0x0)
+#define CDMA_D_NAN_FLUSH_TO_ZERO_0_NAN_TO_ZERO_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_NAN_FLUSH_TO_ZERO_0_NAN_TO_ZERO_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1))
+#define CDMA_D_NAN_FLUSH_TO_ZERO_0_NAN_TO_ZERO_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_NAN_FLUSH_TO_ZERO_0_NAN_TO_ZERO_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_NAN_FLUSH_TO_ZERO_0_NAN_TO_ZERO_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_NAN_FLUSH_TO_ZERO_0_NAN_TO_ZERO_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define CDMA_D_NAN_FLUSH_TO_ZERO_0_NAN_TO_ZERO_INIT_ENUM (DISABLE)
+#define CDMA_D_NAN_FLUSH_TO_ZERO_0_NAN_TO_ZERO_DISABLE (_MK_ENUM_CONST(0))
+#define CDMA_D_NAN_FLUSH_TO_ZERO_0_NAN_TO_ZERO_ENABLE (_MK_ENUM_CONST(1))
+
+// Register CDMA_D_NAN_INPUT_DATA_NUM_0
+#define CDMA_D_NAN_INPUT_DATA_NUM_0 (_MK_ADDR_CONST(0x50c4))
+#define CDMA_D_NAN_INPUT_DATA_NUM_0_SECURE (0x0)
+#define CDMA_D_NAN_INPUT_DATA_NUM_0_DUAL (0x0)
+#define CDMA_D_NAN_INPUT_DATA_NUM_0_SCR (0)
+#define CDMA_D_NAN_INPUT_DATA_NUM_0_WORD_COUNT (0x1)
+#define CDMA_D_NAN_INPUT_DATA_NUM_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_NAN_INPUT_DATA_NUM_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDMA_D_NAN_INPUT_DATA_NUM_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_NAN_INPUT_DATA_NUM_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_NAN_INPUT_DATA_NUM_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDMA_D_NAN_INPUT_DATA_NUM_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_NAN_INPUT_DATA_NUM_0_NAN_DATA_NUM_SHIFT (_MK_SHIFT_CONST(0))
+#define CDMA_D_NAN_INPUT_DATA_NUM_0_NAN_DATA_NUM_FIELD \
+	(_MK_FIELD_CONST(0xffffffff,                   \
+			 CDMA_D_NAN_INPUT_DATA_NUM_0_NAN_DATA_NUM_SHIFT))
+#define CDMA_D_NAN_INPUT_DATA_NUM_0_NAN_DATA_NUM_RANGE (31 : 0)
+#define CDMA_D_NAN_INPUT_DATA_NUM_0_NAN_DATA_NUM_WOFFSET (0x0)
+#define CDMA_D_NAN_INPUT_DATA_NUM_0_NAN_DATA_NUM_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_NAN_INPUT_DATA_NUM_0_NAN_DATA_NUM_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define CDMA_D_NAN_INPUT_DATA_NUM_0_NAN_DATA_NUM_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_NAN_INPUT_DATA_NUM_0_NAN_DATA_NUM_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_NAN_INPUT_DATA_NUM_0_NAN_DATA_NUM_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_NAN_INPUT_DATA_NUM_0_NAN_DATA_NUM_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDMA_D_NAN_INPUT_WEIGHT_NUM_0
+#define CDMA_D_NAN_INPUT_WEIGHT_NUM_0 (_MK_ADDR_CONST(0x50c8))
+#define CDMA_D_NAN_INPUT_WEIGHT_NUM_0_SECURE (0x0)
+#define CDMA_D_NAN_INPUT_WEIGHT_NUM_0_DUAL (0x0)
+#define CDMA_D_NAN_INPUT_WEIGHT_NUM_0_SCR (0)
+#define CDMA_D_NAN_INPUT_WEIGHT_NUM_0_WORD_COUNT (0x1)
+#define CDMA_D_NAN_INPUT_WEIGHT_NUM_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_NAN_INPUT_WEIGHT_NUM_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDMA_D_NAN_INPUT_WEIGHT_NUM_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_NAN_INPUT_WEIGHT_NUM_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_NAN_INPUT_WEIGHT_NUM_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDMA_D_NAN_INPUT_WEIGHT_NUM_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_NAN_INPUT_WEIGHT_NUM_0_NAN_WEIGHT_NUM_SHIFT (_MK_SHIFT_CONST(0))
+#define CDMA_D_NAN_INPUT_WEIGHT_NUM_0_NAN_WEIGHT_NUM_FIELD \
+	(_MK_FIELD_CONST(0xffffffff,                       \
+			 CDMA_D_NAN_INPUT_WEIGHT_NUM_0_NAN_WEIGHT_NUM_SHIFT))
+#define CDMA_D_NAN_INPUT_WEIGHT_NUM_0_NAN_WEIGHT_NUM_RANGE (31 : 0)
+#define CDMA_D_NAN_INPUT_WEIGHT_NUM_0_NAN_WEIGHT_NUM_WOFFSET (0x0)
+#define CDMA_D_NAN_INPUT_WEIGHT_NUM_0_NAN_WEIGHT_NUM_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_NAN_INPUT_WEIGHT_NUM_0_NAN_WEIGHT_NUM_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define CDMA_D_NAN_INPUT_WEIGHT_NUM_0_NAN_WEIGHT_NUM_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_NAN_INPUT_WEIGHT_NUM_0_NAN_WEIGHT_NUM_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_NAN_INPUT_WEIGHT_NUM_0_NAN_WEIGHT_NUM_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_NAN_INPUT_WEIGHT_NUM_0_NAN_WEIGHT_NUM_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDMA_D_INF_INPUT_DATA_NUM_0
+#define CDMA_D_INF_INPUT_DATA_NUM_0 (_MK_ADDR_CONST(0x50cc))
+#define CDMA_D_INF_INPUT_DATA_NUM_0_SECURE (0x0)
+#define CDMA_D_INF_INPUT_DATA_NUM_0_DUAL (0x0)
+#define CDMA_D_INF_INPUT_DATA_NUM_0_SCR (0)
+#define CDMA_D_INF_INPUT_DATA_NUM_0_WORD_COUNT (0x1)
+#define CDMA_D_INF_INPUT_DATA_NUM_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_INF_INPUT_DATA_NUM_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDMA_D_INF_INPUT_DATA_NUM_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_INF_INPUT_DATA_NUM_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_INF_INPUT_DATA_NUM_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDMA_D_INF_INPUT_DATA_NUM_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_INF_INPUT_DATA_NUM_0_INF_DATA_NUM_SHIFT (_MK_SHIFT_CONST(0))
+#define CDMA_D_INF_INPUT_DATA_NUM_0_INF_DATA_NUM_FIELD \
+	(_MK_FIELD_CONST(0xffffffff,                   \
+			 CDMA_D_INF_INPUT_DATA_NUM_0_INF_DATA_NUM_SHIFT))
+#define CDMA_D_INF_INPUT_DATA_NUM_0_INF_DATA_NUM_RANGE (31 : 0)
+#define CDMA_D_INF_INPUT_DATA_NUM_0_INF_DATA_NUM_WOFFSET (0x0)
+#define CDMA_D_INF_INPUT_DATA_NUM_0_INF_DATA_NUM_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_INF_INPUT_DATA_NUM_0_INF_DATA_NUM_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define CDMA_D_INF_INPUT_DATA_NUM_0_INF_DATA_NUM_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_INF_INPUT_DATA_NUM_0_INF_DATA_NUM_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_INF_INPUT_DATA_NUM_0_INF_DATA_NUM_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_INF_INPUT_DATA_NUM_0_INF_DATA_NUM_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDMA_D_INF_INPUT_WEIGHT_NUM_0
+#define CDMA_D_INF_INPUT_WEIGHT_NUM_0 (_MK_ADDR_CONST(0x50d0))
+#define CDMA_D_INF_INPUT_WEIGHT_NUM_0_SECURE (0x0)
+#define CDMA_D_INF_INPUT_WEIGHT_NUM_0_DUAL (0x0)
+#define CDMA_D_INF_INPUT_WEIGHT_NUM_0_SCR (0)
+#define CDMA_D_INF_INPUT_WEIGHT_NUM_0_WORD_COUNT (0x1)
+#define CDMA_D_INF_INPUT_WEIGHT_NUM_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_INF_INPUT_WEIGHT_NUM_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDMA_D_INF_INPUT_WEIGHT_NUM_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_INF_INPUT_WEIGHT_NUM_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_INF_INPUT_WEIGHT_NUM_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDMA_D_INF_INPUT_WEIGHT_NUM_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_INF_INPUT_WEIGHT_NUM_0_INF_WEIGHT_NUM_SHIFT (_MK_SHIFT_CONST(0))
+#define CDMA_D_INF_INPUT_WEIGHT_NUM_0_INF_WEIGHT_NUM_FIELD \
+	(_MK_FIELD_CONST(0xffffffff,                       \
+			 CDMA_D_INF_INPUT_WEIGHT_NUM_0_INF_WEIGHT_NUM_SHIFT))
+#define CDMA_D_INF_INPUT_WEIGHT_NUM_0_INF_WEIGHT_NUM_RANGE (31 : 0)
+#define CDMA_D_INF_INPUT_WEIGHT_NUM_0_INF_WEIGHT_NUM_WOFFSET (0x0)
+#define CDMA_D_INF_INPUT_WEIGHT_NUM_0_INF_WEIGHT_NUM_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_INF_INPUT_WEIGHT_NUM_0_INF_WEIGHT_NUM_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define CDMA_D_INF_INPUT_WEIGHT_NUM_0_INF_WEIGHT_NUM_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_INF_INPUT_WEIGHT_NUM_0_INF_WEIGHT_NUM_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_INF_INPUT_WEIGHT_NUM_0_INF_WEIGHT_NUM_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_INF_INPUT_WEIGHT_NUM_0_INF_WEIGHT_NUM_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDMA_D_PERF_ENABLE_0
+#define CDMA_D_PERF_ENABLE_0 (_MK_ADDR_CONST(0x50d4))
+#define CDMA_D_PERF_ENABLE_0_SECURE (0x0)
+#define CDMA_D_PERF_ENABLE_0_DUAL (0x0)
+#define CDMA_D_PERF_ENABLE_0_SCR (0)
+#define CDMA_D_PERF_ENABLE_0_WORD_COUNT (0x1)
+#define CDMA_D_PERF_ENABLE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_PERF_ENABLE_0_RESET_MASK (_MK_MASK_CONST(0x1))
+#define CDMA_D_PERF_ENABLE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_PERF_ENABLE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_PERF_ENABLE_0_READ_MASK (_MK_MASK_CONST(0x1))
+#define CDMA_D_PERF_ENABLE_0_WRITE_MASK (_MK_MASK_CONST(0x1))
+#define CDMA_D_PERF_ENABLE_0_DMA_EN_SHIFT (_MK_SHIFT_CONST(0))
+#define CDMA_D_PERF_ENABLE_0_DMA_EN_FIELD \
+	(_MK_FIELD_CONST(0x1, CDMA_D_PERF_ENABLE_0_DMA_EN_SHIFT))
+#define CDMA_D_PERF_ENABLE_0_DMA_EN_RANGE (0 : 0)
+#define CDMA_D_PERF_ENABLE_0_DMA_EN_WOFFSET (0x0)
+#define CDMA_D_PERF_ENABLE_0_DMA_EN_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_PERF_ENABLE_0_DMA_EN_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CDMA_D_PERF_ENABLE_0_DMA_EN_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_PERF_ENABLE_0_DMA_EN_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_PERF_ENABLE_0_DMA_EN_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDMA_D_PERF_ENABLE_0_DMA_EN_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+// Register CDMA_D_PERF_DAT_READ_STALL_0
+#define CDMA_D_PERF_DAT_READ_STALL_0 (_MK_ADDR_CONST(0x50d8))
+#define CDMA_D_PERF_DAT_READ_STALL_0_SECURE (0x0)
+#define CDMA_D_PERF_DAT_READ_STALL_0_DUAL (0x0)
+#define CDMA_D_PERF_DAT_READ_STALL_0_SCR (0)
+#define CDMA_D_PERF_DAT_READ_STALL_0_WORD_COUNT (0x1)
+#define CDMA_D_PERF_DAT_READ_STALL_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_PERF_DAT_READ_STALL_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDMA_D_PERF_DAT_READ_STALL_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_PERF_DAT_READ_STALL_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_PERF_DAT_READ_STALL_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDMA_D_PERF_DAT_READ_STALL_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_PERF_DAT_READ_STALL_0_DAT_RD_STALL_SHIFT (_MK_SHIFT_CONST(0))
+#define CDMA_D_PERF_DAT_READ_STALL_0_DAT_RD_STALL_FIELD \
+	(_MK_FIELD_CONST(0xffffffff,                    \
+			 CDMA_D_PERF_DAT_READ_STALL_0_DAT_RD_STALL_SHIFT))
+#define CDMA_D_PERF_DAT_READ_STALL_0_DAT_RD_STALL_RANGE (31 : 0)
+#define CDMA_D_PERF_DAT_READ_STALL_0_DAT_RD_STALL_WOFFSET (0x0)
+#define CDMA_D_PERF_DAT_READ_STALL_0_DAT_RD_STALL_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_PERF_DAT_READ_STALL_0_DAT_RD_STALL_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define CDMA_D_PERF_DAT_READ_STALL_0_DAT_RD_STALL_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_PERF_DAT_READ_STALL_0_DAT_RD_STALL_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_PERF_DAT_READ_STALL_0_DAT_RD_STALL_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_PERF_DAT_READ_STALL_0_DAT_RD_STALL_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDMA_D_PERF_WT_READ_STALL_0
+#define CDMA_D_PERF_WT_READ_STALL_0 (_MK_ADDR_CONST(0x50dc))
+#define CDMA_D_PERF_WT_READ_STALL_0_SECURE (0x0)
+#define CDMA_D_PERF_WT_READ_STALL_0_DUAL (0x0)
+#define CDMA_D_PERF_WT_READ_STALL_0_SCR (0)
+#define CDMA_D_PERF_WT_READ_STALL_0_WORD_COUNT (0x1)
+#define CDMA_D_PERF_WT_READ_STALL_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_PERF_WT_READ_STALL_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDMA_D_PERF_WT_READ_STALL_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_PERF_WT_READ_STALL_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_PERF_WT_READ_STALL_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDMA_D_PERF_WT_READ_STALL_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_PERF_WT_READ_STALL_0_WT_RD_STALL_SHIFT (_MK_SHIFT_CONST(0))
+#define CDMA_D_PERF_WT_READ_STALL_0_WT_RD_STALL_FIELD \
+	(_MK_FIELD_CONST(0xffffffff,                  \
+			 CDMA_D_PERF_WT_READ_STALL_0_WT_RD_STALL_SHIFT))
+#define CDMA_D_PERF_WT_READ_STALL_0_WT_RD_STALL_RANGE (31 : 0)
+#define CDMA_D_PERF_WT_READ_STALL_0_WT_RD_STALL_WOFFSET (0x0)
+#define CDMA_D_PERF_WT_READ_STALL_0_WT_RD_STALL_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_PERF_WT_READ_STALL_0_WT_RD_STALL_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define CDMA_D_PERF_WT_READ_STALL_0_WT_RD_STALL_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_PERF_WT_READ_STALL_0_WT_RD_STALL_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_PERF_WT_READ_STALL_0_WT_RD_STALL_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_PERF_WT_READ_STALL_0_WT_RD_STALL_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDMA_D_PERF_DAT_READ_LATENCY_0
+#define CDMA_D_PERF_DAT_READ_LATENCY_0 (_MK_ADDR_CONST(0x50e0))
+#define CDMA_D_PERF_DAT_READ_LATENCY_0_SECURE (0x0)
+#define CDMA_D_PERF_DAT_READ_LATENCY_0_DUAL (0x0)
+#define CDMA_D_PERF_DAT_READ_LATENCY_0_SCR (0)
+#define CDMA_D_PERF_DAT_READ_LATENCY_0_WORD_COUNT (0x1)
+#define CDMA_D_PERF_DAT_READ_LATENCY_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_PERF_DAT_READ_LATENCY_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDMA_D_PERF_DAT_READ_LATENCY_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_PERF_DAT_READ_LATENCY_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_PERF_DAT_READ_LATENCY_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDMA_D_PERF_DAT_READ_LATENCY_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_PERF_DAT_READ_LATENCY_0_DAT_RD_LATENCY_SHIFT (_MK_SHIFT_CONST(0))
+#define CDMA_D_PERF_DAT_READ_LATENCY_0_DAT_RD_LATENCY_FIELD \
+	(_MK_FIELD_CONST(0xffffffff,                        \
+			 CDMA_D_PERF_DAT_READ_LATENCY_0_DAT_RD_LATENCY_SHIFT))
+#define CDMA_D_PERF_DAT_READ_LATENCY_0_DAT_RD_LATENCY_RANGE (31 : 0)
+#define CDMA_D_PERF_DAT_READ_LATENCY_0_DAT_RD_LATENCY_WOFFSET (0x0)
+#define CDMA_D_PERF_DAT_READ_LATENCY_0_DAT_RD_LATENCY_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_PERF_DAT_READ_LATENCY_0_DAT_RD_LATENCY_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define CDMA_D_PERF_DAT_READ_LATENCY_0_DAT_RD_LATENCY_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_PERF_DAT_READ_LATENCY_0_DAT_RD_LATENCY_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_PERF_DAT_READ_LATENCY_0_DAT_RD_LATENCY_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_PERF_DAT_READ_LATENCY_0_DAT_RD_LATENCY_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDMA_D_PERF_WT_READ_LATENCY_0
+#define CDMA_D_PERF_WT_READ_LATENCY_0 (_MK_ADDR_CONST(0x50e4))
+#define CDMA_D_PERF_WT_READ_LATENCY_0_SECURE (0x0)
+#define CDMA_D_PERF_WT_READ_LATENCY_0_DUAL (0x0)
+#define CDMA_D_PERF_WT_READ_LATENCY_0_SCR (0)
+#define CDMA_D_PERF_WT_READ_LATENCY_0_WORD_COUNT (0x1)
+#define CDMA_D_PERF_WT_READ_LATENCY_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_PERF_WT_READ_LATENCY_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDMA_D_PERF_WT_READ_LATENCY_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_PERF_WT_READ_LATENCY_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_PERF_WT_READ_LATENCY_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDMA_D_PERF_WT_READ_LATENCY_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_PERF_WT_READ_LATENCY_0_WT_RD_LATENCY_SHIFT (_MK_SHIFT_CONST(0))
+#define CDMA_D_PERF_WT_READ_LATENCY_0_WT_RD_LATENCY_FIELD \
+	(_MK_FIELD_CONST(0xffffffff,                      \
+			 CDMA_D_PERF_WT_READ_LATENCY_0_WT_RD_LATENCY_SHIFT))
+#define CDMA_D_PERF_WT_READ_LATENCY_0_WT_RD_LATENCY_RANGE (31 : 0)
+#define CDMA_D_PERF_WT_READ_LATENCY_0_WT_RD_LATENCY_WOFFSET (0x0)
+#define CDMA_D_PERF_WT_READ_LATENCY_0_WT_RD_LATENCY_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_PERF_WT_READ_LATENCY_0_WT_RD_LATENCY_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define CDMA_D_PERF_WT_READ_LATENCY_0_WT_RD_LATENCY_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_PERF_WT_READ_LATENCY_0_WT_RD_LATENCY_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_PERF_WT_READ_LATENCY_0_WT_RD_LATENCY_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDMA_D_PERF_WT_READ_LATENCY_0_WT_RD_LATENCY_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDMA_D_CYA_0
+#define CDMA_D_CYA_0 (_MK_ADDR_CONST(0x50e8))
+#define CDMA_D_CYA_0_SECURE (0x0)
+#define CDMA_D_CYA_0_DUAL (0x0)
+#define CDMA_D_CYA_0_SCR (0)
+#define CDMA_D_CYA_0_WORD_COUNT (0x1)
+#define CDMA_D_CYA_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_CYA_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDMA_D_CYA_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDMA_D_CYA_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_CYA_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDMA_D_CYA_0_WRITE_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDMA_D_CYA_0_CYA_SHIFT (_MK_SHIFT_CONST(0))
+#define CDMA_D_CYA_0_CYA_FIELD \
+	(_MK_FIELD_CONST(0xffffffff, CDMA_D_CYA_0_CYA_SHIFT))
+#define CDMA_D_CYA_0_CYA_RANGE (31 : 0)
+#define CDMA_D_CYA_0_CYA_WOFFSET (0x0)
+#define CDMA_D_CYA_0_CYA_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_CYA_0_CYA_DEFAULT_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDMA_D_CYA_0_CYA_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDMA_D_CYA_0_CYA_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDMA_D_CYA_0_CYA_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDMA_D_CYA_0_CYA_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+// Register CSC_S_STATUS_0
+#define CSC_S_STATUS_0 (_MK_ADDR_CONST(0x6000))
+#define CSC_S_STATUS_0_SECURE (0x0)
+#define CSC_S_STATUS_0_DUAL (0x0)
+#define CSC_S_STATUS_0_SCR (0)
+#define CSC_S_STATUS_0_WORD_COUNT (0x1)
+#define CSC_S_STATUS_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CSC_S_STATUS_0_RESET_MASK (_MK_MASK_CONST(0x30003))
+#define CSC_S_STATUS_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CSC_S_STATUS_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CSC_S_STATUS_0_READ_MASK (_MK_MASK_CONST(0x30003))
+#define CSC_S_STATUS_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define CSC_S_STATUS_0_STATUS_0_SHIFT (_MK_SHIFT_CONST(0))
+#define CSC_S_STATUS_0_STATUS_0_FIELD \
+	(_MK_FIELD_CONST(0x3, CSC_S_STATUS_0_STATUS_0_SHIFT))
+#define CSC_S_STATUS_0_STATUS_0_RANGE (1 : 0)
+#define CSC_S_STATUS_0_STATUS_0_WOFFSET (0x0)
+#define CSC_S_STATUS_0_STATUS_0_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_S_STATUS_0_STATUS_0_DEFAULT_MASK (_MK_MASK_CONST(0x3))
+#define CSC_S_STATUS_0_STATUS_0_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_S_STATUS_0_STATUS_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CSC_S_STATUS_0_STATUS_0_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CSC_S_STATUS_0_STATUS_0_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define CSC_S_STATUS_0_STATUS_0_INIT_ENUM (IDLE)
+#define CSC_S_STATUS_0_STATUS_0_IDLE (_MK_ENUM_CONST(0))
+#define CSC_S_STATUS_0_STATUS_0_RUNNING (_MK_ENUM_CONST(1))
+#define CSC_S_STATUS_0_STATUS_0_PENDING (_MK_ENUM_CONST(2))
+
+#define CSC_S_STATUS_0_STATUS_1_SHIFT (_MK_SHIFT_CONST(16))
+#define CSC_S_STATUS_0_STATUS_1_FIELD \
+	(_MK_FIELD_CONST(0x3, CSC_S_STATUS_0_STATUS_1_SHIFT))
+#define CSC_S_STATUS_0_STATUS_1_RANGE (17 : 16)
+#define CSC_S_STATUS_0_STATUS_1_WOFFSET (0x0)
+#define CSC_S_STATUS_0_STATUS_1_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_S_STATUS_0_STATUS_1_DEFAULT_MASK (_MK_MASK_CONST(0x3))
+#define CSC_S_STATUS_0_STATUS_1_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_S_STATUS_0_STATUS_1_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CSC_S_STATUS_0_STATUS_1_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CSC_S_STATUS_0_STATUS_1_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define CSC_S_STATUS_0_STATUS_1_INIT_ENUM (IDLE)
+#define CSC_S_STATUS_0_STATUS_1_IDLE (_MK_ENUM_CONST(0))
+#define CSC_S_STATUS_0_STATUS_1_RUNNING (_MK_ENUM_CONST(1))
+#define CSC_S_STATUS_0_STATUS_1_PENDING (_MK_ENUM_CONST(2))
+
+// Register CSC_S_POINTER_0
+#define CSC_S_POINTER_0 (_MK_ADDR_CONST(0x6004))
+#define CSC_S_POINTER_0_SECURE (0x0)
+#define CSC_S_POINTER_0_DUAL (0x0)
+#define CSC_S_POINTER_0_SCR (0)
+#define CSC_S_POINTER_0_WORD_COUNT (0x1)
+#define CSC_S_POINTER_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CSC_S_POINTER_0_RESET_MASK (_MK_MASK_CONST(0x10001))
+#define CSC_S_POINTER_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CSC_S_POINTER_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CSC_S_POINTER_0_READ_MASK (_MK_MASK_CONST(0x10001))
+#define CSC_S_POINTER_0_WRITE_MASK (_MK_MASK_CONST(0x1))
+#define CSC_S_POINTER_0_PRODUCER_SHIFT (_MK_SHIFT_CONST(0))
+#define CSC_S_POINTER_0_PRODUCER_FIELD \
+	(_MK_FIELD_CONST(0x1, CSC_S_POINTER_0_PRODUCER_SHIFT))
+#define CSC_S_POINTER_0_PRODUCER_RANGE (0 : 0)
+#define CSC_S_POINTER_0_PRODUCER_WOFFSET (0x0)
+#define CSC_S_POINTER_0_PRODUCER_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_S_POINTER_0_PRODUCER_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CSC_S_POINTER_0_PRODUCER_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_S_POINTER_0_PRODUCER_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CSC_S_POINTER_0_PRODUCER_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CSC_S_POINTER_0_PRODUCER_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define CSC_S_POINTER_0_PRODUCER_INIT_ENUM (GROUP_0)
+#define CSC_S_POINTER_0_PRODUCER_GROUP_0 (_MK_ENUM_CONST(0))
+#define CSC_S_POINTER_0_PRODUCER_GROUP_1 (_MK_ENUM_CONST(1))
+
+#define CSC_S_POINTER_0_CONSUMER_SHIFT (_MK_SHIFT_CONST(16))
+#define CSC_S_POINTER_0_CONSUMER_FIELD \
+	(_MK_FIELD_CONST(0x1, CSC_S_POINTER_0_CONSUMER_SHIFT))
+#define CSC_S_POINTER_0_CONSUMER_RANGE (16 : 16)
+#define CSC_S_POINTER_0_CONSUMER_WOFFSET (0x0)
+#define CSC_S_POINTER_0_CONSUMER_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_S_POINTER_0_CONSUMER_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CSC_S_POINTER_0_CONSUMER_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_S_POINTER_0_CONSUMER_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CSC_S_POINTER_0_CONSUMER_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CSC_S_POINTER_0_CONSUMER_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define CSC_S_POINTER_0_CONSUMER_INIT_ENUM (GROUP_0)
+#define CSC_S_POINTER_0_CONSUMER_GROUP_0 (_MK_ENUM_CONST(0))
+#define CSC_S_POINTER_0_CONSUMER_GROUP_1 (_MK_ENUM_CONST(1))
+
+// Register CSC_D_OP_ENABLE_0
+#define CSC_D_OP_ENABLE_0 (_MK_ADDR_CONST(0x6008))
+#define CSC_D_OP_ENABLE_0_SECURE (0x0)
+#define CSC_D_OP_ENABLE_0_DUAL (0x0)
+#define CSC_D_OP_ENABLE_0_SCR (0)
+#define CSC_D_OP_ENABLE_0_WORD_COUNT (0x1)
+#define CSC_D_OP_ENABLE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CSC_D_OP_ENABLE_0_RESET_MASK (_MK_MASK_CONST(0x1))
+#define CSC_D_OP_ENABLE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CSC_D_OP_ENABLE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CSC_D_OP_ENABLE_0_READ_MASK (_MK_MASK_CONST(0x1))
+#define CSC_D_OP_ENABLE_0_WRITE_MASK (_MK_MASK_CONST(0x1))
+#define CSC_D_OP_ENABLE_0_OP_EN_SHIFT (_MK_SHIFT_CONST(0))
+#define CSC_D_OP_ENABLE_0_OP_EN_FIELD \
+	(_MK_FIELD_CONST(0x1, CSC_D_OP_ENABLE_0_OP_EN_SHIFT))
+#define CSC_D_OP_ENABLE_0_OP_EN_RANGE (0 : 0)
+#define CSC_D_OP_ENABLE_0_OP_EN_WOFFSET (0x0)
+#define CSC_D_OP_ENABLE_0_OP_EN_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_D_OP_ENABLE_0_OP_EN_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CSC_D_OP_ENABLE_0_OP_EN_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_D_OP_ENABLE_0_OP_EN_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CSC_D_OP_ENABLE_0_OP_EN_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CSC_D_OP_ENABLE_0_OP_EN_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define CSC_D_OP_ENABLE_0_OP_EN_INIT_ENUM (DISABLE)
+#define CSC_D_OP_ENABLE_0_OP_EN_DISABLE (_MK_ENUM_CONST(0))
+#define CSC_D_OP_ENABLE_0_OP_EN_ENABLE (_MK_ENUM_CONST(1))
+
+// Register CSC_D_MISC_CFG_0
+#define CSC_D_MISC_CFG_0 (_MK_ADDR_CONST(0x600c))
+#define CSC_D_MISC_CFG_0_SECURE (0x0)
+#define CSC_D_MISC_CFG_0_DUAL (0x0)
+#define CSC_D_MISC_CFG_0_SCR (0)
+#define CSC_D_MISC_CFG_0_WORD_COUNT (0x1)
+#define CSC_D_MISC_CFG_0_RESET_VAL (_MK_MASK_CONST(0x1100))
+#define CSC_D_MISC_CFG_0_RESET_MASK (_MK_MASK_CONST(0x11113301))
+#define CSC_D_MISC_CFG_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CSC_D_MISC_CFG_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CSC_D_MISC_CFG_0_READ_MASK (_MK_MASK_CONST(0x11113301))
+#define CSC_D_MISC_CFG_0_WRITE_MASK (_MK_MASK_CONST(0x11113301))
+#define CSC_D_MISC_CFG_0_CONV_MODE_SHIFT (_MK_SHIFT_CONST(0))
+#define CSC_D_MISC_CFG_0_CONV_MODE_FIELD \
+	(_MK_FIELD_CONST(0x1, CSC_D_MISC_CFG_0_CONV_MODE_SHIFT))
+#define CSC_D_MISC_CFG_0_CONV_MODE_RANGE (0 : 0)
+#define CSC_D_MISC_CFG_0_CONV_MODE_WOFFSET (0x0)
+#define CSC_D_MISC_CFG_0_CONV_MODE_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_D_MISC_CFG_0_CONV_MODE_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CSC_D_MISC_CFG_0_CONV_MODE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_D_MISC_CFG_0_CONV_MODE_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CSC_D_MISC_CFG_0_CONV_MODE_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CSC_D_MISC_CFG_0_CONV_MODE_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define CSC_D_MISC_CFG_0_CONV_MODE_INIT_ENUM (DIRECT)
+#define CSC_D_MISC_CFG_0_CONV_MODE_DIRECT (_MK_ENUM_CONST(0))
+#define CSC_D_MISC_CFG_0_CONV_MODE_WINOGRAD (_MK_ENUM_CONST(1))
+
+#define CSC_D_MISC_CFG_0_IN_PRECISION_SHIFT (_MK_SHIFT_CONST(8))
+#define CSC_D_MISC_CFG_0_IN_PRECISION_FIELD \
+	(_MK_FIELD_CONST(0x3, CSC_D_MISC_CFG_0_IN_PRECISION_SHIFT))
+#define CSC_D_MISC_CFG_0_IN_PRECISION_RANGE (9 : 8)
+#define CSC_D_MISC_CFG_0_IN_PRECISION_WOFFSET (0x0)
+#define CSC_D_MISC_CFG_0_IN_PRECISION_DEFAULT (_MK_MASK_CONST(0x1))
+#define CSC_D_MISC_CFG_0_IN_PRECISION_DEFAULT_MASK (_MK_MASK_CONST(0x3))
+#define CSC_D_MISC_CFG_0_IN_PRECISION_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_D_MISC_CFG_0_IN_PRECISION_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CSC_D_MISC_CFG_0_IN_PRECISION_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CSC_D_MISC_CFG_0_IN_PRECISION_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define CSC_D_MISC_CFG_0_IN_PRECISION_INIT_ENUM (INT16)
+#define CSC_D_MISC_CFG_0_IN_PRECISION_INT8 (_MK_ENUM_CONST(0))
+#define CSC_D_MISC_CFG_0_IN_PRECISION_INT16 (_MK_ENUM_CONST(1))
+#define CSC_D_MISC_CFG_0_IN_PRECISION_FP16 (_MK_ENUM_CONST(2))
+
+#define CSC_D_MISC_CFG_0_PROC_PRECISION_SHIFT (_MK_SHIFT_CONST(12))
+#define CSC_D_MISC_CFG_0_PROC_PRECISION_FIELD \
+	(_MK_FIELD_CONST(0x3, CSC_D_MISC_CFG_0_PROC_PRECISION_SHIFT))
+#define CSC_D_MISC_CFG_0_PROC_PRECISION_RANGE (13 : 12)
+#define CSC_D_MISC_CFG_0_PROC_PRECISION_WOFFSET (0x0)
+#define CSC_D_MISC_CFG_0_PROC_PRECISION_DEFAULT (_MK_MASK_CONST(0x1))
+#define CSC_D_MISC_CFG_0_PROC_PRECISION_DEFAULT_MASK (_MK_MASK_CONST(0x3))
+#define CSC_D_MISC_CFG_0_PROC_PRECISION_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_D_MISC_CFG_0_PROC_PRECISION_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CSC_D_MISC_CFG_0_PROC_PRECISION_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CSC_D_MISC_CFG_0_PROC_PRECISION_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define CSC_D_MISC_CFG_0_PROC_PRECISION_INIT_ENUM (INT16)
+#define CSC_D_MISC_CFG_0_PROC_PRECISION_INT8 (_MK_ENUM_CONST(0))
+#define CSC_D_MISC_CFG_0_PROC_PRECISION_INT16 (_MK_ENUM_CONST(1))
+#define CSC_D_MISC_CFG_0_PROC_PRECISION_FP16 (_MK_ENUM_CONST(2))
+
+#define CSC_D_MISC_CFG_0_DATA_REUSE_SHIFT (_MK_SHIFT_CONST(16))
+#define CSC_D_MISC_CFG_0_DATA_REUSE_FIELD \
+	(_MK_FIELD_CONST(0x1, CSC_D_MISC_CFG_0_DATA_REUSE_SHIFT))
+#define CSC_D_MISC_CFG_0_DATA_REUSE_RANGE (16 : 16)
+#define CSC_D_MISC_CFG_0_DATA_REUSE_WOFFSET (0x0)
+#define CSC_D_MISC_CFG_0_DATA_REUSE_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_D_MISC_CFG_0_DATA_REUSE_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CSC_D_MISC_CFG_0_DATA_REUSE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_D_MISC_CFG_0_DATA_REUSE_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CSC_D_MISC_CFG_0_DATA_REUSE_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CSC_D_MISC_CFG_0_DATA_REUSE_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define CSC_D_MISC_CFG_0_DATA_REUSE_INIT_ENUM (DISABLE)
+#define CSC_D_MISC_CFG_0_DATA_REUSE_DISABLE (_MK_ENUM_CONST(0))
+#define CSC_D_MISC_CFG_0_DATA_REUSE_ENABLE (_MK_ENUM_CONST(1))
+
+#define CSC_D_MISC_CFG_0_WEIGHT_REUSE_SHIFT (_MK_SHIFT_CONST(20))
+#define CSC_D_MISC_CFG_0_WEIGHT_REUSE_FIELD \
+	(_MK_FIELD_CONST(0x1, CSC_D_MISC_CFG_0_WEIGHT_REUSE_SHIFT))
+#define CSC_D_MISC_CFG_0_WEIGHT_REUSE_RANGE (20 : 20)
+#define CSC_D_MISC_CFG_0_WEIGHT_REUSE_WOFFSET (0x0)
+#define CSC_D_MISC_CFG_0_WEIGHT_REUSE_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_D_MISC_CFG_0_WEIGHT_REUSE_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CSC_D_MISC_CFG_0_WEIGHT_REUSE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_D_MISC_CFG_0_WEIGHT_REUSE_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CSC_D_MISC_CFG_0_WEIGHT_REUSE_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CSC_D_MISC_CFG_0_WEIGHT_REUSE_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define CSC_D_MISC_CFG_0_WEIGHT_REUSE_INIT_ENUM (DISABLE)
+#define CSC_D_MISC_CFG_0_WEIGHT_REUSE_DISABLE (_MK_ENUM_CONST(0))
+#define CSC_D_MISC_CFG_0_WEIGHT_REUSE_ENABLE (_MK_ENUM_CONST(1))
+
+#define CSC_D_MISC_CFG_0_SKIP_DATA_RLS_SHIFT (_MK_SHIFT_CONST(24))
+#define CSC_D_MISC_CFG_0_SKIP_DATA_RLS_FIELD \
+	(_MK_FIELD_CONST(0x1, CSC_D_MISC_CFG_0_SKIP_DATA_RLS_SHIFT))
+#define CSC_D_MISC_CFG_0_SKIP_DATA_RLS_RANGE (24 : 24)
+#define CSC_D_MISC_CFG_0_SKIP_DATA_RLS_WOFFSET (0x0)
+#define CSC_D_MISC_CFG_0_SKIP_DATA_RLS_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_D_MISC_CFG_0_SKIP_DATA_RLS_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CSC_D_MISC_CFG_0_SKIP_DATA_RLS_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_D_MISC_CFG_0_SKIP_DATA_RLS_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CSC_D_MISC_CFG_0_SKIP_DATA_RLS_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CSC_D_MISC_CFG_0_SKIP_DATA_RLS_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define CSC_D_MISC_CFG_0_SKIP_DATA_RLS_INIT_ENUM (DISABLE)
+#define CSC_D_MISC_CFG_0_SKIP_DATA_RLS_DISABLE (_MK_ENUM_CONST(0))
+#define CSC_D_MISC_CFG_0_SKIP_DATA_RLS_ENABLE (_MK_ENUM_CONST(1))
+
+#define CSC_D_MISC_CFG_0_SKIP_WEIGHT_RLS_SHIFT (_MK_SHIFT_CONST(28))
+#define CSC_D_MISC_CFG_0_SKIP_WEIGHT_RLS_FIELD \
+	(_MK_FIELD_CONST(0x1, CSC_D_MISC_CFG_0_SKIP_WEIGHT_RLS_SHIFT))
+#define CSC_D_MISC_CFG_0_SKIP_WEIGHT_RLS_RANGE (28 : 28)
+#define CSC_D_MISC_CFG_0_SKIP_WEIGHT_RLS_WOFFSET (0x0)
+#define CSC_D_MISC_CFG_0_SKIP_WEIGHT_RLS_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_D_MISC_CFG_0_SKIP_WEIGHT_RLS_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CSC_D_MISC_CFG_0_SKIP_WEIGHT_RLS_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_D_MISC_CFG_0_SKIP_WEIGHT_RLS_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CSC_D_MISC_CFG_0_SKIP_WEIGHT_RLS_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CSC_D_MISC_CFG_0_SKIP_WEIGHT_RLS_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define CSC_D_MISC_CFG_0_SKIP_WEIGHT_RLS_INIT_ENUM (DISABLE)
+#define CSC_D_MISC_CFG_0_SKIP_WEIGHT_RLS_DISABLE (_MK_ENUM_CONST(0))
+#define CSC_D_MISC_CFG_0_SKIP_WEIGHT_RLS_ENABLE (_MK_ENUM_CONST(1))
+
+// Register CSC_D_DATAIN_FORMAT_0
+#define CSC_D_DATAIN_FORMAT_0 (_MK_ADDR_CONST(0x6010))
+#define CSC_D_DATAIN_FORMAT_0_SECURE (0x0)
+#define CSC_D_DATAIN_FORMAT_0_DUAL (0x0)
+#define CSC_D_DATAIN_FORMAT_0_SCR (0)
+#define CSC_D_DATAIN_FORMAT_0_WORD_COUNT (0x1)
+#define CSC_D_DATAIN_FORMAT_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CSC_D_DATAIN_FORMAT_0_RESET_MASK (_MK_MASK_CONST(0x1))
+#define CSC_D_DATAIN_FORMAT_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CSC_D_DATAIN_FORMAT_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CSC_D_DATAIN_FORMAT_0_READ_MASK (_MK_MASK_CONST(0x1))
+#define CSC_D_DATAIN_FORMAT_0_WRITE_MASK (_MK_MASK_CONST(0x1))
+#define CSC_D_DATAIN_FORMAT_0_DATAIN_FORMAT_SHIFT (_MK_SHIFT_CONST(0))
+#define CSC_D_DATAIN_FORMAT_0_DATAIN_FORMAT_FIELD \
+	(_MK_FIELD_CONST(0x1, CSC_D_DATAIN_FORMAT_0_DATAIN_FORMAT_SHIFT))
+#define CSC_D_DATAIN_FORMAT_0_DATAIN_FORMAT_RANGE (0 : 0)
+#define CSC_D_DATAIN_FORMAT_0_DATAIN_FORMAT_WOFFSET (0x0)
+#define CSC_D_DATAIN_FORMAT_0_DATAIN_FORMAT_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_D_DATAIN_FORMAT_0_DATAIN_FORMAT_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CSC_D_DATAIN_FORMAT_0_DATAIN_FORMAT_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_D_DATAIN_FORMAT_0_DATAIN_FORMAT_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CSC_D_DATAIN_FORMAT_0_DATAIN_FORMAT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CSC_D_DATAIN_FORMAT_0_DATAIN_FORMAT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define CSC_D_DATAIN_FORMAT_0_DATAIN_FORMAT_INIT_ENUM (FEATURE)
+#define CSC_D_DATAIN_FORMAT_0_DATAIN_FORMAT_FEATURE (_MK_ENUM_CONST(0))
+#define CSC_D_DATAIN_FORMAT_0_DATAIN_FORMAT_PIXEL (_MK_ENUM_CONST(1))
+
+// Register CSC_D_DATAIN_SIZE_EXT_0_0
+#define CSC_D_DATAIN_SIZE_EXT_0_0 (_MK_ADDR_CONST(0x6014))
+#define CSC_D_DATAIN_SIZE_EXT_0_0_SECURE (0x0)
+#define CSC_D_DATAIN_SIZE_EXT_0_0_DUAL (0x0)
+#define CSC_D_DATAIN_SIZE_EXT_0_0_SCR (0)
+#define CSC_D_DATAIN_SIZE_EXT_0_0_WORD_COUNT (0x1)
+#define CSC_D_DATAIN_SIZE_EXT_0_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CSC_D_DATAIN_SIZE_EXT_0_0_RESET_MASK (_MK_MASK_CONST(0x1fff1fff))
+#define CSC_D_DATAIN_SIZE_EXT_0_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CSC_D_DATAIN_SIZE_EXT_0_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CSC_D_DATAIN_SIZE_EXT_0_0_READ_MASK (_MK_MASK_CONST(0x1fff1fff))
+#define CSC_D_DATAIN_SIZE_EXT_0_0_WRITE_MASK (_MK_MASK_CONST(0x1fff1fff))
+#define CSC_D_DATAIN_SIZE_EXT_0_0_DATAIN_WIDTH_EXT_SHIFT (_MK_SHIFT_CONST(0))
+#define CSC_D_DATAIN_SIZE_EXT_0_0_DATAIN_WIDTH_EXT_FIELD \
+	(_MK_FIELD_CONST(0x1fff,                         \
+			 CSC_D_DATAIN_SIZE_EXT_0_0_DATAIN_WIDTH_EXT_SHIFT))
+#define CSC_D_DATAIN_SIZE_EXT_0_0_DATAIN_WIDTH_EXT_RANGE (12 : 0)
+#define CSC_D_DATAIN_SIZE_EXT_0_0_DATAIN_WIDTH_EXT_WOFFSET (0x0)
+#define CSC_D_DATAIN_SIZE_EXT_0_0_DATAIN_WIDTH_EXT_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_D_DATAIN_SIZE_EXT_0_0_DATAIN_WIDTH_EXT_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1fff))
+#define CSC_D_DATAIN_SIZE_EXT_0_0_DATAIN_WIDTH_EXT_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CSC_D_DATAIN_SIZE_EXT_0_0_DATAIN_WIDTH_EXT_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CSC_D_DATAIN_SIZE_EXT_0_0_DATAIN_WIDTH_EXT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CSC_D_DATAIN_SIZE_EXT_0_0_DATAIN_WIDTH_EXT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define CSC_D_DATAIN_SIZE_EXT_0_0_DATAIN_HEIGHT_EXT_SHIFT (_MK_SHIFT_CONST(16))
+#define CSC_D_DATAIN_SIZE_EXT_0_0_DATAIN_HEIGHT_EXT_FIELD \
+	(_MK_FIELD_CONST(0x1fff,                          \
+			 CSC_D_DATAIN_SIZE_EXT_0_0_DATAIN_HEIGHT_EXT_SHIFT))
+#define CSC_D_DATAIN_SIZE_EXT_0_0_DATAIN_HEIGHT_EXT_RANGE (28 : 16)
+#define CSC_D_DATAIN_SIZE_EXT_0_0_DATAIN_HEIGHT_EXT_WOFFSET (0x0)
+#define CSC_D_DATAIN_SIZE_EXT_0_0_DATAIN_HEIGHT_EXT_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CSC_D_DATAIN_SIZE_EXT_0_0_DATAIN_HEIGHT_EXT_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1fff))
+#define CSC_D_DATAIN_SIZE_EXT_0_0_DATAIN_HEIGHT_EXT_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CSC_D_DATAIN_SIZE_EXT_0_0_DATAIN_HEIGHT_EXT_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CSC_D_DATAIN_SIZE_EXT_0_0_DATAIN_HEIGHT_EXT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CSC_D_DATAIN_SIZE_EXT_0_0_DATAIN_HEIGHT_EXT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CSC_D_DATAIN_SIZE_EXT_1_0
+#define CSC_D_DATAIN_SIZE_EXT_1_0 (_MK_ADDR_CONST(0x6018))
+#define CSC_D_DATAIN_SIZE_EXT_1_0_SECURE (0x0)
+#define CSC_D_DATAIN_SIZE_EXT_1_0_DUAL (0x0)
+#define CSC_D_DATAIN_SIZE_EXT_1_0_SCR (0)
+#define CSC_D_DATAIN_SIZE_EXT_1_0_WORD_COUNT (0x1)
+#define CSC_D_DATAIN_SIZE_EXT_1_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CSC_D_DATAIN_SIZE_EXT_1_0_RESET_MASK (_MK_MASK_CONST(0x1fff))
+#define CSC_D_DATAIN_SIZE_EXT_1_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CSC_D_DATAIN_SIZE_EXT_1_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CSC_D_DATAIN_SIZE_EXT_1_0_READ_MASK (_MK_MASK_CONST(0x1fff))
+#define CSC_D_DATAIN_SIZE_EXT_1_0_WRITE_MASK (_MK_MASK_CONST(0x1fff))
+#define CSC_D_DATAIN_SIZE_EXT_1_0_DATAIN_CHANNEL_EXT_SHIFT (_MK_SHIFT_CONST(0))
+#define CSC_D_DATAIN_SIZE_EXT_1_0_DATAIN_CHANNEL_EXT_FIELD \
+	(_MK_FIELD_CONST(0x1fff,                           \
+			 CSC_D_DATAIN_SIZE_EXT_1_0_DATAIN_CHANNEL_EXT_SHIFT))
+#define CSC_D_DATAIN_SIZE_EXT_1_0_DATAIN_CHANNEL_EXT_RANGE (12 : 0)
+#define CSC_D_DATAIN_SIZE_EXT_1_0_DATAIN_CHANNEL_EXT_WOFFSET (0x0)
+#define CSC_D_DATAIN_SIZE_EXT_1_0_DATAIN_CHANNEL_EXT_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CSC_D_DATAIN_SIZE_EXT_1_0_DATAIN_CHANNEL_EXT_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1fff))
+#define CSC_D_DATAIN_SIZE_EXT_1_0_DATAIN_CHANNEL_EXT_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CSC_D_DATAIN_SIZE_EXT_1_0_DATAIN_CHANNEL_EXT_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CSC_D_DATAIN_SIZE_EXT_1_0_DATAIN_CHANNEL_EXT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CSC_D_DATAIN_SIZE_EXT_1_0_DATAIN_CHANNEL_EXT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CSC_D_BATCH_NUMBER_0
+#define CSC_D_BATCH_NUMBER_0 (_MK_ADDR_CONST(0x601c))
+#define CSC_D_BATCH_NUMBER_0_SECURE (0x0)
+#define CSC_D_BATCH_NUMBER_0_DUAL (0x0)
+#define CSC_D_BATCH_NUMBER_0_SCR (0)
+#define CSC_D_BATCH_NUMBER_0_WORD_COUNT (0x1)
+#define CSC_D_BATCH_NUMBER_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CSC_D_BATCH_NUMBER_0_RESET_MASK (_MK_MASK_CONST(0x1f))
+#define CSC_D_BATCH_NUMBER_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CSC_D_BATCH_NUMBER_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CSC_D_BATCH_NUMBER_0_READ_MASK (_MK_MASK_CONST(0x1f))
+#define CSC_D_BATCH_NUMBER_0_WRITE_MASK (_MK_MASK_CONST(0x1f))
+#define CSC_D_BATCH_NUMBER_0_BATCHES_SHIFT (_MK_SHIFT_CONST(0))
+#define CSC_D_BATCH_NUMBER_0_BATCHES_FIELD \
+	(_MK_FIELD_CONST(0x1f, CSC_D_BATCH_NUMBER_0_BATCHES_SHIFT))
+#define CSC_D_BATCH_NUMBER_0_BATCHES_RANGE (4 : 0)
+#define CSC_D_BATCH_NUMBER_0_BATCHES_WOFFSET (0x0)
+#define CSC_D_BATCH_NUMBER_0_BATCHES_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_D_BATCH_NUMBER_0_BATCHES_DEFAULT_MASK (_MK_MASK_CONST(0x1f))
+#define CSC_D_BATCH_NUMBER_0_BATCHES_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_D_BATCH_NUMBER_0_BATCHES_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CSC_D_BATCH_NUMBER_0_BATCHES_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CSC_D_BATCH_NUMBER_0_BATCHES_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+// Register CSC_D_POST_Y_EXTENSION_0
+#define CSC_D_POST_Y_EXTENSION_0 (_MK_ADDR_CONST(0x6020))
+#define CSC_D_POST_Y_EXTENSION_0_SECURE (0x0)
+#define CSC_D_POST_Y_EXTENSION_0_DUAL (0x0)
+#define CSC_D_POST_Y_EXTENSION_0_SCR (0)
+#define CSC_D_POST_Y_EXTENSION_0_WORD_COUNT (0x1)
+#define CSC_D_POST_Y_EXTENSION_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CSC_D_POST_Y_EXTENSION_0_RESET_MASK (_MK_MASK_CONST(0x3))
+#define CSC_D_POST_Y_EXTENSION_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CSC_D_POST_Y_EXTENSION_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CSC_D_POST_Y_EXTENSION_0_READ_MASK (_MK_MASK_CONST(0x3))
+#define CSC_D_POST_Y_EXTENSION_0_WRITE_MASK (_MK_MASK_CONST(0x3))
+#define CSC_D_POST_Y_EXTENSION_0_Y_EXTENSION_SHIFT (_MK_SHIFT_CONST(0))
+#define CSC_D_POST_Y_EXTENSION_0_Y_EXTENSION_FIELD \
+	(_MK_FIELD_CONST(0x3, CSC_D_POST_Y_EXTENSION_0_Y_EXTENSION_SHIFT))
+#define CSC_D_POST_Y_EXTENSION_0_Y_EXTENSION_RANGE (1 : 0)
+#define CSC_D_POST_Y_EXTENSION_0_Y_EXTENSION_WOFFSET (0x0)
+#define CSC_D_POST_Y_EXTENSION_0_Y_EXTENSION_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_D_POST_Y_EXTENSION_0_Y_EXTENSION_DEFAULT_MASK (_MK_MASK_CONST(0x3))
+#define CSC_D_POST_Y_EXTENSION_0_Y_EXTENSION_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_D_POST_Y_EXTENSION_0_Y_EXTENSION_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CSC_D_POST_Y_EXTENSION_0_Y_EXTENSION_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CSC_D_POST_Y_EXTENSION_0_Y_EXTENSION_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CSC_D_ENTRY_PER_SLICE_0
+#define CSC_D_ENTRY_PER_SLICE_0 (_MK_ADDR_CONST(0x6024))
+#define CSC_D_ENTRY_PER_SLICE_0_SECURE (0x0)
+#define CSC_D_ENTRY_PER_SLICE_0_DUAL (0x0)
+#define CSC_D_ENTRY_PER_SLICE_0_SCR (0)
+#define CSC_D_ENTRY_PER_SLICE_0_WORD_COUNT (0x1)
+#define CSC_D_ENTRY_PER_SLICE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CSC_D_ENTRY_PER_SLICE_0_RESET_MASK (_MK_MASK_CONST(0xfff))
+#define CSC_D_ENTRY_PER_SLICE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CSC_D_ENTRY_PER_SLICE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CSC_D_ENTRY_PER_SLICE_0_READ_MASK (_MK_MASK_CONST(0xfff))
+#define CSC_D_ENTRY_PER_SLICE_0_WRITE_MASK (_MK_MASK_CONST(0xfff))
+#define CSC_D_ENTRY_PER_SLICE_0_ENTRIES_SHIFT (_MK_SHIFT_CONST(0))
+#define CSC_D_ENTRY_PER_SLICE_0_ENTRIES_FIELD \
+	(_MK_FIELD_CONST(0xfff, CSC_D_ENTRY_PER_SLICE_0_ENTRIES_SHIFT))
+#define CSC_D_ENTRY_PER_SLICE_0_ENTRIES_RANGE (11 : 0)
+#define CSC_D_ENTRY_PER_SLICE_0_ENTRIES_WOFFSET (0x0)
+#define CSC_D_ENTRY_PER_SLICE_0_ENTRIES_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_D_ENTRY_PER_SLICE_0_ENTRIES_DEFAULT_MASK (_MK_MASK_CONST(0xfff))
+#define CSC_D_ENTRY_PER_SLICE_0_ENTRIES_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_D_ENTRY_PER_SLICE_0_ENTRIES_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CSC_D_ENTRY_PER_SLICE_0_ENTRIES_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CSC_D_ENTRY_PER_SLICE_0_ENTRIES_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+// Register CSC_D_WEIGHT_FORMAT_0
+#define CSC_D_WEIGHT_FORMAT_0 (_MK_ADDR_CONST(0x6028))
+#define CSC_D_WEIGHT_FORMAT_0_SECURE (0x0)
+#define CSC_D_WEIGHT_FORMAT_0_DUAL (0x0)
+#define CSC_D_WEIGHT_FORMAT_0_SCR (0)
+#define CSC_D_WEIGHT_FORMAT_0_WORD_COUNT (0x1)
+#define CSC_D_WEIGHT_FORMAT_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CSC_D_WEIGHT_FORMAT_0_RESET_MASK (_MK_MASK_CONST(0x1))
+#define CSC_D_WEIGHT_FORMAT_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CSC_D_WEIGHT_FORMAT_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CSC_D_WEIGHT_FORMAT_0_READ_MASK (_MK_MASK_CONST(0x1))
+#define CSC_D_WEIGHT_FORMAT_0_WRITE_MASK (_MK_MASK_CONST(0x1))
+#define CSC_D_WEIGHT_FORMAT_0_WEIGHT_FORMAT_SHIFT (_MK_SHIFT_CONST(0))
+#define CSC_D_WEIGHT_FORMAT_0_WEIGHT_FORMAT_FIELD \
+	(_MK_FIELD_CONST(0x1, CSC_D_WEIGHT_FORMAT_0_WEIGHT_FORMAT_SHIFT))
+#define CSC_D_WEIGHT_FORMAT_0_WEIGHT_FORMAT_RANGE (0 : 0)
+#define CSC_D_WEIGHT_FORMAT_0_WEIGHT_FORMAT_WOFFSET (0x0)
+#define CSC_D_WEIGHT_FORMAT_0_WEIGHT_FORMAT_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_D_WEIGHT_FORMAT_0_WEIGHT_FORMAT_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CSC_D_WEIGHT_FORMAT_0_WEIGHT_FORMAT_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_D_WEIGHT_FORMAT_0_WEIGHT_FORMAT_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CSC_D_WEIGHT_FORMAT_0_WEIGHT_FORMAT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CSC_D_WEIGHT_FORMAT_0_WEIGHT_FORMAT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define CSC_D_WEIGHT_FORMAT_0_WEIGHT_FORMAT_INIT_ENUM (UNCOMPRESSED)
+#define CSC_D_WEIGHT_FORMAT_0_WEIGHT_FORMAT_UNCOMPRESSED (_MK_ENUM_CONST(0))
+#define CSC_D_WEIGHT_FORMAT_0_WEIGHT_FORMAT_COMPRESSED (_MK_ENUM_CONST(1))
+
+// Register CSC_D_WEIGHT_SIZE_EXT_0_0
+#define CSC_D_WEIGHT_SIZE_EXT_0_0 (_MK_ADDR_CONST(0x602c))
+#define CSC_D_WEIGHT_SIZE_EXT_0_0_SECURE (0x0)
+#define CSC_D_WEIGHT_SIZE_EXT_0_0_DUAL (0x0)
+#define CSC_D_WEIGHT_SIZE_EXT_0_0_SCR (0)
+#define CSC_D_WEIGHT_SIZE_EXT_0_0_WORD_COUNT (0x1)
+#define CSC_D_WEIGHT_SIZE_EXT_0_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CSC_D_WEIGHT_SIZE_EXT_0_0_RESET_MASK (_MK_MASK_CONST(0x1f001f))
+#define CSC_D_WEIGHT_SIZE_EXT_0_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CSC_D_WEIGHT_SIZE_EXT_0_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CSC_D_WEIGHT_SIZE_EXT_0_0_READ_MASK (_MK_MASK_CONST(0x1f001f))
+#define CSC_D_WEIGHT_SIZE_EXT_0_0_WRITE_MASK (_MK_MASK_CONST(0x1f001f))
+#define CSC_D_WEIGHT_SIZE_EXT_0_0_WEIGHT_WIDTH_EXT_SHIFT (_MK_SHIFT_CONST(0))
+#define CSC_D_WEIGHT_SIZE_EXT_0_0_WEIGHT_WIDTH_EXT_FIELD \
+	(_MK_FIELD_CONST(0x1f,                           \
+			 CSC_D_WEIGHT_SIZE_EXT_0_0_WEIGHT_WIDTH_EXT_SHIFT))
+#define CSC_D_WEIGHT_SIZE_EXT_0_0_WEIGHT_WIDTH_EXT_RANGE (4 : 0)
+#define CSC_D_WEIGHT_SIZE_EXT_0_0_WEIGHT_WIDTH_EXT_WOFFSET (0x0)
+#define CSC_D_WEIGHT_SIZE_EXT_0_0_WEIGHT_WIDTH_EXT_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_D_WEIGHT_SIZE_EXT_0_0_WEIGHT_WIDTH_EXT_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1f))
+#define CSC_D_WEIGHT_SIZE_EXT_0_0_WEIGHT_WIDTH_EXT_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CSC_D_WEIGHT_SIZE_EXT_0_0_WEIGHT_WIDTH_EXT_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CSC_D_WEIGHT_SIZE_EXT_0_0_WEIGHT_WIDTH_EXT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CSC_D_WEIGHT_SIZE_EXT_0_0_WEIGHT_WIDTH_EXT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define CSC_D_WEIGHT_SIZE_EXT_0_0_WEIGHT_HEIGHT_EXT_SHIFT (_MK_SHIFT_CONST(16))
+#define CSC_D_WEIGHT_SIZE_EXT_0_0_WEIGHT_HEIGHT_EXT_FIELD \
+	(_MK_FIELD_CONST(0x1f,                            \
+			 CSC_D_WEIGHT_SIZE_EXT_0_0_WEIGHT_HEIGHT_EXT_SHIFT))
+#define CSC_D_WEIGHT_SIZE_EXT_0_0_WEIGHT_HEIGHT_EXT_RANGE (20 : 16)
+#define CSC_D_WEIGHT_SIZE_EXT_0_0_WEIGHT_HEIGHT_EXT_WOFFSET (0x0)
+#define CSC_D_WEIGHT_SIZE_EXT_0_0_WEIGHT_HEIGHT_EXT_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CSC_D_WEIGHT_SIZE_EXT_0_0_WEIGHT_HEIGHT_EXT_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1f))
+#define CSC_D_WEIGHT_SIZE_EXT_0_0_WEIGHT_HEIGHT_EXT_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CSC_D_WEIGHT_SIZE_EXT_0_0_WEIGHT_HEIGHT_EXT_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CSC_D_WEIGHT_SIZE_EXT_0_0_WEIGHT_HEIGHT_EXT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CSC_D_WEIGHT_SIZE_EXT_0_0_WEIGHT_HEIGHT_EXT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CSC_D_WEIGHT_SIZE_EXT_1_0
+#define CSC_D_WEIGHT_SIZE_EXT_1_0 (_MK_ADDR_CONST(0x6030))
+#define CSC_D_WEIGHT_SIZE_EXT_1_0_SECURE (0x0)
+#define CSC_D_WEIGHT_SIZE_EXT_1_0_DUAL (0x0)
+#define CSC_D_WEIGHT_SIZE_EXT_1_0_SCR (0)
+#define CSC_D_WEIGHT_SIZE_EXT_1_0_WORD_COUNT (0x1)
+#define CSC_D_WEIGHT_SIZE_EXT_1_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CSC_D_WEIGHT_SIZE_EXT_1_0_RESET_MASK (_MK_MASK_CONST(0x1fff1fff))
+#define CSC_D_WEIGHT_SIZE_EXT_1_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CSC_D_WEIGHT_SIZE_EXT_1_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CSC_D_WEIGHT_SIZE_EXT_1_0_READ_MASK (_MK_MASK_CONST(0x1fff1fff))
+#define CSC_D_WEIGHT_SIZE_EXT_1_0_WRITE_MASK (_MK_MASK_CONST(0x1fff1fff))
+#define CSC_D_WEIGHT_SIZE_EXT_1_0_WEIGHT_CHANNEL_EXT_SHIFT (_MK_SHIFT_CONST(0))
+#define CSC_D_WEIGHT_SIZE_EXT_1_0_WEIGHT_CHANNEL_EXT_FIELD \
+	(_MK_FIELD_CONST(0x1fff,                           \
+			 CSC_D_WEIGHT_SIZE_EXT_1_0_WEIGHT_CHANNEL_EXT_SHIFT))
+#define CSC_D_WEIGHT_SIZE_EXT_1_0_WEIGHT_CHANNEL_EXT_RANGE (12 : 0)
+#define CSC_D_WEIGHT_SIZE_EXT_1_0_WEIGHT_CHANNEL_EXT_WOFFSET (0x0)
+#define CSC_D_WEIGHT_SIZE_EXT_1_0_WEIGHT_CHANNEL_EXT_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CSC_D_WEIGHT_SIZE_EXT_1_0_WEIGHT_CHANNEL_EXT_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1fff))
+#define CSC_D_WEIGHT_SIZE_EXT_1_0_WEIGHT_CHANNEL_EXT_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CSC_D_WEIGHT_SIZE_EXT_1_0_WEIGHT_CHANNEL_EXT_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CSC_D_WEIGHT_SIZE_EXT_1_0_WEIGHT_CHANNEL_EXT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CSC_D_WEIGHT_SIZE_EXT_1_0_WEIGHT_CHANNEL_EXT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define CSC_D_WEIGHT_SIZE_EXT_1_0_WEIGHT_KERNEL_SHIFT (_MK_SHIFT_CONST(16))
+#define CSC_D_WEIGHT_SIZE_EXT_1_0_WEIGHT_KERNEL_FIELD \
+	(_MK_FIELD_CONST(0x1fff, CSC_D_WEIGHT_SIZE_EXT_1_0_WEIGHT_KERNEL_SHIFT))
+#define CSC_D_WEIGHT_SIZE_EXT_1_0_WEIGHT_KERNEL_RANGE (28 : 16)
+#define CSC_D_WEIGHT_SIZE_EXT_1_0_WEIGHT_KERNEL_WOFFSET (0x0)
+#define CSC_D_WEIGHT_SIZE_EXT_1_0_WEIGHT_KERNEL_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_D_WEIGHT_SIZE_EXT_1_0_WEIGHT_KERNEL_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1fff))
+#define CSC_D_WEIGHT_SIZE_EXT_1_0_WEIGHT_KERNEL_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_D_WEIGHT_SIZE_EXT_1_0_WEIGHT_KERNEL_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CSC_D_WEIGHT_SIZE_EXT_1_0_WEIGHT_KERNEL_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CSC_D_WEIGHT_SIZE_EXT_1_0_WEIGHT_KERNEL_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CSC_D_WEIGHT_BYTES_0
+#define CSC_D_WEIGHT_BYTES_0 (_MK_ADDR_CONST(0x6034))
+#define CSC_D_WEIGHT_BYTES_0_SECURE (0x0)
+#define CSC_D_WEIGHT_BYTES_0_DUAL (0x0)
+#define CSC_D_WEIGHT_BYTES_0_SCR (0)
+#define CSC_D_WEIGHT_BYTES_0_WORD_COUNT (0x1)
+#define CSC_D_WEIGHT_BYTES_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CSC_D_WEIGHT_BYTES_0_RESET_MASK (_MK_MASK_CONST(0xffffff80))
+#define CSC_D_WEIGHT_BYTES_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CSC_D_WEIGHT_BYTES_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CSC_D_WEIGHT_BYTES_0_READ_MASK (_MK_MASK_CONST(0xffffff80))
+#define CSC_D_WEIGHT_BYTES_0_WRITE_MASK (_MK_MASK_CONST(0xffffff80))
+#define CSC_D_WEIGHT_BYTES_0_WEIGHT_BYTES_SHIFT (_MK_SHIFT_CONST(7))
+#define CSC_D_WEIGHT_BYTES_0_WEIGHT_BYTES_FIELD \
+	(_MK_FIELD_CONST(0x1ffffff, CSC_D_WEIGHT_BYTES_0_WEIGHT_BYTES_SHIFT))
+#define CSC_D_WEIGHT_BYTES_0_WEIGHT_BYTES_RANGE (31 : 7)
+#define CSC_D_WEIGHT_BYTES_0_WEIGHT_BYTES_WOFFSET (0x0)
+#define CSC_D_WEIGHT_BYTES_0_WEIGHT_BYTES_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_D_WEIGHT_BYTES_0_WEIGHT_BYTES_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1ffffff))
+#define CSC_D_WEIGHT_BYTES_0_WEIGHT_BYTES_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_D_WEIGHT_BYTES_0_WEIGHT_BYTES_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CSC_D_WEIGHT_BYTES_0_WEIGHT_BYTES_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CSC_D_WEIGHT_BYTES_0_WEIGHT_BYTES_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CSC_D_WMB_BYTES_0
+#define CSC_D_WMB_BYTES_0 (_MK_ADDR_CONST(0x6038))
+#define CSC_D_WMB_BYTES_0_SECURE (0x0)
+#define CSC_D_WMB_BYTES_0_DUAL (0x0)
+#define CSC_D_WMB_BYTES_0_SCR (0)
+#define CSC_D_WMB_BYTES_0_WORD_COUNT (0x1)
+#define CSC_D_WMB_BYTES_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CSC_D_WMB_BYTES_0_RESET_MASK (_MK_MASK_CONST(0xfffff80))
+#define CSC_D_WMB_BYTES_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CSC_D_WMB_BYTES_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CSC_D_WMB_BYTES_0_READ_MASK (_MK_MASK_CONST(0xfffff80))
+#define CSC_D_WMB_BYTES_0_WRITE_MASK (_MK_MASK_CONST(0xfffff80))
+#define CSC_D_WMB_BYTES_0_WMB_BYTES_SHIFT (_MK_SHIFT_CONST(7))
+#define CSC_D_WMB_BYTES_0_WMB_BYTES_FIELD \
+	(_MK_FIELD_CONST(0x1fffff, CSC_D_WMB_BYTES_0_WMB_BYTES_SHIFT))
+#define CSC_D_WMB_BYTES_0_WMB_BYTES_RANGE (27 : 7)
+#define CSC_D_WMB_BYTES_0_WMB_BYTES_WOFFSET (0x0)
+#define CSC_D_WMB_BYTES_0_WMB_BYTES_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_D_WMB_BYTES_0_WMB_BYTES_DEFAULT_MASK (_MK_MASK_CONST(0x1fffff))
+#define CSC_D_WMB_BYTES_0_WMB_BYTES_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_D_WMB_BYTES_0_WMB_BYTES_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CSC_D_WMB_BYTES_0_WMB_BYTES_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CSC_D_WMB_BYTES_0_WMB_BYTES_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+// Register CSC_D_DATAOUT_SIZE_0_0
+#define CSC_D_DATAOUT_SIZE_0_0 (_MK_ADDR_CONST(0x603c))
+#define CSC_D_DATAOUT_SIZE_0_0_SECURE (0x0)
+#define CSC_D_DATAOUT_SIZE_0_0_DUAL (0x0)
+#define CSC_D_DATAOUT_SIZE_0_0_SCR (0)
+#define CSC_D_DATAOUT_SIZE_0_0_WORD_COUNT (0x1)
+#define CSC_D_DATAOUT_SIZE_0_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CSC_D_DATAOUT_SIZE_0_0_RESET_MASK (_MK_MASK_CONST(0x1fff1fff))
+#define CSC_D_DATAOUT_SIZE_0_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CSC_D_DATAOUT_SIZE_0_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CSC_D_DATAOUT_SIZE_0_0_READ_MASK (_MK_MASK_CONST(0x1fff1fff))
+#define CSC_D_DATAOUT_SIZE_0_0_WRITE_MASK (_MK_MASK_CONST(0x1fff1fff))
+#define CSC_D_DATAOUT_SIZE_0_0_DATAOUT_WIDTH_SHIFT (_MK_SHIFT_CONST(0))
+#define CSC_D_DATAOUT_SIZE_0_0_DATAOUT_WIDTH_FIELD \
+	(_MK_FIELD_CONST(0x1fff, CSC_D_DATAOUT_SIZE_0_0_DATAOUT_WIDTH_SHIFT))
+#define CSC_D_DATAOUT_SIZE_0_0_DATAOUT_WIDTH_RANGE (12 : 0)
+#define CSC_D_DATAOUT_SIZE_0_0_DATAOUT_WIDTH_WOFFSET (0x0)
+#define CSC_D_DATAOUT_SIZE_0_0_DATAOUT_WIDTH_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_D_DATAOUT_SIZE_0_0_DATAOUT_WIDTH_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1fff))
+#define CSC_D_DATAOUT_SIZE_0_0_DATAOUT_WIDTH_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_D_DATAOUT_SIZE_0_0_DATAOUT_WIDTH_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CSC_D_DATAOUT_SIZE_0_0_DATAOUT_WIDTH_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CSC_D_DATAOUT_SIZE_0_0_DATAOUT_WIDTH_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define CSC_D_DATAOUT_SIZE_0_0_DATAOUT_HEIGHT_SHIFT (_MK_SHIFT_CONST(16))
+#define CSC_D_DATAOUT_SIZE_0_0_DATAOUT_HEIGHT_FIELD \
+	(_MK_FIELD_CONST(0x1fff, CSC_D_DATAOUT_SIZE_0_0_DATAOUT_HEIGHT_SHIFT))
+#define CSC_D_DATAOUT_SIZE_0_0_DATAOUT_HEIGHT_RANGE (28 : 16)
+#define CSC_D_DATAOUT_SIZE_0_0_DATAOUT_HEIGHT_WOFFSET (0x0)
+#define CSC_D_DATAOUT_SIZE_0_0_DATAOUT_HEIGHT_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_D_DATAOUT_SIZE_0_0_DATAOUT_HEIGHT_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1fff))
+#define CSC_D_DATAOUT_SIZE_0_0_DATAOUT_HEIGHT_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_D_DATAOUT_SIZE_0_0_DATAOUT_HEIGHT_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CSC_D_DATAOUT_SIZE_0_0_DATAOUT_HEIGHT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CSC_D_DATAOUT_SIZE_0_0_DATAOUT_HEIGHT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CSC_D_DATAOUT_SIZE_1_0
+#define CSC_D_DATAOUT_SIZE_1_0 (_MK_ADDR_CONST(0x6040))
+#define CSC_D_DATAOUT_SIZE_1_0_SECURE (0x0)
+#define CSC_D_DATAOUT_SIZE_1_0_DUAL (0x0)
+#define CSC_D_DATAOUT_SIZE_1_0_SCR (0)
+#define CSC_D_DATAOUT_SIZE_1_0_WORD_COUNT (0x1)
+#define CSC_D_DATAOUT_SIZE_1_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CSC_D_DATAOUT_SIZE_1_0_RESET_MASK (_MK_MASK_CONST(0x1fff))
+#define CSC_D_DATAOUT_SIZE_1_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CSC_D_DATAOUT_SIZE_1_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CSC_D_DATAOUT_SIZE_1_0_READ_MASK (_MK_MASK_CONST(0x1fff))
+#define CSC_D_DATAOUT_SIZE_1_0_WRITE_MASK (_MK_MASK_CONST(0x1fff))
+#define CSC_D_DATAOUT_SIZE_1_0_DATAOUT_CHANNEL_SHIFT (_MK_SHIFT_CONST(0))
+#define CSC_D_DATAOUT_SIZE_1_0_DATAOUT_CHANNEL_FIELD \
+	(_MK_FIELD_CONST(0x1fff, CSC_D_DATAOUT_SIZE_1_0_DATAOUT_CHANNEL_SHIFT))
+#define CSC_D_DATAOUT_SIZE_1_0_DATAOUT_CHANNEL_RANGE (12 : 0)
+#define CSC_D_DATAOUT_SIZE_1_0_DATAOUT_CHANNEL_WOFFSET (0x0)
+#define CSC_D_DATAOUT_SIZE_1_0_DATAOUT_CHANNEL_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_D_DATAOUT_SIZE_1_0_DATAOUT_CHANNEL_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1fff))
+#define CSC_D_DATAOUT_SIZE_1_0_DATAOUT_CHANNEL_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_D_DATAOUT_SIZE_1_0_DATAOUT_CHANNEL_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CSC_D_DATAOUT_SIZE_1_0_DATAOUT_CHANNEL_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CSC_D_DATAOUT_SIZE_1_0_DATAOUT_CHANNEL_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CSC_D_ATOMICS_0
+#define CSC_D_ATOMICS_0 (_MK_ADDR_CONST(0x6044))
+#define CSC_D_ATOMICS_0_SECURE (0x0)
+#define CSC_D_ATOMICS_0_DUAL (0x0)
+#define CSC_D_ATOMICS_0_SCR (0)
+#define CSC_D_ATOMICS_0_WORD_COUNT (0x1)
+#define CSC_D_ATOMICS_0_RESET_VAL (_MK_MASK_CONST(0x1))
+#define CSC_D_ATOMICS_0_RESET_MASK (_MK_MASK_CONST(0x1fffff))
+#define CSC_D_ATOMICS_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CSC_D_ATOMICS_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CSC_D_ATOMICS_0_READ_MASK (_MK_MASK_CONST(0x1fffff))
+#define CSC_D_ATOMICS_0_WRITE_MASK (_MK_MASK_CONST(0x1fffff))
+#define CSC_D_ATOMICS_0_ATOMICS_SHIFT (_MK_SHIFT_CONST(0))
+#define CSC_D_ATOMICS_0_ATOMICS_FIELD \
+	(_MK_FIELD_CONST(0x1fffff, CSC_D_ATOMICS_0_ATOMICS_SHIFT))
+#define CSC_D_ATOMICS_0_ATOMICS_RANGE (20 : 0)
+#define CSC_D_ATOMICS_0_ATOMICS_WOFFSET (0x0)
+#define CSC_D_ATOMICS_0_ATOMICS_DEFAULT (_MK_MASK_CONST(0x1))
+#define CSC_D_ATOMICS_0_ATOMICS_DEFAULT_MASK (_MK_MASK_CONST(0x1fffff))
+#define CSC_D_ATOMICS_0_ATOMICS_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_D_ATOMICS_0_ATOMICS_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CSC_D_ATOMICS_0_ATOMICS_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CSC_D_ATOMICS_0_ATOMICS_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+// Register CSC_D_RELEASE_0
+#define CSC_D_RELEASE_0 (_MK_ADDR_CONST(0x6048))
+#define CSC_D_RELEASE_0_SECURE (0x0)
+#define CSC_D_RELEASE_0_DUAL (0x0)
+#define CSC_D_RELEASE_0_SCR (0)
+#define CSC_D_RELEASE_0_WORD_COUNT (0x1)
+#define CSC_D_RELEASE_0_RESET_VAL (_MK_MASK_CONST(0x1))
+#define CSC_D_RELEASE_0_RESET_MASK (_MK_MASK_CONST(0xfff))
+#define CSC_D_RELEASE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CSC_D_RELEASE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CSC_D_RELEASE_0_READ_MASK (_MK_MASK_CONST(0xfff))
+#define CSC_D_RELEASE_0_WRITE_MASK (_MK_MASK_CONST(0xfff))
+#define CSC_D_RELEASE_0_RLS_SLICES_SHIFT (_MK_SHIFT_CONST(0))
+#define CSC_D_RELEASE_0_RLS_SLICES_FIELD \
+	(_MK_FIELD_CONST(0xfff, CSC_D_RELEASE_0_RLS_SLICES_SHIFT))
+#define CSC_D_RELEASE_0_RLS_SLICES_RANGE (11 : 0)
+#define CSC_D_RELEASE_0_RLS_SLICES_WOFFSET (0x0)
+#define CSC_D_RELEASE_0_RLS_SLICES_DEFAULT (_MK_MASK_CONST(0x1))
+#define CSC_D_RELEASE_0_RLS_SLICES_DEFAULT_MASK (_MK_MASK_CONST(0xfff))
+#define CSC_D_RELEASE_0_RLS_SLICES_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_D_RELEASE_0_RLS_SLICES_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CSC_D_RELEASE_0_RLS_SLICES_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CSC_D_RELEASE_0_RLS_SLICES_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+// Register CSC_D_CONV_STRIDE_EXT_0
+#define CSC_D_CONV_STRIDE_EXT_0 (_MK_ADDR_CONST(0x604c))
+#define CSC_D_CONV_STRIDE_EXT_0_SECURE (0x0)
+#define CSC_D_CONV_STRIDE_EXT_0_DUAL (0x0)
+#define CSC_D_CONV_STRIDE_EXT_0_SCR (0)
+#define CSC_D_CONV_STRIDE_EXT_0_WORD_COUNT (0x1)
+#define CSC_D_CONV_STRIDE_EXT_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CSC_D_CONV_STRIDE_EXT_0_RESET_MASK (_MK_MASK_CONST(0x70007))
+#define CSC_D_CONV_STRIDE_EXT_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CSC_D_CONV_STRIDE_EXT_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CSC_D_CONV_STRIDE_EXT_0_READ_MASK (_MK_MASK_CONST(0x70007))
+#define CSC_D_CONV_STRIDE_EXT_0_WRITE_MASK (_MK_MASK_CONST(0x70007))
+#define CSC_D_CONV_STRIDE_EXT_0_CONV_X_STRIDE_EXT_SHIFT (_MK_SHIFT_CONST(0))
+#define CSC_D_CONV_STRIDE_EXT_0_CONV_X_STRIDE_EXT_FIELD \
+	(_MK_FIELD_CONST(0x7, CSC_D_CONV_STRIDE_EXT_0_CONV_X_STRIDE_EXT_SHIFT))
+#define CSC_D_CONV_STRIDE_EXT_0_CONV_X_STRIDE_EXT_RANGE (2 : 0)
+#define CSC_D_CONV_STRIDE_EXT_0_CONV_X_STRIDE_EXT_WOFFSET (0x0)
+#define CSC_D_CONV_STRIDE_EXT_0_CONV_X_STRIDE_EXT_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_D_CONV_STRIDE_EXT_0_CONV_X_STRIDE_EXT_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7))
+#define CSC_D_CONV_STRIDE_EXT_0_CONV_X_STRIDE_EXT_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CSC_D_CONV_STRIDE_EXT_0_CONV_X_STRIDE_EXT_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CSC_D_CONV_STRIDE_EXT_0_CONV_X_STRIDE_EXT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CSC_D_CONV_STRIDE_EXT_0_CONV_X_STRIDE_EXT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define CSC_D_CONV_STRIDE_EXT_0_CONV_Y_STRIDE_EXT_SHIFT (_MK_SHIFT_CONST(16))
+#define CSC_D_CONV_STRIDE_EXT_0_CONV_Y_STRIDE_EXT_FIELD \
+	(_MK_FIELD_CONST(0x7, CSC_D_CONV_STRIDE_EXT_0_CONV_Y_STRIDE_EXT_SHIFT))
+#define CSC_D_CONV_STRIDE_EXT_0_CONV_Y_STRIDE_EXT_RANGE (18 : 16)
+#define CSC_D_CONV_STRIDE_EXT_0_CONV_Y_STRIDE_EXT_WOFFSET (0x0)
+#define CSC_D_CONV_STRIDE_EXT_0_CONV_Y_STRIDE_EXT_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_D_CONV_STRIDE_EXT_0_CONV_Y_STRIDE_EXT_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7))
+#define CSC_D_CONV_STRIDE_EXT_0_CONV_Y_STRIDE_EXT_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CSC_D_CONV_STRIDE_EXT_0_CONV_Y_STRIDE_EXT_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CSC_D_CONV_STRIDE_EXT_0_CONV_Y_STRIDE_EXT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CSC_D_CONV_STRIDE_EXT_0_CONV_Y_STRIDE_EXT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CSC_D_DILATION_EXT_0
+#define CSC_D_DILATION_EXT_0 (_MK_ADDR_CONST(0x6050))
+#define CSC_D_DILATION_EXT_0_SECURE (0x0)
+#define CSC_D_DILATION_EXT_0_DUAL (0x0)
+#define CSC_D_DILATION_EXT_0_SCR (0)
+#define CSC_D_DILATION_EXT_0_WORD_COUNT (0x1)
+#define CSC_D_DILATION_EXT_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CSC_D_DILATION_EXT_0_RESET_MASK (_MK_MASK_CONST(0x1f001f))
+#define CSC_D_DILATION_EXT_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CSC_D_DILATION_EXT_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CSC_D_DILATION_EXT_0_READ_MASK (_MK_MASK_CONST(0x1f001f))
+#define CSC_D_DILATION_EXT_0_WRITE_MASK (_MK_MASK_CONST(0x1f001f))
+#define CSC_D_DILATION_EXT_0_X_DILATION_EXT_SHIFT (_MK_SHIFT_CONST(0))
+#define CSC_D_DILATION_EXT_0_X_DILATION_EXT_FIELD \
+	(_MK_FIELD_CONST(0x1f, CSC_D_DILATION_EXT_0_X_DILATION_EXT_SHIFT))
+#define CSC_D_DILATION_EXT_0_X_DILATION_EXT_RANGE (4 : 0)
+#define CSC_D_DILATION_EXT_0_X_DILATION_EXT_WOFFSET (0x0)
+#define CSC_D_DILATION_EXT_0_X_DILATION_EXT_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_D_DILATION_EXT_0_X_DILATION_EXT_DEFAULT_MASK (_MK_MASK_CONST(0x1f))
+#define CSC_D_DILATION_EXT_0_X_DILATION_EXT_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_D_DILATION_EXT_0_X_DILATION_EXT_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CSC_D_DILATION_EXT_0_X_DILATION_EXT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CSC_D_DILATION_EXT_0_X_DILATION_EXT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define CSC_D_DILATION_EXT_0_Y_DILATION_EXT_SHIFT (_MK_SHIFT_CONST(16))
+#define CSC_D_DILATION_EXT_0_Y_DILATION_EXT_FIELD \
+	(_MK_FIELD_CONST(0x1f, CSC_D_DILATION_EXT_0_Y_DILATION_EXT_SHIFT))
+#define CSC_D_DILATION_EXT_0_Y_DILATION_EXT_RANGE (20 : 16)
+#define CSC_D_DILATION_EXT_0_Y_DILATION_EXT_WOFFSET (0x0)
+#define CSC_D_DILATION_EXT_0_Y_DILATION_EXT_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_D_DILATION_EXT_0_Y_DILATION_EXT_DEFAULT_MASK (_MK_MASK_CONST(0x1f))
+#define CSC_D_DILATION_EXT_0_Y_DILATION_EXT_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_D_DILATION_EXT_0_Y_DILATION_EXT_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CSC_D_DILATION_EXT_0_Y_DILATION_EXT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CSC_D_DILATION_EXT_0_Y_DILATION_EXT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CSC_D_ZERO_PADDING_0
+#define CSC_D_ZERO_PADDING_0 (_MK_ADDR_CONST(0x6054))
+#define CSC_D_ZERO_PADDING_0_SECURE (0x0)
+#define CSC_D_ZERO_PADDING_0_DUAL (0x0)
+#define CSC_D_ZERO_PADDING_0_SCR (0)
+#define CSC_D_ZERO_PADDING_0_WORD_COUNT (0x1)
+#define CSC_D_ZERO_PADDING_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CSC_D_ZERO_PADDING_0_RESET_MASK (_MK_MASK_CONST(0x1f001f))
+#define CSC_D_ZERO_PADDING_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CSC_D_ZERO_PADDING_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CSC_D_ZERO_PADDING_0_READ_MASK (_MK_MASK_CONST(0x1f001f))
+#define CSC_D_ZERO_PADDING_0_WRITE_MASK (_MK_MASK_CONST(0x1f001f))
+#define CSC_D_ZERO_PADDING_0_PAD_LEFT_SHIFT (_MK_SHIFT_CONST(0))
+#define CSC_D_ZERO_PADDING_0_PAD_LEFT_FIELD \
+	(_MK_FIELD_CONST(0x1f, CSC_D_ZERO_PADDING_0_PAD_LEFT_SHIFT))
+#define CSC_D_ZERO_PADDING_0_PAD_LEFT_RANGE (4 : 0)
+#define CSC_D_ZERO_PADDING_0_PAD_LEFT_WOFFSET (0x0)
+#define CSC_D_ZERO_PADDING_0_PAD_LEFT_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_D_ZERO_PADDING_0_PAD_LEFT_DEFAULT_MASK (_MK_MASK_CONST(0x1f))
+#define CSC_D_ZERO_PADDING_0_PAD_LEFT_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_D_ZERO_PADDING_0_PAD_LEFT_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CSC_D_ZERO_PADDING_0_PAD_LEFT_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CSC_D_ZERO_PADDING_0_PAD_LEFT_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+#define CSC_D_ZERO_PADDING_0_PAD_TOP_SHIFT (_MK_SHIFT_CONST(16))
+#define CSC_D_ZERO_PADDING_0_PAD_TOP_FIELD \
+	(_MK_FIELD_CONST(0x1f, CSC_D_ZERO_PADDING_0_PAD_TOP_SHIFT))
+#define CSC_D_ZERO_PADDING_0_PAD_TOP_RANGE (20 : 16)
+#define CSC_D_ZERO_PADDING_0_PAD_TOP_WOFFSET (0x0)
+#define CSC_D_ZERO_PADDING_0_PAD_TOP_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_D_ZERO_PADDING_0_PAD_TOP_DEFAULT_MASK (_MK_MASK_CONST(0x1f))
+#define CSC_D_ZERO_PADDING_0_PAD_TOP_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_D_ZERO_PADDING_0_PAD_TOP_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CSC_D_ZERO_PADDING_0_PAD_TOP_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CSC_D_ZERO_PADDING_0_PAD_TOP_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+// Register CSC_D_ZERO_PADDING_VALUE_0
+#define CSC_D_ZERO_PADDING_VALUE_0 (_MK_ADDR_CONST(0x6058))
+#define CSC_D_ZERO_PADDING_VALUE_0_SECURE (0x0)
+#define CSC_D_ZERO_PADDING_VALUE_0_DUAL (0x0)
+#define CSC_D_ZERO_PADDING_VALUE_0_SCR (0)
+#define CSC_D_ZERO_PADDING_VALUE_0_WORD_COUNT (0x1)
+#define CSC_D_ZERO_PADDING_VALUE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CSC_D_ZERO_PADDING_VALUE_0_RESET_MASK (_MK_MASK_CONST(0xffff))
+#define CSC_D_ZERO_PADDING_VALUE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CSC_D_ZERO_PADDING_VALUE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CSC_D_ZERO_PADDING_VALUE_0_READ_MASK (_MK_MASK_CONST(0xffff))
+#define CSC_D_ZERO_PADDING_VALUE_0_WRITE_MASK (_MK_MASK_CONST(0xffff))
+#define CSC_D_ZERO_PADDING_VALUE_0_PAD_VALUE_SHIFT (_MK_SHIFT_CONST(0))
+#define CSC_D_ZERO_PADDING_VALUE_0_PAD_VALUE_FIELD \
+	(_MK_FIELD_CONST(0xffff, CSC_D_ZERO_PADDING_VALUE_0_PAD_VALUE_SHIFT))
+#define CSC_D_ZERO_PADDING_VALUE_0_PAD_VALUE_RANGE (15 : 0)
+#define CSC_D_ZERO_PADDING_VALUE_0_PAD_VALUE_WOFFSET (0x0)
+#define CSC_D_ZERO_PADDING_VALUE_0_PAD_VALUE_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_D_ZERO_PADDING_VALUE_0_PAD_VALUE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffff))
+#define CSC_D_ZERO_PADDING_VALUE_0_PAD_VALUE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_D_ZERO_PADDING_VALUE_0_PAD_VALUE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CSC_D_ZERO_PADDING_VALUE_0_PAD_VALUE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CSC_D_ZERO_PADDING_VALUE_0_PAD_VALUE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CSC_D_BANK_0
+#define CSC_D_BANK_0 (_MK_ADDR_CONST(0x605c))
+#define CSC_D_BANK_0_SECURE (0x0)
+#define CSC_D_BANK_0_DUAL (0x0)
+#define CSC_D_BANK_0_SCR (0)
+#define CSC_D_BANK_0_WORD_COUNT (0x1)
+#define CSC_D_BANK_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CSC_D_BANK_0_RESET_MASK (_MK_MASK_CONST(0xf000f))
+#define CSC_D_BANK_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CSC_D_BANK_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CSC_D_BANK_0_READ_MASK (_MK_MASK_CONST(0xf000f))
+#define CSC_D_BANK_0_WRITE_MASK (_MK_MASK_CONST(0xf000f))
+#define CSC_D_BANK_0_DATA_BANK_SHIFT (_MK_SHIFT_CONST(0))
+#define CSC_D_BANK_0_DATA_BANK_FIELD \
+	(_MK_FIELD_CONST(0xf, CSC_D_BANK_0_DATA_BANK_SHIFT))
+#define CSC_D_BANK_0_DATA_BANK_RANGE (3 : 0)
+#define CSC_D_BANK_0_DATA_BANK_WOFFSET (0x0)
+#define CSC_D_BANK_0_DATA_BANK_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_D_BANK_0_DATA_BANK_DEFAULT_MASK (_MK_MASK_CONST(0xf))
+#define CSC_D_BANK_0_DATA_BANK_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_D_BANK_0_DATA_BANK_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CSC_D_BANK_0_DATA_BANK_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CSC_D_BANK_0_DATA_BANK_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+#define CSC_D_BANK_0_WEIGHT_BANK_SHIFT (_MK_SHIFT_CONST(16))
+#define CSC_D_BANK_0_WEIGHT_BANK_FIELD \
+	(_MK_FIELD_CONST(0xf, CSC_D_BANK_0_WEIGHT_BANK_SHIFT))
+#define CSC_D_BANK_0_WEIGHT_BANK_RANGE (19 : 16)
+#define CSC_D_BANK_0_WEIGHT_BANK_WOFFSET (0x0)
+#define CSC_D_BANK_0_WEIGHT_BANK_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_D_BANK_0_WEIGHT_BANK_DEFAULT_MASK (_MK_MASK_CONST(0xf))
+#define CSC_D_BANK_0_WEIGHT_BANK_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_D_BANK_0_WEIGHT_BANK_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CSC_D_BANK_0_WEIGHT_BANK_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CSC_D_BANK_0_WEIGHT_BANK_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+// Register CSC_D_PRA_CFG_0
+#define CSC_D_PRA_CFG_0 (_MK_ADDR_CONST(0x6060))
+#define CSC_D_PRA_CFG_0_SECURE (0x0)
+#define CSC_D_PRA_CFG_0_DUAL (0x0)
+#define CSC_D_PRA_CFG_0_SCR (0)
+#define CSC_D_PRA_CFG_0_WORD_COUNT (0x1)
+#define CSC_D_PRA_CFG_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CSC_D_PRA_CFG_0_RESET_MASK (_MK_MASK_CONST(0x3))
+#define CSC_D_PRA_CFG_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CSC_D_PRA_CFG_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CSC_D_PRA_CFG_0_READ_MASK (_MK_MASK_CONST(0x3))
+#define CSC_D_PRA_CFG_0_WRITE_MASK (_MK_MASK_CONST(0x3))
+#define CSC_D_PRA_CFG_0_PRA_TRUNCATE_SHIFT (_MK_SHIFT_CONST(0))
+#define CSC_D_PRA_CFG_0_PRA_TRUNCATE_FIELD \
+	(_MK_FIELD_CONST(0x3, CSC_D_PRA_CFG_0_PRA_TRUNCATE_SHIFT))
+#define CSC_D_PRA_CFG_0_PRA_TRUNCATE_RANGE (1 : 0)
+#define CSC_D_PRA_CFG_0_PRA_TRUNCATE_WOFFSET (0x0)
+#define CSC_D_PRA_CFG_0_PRA_TRUNCATE_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_D_PRA_CFG_0_PRA_TRUNCATE_DEFAULT_MASK (_MK_MASK_CONST(0x3))
+#define CSC_D_PRA_CFG_0_PRA_TRUNCATE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_D_PRA_CFG_0_PRA_TRUNCATE_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CSC_D_PRA_CFG_0_PRA_TRUNCATE_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CSC_D_PRA_CFG_0_PRA_TRUNCATE_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+// Register CSC_D_CYA_0
+#define CSC_D_CYA_0 (_MK_ADDR_CONST(0x6064))
+#define CSC_D_CYA_0_SECURE (0x0)
+#define CSC_D_CYA_0_DUAL (0x0)
+#define CSC_D_CYA_0_SCR (0)
+#define CSC_D_CYA_0_WORD_COUNT (0x1)
+#define CSC_D_CYA_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CSC_D_CYA_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define CSC_D_CYA_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CSC_D_CYA_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CSC_D_CYA_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define CSC_D_CYA_0_WRITE_MASK (_MK_MASK_CONST(0xffffffff))
+#define CSC_D_CYA_0_CYA_SHIFT (_MK_SHIFT_CONST(0))
+#define CSC_D_CYA_0_CYA_FIELD \
+	(_MK_FIELD_CONST(0xffffffff, CSC_D_CYA_0_CYA_SHIFT))
+#define CSC_D_CYA_0_CYA_RANGE (31 : 0)
+#define CSC_D_CYA_0_CYA_WOFFSET (0x0)
+#define CSC_D_CYA_0_CYA_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_D_CYA_0_CYA_DEFAULT_MASK (_MK_MASK_CONST(0xffffffff))
+#define CSC_D_CYA_0_CYA_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CSC_D_CYA_0_CYA_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CSC_D_CYA_0_CYA_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CSC_D_CYA_0_CYA_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+// Register CMAC_A_S_STATUS_0
+#define CMAC_A_S_STATUS_0 (_MK_ADDR_CONST(0x7000))
+#define CMAC_A_S_STATUS_0_SECURE (0x0)
+#define CMAC_A_S_STATUS_0_DUAL (0x0)
+#define CMAC_A_S_STATUS_0_SCR (0)
+#define CMAC_A_S_STATUS_0_WORD_COUNT (0x1)
+#define CMAC_A_S_STATUS_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CMAC_A_S_STATUS_0_RESET_MASK (_MK_MASK_CONST(0x30003))
+#define CMAC_A_S_STATUS_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CMAC_A_S_STATUS_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CMAC_A_S_STATUS_0_READ_MASK (_MK_MASK_CONST(0x30003))
+#define CMAC_A_S_STATUS_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define CMAC_A_S_STATUS_0_STATUS_0_SHIFT (_MK_SHIFT_CONST(0))
+#define CMAC_A_S_STATUS_0_STATUS_0_FIELD \
+	(_MK_FIELD_CONST(0x3, CMAC_A_S_STATUS_0_STATUS_0_SHIFT))
+#define CMAC_A_S_STATUS_0_STATUS_0_RANGE (1 : 0)
+#define CMAC_A_S_STATUS_0_STATUS_0_WOFFSET (0x0)
+#define CMAC_A_S_STATUS_0_STATUS_0_DEFAULT (_MK_MASK_CONST(0x0))
+#define CMAC_A_S_STATUS_0_STATUS_0_DEFAULT_MASK (_MK_MASK_CONST(0x3))
+#define CMAC_A_S_STATUS_0_STATUS_0_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CMAC_A_S_STATUS_0_STATUS_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CMAC_A_S_STATUS_0_STATUS_0_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CMAC_A_S_STATUS_0_STATUS_0_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define CMAC_A_S_STATUS_0_STATUS_0_INIT_ENUM (IDLE)
+#define CMAC_A_S_STATUS_0_STATUS_0_IDLE (_MK_ENUM_CONST(0))
+#define CMAC_A_S_STATUS_0_STATUS_0_RUNNING (_MK_ENUM_CONST(1))
+#define CMAC_A_S_STATUS_0_STATUS_0_PENDING (_MK_ENUM_CONST(2))
+
+#define CMAC_A_S_STATUS_0_STATUS_1_SHIFT (_MK_SHIFT_CONST(16))
+#define CMAC_A_S_STATUS_0_STATUS_1_FIELD \
+	(_MK_FIELD_CONST(0x3, CMAC_A_S_STATUS_0_STATUS_1_SHIFT))
+#define CMAC_A_S_STATUS_0_STATUS_1_RANGE (17 : 16)
+#define CMAC_A_S_STATUS_0_STATUS_1_WOFFSET (0x0)
+#define CMAC_A_S_STATUS_0_STATUS_1_DEFAULT (_MK_MASK_CONST(0x0))
+#define CMAC_A_S_STATUS_0_STATUS_1_DEFAULT_MASK (_MK_MASK_CONST(0x3))
+#define CMAC_A_S_STATUS_0_STATUS_1_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CMAC_A_S_STATUS_0_STATUS_1_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CMAC_A_S_STATUS_0_STATUS_1_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CMAC_A_S_STATUS_0_STATUS_1_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define CMAC_A_S_STATUS_0_STATUS_1_INIT_ENUM (IDLE)
+#define CMAC_A_S_STATUS_0_STATUS_1_IDLE (_MK_ENUM_CONST(0))
+#define CMAC_A_S_STATUS_0_STATUS_1_RUNNING (_MK_ENUM_CONST(1))
+#define CMAC_A_S_STATUS_0_STATUS_1_PENDING (_MK_ENUM_CONST(2))
+
+// Register CMAC_A_S_POINTER_0
+#define CMAC_A_S_POINTER_0 (_MK_ADDR_CONST(0x7004))
+#define CMAC_A_S_POINTER_0_SECURE (0x0)
+#define CMAC_A_S_POINTER_0_DUAL (0x0)
+#define CMAC_A_S_POINTER_0_SCR (0)
+#define CMAC_A_S_POINTER_0_WORD_COUNT (0x1)
+#define CMAC_A_S_POINTER_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CMAC_A_S_POINTER_0_RESET_MASK (_MK_MASK_CONST(0x10001))
+#define CMAC_A_S_POINTER_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CMAC_A_S_POINTER_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CMAC_A_S_POINTER_0_READ_MASK (_MK_MASK_CONST(0x10001))
+#define CMAC_A_S_POINTER_0_WRITE_MASK (_MK_MASK_CONST(0x1))
+#define CMAC_A_S_POINTER_0_PRODUCER_SHIFT (_MK_SHIFT_CONST(0))
+#define CMAC_A_S_POINTER_0_PRODUCER_FIELD \
+	(_MK_FIELD_CONST(0x1, CMAC_A_S_POINTER_0_PRODUCER_SHIFT))
+#define CMAC_A_S_POINTER_0_PRODUCER_RANGE (0 : 0)
+#define CMAC_A_S_POINTER_0_PRODUCER_WOFFSET (0x0)
+#define CMAC_A_S_POINTER_0_PRODUCER_DEFAULT (_MK_MASK_CONST(0x0))
+#define CMAC_A_S_POINTER_0_PRODUCER_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CMAC_A_S_POINTER_0_PRODUCER_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CMAC_A_S_POINTER_0_PRODUCER_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CMAC_A_S_POINTER_0_PRODUCER_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CMAC_A_S_POINTER_0_PRODUCER_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define CMAC_A_S_POINTER_0_PRODUCER_INIT_ENUM (GROUP_0)
+#define CMAC_A_S_POINTER_0_PRODUCER_GROUP_0 (_MK_ENUM_CONST(0))
+#define CMAC_A_S_POINTER_0_PRODUCER_GROUP_1 (_MK_ENUM_CONST(1))
+
+#define CMAC_A_S_POINTER_0_CONSUMER_SHIFT (_MK_SHIFT_CONST(16))
+#define CMAC_A_S_POINTER_0_CONSUMER_FIELD \
+	(_MK_FIELD_CONST(0x1, CMAC_A_S_POINTER_0_CONSUMER_SHIFT))
+#define CMAC_A_S_POINTER_0_CONSUMER_RANGE (16 : 16)
+#define CMAC_A_S_POINTER_0_CONSUMER_WOFFSET (0x0)
+#define CMAC_A_S_POINTER_0_CONSUMER_DEFAULT (_MK_MASK_CONST(0x0))
+#define CMAC_A_S_POINTER_0_CONSUMER_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CMAC_A_S_POINTER_0_CONSUMER_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CMAC_A_S_POINTER_0_CONSUMER_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CMAC_A_S_POINTER_0_CONSUMER_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CMAC_A_S_POINTER_0_CONSUMER_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define CMAC_A_S_POINTER_0_CONSUMER_INIT_ENUM (GROUP_0)
+#define CMAC_A_S_POINTER_0_CONSUMER_GROUP_0 (_MK_ENUM_CONST(0))
+#define CMAC_A_S_POINTER_0_CONSUMER_GROUP_1 (_MK_ENUM_CONST(1))
+
+// Register CMAC_A_D_OP_ENABLE_0
+#define CMAC_A_D_OP_ENABLE_0 (_MK_ADDR_CONST(0x7008))
+#define CMAC_A_D_OP_ENABLE_0_SECURE (0x0)
+#define CMAC_A_D_OP_ENABLE_0_DUAL (0x0)
+#define CMAC_A_D_OP_ENABLE_0_SCR (0)
+#define CMAC_A_D_OP_ENABLE_0_WORD_COUNT (0x1)
+#define CMAC_A_D_OP_ENABLE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CMAC_A_D_OP_ENABLE_0_RESET_MASK (_MK_MASK_CONST(0x1))
+#define CMAC_A_D_OP_ENABLE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CMAC_A_D_OP_ENABLE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CMAC_A_D_OP_ENABLE_0_READ_MASK (_MK_MASK_CONST(0x1))
+#define CMAC_A_D_OP_ENABLE_0_WRITE_MASK (_MK_MASK_CONST(0x1))
+#define CMAC_A_D_OP_ENABLE_0_OP_EN_SHIFT (_MK_SHIFT_CONST(0))
+#define CMAC_A_D_OP_ENABLE_0_OP_EN_FIELD \
+	(_MK_FIELD_CONST(0x1, CMAC_A_D_OP_ENABLE_0_OP_EN_SHIFT))
+#define CMAC_A_D_OP_ENABLE_0_OP_EN_RANGE (0 : 0)
+#define CMAC_A_D_OP_ENABLE_0_OP_EN_WOFFSET (0x0)
+#define CMAC_A_D_OP_ENABLE_0_OP_EN_DEFAULT (_MK_MASK_CONST(0x0))
+#define CMAC_A_D_OP_ENABLE_0_OP_EN_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CMAC_A_D_OP_ENABLE_0_OP_EN_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CMAC_A_D_OP_ENABLE_0_OP_EN_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CMAC_A_D_OP_ENABLE_0_OP_EN_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CMAC_A_D_OP_ENABLE_0_OP_EN_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define CMAC_A_D_OP_ENABLE_0_OP_EN_INIT_ENUM (DISABLE)
+#define CMAC_A_D_OP_ENABLE_0_OP_EN_DISABLE (_MK_ENUM_CONST(0))
+#define CMAC_A_D_OP_ENABLE_0_OP_EN_ENABLE (_MK_ENUM_CONST(1))
+
+// Register CMAC_A_D_MISC_CFG_0
+#define CMAC_A_D_MISC_CFG_0 (_MK_ADDR_CONST(0x700c))
+#define CMAC_A_D_MISC_CFG_0_SECURE (0x0)
+#define CMAC_A_D_MISC_CFG_0_DUAL (0x0)
+#define CMAC_A_D_MISC_CFG_0_SCR (0)
+#define CMAC_A_D_MISC_CFG_0_WORD_COUNT (0x1)
+#define CMAC_A_D_MISC_CFG_0_RESET_VAL (_MK_MASK_CONST(0x1000))
+#define CMAC_A_D_MISC_CFG_0_RESET_MASK (_MK_MASK_CONST(0x3001))
+#define CMAC_A_D_MISC_CFG_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CMAC_A_D_MISC_CFG_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CMAC_A_D_MISC_CFG_0_READ_MASK (_MK_MASK_CONST(0x3001))
+#define CMAC_A_D_MISC_CFG_0_WRITE_MASK (_MK_MASK_CONST(0x3001))
+#define CMAC_A_D_MISC_CFG_0_CONV_MODE_SHIFT (_MK_SHIFT_CONST(0))
+#define CMAC_A_D_MISC_CFG_0_CONV_MODE_FIELD \
+	(_MK_FIELD_CONST(0x1, CMAC_A_D_MISC_CFG_0_CONV_MODE_SHIFT))
+#define CMAC_A_D_MISC_CFG_0_CONV_MODE_RANGE (0 : 0)
+#define CMAC_A_D_MISC_CFG_0_CONV_MODE_WOFFSET (0x0)
+#define CMAC_A_D_MISC_CFG_0_CONV_MODE_DEFAULT (_MK_MASK_CONST(0x0))
+#define CMAC_A_D_MISC_CFG_0_CONV_MODE_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CMAC_A_D_MISC_CFG_0_CONV_MODE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CMAC_A_D_MISC_CFG_0_CONV_MODE_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CMAC_A_D_MISC_CFG_0_CONV_MODE_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CMAC_A_D_MISC_CFG_0_CONV_MODE_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define CMAC_A_D_MISC_CFG_0_CONV_MODE_INIT_ENUM (DIRECT)
+#define CMAC_A_D_MISC_CFG_0_CONV_MODE_DIRECT (_MK_ENUM_CONST(0))
+#define CMAC_A_D_MISC_CFG_0_CONV_MODE_WINOGRAD (_MK_ENUM_CONST(1))
+
+#define CMAC_A_D_MISC_CFG_0_PROC_PRECISION_SHIFT (_MK_SHIFT_CONST(12))
+#define CMAC_A_D_MISC_CFG_0_PROC_PRECISION_FIELD \
+	(_MK_FIELD_CONST(0x3, CMAC_A_D_MISC_CFG_0_PROC_PRECISION_SHIFT))
+#define CMAC_A_D_MISC_CFG_0_PROC_PRECISION_RANGE (13 : 12)
+#define CMAC_A_D_MISC_CFG_0_PROC_PRECISION_WOFFSET (0x0)
+#define CMAC_A_D_MISC_CFG_0_PROC_PRECISION_DEFAULT (_MK_MASK_CONST(0x1))
+#define CMAC_A_D_MISC_CFG_0_PROC_PRECISION_DEFAULT_MASK (_MK_MASK_CONST(0x3))
+#define CMAC_A_D_MISC_CFG_0_PROC_PRECISION_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CMAC_A_D_MISC_CFG_0_PROC_PRECISION_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CMAC_A_D_MISC_CFG_0_PROC_PRECISION_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CMAC_A_D_MISC_CFG_0_PROC_PRECISION_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define CMAC_A_D_MISC_CFG_0_PROC_PRECISION_INIT_ENUM (INT16)
+#define CMAC_A_D_MISC_CFG_0_PROC_PRECISION_INT8 (_MK_ENUM_CONST(0))
+#define CMAC_A_D_MISC_CFG_0_PROC_PRECISION_INT16 (_MK_ENUM_CONST(1))
+#define CMAC_A_D_MISC_CFG_0_PROC_PRECISION_FP16 (_MK_ENUM_CONST(2))
+
+// Register CMAC_B_S_STATUS_0
+#define CMAC_B_S_STATUS_0 (_MK_ADDR_CONST(0x8000))
+#define CMAC_B_S_STATUS_0_SECURE (0x0)
+#define CMAC_B_S_STATUS_0_DUAL (0x0)
+#define CMAC_B_S_STATUS_0_SCR (0)
+#define CMAC_B_S_STATUS_0_WORD_COUNT (0x1)
+#define CMAC_B_S_STATUS_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CMAC_B_S_STATUS_0_RESET_MASK (_MK_MASK_CONST(0x30003))
+#define CMAC_B_S_STATUS_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CMAC_B_S_STATUS_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CMAC_B_S_STATUS_0_READ_MASK (_MK_MASK_CONST(0x30003))
+#define CMAC_B_S_STATUS_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define CMAC_B_S_STATUS_0_STATUS_0_SHIFT (_MK_SHIFT_CONST(0))
+#define CMAC_B_S_STATUS_0_STATUS_0_FIELD \
+	(_MK_FIELD_CONST(0x3, CMAC_B_S_STATUS_0_STATUS_0_SHIFT))
+#define CMAC_B_S_STATUS_0_STATUS_0_RANGE (1 : 0)
+#define CMAC_B_S_STATUS_0_STATUS_0_WOFFSET (0x0)
+#define CMAC_B_S_STATUS_0_STATUS_0_DEFAULT (_MK_MASK_CONST(0x0))
+#define CMAC_B_S_STATUS_0_STATUS_0_DEFAULT_MASK (_MK_MASK_CONST(0x3))
+#define CMAC_B_S_STATUS_0_STATUS_0_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CMAC_B_S_STATUS_0_STATUS_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CMAC_B_S_STATUS_0_STATUS_0_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CMAC_B_S_STATUS_0_STATUS_0_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define CMAC_B_S_STATUS_0_STATUS_0_INIT_ENUM (IDLE)
+#define CMAC_B_S_STATUS_0_STATUS_0_IDLE (_MK_ENUM_CONST(0))
+#define CMAC_B_S_STATUS_0_STATUS_0_RUNNING (_MK_ENUM_CONST(1))
+#define CMAC_B_S_STATUS_0_STATUS_0_PENDING (_MK_ENUM_CONST(2))
+
+#define CMAC_B_S_STATUS_0_STATUS_1_SHIFT (_MK_SHIFT_CONST(16))
+#define CMAC_B_S_STATUS_0_STATUS_1_FIELD \
+	(_MK_FIELD_CONST(0x3, CMAC_B_S_STATUS_0_STATUS_1_SHIFT))
+#define CMAC_B_S_STATUS_0_STATUS_1_RANGE (17 : 16)
+#define CMAC_B_S_STATUS_0_STATUS_1_WOFFSET (0x0)
+#define CMAC_B_S_STATUS_0_STATUS_1_DEFAULT (_MK_MASK_CONST(0x0))
+#define CMAC_B_S_STATUS_0_STATUS_1_DEFAULT_MASK (_MK_MASK_CONST(0x3))
+#define CMAC_B_S_STATUS_0_STATUS_1_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CMAC_B_S_STATUS_0_STATUS_1_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CMAC_B_S_STATUS_0_STATUS_1_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CMAC_B_S_STATUS_0_STATUS_1_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define CMAC_B_S_STATUS_0_STATUS_1_INIT_ENUM (IDLE)
+#define CMAC_B_S_STATUS_0_STATUS_1_IDLE (_MK_ENUM_CONST(0))
+#define CMAC_B_S_STATUS_0_STATUS_1_RUNNING (_MK_ENUM_CONST(1))
+#define CMAC_B_S_STATUS_0_STATUS_1_PENDING (_MK_ENUM_CONST(2))
+
+// Register CMAC_B_S_POINTER_0
+#define CMAC_B_S_POINTER_0 (_MK_ADDR_CONST(0x8004))
+#define CMAC_B_S_POINTER_0_SECURE (0x0)
+#define CMAC_B_S_POINTER_0_DUAL (0x0)
+#define CMAC_B_S_POINTER_0_SCR (0)
+#define CMAC_B_S_POINTER_0_WORD_COUNT (0x1)
+#define CMAC_B_S_POINTER_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CMAC_B_S_POINTER_0_RESET_MASK (_MK_MASK_CONST(0x10001))
+#define CMAC_B_S_POINTER_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CMAC_B_S_POINTER_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CMAC_B_S_POINTER_0_READ_MASK (_MK_MASK_CONST(0x10001))
+#define CMAC_B_S_POINTER_0_WRITE_MASK (_MK_MASK_CONST(0x1))
+#define CMAC_B_S_POINTER_0_PRODUCER_SHIFT (_MK_SHIFT_CONST(0))
+#define CMAC_B_S_POINTER_0_PRODUCER_FIELD \
+	(_MK_FIELD_CONST(0x1, CMAC_B_S_POINTER_0_PRODUCER_SHIFT))
+#define CMAC_B_S_POINTER_0_PRODUCER_RANGE (0 : 0)
+#define CMAC_B_S_POINTER_0_PRODUCER_WOFFSET (0x0)
+#define CMAC_B_S_POINTER_0_PRODUCER_DEFAULT (_MK_MASK_CONST(0x0))
+#define CMAC_B_S_POINTER_0_PRODUCER_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CMAC_B_S_POINTER_0_PRODUCER_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CMAC_B_S_POINTER_0_PRODUCER_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CMAC_B_S_POINTER_0_PRODUCER_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CMAC_B_S_POINTER_0_PRODUCER_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define CMAC_B_S_POINTER_0_PRODUCER_INIT_ENUM (GROUP_0)
+#define CMAC_B_S_POINTER_0_PRODUCER_GROUP_0 (_MK_ENUM_CONST(0))
+#define CMAC_B_S_POINTER_0_PRODUCER_GROUP_1 (_MK_ENUM_CONST(1))
+
+#define CMAC_B_S_POINTER_0_CONSUMER_SHIFT (_MK_SHIFT_CONST(16))
+#define CMAC_B_S_POINTER_0_CONSUMER_FIELD \
+	(_MK_FIELD_CONST(0x1, CMAC_B_S_POINTER_0_CONSUMER_SHIFT))
+#define CMAC_B_S_POINTER_0_CONSUMER_RANGE (16 : 16)
+#define CMAC_B_S_POINTER_0_CONSUMER_WOFFSET (0x0)
+#define CMAC_B_S_POINTER_0_CONSUMER_DEFAULT (_MK_MASK_CONST(0x0))
+#define CMAC_B_S_POINTER_0_CONSUMER_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CMAC_B_S_POINTER_0_CONSUMER_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CMAC_B_S_POINTER_0_CONSUMER_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CMAC_B_S_POINTER_0_CONSUMER_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CMAC_B_S_POINTER_0_CONSUMER_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define CMAC_B_S_POINTER_0_CONSUMER_INIT_ENUM (GROUP_0)
+#define CMAC_B_S_POINTER_0_CONSUMER_GROUP_0 (_MK_ENUM_CONST(0))
+#define CMAC_B_S_POINTER_0_CONSUMER_GROUP_1 (_MK_ENUM_CONST(1))
+
+// Register CMAC_B_D_OP_ENABLE_0
+#define CMAC_B_D_OP_ENABLE_0 (_MK_ADDR_CONST(0x8008))
+#define CMAC_B_D_OP_ENABLE_0_SECURE (0x0)
+#define CMAC_B_D_OP_ENABLE_0_DUAL (0x0)
+#define CMAC_B_D_OP_ENABLE_0_SCR (0)
+#define CMAC_B_D_OP_ENABLE_0_WORD_COUNT (0x1)
+#define CMAC_B_D_OP_ENABLE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CMAC_B_D_OP_ENABLE_0_RESET_MASK (_MK_MASK_CONST(0x1))
+#define CMAC_B_D_OP_ENABLE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CMAC_B_D_OP_ENABLE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CMAC_B_D_OP_ENABLE_0_READ_MASK (_MK_MASK_CONST(0x1))
+#define CMAC_B_D_OP_ENABLE_0_WRITE_MASK (_MK_MASK_CONST(0x1))
+#define CMAC_B_D_OP_ENABLE_0_OP_EN_SHIFT (_MK_SHIFT_CONST(0))
+#define CMAC_B_D_OP_ENABLE_0_OP_EN_FIELD \
+	(_MK_FIELD_CONST(0x1, CMAC_B_D_OP_ENABLE_0_OP_EN_SHIFT))
+#define CMAC_B_D_OP_ENABLE_0_OP_EN_RANGE (0 : 0)
+#define CMAC_B_D_OP_ENABLE_0_OP_EN_WOFFSET (0x0)
+#define CMAC_B_D_OP_ENABLE_0_OP_EN_DEFAULT (_MK_MASK_CONST(0x0))
+#define CMAC_B_D_OP_ENABLE_0_OP_EN_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CMAC_B_D_OP_ENABLE_0_OP_EN_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CMAC_B_D_OP_ENABLE_0_OP_EN_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CMAC_B_D_OP_ENABLE_0_OP_EN_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CMAC_B_D_OP_ENABLE_0_OP_EN_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define CMAC_B_D_OP_ENABLE_0_OP_EN_INIT_ENUM (DISABLE)
+#define CMAC_B_D_OP_ENABLE_0_OP_EN_DISABLE (_MK_ENUM_CONST(0))
+#define CMAC_B_D_OP_ENABLE_0_OP_EN_ENABLE (_MK_ENUM_CONST(1))
+
+// Register CMAC_B_D_MISC_CFG_0
+#define CMAC_B_D_MISC_CFG_0 (_MK_ADDR_CONST(0x800c))
+#define CMAC_B_D_MISC_CFG_0_SECURE (0x0)
+#define CMAC_B_D_MISC_CFG_0_DUAL (0x0)
+#define CMAC_B_D_MISC_CFG_0_SCR (0)
+#define CMAC_B_D_MISC_CFG_0_WORD_COUNT (0x1)
+#define CMAC_B_D_MISC_CFG_0_RESET_VAL (_MK_MASK_CONST(0x1000))
+#define CMAC_B_D_MISC_CFG_0_RESET_MASK (_MK_MASK_CONST(0x3001))
+#define CMAC_B_D_MISC_CFG_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CMAC_B_D_MISC_CFG_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CMAC_B_D_MISC_CFG_0_READ_MASK (_MK_MASK_CONST(0x3001))
+#define CMAC_B_D_MISC_CFG_0_WRITE_MASK (_MK_MASK_CONST(0x3001))
+#define CMAC_B_D_MISC_CFG_0_CONV_MODE_SHIFT (_MK_SHIFT_CONST(0))
+#define CMAC_B_D_MISC_CFG_0_CONV_MODE_FIELD \
+	(_MK_FIELD_CONST(0x1, CMAC_B_D_MISC_CFG_0_CONV_MODE_SHIFT))
+#define CMAC_B_D_MISC_CFG_0_CONV_MODE_RANGE (0 : 0)
+#define CMAC_B_D_MISC_CFG_0_CONV_MODE_WOFFSET (0x0)
+#define CMAC_B_D_MISC_CFG_0_CONV_MODE_DEFAULT (_MK_MASK_CONST(0x0))
+#define CMAC_B_D_MISC_CFG_0_CONV_MODE_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CMAC_B_D_MISC_CFG_0_CONV_MODE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CMAC_B_D_MISC_CFG_0_CONV_MODE_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CMAC_B_D_MISC_CFG_0_CONV_MODE_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CMAC_B_D_MISC_CFG_0_CONV_MODE_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define CMAC_B_D_MISC_CFG_0_CONV_MODE_INIT_ENUM (DIRECT)
+#define CMAC_B_D_MISC_CFG_0_CONV_MODE_DIRECT (_MK_ENUM_CONST(0))
+#define CMAC_B_D_MISC_CFG_0_CONV_MODE_WINOGRAD (_MK_ENUM_CONST(1))
+
+#define CMAC_B_D_MISC_CFG_0_PROC_PRECISION_SHIFT (_MK_SHIFT_CONST(12))
+#define CMAC_B_D_MISC_CFG_0_PROC_PRECISION_FIELD \
+	(_MK_FIELD_CONST(0x3, CMAC_B_D_MISC_CFG_0_PROC_PRECISION_SHIFT))
+#define CMAC_B_D_MISC_CFG_0_PROC_PRECISION_RANGE (13 : 12)
+#define CMAC_B_D_MISC_CFG_0_PROC_PRECISION_WOFFSET (0x0)
+#define CMAC_B_D_MISC_CFG_0_PROC_PRECISION_DEFAULT (_MK_MASK_CONST(0x1))
+#define CMAC_B_D_MISC_CFG_0_PROC_PRECISION_DEFAULT_MASK (_MK_MASK_CONST(0x3))
+#define CMAC_B_D_MISC_CFG_0_PROC_PRECISION_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CMAC_B_D_MISC_CFG_0_PROC_PRECISION_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CMAC_B_D_MISC_CFG_0_PROC_PRECISION_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CMAC_B_D_MISC_CFG_0_PROC_PRECISION_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define CMAC_B_D_MISC_CFG_0_PROC_PRECISION_INIT_ENUM (INT16)
+#define CMAC_B_D_MISC_CFG_0_PROC_PRECISION_INT8 (_MK_ENUM_CONST(0))
+#define CMAC_B_D_MISC_CFG_0_PROC_PRECISION_INT16 (_MK_ENUM_CONST(1))
+#define CMAC_B_D_MISC_CFG_0_PROC_PRECISION_FP16 (_MK_ENUM_CONST(2))
+
+// Register CACC_S_STATUS_0
+#define CACC_S_STATUS_0 (_MK_ADDR_CONST(0x9000))
+#define CACC_S_STATUS_0_SECURE (0x0)
+#define CACC_S_STATUS_0_DUAL (0x0)
+#define CACC_S_STATUS_0_SCR (0)
+#define CACC_S_STATUS_0_WORD_COUNT (0x1)
+#define CACC_S_STATUS_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CACC_S_STATUS_0_RESET_MASK (_MK_MASK_CONST(0x30003))
+#define CACC_S_STATUS_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CACC_S_STATUS_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CACC_S_STATUS_0_READ_MASK (_MK_MASK_CONST(0x30003))
+#define CACC_S_STATUS_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define CACC_S_STATUS_0_STATUS_0_SHIFT (_MK_SHIFT_CONST(0))
+#define CACC_S_STATUS_0_STATUS_0_FIELD \
+	(_MK_FIELD_CONST(0x3, CACC_S_STATUS_0_STATUS_0_SHIFT))
+#define CACC_S_STATUS_0_STATUS_0_RANGE (1 : 0)
+#define CACC_S_STATUS_0_STATUS_0_WOFFSET (0x0)
+#define CACC_S_STATUS_0_STATUS_0_DEFAULT (_MK_MASK_CONST(0x0))
+#define CACC_S_STATUS_0_STATUS_0_DEFAULT_MASK (_MK_MASK_CONST(0x3))
+#define CACC_S_STATUS_0_STATUS_0_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CACC_S_STATUS_0_STATUS_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CACC_S_STATUS_0_STATUS_0_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CACC_S_STATUS_0_STATUS_0_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define CACC_S_STATUS_0_STATUS_0_INIT_ENUM (IDLE)
+#define CACC_S_STATUS_0_STATUS_0_IDLE (_MK_ENUM_CONST(0))
+#define CACC_S_STATUS_0_STATUS_0_RUNNING (_MK_ENUM_CONST(1))
+#define CACC_S_STATUS_0_STATUS_0_PENDING (_MK_ENUM_CONST(2))
+
+#define CACC_S_STATUS_0_STATUS_1_SHIFT (_MK_SHIFT_CONST(16))
+#define CACC_S_STATUS_0_STATUS_1_FIELD \
+	(_MK_FIELD_CONST(0x3, CACC_S_STATUS_0_STATUS_1_SHIFT))
+#define CACC_S_STATUS_0_STATUS_1_RANGE (17 : 16)
+#define CACC_S_STATUS_0_STATUS_1_WOFFSET (0x0)
+#define CACC_S_STATUS_0_STATUS_1_DEFAULT (_MK_MASK_CONST(0x0))
+#define CACC_S_STATUS_0_STATUS_1_DEFAULT_MASK (_MK_MASK_CONST(0x3))
+#define CACC_S_STATUS_0_STATUS_1_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CACC_S_STATUS_0_STATUS_1_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CACC_S_STATUS_0_STATUS_1_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CACC_S_STATUS_0_STATUS_1_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define CACC_S_STATUS_0_STATUS_1_INIT_ENUM (IDLE)
+#define CACC_S_STATUS_0_STATUS_1_IDLE (_MK_ENUM_CONST(0))
+#define CACC_S_STATUS_0_STATUS_1_RUNNING (_MK_ENUM_CONST(1))
+#define CACC_S_STATUS_0_STATUS_1_PENDING (_MK_ENUM_CONST(2))
+
+// Register CACC_S_POINTER_0
+#define CACC_S_POINTER_0 (_MK_ADDR_CONST(0x9004))
+#define CACC_S_POINTER_0_SECURE (0x0)
+#define CACC_S_POINTER_0_DUAL (0x0)
+#define CACC_S_POINTER_0_SCR (0)
+#define CACC_S_POINTER_0_WORD_COUNT (0x1)
+#define CACC_S_POINTER_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CACC_S_POINTER_0_RESET_MASK (_MK_MASK_CONST(0x10001))
+#define CACC_S_POINTER_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CACC_S_POINTER_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CACC_S_POINTER_0_READ_MASK (_MK_MASK_CONST(0x10001))
+#define CACC_S_POINTER_0_WRITE_MASK (_MK_MASK_CONST(0x1))
+#define CACC_S_POINTER_0_PRODUCER_SHIFT (_MK_SHIFT_CONST(0))
+#define CACC_S_POINTER_0_PRODUCER_FIELD \
+	(_MK_FIELD_CONST(0x1, CACC_S_POINTER_0_PRODUCER_SHIFT))
+#define CACC_S_POINTER_0_PRODUCER_RANGE (0 : 0)
+#define CACC_S_POINTER_0_PRODUCER_WOFFSET (0x0)
+#define CACC_S_POINTER_0_PRODUCER_DEFAULT (_MK_MASK_CONST(0x0))
+#define CACC_S_POINTER_0_PRODUCER_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CACC_S_POINTER_0_PRODUCER_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CACC_S_POINTER_0_PRODUCER_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CACC_S_POINTER_0_PRODUCER_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CACC_S_POINTER_0_PRODUCER_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define CACC_S_POINTER_0_PRODUCER_INIT_ENUM (GROUP_0)
+#define CACC_S_POINTER_0_PRODUCER_GROUP_0 (_MK_ENUM_CONST(0))
+#define CACC_S_POINTER_0_PRODUCER_GROUP_1 (_MK_ENUM_CONST(1))
+
+#define CACC_S_POINTER_0_CONSUMER_SHIFT (_MK_SHIFT_CONST(16))
+#define CACC_S_POINTER_0_CONSUMER_FIELD \
+	(_MK_FIELD_CONST(0x1, CACC_S_POINTER_0_CONSUMER_SHIFT))
+#define CACC_S_POINTER_0_CONSUMER_RANGE (16 : 16)
+#define CACC_S_POINTER_0_CONSUMER_WOFFSET (0x0)
+#define CACC_S_POINTER_0_CONSUMER_DEFAULT (_MK_MASK_CONST(0x0))
+#define CACC_S_POINTER_0_CONSUMER_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CACC_S_POINTER_0_CONSUMER_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CACC_S_POINTER_0_CONSUMER_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CACC_S_POINTER_0_CONSUMER_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CACC_S_POINTER_0_CONSUMER_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define CACC_S_POINTER_0_CONSUMER_INIT_ENUM (GROUP_0)
+#define CACC_S_POINTER_0_CONSUMER_GROUP_0 (_MK_ENUM_CONST(0))
+#define CACC_S_POINTER_0_CONSUMER_GROUP_1 (_MK_ENUM_CONST(1))
+
+// Register CACC_D_OP_ENABLE_0
+#define CACC_D_OP_ENABLE_0 (_MK_ADDR_CONST(0x9008))
+#define CACC_D_OP_ENABLE_0_SECURE (0x0)
+#define CACC_D_OP_ENABLE_0_DUAL (0x0)
+#define CACC_D_OP_ENABLE_0_SCR (0)
+#define CACC_D_OP_ENABLE_0_WORD_COUNT (0x1)
+#define CACC_D_OP_ENABLE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CACC_D_OP_ENABLE_0_RESET_MASK (_MK_MASK_CONST(0x1))
+#define CACC_D_OP_ENABLE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CACC_D_OP_ENABLE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CACC_D_OP_ENABLE_0_READ_MASK (_MK_MASK_CONST(0x1))
+#define CACC_D_OP_ENABLE_0_WRITE_MASK (_MK_MASK_CONST(0x1))
+#define CACC_D_OP_ENABLE_0_OP_EN_SHIFT (_MK_SHIFT_CONST(0))
+#define CACC_D_OP_ENABLE_0_OP_EN_FIELD \
+	(_MK_FIELD_CONST(0x1, CACC_D_OP_ENABLE_0_OP_EN_SHIFT))
+#define CACC_D_OP_ENABLE_0_OP_EN_RANGE (0 : 0)
+#define CACC_D_OP_ENABLE_0_OP_EN_WOFFSET (0x0)
+#define CACC_D_OP_ENABLE_0_OP_EN_DEFAULT (_MK_MASK_CONST(0x0))
+#define CACC_D_OP_ENABLE_0_OP_EN_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CACC_D_OP_ENABLE_0_OP_EN_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CACC_D_OP_ENABLE_0_OP_EN_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CACC_D_OP_ENABLE_0_OP_EN_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CACC_D_OP_ENABLE_0_OP_EN_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define CACC_D_OP_ENABLE_0_OP_EN_INIT_ENUM (DISABLE)
+#define CACC_D_OP_ENABLE_0_OP_EN_DISABLE (_MK_ENUM_CONST(0))
+#define CACC_D_OP_ENABLE_0_OP_EN_ENABLE (_MK_ENUM_CONST(1))
+
+// Register CACC_D_MISC_CFG_0
+#define CACC_D_MISC_CFG_0 (_MK_ADDR_CONST(0x900c))
+#define CACC_D_MISC_CFG_0_SECURE (0x0)
+#define CACC_D_MISC_CFG_0_DUAL (0x0)
+#define CACC_D_MISC_CFG_0_SCR (0)
+#define CACC_D_MISC_CFG_0_WORD_COUNT (0x1)
+#define CACC_D_MISC_CFG_0_RESET_VAL (_MK_MASK_CONST(0x1000))
+#define CACC_D_MISC_CFG_0_RESET_MASK (_MK_MASK_CONST(0x3001))
+#define CACC_D_MISC_CFG_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CACC_D_MISC_CFG_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CACC_D_MISC_CFG_0_READ_MASK (_MK_MASK_CONST(0x3001))
+#define CACC_D_MISC_CFG_0_WRITE_MASK (_MK_MASK_CONST(0x3001))
+#define CACC_D_MISC_CFG_0_CONV_MODE_SHIFT (_MK_SHIFT_CONST(0))
+#define CACC_D_MISC_CFG_0_CONV_MODE_FIELD \
+	(_MK_FIELD_CONST(0x1, CACC_D_MISC_CFG_0_CONV_MODE_SHIFT))
+#define CACC_D_MISC_CFG_0_CONV_MODE_RANGE (0 : 0)
+#define CACC_D_MISC_CFG_0_CONV_MODE_WOFFSET (0x0)
+#define CACC_D_MISC_CFG_0_CONV_MODE_DEFAULT (_MK_MASK_CONST(0x0))
+#define CACC_D_MISC_CFG_0_CONV_MODE_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CACC_D_MISC_CFG_0_CONV_MODE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CACC_D_MISC_CFG_0_CONV_MODE_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CACC_D_MISC_CFG_0_CONV_MODE_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CACC_D_MISC_CFG_0_CONV_MODE_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define CACC_D_MISC_CFG_0_CONV_MODE_INIT_ENUM (DIRECT)
+#define CACC_D_MISC_CFG_0_CONV_MODE_DIRECT (_MK_ENUM_CONST(0))
+#define CACC_D_MISC_CFG_0_CONV_MODE_WINOGRAD (_MK_ENUM_CONST(1))
+
+#define CACC_D_MISC_CFG_0_PROC_PRECISION_SHIFT (_MK_SHIFT_CONST(12))
+#define CACC_D_MISC_CFG_0_PROC_PRECISION_FIELD \
+	(_MK_FIELD_CONST(0x3, CACC_D_MISC_CFG_0_PROC_PRECISION_SHIFT))
+#define CACC_D_MISC_CFG_0_PROC_PRECISION_RANGE (13 : 12)
+#define CACC_D_MISC_CFG_0_PROC_PRECISION_WOFFSET (0x0)
+#define CACC_D_MISC_CFG_0_PROC_PRECISION_DEFAULT (_MK_MASK_CONST(0x1))
+#define CACC_D_MISC_CFG_0_PROC_PRECISION_DEFAULT_MASK (_MK_MASK_CONST(0x3))
+#define CACC_D_MISC_CFG_0_PROC_PRECISION_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CACC_D_MISC_CFG_0_PROC_PRECISION_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CACC_D_MISC_CFG_0_PROC_PRECISION_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CACC_D_MISC_CFG_0_PROC_PRECISION_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define CACC_D_MISC_CFG_0_PROC_PRECISION_INIT_ENUM (INT16)
+#define CACC_D_MISC_CFG_0_PROC_PRECISION_INT8 (_MK_ENUM_CONST(0))
+#define CACC_D_MISC_CFG_0_PROC_PRECISION_INT16 (_MK_ENUM_CONST(1))
+#define CACC_D_MISC_CFG_0_PROC_PRECISION_FP16 (_MK_ENUM_CONST(2))
+
+// Register CACC_D_DATAOUT_SIZE_0_0
+#define CACC_D_DATAOUT_SIZE_0_0 (_MK_ADDR_CONST(0x9010))
+#define CACC_D_DATAOUT_SIZE_0_0_SECURE (0x0)
+#define CACC_D_DATAOUT_SIZE_0_0_DUAL (0x0)
+#define CACC_D_DATAOUT_SIZE_0_0_SCR (0)
+#define CACC_D_DATAOUT_SIZE_0_0_WORD_COUNT (0x1)
+#define CACC_D_DATAOUT_SIZE_0_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CACC_D_DATAOUT_SIZE_0_0_RESET_MASK (_MK_MASK_CONST(0x1fff1fff))
+#define CACC_D_DATAOUT_SIZE_0_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CACC_D_DATAOUT_SIZE_0_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CACC_D_DATAOUT_SIZE_0_0_READ_MASK (_MK_MASK_CONST(0x1fff1fff))
+#define CACC_D_DATAOUT_SIZE_0_0_WRITE_MASK (_MK_MASK_CONST(0x1fff1fff))
+#define CACC_D_DATAOUT_SIZE_0_0_DATAOUT_WIDTH_SHIFT (_MK_SHIFT_CONST(0))
+#define CACC_D_DATAOUT_SIZE_0_0_DATAOUT_WIDTH_FIELD \
+	(_MK_FIELD_CONST(0x1fff, CACC_D_DATAOUT_SIZE_0_0_DATAOUT_WIDTH_SHIFT))
+#define CACC_D_DATAOUT_SIZE_0_0_DATAOUT_WIDTH_RANGE (12 : 0)
+#define CACC_D_DATAOUT_SIZE_0_0_DATAOUT_WIDTH_WOFFSET (0x0)
+#define CACC_D_DATAOUT_SIZE_0_0_DATAOUT_WIDTH_DEFAULT (_MK_MASK_CONST(0x0))
+#define CACC_D_DATAOUT_SIZE_0_0_DATAOUT_WIDTH_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1fff))
+#define CACC_D_DATAOUT_SIZE_0_0_DATAOUT_WIDTH_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CACC_D_DATAOUT_SIZE_0_0_DATAOUT_WIDTH_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CACC_D_DATAOUT_SIZE_0_0_DATAOUT_WIDTH_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CACC_D_DATAOUT_SIZE_0_0_DATAOUT_WIDTH_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define CACC_D_DATAOUT_SIZE_0_0_DATAOUT_HEIGHT_SHIFT (_MK_SHIFT_CONST(16))
+#define CACC_D_DATAOUT_SIZE_0_0_DATAOUT_HEIGHT_FIELD \
+	(_MK_FIELD_CONST(0x1fff, CACC_D_DATAOUT_SIZE_0_0_DATAOUT_HEIGHT_SHIFT))
+#define CACC_D_DATAOUT_SIZE_0_0_DATAOUT_HEIGHT_RANGE (28 : 16)
+#define CACC_D_DATAOUT_SIZE_0_0_DATAOUT_HEIGHT_WOFFSET (0x0)
+#define CACC_D_DATAOUT_SIZE_0_0_DATAOUT_HEIGHT_DEFAULT (_MK_MASK_CONST(0x0))
+#define CACC_D_DATAOUT_SIZE_0_0_DATAOUT_HEIGHT_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1fff))
+#define CACC_D_DATAOUT_SIZE_0_0_DATAOUT_HEIGHT_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CACC_D_DATAOUT_SIZE_0_0_DATAOUT_HEIGHT_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CACC_D_DATAOUT_SIZE_0_0_DATAOUT_HEIGHT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CACC_D_DATAOUT_SIZE_0_0_DATAOUT_HEIGHT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CACC_D_DATAOUT_SIZE_1_0
+#define CACC_D_DATAOUT_SIZE_1_0 (_MK_ADDR_CONST(0x9014))
+#define CACC_D_DATAOUT_SIZE_1_0_SECURE (0x0)
+#define CACC_D_DATAOUT_SIZE_1_0_DUAL (0x0)
+#define CACC_D_DATAOUT_SIZE_1_0_SCR (0)
+#define CACC_D_DATAOUT_SIZE_1_0_WORD_COUNT (0x1)
+#define CACC_D_DATAOUT_SIZE_1_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CACC_D_DATAOUT_SIZE_1_0_RESET_MASK (_MK_MASK_CONST(0x1fff))
+#define CACC_D_DATAOUT_SIZE_1_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CACC_D_DATAOUT_SIZE_1_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CACC_D_DATAOUT_SIZE_1_0_READ_MASK (_MK_MASK_CONST(0x1fff))
+#define CACC_D_DATAOUT_SIZE_1_0_WRITE_MASK (_MK_MASK_CONST(0x1fff))
+#define CACC_D_DATAOUT_SIZE_1_0_DATAOUT_CHANNEL_SHIFT (_MK_SHIFT_CONST(0))
+#define CACC_D_DATAOUT_SIZE_1_0_DATAOUT_CHANNEL_FIELD \
+	(_MK_FIELD_CONST(0x1fff, CACC_D_DATAOUT_SIZE_1_0_DATAOUT_CHANNEL_SHIFT))
+#define CACC_D_DATAOUT_SIZE_1_0_DATAOUT_CHANNEL_RANGE (12 : 0)
+#define CACC_D_DATAOUT_SIZE_1_0_DATAOUT_CHANNEL_WOFFSET (0x0)
+#define CACC_D_DATAOUT_SIZE_1_0_DATAOUT_CHANNEL_DEFAULT (_MK_MASK_CONST(0x0))
+#define CACC_D_DATAOUT_SIZE_1_0_DATAOUT_CHANNEL_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1fff))
+#define CACC_D_DATAOUT_SIZE_1_0_DATAOUT_CHANNEL_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CACC_D_DATAOUT_SIZE_1_0_DATAOUT_CHANNEL_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CACC_D_DATAOUT_SIZE_1_0_DATAOUT_CHANNEL_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CACC_D_DATAOUT_SIZE_1_0_DATAOUT_CHANNEL_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CACC_D_DATAOUT_ADDR_0
+#define CACC_D_DATAOUT_ADDR_0 (_MK_ADDR_CONST(0x9018))
+#define CACC_D_DATAOUT_ADDR_0_SECURE (0x0)
+#define CACC_D_DATAOUT_ADDR_0_DUAL (0x0)
+#define CACC_D_DATAOUT_ADDR_0_SCR (0)
+#define CACC_D_DATAOUT_ADDR_0_WORD_COUNT (0x1)
+#define CACC_D_DATAOUT_ADDR_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CACC_D_DATAOUT_ADDR_0_RESET_MASK (_MK_MASK_CONST(0xffffffe0))
+#define CACC_D_DATAOUT_ADDR_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CACC_D_DATAOUT_ADDR_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CACC_D_DATAOUT_ADDR_0_READ_MASK (_MK_MASK_CONST(0xffffffe0))
+#define CACC_D_DATAOUT_ADDR_0_WRITE_MASK (_MK_MASK_CONST(0xffffffe0))
+#define CACC_D_DATAOUT_ADDR_0_DATAOUT_ADDR_SHIFT (_MK_SHIFT_CONST(5))
+#define CACC_D_DATAOUT_ADDR_0_DATAOUT_ADDR_FIELD \
+	(_MK_FIELD_CONST(0x7ffffff, CACC_D_DATAOUT_ADDR_0_DATAOUT_ADDR_SHIFT))
+#define CACC_D_DATAOUT_ADDR_0_DATAOUT_ADDR_RANGE (31 : 5)
+#define CACC_D_DATAOUT_ADDR_0_DATAOUT_ADDR_WOFFSET (0x0)
+#define CACC_D_DATAOUT_ADDR_0_DATAOUT_ADDR_DEFAULT (_MK_MASK_CONST(0x0))
+#define CACC_D_DATAOUT_ADDR_0_DATAOUT_ADDR_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffffff))
+#define CACC_D_DATAOUT_ADDR_0_DATAOUT_ADDR_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CACC_D_DATAOUT_ADDR_0_DATAOUT_ADDR_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CACC_D_DATAOUT_ADDR_0_DATAOUT_ADDR_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CACC_D_DATAOUT_ADDR_0_DATAOUT_ADDR_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CACC_D_BATCH_NUMBER_0
+#define CACC_D_BATCH_NUMBER_0 (_MK_ADDR_CONST(0x901c))
+#define CACC_D_BATCH_NUMBER_0_SECURE (0x0)
+#define CACC_D_BATCH_NUMBER_0_DUAL (0x0)
+#define CACC_D_BATCH_NUMBER_0_SCR (0)
+#define CACC_D_BATCH_NUMBER_0_WORD_COUNT (0x1)
+#define CACC_D_BATCH_NUMBER_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CACC_D_BATCH_NUMBER_0_RESET_MASK (_MK_MASK_CONST(0x1f))
+#define CACC_D_BATCH_NUMBER_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CACC_D_BATCH_NUMBER_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CACC_D_BATCH_NUMBER_0_READ_MASK (_MK_MASK_CONST(0x1f))
+#define CACC_D_BATCH_NUMBER_0_WRITE_MASK (_MK_MASK_CONST(0x1f))
+#define CACC_D_BATCH_NUMBER_0_BATCHES_SHIFT (_MK_SHIFT_CONST(0))
+#define CACC_D_BATCH_NUMBER_0_BATCHES_FIELD \
+	(_MK_FIELD_CONST(0x1f, CACC_D_BATCH_NUMBER_0_BATCHES_SHIFT))
+#define CACC_D_BATCH_NUMBER_0_BATCHES_RANGE (4 : 0)
+#define CACC_D_BATCH_NUMBER_0_BATCHES_WOFFSET (0x0)
+#define CACC_D_BATCH_NUMBER_0_BATCHES_DEFAULT (_MK_MASK_CONST(0x0))
+#define CACC_D_BATCH_NUMBER_0_BATCHES_DEFAULT_MASK (_MK_MASK_CONST(0x1f))
+#define CACC_D_BATCH_NUMBER_0_BATCHES_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CACC_D_BATCH_NUMBER_0_BATCHES_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CACC_D_BATCH_NUMBER_0_BATCHES_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CACC_D_BATCH_NUMBER_0_BATCHES_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+// Register CACC_D_LINE_STRIDE_0
+#define CACC_D_LINE_STRIDE_0 (_MK_ADDR_CONST(0x9020))
+#define CACC_D_LINE_STRIDE_0_SECURE (0x0)
+#define CACC_D_LINE_STRIDE_0_DUAL (0x0)
+#define CACC_D_LINE_STRIDE_0_SCR (0)
+#define CACC_D_LINE_STRIDE_0_WORD_COUNT (0x1)
+#define CACC_D_LINE_STRIDE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CACC_D_LINE_STRIDE_0_RESET_MASK (_MK_MASK_CONST(0xffffe0))
+#define CACC_D_LINE_STRIDE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CACC_D_LINE_STRIDE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CACC_D_LINE_STRIDE_0_READ_MASK (_MK_MASK_CONST(0xffffe0))
+#define CACC_D_LINE_STRIDE_0_WRITE_MASK (_MK_MASK_CONST(0xffffe0))
+#define CACC_D_LINE_STRIDE_0_LINE_STRIDE_SHIFT (_MK_SHIFT_CONST(5))
+#define CACC_D_LINE_STRIDE_0_LINE_STRIDE_FIELD \
+	(_MK_FIELD_CONST(0x7ffff, CACC_D_LINE_STRIDE_0_LINE_STRIDE_SHIFT))
+#define CACC_D_LINE_STRIDE_0_LINE_STRIDE_RANGE (23 : 5)
+#define CACC_D_LINE_STRIDE_0_LINE_STRIDE_WOFFSET (0x0)
+#define CACC_D_LINE_STRIDE_0_LINE_STRIDE_DEFAULT (_MK_MASK_CONST(0x0))
+#define CACC_D_LINE_STRIDE_0_LINE_STRIDE_DEFAULT_MASK (_MK_MASK_CONST(0x7ffff))
+#define CACC_D_LINE_STRIDE_0_LINE_STRIDE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CACC_D_LINE_STRIDE_0_LINE_STRIDE_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CACC_D_LINE_STRIDE_0_LINE_STRIDE_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CACC_D_LINE_STRIDE_0_LINE_STRIDE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CACC_D_SURF_STRIDE_0
+#define CACC_D_SURF_STRIDE_0 (_MK_ADDR_CONST(0x9024))
+#define CACC_D_SURF_STRIDE_0_SECURE (0x0)
+#define CACC_D_SURF_STRIDE_0_DUAL (0x0)
+#define CACC_D_SURF_STRIDE_0_SCR (0)
+#define CACC_D_SURF_STRIDE_0_WORD_COUNT (0x1)
+#define CACC_D_SURF_STRIDE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CACC_D_SURF_STRIDE_0_RESET_MASK (_MK_MASK_CONST(0xffffe0))
+#define CACC_D_SURF_STRIDE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CACC_D_SURF_STRIDE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CACC_D_SURF_STRIDE_0_READ_MASK (_MK_MASK_CONST(0xffffe0))
+#define CACC_D_SURF_STRIDE_0_WRITE_MASK (_MK_MASK_CONST(0xffffe0))
+#define CACC_D_SURF_STRIDE_0_SURF_STRIDE_SHIFT (_MK_SHIFT_CONST(5))
+#define CACC_D_SURF_STRIDE_0_SURF_STRIDE_FIELD \
+	(_MK_FIELD_CONST(0x7ffff, CACC_D_SURF_STRIDE_0_SURF_STRIDE_SHIFT))
+#define CACC_D_SURF_STRIDE_0_SURF_STRIDE_RANGE (23 : 5)
+#define CACC_D_SURF_STRIDE_0_SURF_STRIDE_WOFFSET (0x0)
+#define CACC_D_SURF_STRIDE_0_SURF_STRIDE_DEFAULT (_MK_MASK_CONST(0x0))
+#define CACC_D_SURF_STRIDE_0_SURF_STRIDE_DEFAULT_MASK (_MK_MASK_CONST(0x7ffff))
+#define CACC_D_SURF_STRIDE_0_SURF_STRIDE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CACC_D_SURF_STRIDE_0_SURF_STRIDE_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CACC_D_SURF_STRIDE_0_SURF_STRIDE_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CACC_D_SURF_STRIDE_0_SURF_STRIDE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CACC_D_DATAOUT_MAP_0
+#define CACC_D_DATAOUT_MAP_0 (_MK_ADDR_CONST(0x9028))
+#define CACC_D_DATAOUT_MAP_0_SECURE (0x0)
+#define CACC_D_DATAOUT_MAP_0_DUAL (0x0)
+#define CACC_D_DATAOUT_MAP_0_SCR (0)
+#define CACC_D_DATAOUT_MAP_0_WORD_COUNT (0x1)
+#define CACC_D_DATAOUT_MAP_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CACC_D_DATAOUT_MAP_0_RESET_MASK (_MK_MASK_CONST(0x10001))
+#define CACC_D_DATAOUT_MAP_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CACC_D_DATAOUT_MAP_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CACC_D_DATAOUT_MAP_0_READ_MASK (_MK_MASK_CONST(0x10001))
+#define CACC_D_DATAOUT_MAP_0_WRITE_MASK (_MK_MASK_CONST(0x10001))
+#define CACC_D_DATAOUT_MAP_0_LINE_PACKED_SHIFT (_MK_SHIFT_CONST(0))
+#define CACC_D_DATAOUT_MAP_0_LINE_PACKED_FIELD \
+	(_MK_FIELD_CONST(0x1, CACC_D_DATAOUT_MAP_0_LINE_PACKED_SHIFT))
+#define CACC_D_DATAOUT_MAP_0_LINE_PACKED_RANGE (0 : 0)
+#define CACC_D_DATAOUT_MAP_0_LINE_PACKED_WOFFSET (0x0)
+#define CACC_D_DATAOUT_MAP_0_LINE_PACKED_DEFAULT (_MK_MASK_CONST(0x0))
+#define CACC_D_DATAOUT_MAP_0_LINE_PACKED_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CACC_D_DATAOUT_MAP_0_LINE_PACKED_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CACC_D_DATAOUT_MAP_0_LINE_PACKED_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CACC_D_DATAOUT_MAP_0_LINE_PACKED_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CACC_D_DATAOUT_MAP_0_LINE_PACKED_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define CACC_D_DATAOUT_MAP_0_LINE_PACKED_INIT_ENUM (FALSE)
+#define CACC_D_DATAOUT_MAP_0_LINE_PACKED_FALSE (_MK_ENUM_CONST(0))
+#define CACC_D_DATAOUT_MAP_0_LINE_PACKED_TRUE (_MK_ENUM_CONST(1))
+
+#define CACC_D_DATAOUT_MAP_0_SURF_PACKED_SHIFT (_MK_SHIFT_CONST(16))
+#define CACC_D_DATAOUT_MAP_0_SURF_PACKED_FIELD \
+	(_MK_FIELD_CONST(0x1, CACC_D_DATAOUT_MAP_0_SURF_PACKED_SHIFT))
+#define CACC_D_DATAOUT_MAP_0_SURF_PACKED_RANGE (16 : 16)
+#define CACC_D_DATAOUT_MAP_0_SURF_PACKED_WOFFSET (0x0)
+#define CACC_D_DATAOUT_MAP_0_SURF_PACKED_DEFAULT (_MK_MASK_CONST(0x0))
+#define CACC_D_DATAOUT_MAP_0_SURF_PACKED_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CACC_D_DATAOUT_MAP_0_SURF_PACKED_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CACC_D_DATAOUT_MAP_0_SURF_PACKED_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CACC_D_DATAOUT_MAP_0_SURF_PACKED_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CACC_D_DATAOUT_MAP_0_SURF_PACKED_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define CACC_D_DATAOUT_MAP_0_SURF_PACKED_INIT_ENUM (FALSE)
+#define CACC_D_DATAOUT_MAP_0_SURF_PACKED_FALSE (_MK_ENUM_CONST(0))
+#define CACC_D_DATAOUT_MAP_0_SURF_PACKED_TRUE (_MK_ENUM_CONST(1))
+
+// Register CACC_D_CLIP_CFG_0
+#define CACC_D_CLIP_CFG_0 (_MK_ADDR_CONST(0x902c))
+#define CACC_D_CLIP_CFG_0_SECURE (0x0)
+#define CACC_D_CLIP_CFG_0_DUAL (0x0)
+#define CACC_D_CLIP_CFG_0_SCR (0)
+#define CACC_D_CLIP_CFG_0_WORD_COUNT (0x1)
+#define CACC_D_CLIP_CFG_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CACC_D_CLIP_CFG_0_RESET_MASK (_MK_MASK_CONST(0x1f))
+#define CACC_D_CLIP_CFG_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CACC_D_CLIP_CFG_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CACC_D_CLIP_CFG_0_READ_MASK (_MK_MASK_CONST(0x1f))
+#define CACC_D_CLIP_CFG_0_WRITE_MASK (_MK_MASK_CONST(0x1f))
+#define CACC_D_CLIP_CFG_0_CLIP_TRUNCATE_SHIFT (_MK_SHIFT_CONST(0))
+#define CACC_D_CLIP_CFG_0_CLIP_TRUNCATE_FIELD \
+	(_MK_FIELD_CONST(0x1f, CACC_D_CLIP_CFG_0_CLIP_TRUNCATE_SHIFT))
+#define CACC_D_CLIP_CFG_0_CLIP_TRUNCATE_RANGE (4 : 0)
+#define CACC_D_CLIP_CFG_0_CLIP_TRUNCATE_WOFFSET (0x0)
+#define CACC_D_CLIP_CFG_0_CLIP_TRUNCATE_DEFAULT (_MK_MASK_CONST(0x0))
+#define CACC_D_CLIP_CFG_0_CLIP_TRUNCATE_DEFAULT_MASK (_MK_MASK_CONST(0x1f))
+#define CACC_D_CLIP_CFG_0_CLIP_TRUNCATE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CACC_D_CLIP_CFG_0_CLIP_TRUNCATE_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CACC_D_CLIP_CFG_0_CLIP_TRUNCATE_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CACC_D_CLIP_CFG_0_CLIP_TRUNCATE_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+// Register CACC_D_OUT_SATURATION_0
+#define CACC_D_OUT_SATURATION_0 (_MK_ADDR_CONST(0x9030))
+#define CACC_D_OUT_SATURATION_0_SECURE (0x0)
+#define CACC_D_OUT_SATURATION_0_DUAL (0x0)
+#define CACC_D_OUT_SATURATION_0_SCR (0)
+#define CACC_D_OUT_SATURATION_0_WORD_COUNT (0x1)
+#define CACC_D_OUT_SATURATION_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CACC_D_OUT_SATURATION_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define CACC_D_OUT_SATURATION_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CACC_D_OUT_SATURATION_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CACC_D_OUT_SATURATION_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define CACC_D_OUT_SATURATION_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define CACC_D_OUT_SATURATION_0_SAT_COUNT_SHIFT (_MK_SHIFT_CONST(0))
+#define CACC_D_OUT_SATURATION_0_SAT_COUNT_FIELD \
+	(_MK_FIELD_CONST(0xffffffff, CACC_D_OUT_SATURATION_0_SAT_COUNT_SHIFT))
+#define CACC_D_OUT_SATURATION_0_SAT_COUNT_RANGE (31 : 0)
+#define CACC_D_OUT_SATURATION_0_SAT_COUNT_WOFFSET (0x0)
+#define CACC_D_OUT_SATURATION_0_SAT_COUNT_DEFAULT (_MK_MASK_CONST(0x0))
+#define CACC_D_OUT_SATURATION_0_SAT_COUNT_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define CACC_D_OUT_SATURATION_0_SAT_COUNT_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CACC_D_OUT_SATURATION_0_SAT_COUNT_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CACC_D_OUT_SATURATION_0_SAT_COUNT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CACC_D_OUT_SATURATION_0_SAT_COUNT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CACC_D_CYA_0
+#define CACC_D_CYA_0 (_MK_ADDR_CONST(0x9034))
+#define CACC_D_CYA_0_SECURE (0x0)
+#define CACC_D_CYA_0_DUAL (0x0)
+#define CACC_D_CYA_0_SCR (0)
+#define CACC_D_CYA_0_WORD_COUNT (0x1)
+#define CACC_D_CYA_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CACC_D_CYA_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define CACC_D_CYA_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CACC_D_CYA_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CACC_D_CYA_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define CACC_D_CYA_0_WRITE_MASK (_MK_MASK_CONST(0xffffffff))
+#define CACC_D_CYA_0_CYA_SHIFT (_MK_SHIFT_CONST(0))
+#define CACC_D_CYA_0_CYA_FIELD \
+	(_MK_FIELD_CONST(0xffffffff, CACC_D_CYA_0_CYA_SHIFT))
+#define CACC_D_CYA_0_CYA_RANGE (31 : 0)
+#define CACC_D_CYA_0_CYA_WOFFSET (0x0)
+#define CACC_D_CYA_0_CYA_DEFAULT (_MK_MASK_CONST(0x0))
+#define CACC_D_CYA_0_CYA_DEFAULT_MASK (_MK_MASK_CONST(0xffffffff))
+#define CACC_D_CYA_0_CYA_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CACC_D_CYA_0_CYA_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CACC_D_CYA_0_CYA_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CACC_D_CYA_0_CYA_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+// Register SDP_RDMA_S_STATUS_0
+#define SDP_RDMA_S_STATUS_0 (_MK_ADDR_CONST(0xa000))
+#define SDP_RDMA_S_STATUS_0_SECURE (0x0)
+#define SDP_RDMA_S_STATUS_0_DUAL (0x0)
+#define SDP_RDMA_S_STATUS_0_SCR (0)
+#define SDP_RDMA_S_STATUS_0_WORD_COUNT (0x1)
+#define SDP_RDMA_S_STATUS_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_S_STATUS_0_RESET_MASK (_MK_MASK_CONST(0x30003))
+#define SDP_RDMA_S_STATUS_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_S_STATUS_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_S_STATUS_0_READ_MASK (_MK_MASK_CONST(0x30003))
+#define SDP_RDMA_S_STATUS_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_S_STATUS_0_STATUS_0_SHIFT (_MK_SHIFT_CONST(0))
+#define SDP_RDMA_S_STATUS_0_STATUS_0_FIELD \
+	(_MK_FIELD_CONST(0x3, SDP_RDMA_S_STATUS_0_STATUS_0_SHIFT))
+#define SDP_RDMA_S_STATUS_0_STATUS_0_RANGE (1 : 0)
+#define SDP_RDMA_S_STATUS_0_STATUS_0_WOFFSET (0x0)
+#define SDP_RDMA_S_STATUS_0_STATUS_0_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_S_STATUS_0_STATUS_0_DEFAULT_MASK (_MK_MASK_CONST(0x3))
+#define SDP_RDMA_S_STATUS_0_STATUS_0_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_S_STATUS_0_STATUS_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_S_STATUS_0_STATUS_0_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_S_STATUS_0_STATUS_0_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define SDP_RDMA_S_STATUS_0_STATUS_0_INIT_ENUM (IDLE)
+#define SDP_RDMA_S_STATUS_0_STATUS_0_IDLE (_MK_ENUM_CONST(0))
+#define SDP_RDMA_S_STATUS_0_STATUS_0_RUNNING (_MK_ENUM_CONST(1))
+#define SDP_RDMA_S_STATUS_0_STATUS_0_PENDING (_MK_ENUM_CONST(2))
+
+#define SDP_RDMA_S_STATUS_0_STATUS_1_SHIFT (_MK_SHIFT_CONST(16))
+#define SDP_RDMA_S_STATUS_0_STATUS_1_FIELD \
+	(_MK_FIELD_CONST(0x3, SDP_RDMA_S_STATUS_0_STATUS_1_SHIFT))
+#define SDP_RDMA_S_STATUS_0_STATUS_1_RANGE (17 : 16)
+#define SDP_RDMA_S_STATUS_0_STATUS_1_WOFFSET (0x0)
+#define SDP_RDMA_S_STATUS_0_STATUS_1_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_S_STATUS_0_STATUS_1_DEFAULT_MASK (_MK_MASK_CONST(0x3))
+#define SDP_RDMA_S_STATUS_0_STATUS_1_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_S_STATUS_0_STATUS_1_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_S_STATUS_0_STATUS_1_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_S_STATUS_0_STATUS_1_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define SDP_RDMA_S_STATUS_0_STATUS_1_INIT_ENUM (IDLE)
+#define SDP_RDMA_S_STATUS_0_STATUS_1_IDLE (_MK_ENUM_CONST(0))
+#define SDP_RDMA_S_STATUS_0_STATUS_1_RUNNING (_MK_ENUM_CONST(1))
+#define SDP_RDMA_S_STATUS_0_STATUS_1_PENDING (_MK_ENUM_CONST(2))
+
+// Register SDP_RDMA_S_POINTER_0
+#define SDP_RDMA_S_POINTER_0 (_MK_ADDR_CONST(0xa004))
+#define SDP_RDMA_S_POINTER_0_SECURE (0x0)
+#define SDP_RDMA_S_POINTER_0_DUAL (0x0)
+#define SDP_RDMA_S_POINTER_0_SCR (0)
+#define SDP_RDMA_S_POINTER_0_WORD_COUNT (0x1)
+#define SDP_RDMA_S_POINTER_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_S_POINTER_0_RESET_MASK (_MK_MASK_CONST(0x10001))
+#define SDP_RDMA_S_POINTER_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_S_POINTER_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_S_POINTER_0_READ_MASK (_MK_MASK_CONST(0x10001))
+#define SDP_RDMA_S_POINTER_0_WRITE_MASK (_MK_MASK_CONST(0x1))
+#define SDP_RDMA_S_POINTER_0_PRODUCER_SHIFT (_MK_SHIFT_CONST(0))
+#define SDP_RDMA_S_POINTER_0_PRODUCER_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_RDMA_S_POINTER_0_PRODUCER_SHIFT))
+#define SDP_RDMA_S_POINTER_0_PRODUCER_RANGE (0 : 0)
+#define SDP_RDMA_S_POINTER_0_PRODUCER_WOFFSET (0x0)
+#define SDP_RDMA_S_POINTER_0_PRODUCER_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_S_POINTER_0_PRODUCER_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define SDP_RDMA_S_POINTER_0_PRODUCER_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_S_POINTER_0_PRODUCER_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_S_POINTER_0_PRODUCER_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_S_POINTER_0_PRODUCER_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define SDP_RDMA_S_POINTER_0_PRODUCER_INIT_ENUM (GROUP_0)
+#define SDP_RDMA_S_POINTER_0_PRODUCER_GROUP_0 (_MK_ENUM_CONST(0))
+#define SDP_RDMA_S_POINTER_0_PRODUCER_GROUP_1 (_MK_ENUM_CONST(1))
+
+#define SDP_RDMA_S_POINTER_0_CONSUMER_SHIFT (_MK_SHIFT_CONST(16))
+#define SDP_RDMA_S_POINTER_0_CONSUMER_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_RDMA_S_POINTER_0_CONSUMER_SHIFT))
+#define SDP_RDMA_S_POINTER_0_CONSUMER_RANGE (16 : 16)
+#define SDP_RDMA_S_POINTER_0_CONSUMER_WOFFSET (0x0)
+#define SDP_RDMA_S_POINTER_0_CONSUMER_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_S_POINTER_0_CONSUMER_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define SDP_RDMA_S_POINTER_0_CONSUMER_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_S_POINTER_0_CONSUMER_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_S_POINTER_0_CONSUMER_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_S_POINTER_0_CONSUMER_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define SDP_RDMA_S_POINTER_0_CONSUMER_INIT_ENUM (GROUP_0)
+#define SDP_RDMA_S_POINTER_0_CONSUMER_GROUP_0 (_MK_ENUM_CONST(0))
+#define SDP_RDMA_S_POINTER_0_CONSUMER_GROUP_1 (_MK_ENUM_CONST(1))
+
+// Register SDP_RDMA_D_OP_ENABLE_0
+#define SDP_RDMA_D_OP_ENABLE_0 (_MK_ADDR_CONST(0xa008))
+#define SDP_RDMA_D_OP_ENABLE_0_SECURE (0x0)
+#define SDP_RDMA_D_OP_ENABLE_0_DUAL (0x0)
+#define SDP_RDMA_D_OP_ENABLE_0_SCR (0)
+#define SDP_RDMA_D_OP_ENABLE_0_WORD_COUNT (0x1)
+#define SDP_RDMA_D_OP_ENABLE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_OP_ENABLE_0_RESET_MASK (_MK_MASK_CONST(0x1))
+#define SDP_RDMA_D_OP_ENABLE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_OP_ENABLE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_OP_ENABLE_0_READ_MASK (_MK_MASK_CONST(0x1))
+#define SDP_RDMA_D_OP_ENABLE_0_WRITE_MASK (_MK_MASK_CONST(0x1))
+#define SDP_RDMA_D_OP_ENABLE_0_OP_EN_SHIFT (_MK_SHIFT_CONST(0))
+#define SDP_RDMA_D_OP_ENABLE_0_OP_EN_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_RDMA_D_OP_ENABLE_0_OP_EN_SHIFT))
+#define SDP_RDMA_D_OP_ENABLE_0_OP_EN_RANGE (0 : 0)
+#define SDP_RDMA_D_OP_ENABLE_0_OP_EN_WOFFSET (0x0)
+#define SDP_RDMA_D_OP_ENABLE_0_OP_EN_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_OP_ENABLE_0_OP_EN_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define SDP_RDMA_D_OP_ENABLE_0_OP_EN_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_OP_ENABLE_0_OP_EN_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_OP_ENABLE_0_OP_EN_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_OP_ENABLE_0_OP_EN_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define SDP_RDMA_D_OP_ENABLE_0_OP_EN_INIT_ENUM (DISABLE)
+#define SDP_RDMA_D_OP_ENABLE_0_OP_EN_DISABLE (_MK_ENUM_CONST(0))
+#define SDP_RDMA_D_OP_ENABLE_0_OP_EN_ENABLE (_MK_ENUM_CONST(1))
+
+// Register SDP_RDMA_D_DATA_CUBE_WIDTH_0
+#define SDP_RDMA_D_DATA_CUBE_WIDTH_0 (_MK_ADDR_CONST(0xa00c))
+#define SDP_RDMA_D_DATA_CUBE_WIDTH_0_SECURE (0x0)
+#define SDP_RDMA_D_DATA_CUBE_WIDTH_0_DUAL (0x0)
+#define SDP_RDMA_D_DATA_CUBE_WIDTH_0_SCR (0)
+#define SDP_RDMA_D_DATA_CUBE_WIDTH_0_WORD_COUNT (0x1)
+#define SDP_RDMA_D_DATA_CUBE_WIDTH_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_DATA_CUBE_WIDTH_0_RESET_MASK (_MK_MASK_CONST(0x1fff))
+#define SDP_RDMA_D_DATA_CUBE_WIDTH_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_DATA_CUBE_WIDTH_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_DATA_CUBE_WIDTH_0_READ_MASK (_MK_MASK_CONST(0x1fff))
+#define SDP_RDMA_D_DATA_CUBE_WIDTH_0_WRITE_MASK (_MK_MASK_CONST(0x1fff))
+#define SDP_RDMA_D_DATA_CUBE_WIDTH_0_WIDTH_SHIFT (_MK_SHIFT_CONST(0))
+#define SDP_RDMA_D_DATA_CUBE_WIDTH_0_WIDTH_FIELD \
+	(_MK_FIELD_CONST(0x1fff, SDP_RDMA_D_DATA_CUBE_WIDTH_0_WIDTH_SHIFT))
+#define SDP_RDMA_D_DATA_CUBE_WIDTH_0_WIDTH_RANGE (12 : 0)
+#define SDP_RDMA_D_DATA_CUBE_WIDTH_0_WIDTH_WOFFSET (0x0)
+#define SDP_RDMA_D_DATA_CUBE_WIDTH_0_WIDTH_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_DATA_CUBE_WIDTH_0_WIDTH_DEFAULT_MASK (_MK_MASK_CONST(0x1fff))
+#define SDP_RDMA_D_DATA_CUBE_WIDTH_0_WIDTH_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_DATA_CUBE_WIDTH_0_WIDTH_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_DATA_CUBE_WIDTH_0_WIDTH_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_DATA_CUBE_WIDTH_0_WIDTH_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_RDMA_D_DATA_CUBE_HEIGHT_0
+#define SDP_RDMA_D_DATA_CUBE_HEIGHT_0 (_MK_ADDR_CONST(0xa010))
+#define SDP_RDMA_D_DATA_CUBE_HEIGHT_0_SECURE (0x0)
+#define SDP_RDMA_D_DATA_CUBE_HEIGHT_0_DUAL (0x0)
+#define SDP_RDMA_D_DATA_CUBE_HEIGHT_0_SCR (0)
+#define SDP_RDMA_D_DATA_CUBE_HEIGHT_0_WORD_COUNT (0x1)
+#define SDP_RDMA_D_DATA_CUBE_HEIGHT_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_DATA_CUBE_HEIGHT_0_RESET_MASK (_MK_MASK_CONST(0x1fff))
+#define SDP_RDMA_D_DATA_CUBE_HEIGHT_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_DATA_CUBE_HEIGHT_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_DATA_CUBE_HEIGHT_0_READ_MASK (_MK_MASK_CONST(0x1fff))
+#define SDP_RDMA_D_DATA_CUBE_HEIGHT_0_WRITE_MASK (_MK_MASK_CONST(0x1fff))
+#define SDP_RDMA_D_DATA_CUBE_HEIGHT_0_HEIGHT_SHIFT (_MK_SHIFT_CONST(0))
+#define SDP_RDMA_D_DATA_CUBE_HEIGHT_0_HEIGHT_FIELD \
+	(_MK_FIELD_CONST(0x1fff, SDP_RDMA_D_DATA_CUBE_HEIGHT_0_HEIGHT_SHIFT))
+#define SDP_RDMA_D_DATA_CUBE_HEIGHT_0_HEIGHT_RANGE (12 : 0)
+#define SDP_RDMA_D_DATA_CUBE_HEIGHT_0_HEIGHT_WOFFSET (0x0)
+#define SDP_RDMA_D_DATA_CUBE_HEIGHT_0_HEIGHT_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_DATA_CUBE_HEIGHT_0_HEIGHT_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1fff))
+#define SDP_RDMA_D_DATA_CUBE_HEIGHT_0_HEIGHT_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_DATA_CUBE_HEIGHT_0_HEIGHT_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_DATA_CUBE_HEIGHT_0_HEIGHT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_DATA_CUBE_HEIGHT_0_HEIGHT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_RDMA_D_DATA_CUBE_CHANNEL_0
+#define SDP_RDMA_D_DATA_CUBE_CHANNEL_0 (_MK_ADDR_CONST(0xa014))
+#define SDP_RDMA_D_DATA_CUBE_CHANNEL_0_SECURE (0x0)
+#define SDP_RDMA_D_DATA_CUBE_CHANNEL_0_DUAL (0x0)
+#define SDP_RDMA_D_DATA_CUBE_CHANNEL_0_SCR (0)
+#define SDP_RDMA_D_DATA_CUBE_CHANNEL_0_WORD_COUNT (0x1)
+#define SDP_RDMA_D_DATA_CUBE_CHANNEL_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_DATA_CUBE_CHANNEL_0_RESET_MASK (_MK_MASK_CONST(0x1fff))
+#define SDP_RDMA_D_DATA_CUBE_CHANNEL_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_DATA_CUBE_CHANNEL_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_DATA_CUBE_CHANNEL_0_READ_MASK (_MK_MASK_CONST(0x1fff))
+#define SDP_RDMA_D_DATA_CUBE_CHANNEL_0_WRITE_MASK (_MK_MASK_CONST(0x1fff))
+#define SDP_RDMA_D_DATA_CUBE_CHANNEL_0_CHANNEL_SHIFT (_MK_SHIFT_CONST(0))
+#define SDP_RDMA_D_DATA_CUBE_CHANNEL_0_CHANNEL_FIELD \
+	(_MK_FIELD_CONST(0x1fff, SDP_RDMA_D_DATA_CUBE_CHANNEL_0_CHANNEL_SHIFT))
+#define SDP_RDMA_D_DATA_CUBE_CHANNEL_0_CHANNEL_RANGE (12 : 0)
+#define SDP_RDMA_D_DATA_CUBE_CHANNEL_0_CHANNEL_WOFFSET (0x0)
+#define SDP_RDMA_D_DATA_CUBE_CHANNEL_0_CHANNEL_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_DATA_CUBE_CHANNEL_0_CHANNEL_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1fff))
+#define SDP_RDMA_D_DATA_CUBE_CHANNEL_0_CHANNEL_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_DATA_CUBE_CHANNEL_0_CHANNEL_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_DATA_CUBE_CHANNEL_0_CHANNEL_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_DATA_CUBE_CHANNEL_0_CHANNEL_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_RDMA_D_SRC_BASE_ADDR_LOW_0
+#define SDP_RDMA_D_SRC_BASE_ADDR_LOW_0 (_MK_ADDR_CONST(0xa018))
+#define SDP_RDMA_D_SRC_BASE_ADDR_LOW_0_SECURE (0x0)
+#define SDP_RDMA_D_SRC_BASE_ADDR_LOW_0_DUAL (0x0)
+#define SDP_RDMA_D_SRC_BASE_ADDR_LOW_0_SCR (0)
+#define SDP_RDMA_D_SRC_BASE_ADDR_LOW_0_WORD_COUNT (0x1)
+#define SDP_RDMA_D_SRC_BASE_ADDR_LOW_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_SRC_BASE_ADDR_LOW_0_RESET_MASK (_MK_MASK_CONST(0xffffffe0))
+#define SDP_RDMA_D_SRC_BASE_ADDR_LOW_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_SRC_BASE_ADDR_LOW_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_SRC_BASE_ADDR_LOW_0_READ_MASK (_MK_MASK_CONST(0xffffffe0))
+#define SDP_RDMA_D_SRC_BASE_ADDR_LOW_0_WRITE_MASK (_MK_MASK_CONST(0xffffffe0))
+#define SDP_RDMA_D_SRC_BASE_ADDR_LOW_0_SRC_BASE_ADDR_LOW_SHIFT \
+	(_MK_SHIFT_CONST(5))
+#define SDP_RDMA_D_SRC_BASE_ADDR_LOW_0_SRC_BASE_ADDR_LOW_FIELD \
+	(_MK_FIELD_CONST(                                      \
+		0x7ffffff,                                     \
+		SDP_RDMA_D_SRC_BASE_ADDR_LOW_0_SRC_BASE_ADDR_LOW_SHIFT))
+#define SDP_RDMA_D_SRC_BASE_ADDR_LOW_0_SRC_BASE_ADDR_LOW_RANGE (31 : 5)
+#define SDP_RDMA_D_SRC_BASE_ADDR_LOW_0_SRC_BASE_ADDR_LOW_WOFFSET (0x0)
+#define SDP_RDMA_D_SRC_BASE_ADDR_LOW_0_SRC_BASE_ADDR_LOW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_SRC_BASE_ADDR_LOW_0_SRC_BASE_ADDR_LOW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffffff))
+#define SDP_RDMA_D_SRC_BASE_ADDR_LOW_0_SRC_BASE_ADDR_LOW_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_SRC_BASE_ADDR_LOW_0_SRC_BASE_ADDR_LOW_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_SRC_BASE_ADDR_LOW_0_SRC_BASE_ADDR_LOW_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_SRC_BASE_ADDR_LOW_0_SRC_BASE_ADDR_LOW_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_RDMA_D_SRC_BASE_ADDR_HIGH_0
+#define SDP_RDMA_D_SRC_BASE_ADDR_HIGH_0 (_MK_ADDR_CONST(0xa01c))
+#define SDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_SECURE (0x0)
+#define SDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_DUAL (0x0)
+#define SDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_SCR (0)
+#define SDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_WORD_COUNT (0x1)
+#define SDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_WRITE_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_SRC_BASE_ADDR_HIGH_SHIFT \
+	(_MK_SHIFT_CONST(0))
+#define SDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_SRC_BASE_ADDR_HIGH_FIELD \
+	(_MK_FIELD_CONST(                                        \
+		0xffffffff,                                      \
+		SDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_SRC_BASE_ADDR_HIGH_SHIFT))
+#define SDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_SRC_BASE_ADDR_HIGH_RANGE (31 : 0)
+#define SDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_SRC_BASE_ADDR_HIGH_WOFFSET (0x0)
+#define SDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_SRC_BASE_ADDR_HIGH_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_SRC_BASE_ADDR_HIGH_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define SDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_SRC_BASE_ADDR_HIGH_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_SRC_BASE_ADDR_HIGH_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_SRC_BASE_ADDR_HIGH_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_SRC_BASE_ADDR_HIGH_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_RDMA_D_SRC_LINE_STRIDE_0
+#define SDP_RDMA_D_SRC_LINE_STRIDE_0 (_MK_ADDR_CONST(0xa020))
+#define SDP_RDMA_D_SRC_LINE_STRIDE_0_SECURE (0x0)
+#define SDP_RDMA_D_SRC_LINE_STRIDE_0_DUAL (0x0)
+#define SDP_RDMA_D_SRC_LINE_STRIDE_0_SCR (0)
+#define SDP_RDMA_D_SRC_LINE_STRIDE_0_WORD_COUNT (0x1)
+#define SDP_RDMA_D_SRC_LINE_STRIDE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_SRC_LINE_STRIDE_0_RESET_MASK (_MK_MASK_CONST(0xffffffe0))
+#define SDP_RDMA_D_SRC_LINE_STRIDE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_SRC_LINE_STRIDE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_SRC_LINE_STRIDE_0_READ_MASK (_MK_MASK_CONST(0xffffffe0))
+#define SDP_RDMA_D_SRC_LINE_STRIDE_0_WRITE_MASK (_MK_MASK_CONST(0xffffffe0))
+#define SDP_RDMA_D_SRC_LINE_STRIDE_0_SRC_LINE_STRIDE_SHIFT (_MK_SHIFT_CONST(5))
+#define SDP_RDMA_D_SRC_LINE_STRIDE_0_SRC_LINE_STRIDE_FIELD \
+	(_MK_FIELD_CONST(0x7ffffff,                        \
+			 SDP_RDMA_D_SRC_LINE_STRIDE_0_SRC_LINE_STRIDE_SHIFT))
+#define SDP_RDMA_D_SRC_LINE_STRIDE_0_SRC_LINE_STRIDE_RANGE (31 : 5)
+#define SDP_RDMA_D_SRC_LINE_STRIDE_0_SRC_LINE_STRIDE_WOFFSET (0x0)
+#define SDP_RDMA_D_SRC_LINE_STRIDE_0_SRC_LINE_STRIDE_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_SRC_LINE_STRIDE_0_SRC_LINE_STRIDE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffffff))
+#define SDP_RDMA_D_SRC_LINE_STRIDE_0_SRC_LINE_STRIDE_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_SRC_LINE_STRIDE_0_SRC_LINE_STRIDE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_SRC_LINE_STRIDE_0_SRC_LINE_STRIDE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_SRC_LINE_STRIDE_0_SRC_LINE_STRIDE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_RDMA_D_SRC_SURFACE_STRIDE_0
+#define SDP_RDMA_D_SRC_SURFACE_STRIDE_0 (_MK_ADDR_CONST(0xa024))
+#define SDP_RDMA_D_SRC_SURFACE_STRIDE_0_SECURE (0x0)
+#define SDP_RDMA_D_SRC_SURFACE_STRIDE_0_DUAL (0x0)
+#define SDP_RDMA_D_SRC_SURFACE_STRIDE_0_SCR (0)
+#define SDP_RDMA_D_SRC_SURFACE_STRIDE_0_WORD_COUNT (0x1)
+#define SDP_RDMA_D_SRC_SURFACE_STRIDE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_SRC_SURFACE_STRIDE_0_RESET_MASK (_MK_MASK_CONST(0xffffffe0))
+#define SDP_RDMA_D_SRC_SURFACE_STRIDE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_SRC_SURFACE_STRIDE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_SRC_SURFACE_STRIDE_0_READ_MASK (_MK_MASK_CONST(0xffffffe0))
+#define SDP_RDMA_D_SRC_SURFACE_STRIDE_0_WRITE_MASK (_MK_MASK_CONST(0xffffffe0))
+#define SDP_RDMA_D_SRC_SURFACE_STRIDE_0_SRC_SURFACE_STRIDE_SHIFT \
+	(_MK_SHIFT_CONST(5))
+#define SDP_RDMA_D_SRC_SURFACE_STRIDE_0_SRC_SURFACE_STRIDE_FIELD \
+	(_MK_FIELD_CONST(                                        \
+		0x7ffffff,                                       \
+		SDP_RDMA_D_SRC_SURFACE_STRIDE_0_SRC_SURFACE_STRIDE_SHIFT))
+#define SDP_RDMA_D_SRC_SURFACE_STRIDE_0_SRC_SURFACE_STRIDE_RANGE (31 : 5)
+#define SDP_RDMA_D_SRC_SURFACE_STRIDE_0_SRC_SURFACE_STRIDE_WOFFSET (0x0)
+#define SDP_RDMA_D_SRC_SURFACE_STRIDE_0_SRC_SURFACE_STRIDE_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_SRC_SURFACE_STRIDE_0_SRC_SURFACE_STRIDE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffffff))
+#define SDP_RDMA_D_SRC_SURFACE_STRIDE_0_SRC_SURFACE_STRIDE_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_SRC_SURFACE_STRIDE_0_SRC_SURFACE_STRIDE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_SRC_SURFACE_STRIDE_0_SRC_SURFACE_STRIDE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_SRC_SURFACE_STRIDE_0_SRC_SURFACE_STRIDE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_RDMA_D_BRDMA_CFG_0
+#define SDP_RDMA_D_BRDMA_CFG_0 (_MK_ADDR_CONST(0xa028))
+#define SDP_RDMA_D_BRDMA_CFG_0_SECURE (0x0)
+#define SDP_RDMA_D_BRDMA_CFG_0_DUAL (0x0)
+#define SDP_RDMA_D_BRDMA_CFG_0_SCR (0)
+#define SDP_RDMA_D_BRDMA_CFG_0_WORD_COUNT (0x1)
+#define SDP_RDMA_D_BRDMA_CFG_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BRDMA_CFG_0_RESET_MASK (_MK_MASK_CONST(0x3f))
+#define SDP_RDMA_D_BRDMA_CFG_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BRDMA_CFG_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BRDMA_CFG_0_READ_MASK (_MK_MASK_CONST(0x3f))
+#define SDP_RDMA_D_BRDMA_CFG_0_WRITE_MASK (_MK_MASK_CONST(0x3f))
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_DISABLE_SHIFT (_MK_SHIFT_CONST(0))
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_DISABLE_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_RDMA_D_BRDMA_CFG_0_BRDMA_DISABLE_SHIFT))
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_DISABLE_RANGE (0 : 0)
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_DISABLE_WOFFSET (0x0)
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_DISABLE_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_DISABLE_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_DISABLE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_DISABLE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_DISABLE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_DISABLE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_DISABLE_NO (_MK_ENUM_CONST(0))
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_DISABLE_YES (_MK_ENUM_CONST(1))
+
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_DATA_USE_SHIFT (_MK_SHIFT_CONST(1))
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_DATA_USE_FIELD \
+	(_MK_FIELD_CONST(0x3, SDP_RDMA_D_BRDMA_CFG_0_BRDMA_DATA_USE_SHIFT))
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_DATA_USE_RANGE (2 : 1)
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_DATA_USE_WOFFSET (0x0)
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_DATA_USE_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_DATA_USE_DEFAULT_MASK (_MK_MASK_CONST(0x3))
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_DATA_USE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_DATA_USE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_DATA_USE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_DATA_USE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_DATA_USE_MUL (_MK_ENUM_CONST(0))
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_DATA_USE_ALU (_MK_ENUM_CONST(1))
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_DATA_USE_BOTH (_MK_ENUM_CONST(2))
+
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_DATA_SIZE_SHIFT (_MK_SHIFT_CONST(3))
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_DATA_SIZE_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_RDMA_D_BRDMA_CFG_0_BRDMA_DATA_SIZE_SHIFT))
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_DATA_SIZE_RANGE (3 : 3)
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_DATA_SIZE_WOFFSET (0x0)
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_DATA_SIZE_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_DATA_SIZE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1))
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_DATA_SIZE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_DATA_SIZE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_DATA_SIZE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_DATA_SIZE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_DATA_SIZE_ONE_BYTE (_MK_ENUM_CONST(0))
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_DATA_SIZE_TWO_BYTE (_MK_ENUM_CONST(1))
+
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_DATA_MODE_SHIFT (_MK_SHIFT_CONST(4))
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_DATA_MODE_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_RDMA_D_BRDMA_CFG_0_BRDMA_DATA_MODE_SHIFT))
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_DATA_MODE_RANGE (4 : 4)
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_DATA_MODE_WOFFSET (0x0)
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_DATA_MODE_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_DATA_MODE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1))
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_DATA_MODE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_DATA_MODE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_DATA_MODE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_DATA_MODE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_DATA_MODE_PER_KERNEL (_MK_ENUM_CONST(0))
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_DATA_MODE_PER_ELEMENT (_MK_ENUM_CONST(1))
+
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_RAM_TYPE_SHIFT (_MK_SHIFT_CONST(5))
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_RAM_TYPE_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_RDMA_D_BRDMA_CFG_0_BRDMA_RAM_TYPE_SHIFT))
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_RAM_TYPE_RANGE (5 : 5)
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_RAM_TYPE_WOFFSET (0x0)
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_RAM_TYPE_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_RAM_TYPE_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_RAM_TYPE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_RAM_TYPE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_RAM_TYPE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_RAM_TYPE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_RAM_TYPE_CV (_MK_ENUM_CONST(0))
+#define SDP_RDMA_D_BRDMA_CFG_0_BRDMA_RAM_TYPE_MC (_MK_ENUM_CONST(1))
+
+// Register SDP_RDMA_D_BS_BASE_ADDR_LOW_0
+#define SDP_RDMA_D_BS_BASE_ADDR_LOW_0 (_MK_ADDR_CONST(0xa02c))
+#define SDP_RDMA_D_BS_BASE_ADDR_LOW_0_SECURE (0x0)
+#define SDP_RDMA_D_BS_BASE_ADDR_LOW_0_DUAL (0x0)
+#define SDP_RDMA_D_BS_BASE_ADDR_LOW_0_SCR (0)
+#define SDP_RDMA_D_BS_BASE_ADDR_LOW_0_WORD_COUNT (0x1)
+#define SDP_RDMA_D_BS_BASE_ADDR_LOW_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BS_BASE_ADDR_LOW_0_RESET_MASK (_MK_MASK_CONST(0xffffffe0))
+#define SDP_RDMA_D_BS_BASE_ADDR_LOW_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BS_BASE_ADDR_LOW_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BS_BASE_ADDR_LOW_0_READ_MASK (_MK_MASK_CONST(0xffffffe0))
+#define SDP_RDMA_D_BS_BASE_ADDR_LOW_0_WRITE_MASK (_MK_MASK_CONST(0xffffffe0))
+#define SDP_RDMA_D_BS_BASE_ADDR_LOW_0_BS_BASE_ADDR_LOW_SHIFT \
+	(_MK_SHIFT_CONST(5))
+#define SDP_RDMA_D_BS_BASE_ADDR_LOW_0_BS_BASE_ADDR_LOW_FIELD \
+	(_MK_FIELD_CONST(0x7ffffff,                          \
+			 SDP_RDMA_D_BS_BASE_ADDR_LOW_0_BS_BASE_ADDR_LOW_SHIFT))
+#define SDP_RDMA_D_BS_BASE_ADDR_LOW_0_BS_BASE_ADDR_LOW_RANGE (31 : 5)
+#define SDP_RDMA_D_BS_BASE_ADDR_LOW_0_BS_BASE_ADDR_LOW_WOFFSET (0x0)
+#define SDP_RDMA_D_BS_BASE_ADDR_LOW_0_BS_BASE_ADDR_LOW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BS_BASE_ADDR_LOW_0_BS_BASE_ADDR_LOW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffffff))
+#define SDP_RDMA_D_BS_BASE_ADDR_LOW_0_BS_BASE_ADDR_LOW_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BS_BASE_ADDR_LOW_0_BS_BASE_ADDR_LOW_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BS_BASE_ADDR_LOW_0_BS_BASE_ADDR_LOW_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BS_BASE_ADDR_LOW_0_BS_BASE_ADDR_LOW_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_RDMA_D_BS_BASE_ADDR_HIGH_0
+#define SDP_RDMA_D_BS_BASE_ADDR_HIGH_0 (_MK_ADDR_CONST(0xa030))
+#define SDP_RDMA_D_BS_BASE_ADDR_HIGH_0_SECURE (0x0)
+#define SDP_RDMA_D_BS_BASE_ADDR_HIGH_0_DUAL (0x0)
+#define SDP_RDMA_D_BS_BASE_ADDR_HIGH_0_SCR (0)
+#define SDP_RDMA_D_BS_BASE_ADDR_HIGH_0_WORD_COUNT (0x1)
+#define SDP_RDMA_D_BS_BASE_ADDR_HIGH_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BS_BASE_ADDR_HIGH_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_RDMA_D_BS_BASE_ADDR_HIGH_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BS_BASE_ADDR_HIGH_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BS_BASE_ADDR_HIGH_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_RDMA_D_BS_BASE_ADDR_HIGH_0_WRITE_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_RDMA_D_BS_BASE_ADDR_HIGH_0_BS_BASE_ADDR_HIGH_SHIFT \
+	(_MK_SHIFT_CONST(0))
+#define SDP_RDMA_D_BS_BASE_ADDR_HIGH_0_BS_BASE_ADDR_HIGH_FIELD \
+	(_MK_FIELD_CONST(                                      \
+		0xffffffff,                                    \
+		SDP_RDMA_D_BS_BASE_ADDR_HIGH_0_BS_BASE_ADDR_HIGH_SHIFT))
+#define SDP_RDMA_D_BS_BASE_ADDR_HIGH_0_BS_BASE_ADDR_HIGH_RANGE (31 : 0)
+#define SDP_RDMA_D_BS_BASE_ADDR_HIGH_0_BS_BASE_ADDR_HIGH_WOFFSET (0x0)
+#define SDP_RDMA_D_BS_BASE_ADDR_HIGH_0_BS_BASE_ADDR_HIGH_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BS_BASE_ADDR_HIGH_0_BS_BASE_ADDR_HIGH_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define SDP_RDMA_D_BS_BASE_ADDR_HIGH_0_BS_BASE_ADDR_HIGH_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BS_BASE_ADDR_HIGH_0_BS_BASE_ADDR_HIGH_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BS_BASE_ADDR_HIGH_0_BS_BASE_ADDR_HIGH_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BS_BASE_ADDR_HIGH_0_BS_BASE_ADDR_HIGH_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_RDMA_D_BS_LINE_STRIDE_0
+#define SDP_RDMA_D_BS_LINE_STRIDE_0 (_MK_ADDR_CONST(0xa034))
+#define SDP_RDMA_D_BS_LINE_STRIDE_0_SECURE (0x0)
+#define SDP_RDMA_D_BS_LINE_STRIDE_0_DUAL (0x0)
+#define SDP_RDMA_D_BS_LINE_STRIDE_0_SCR (0)
+#define SDP_RDMA_D_BS_LINE_STRIDE_0_WORD_COUNT (0x1)
+#define SDP_RDMA_D_BS_LINE_STRIDE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BS_LINE_STRIDE_0_RESET_MASK (_MK_MASK_CONST(0xffffffe0))
+#define SDP_RDMA_D_BS_LINE_STRIDE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BS_LINE_STRIDE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BS_LINE_STRIDE_0_READ_MASK (_MK_MASK_CONST(0xffffffe0))
+#define SDP_RDMA_D_BS_LINE_STRIDE_0_WRITE_MASK (_MK_MASK_CONST(0xffffffe0))
+#define SDP_RDMA_D_BS_LINE_STRIDE_0_BS_LINE_STRIDE_SHIFT (_MK_SHIFT_CONST(5))
+#define SDP_RDMA_D_BS_LINE_STRIDE_0_BS_LINE_STRIDE_FIELD \
+	(_MK_FIELD_CONST(0x7ffffff,                      \
+			 SDP_RDMA_D_BS_LINE_STRIDE_0_BS_LINE_STRIDE_SHIFT))
+#define SDP_RDMA_D_BS_LINE_STRIDE_0_BS_LINE_STRIDE_RANGE (31 : 5)
+#define SDP_RDMA_D_BS_LINE_STRIDE_0_BS_LINE_STRIDE_WOFFSET (0x0)
+#define SDP_RDMA_D_BS_LINE_STRIDE_0_BS_LINE_STRIDE_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BS_LINE_STRIDE_0_BS_LINE_STRIDE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffffff))
+#define SDP_RDMA_D_BS_LINE_STRIDE_0_BS_LINE_STRIDE_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BS_LINE_STRIDE_0_BS_LINE_STRIDE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BS_LINE_STRIDE_0_BS_LINE_STRIDE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BS_LINE_STRIDE_0_BS_LINE_STRIDE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_RDMA_D_BS_SURFACE_STRIDE_0
+#define SDP_RDMA_D_BS_SURFACE_STRIDE_0 (_MK_ADDR_CONST(0xa038))
+#define SDP_RDMA_D_BS_SURFACE_STRIDE_0_SECURE (0x0)
+#define SDP_RDMA_D_BS_SURFACE_STRIDE_0_DUAL (0x0)
+#define SDP_RDMA_D_BS_SURFACE_STRIDE_0_SCR (0)
+#define SDP_RDMA_D_BS_SURFACE_STRIDE_0_WORD_COUNT (0x1)
+#define SDP_RDMA_D_BS_SURFACE_STRIDE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BS_SURFACE_STRIDE_0_RESET_MASK (_MK_MASK_CONST(0xffffffe0))
+#define SDP_RDMA_D_BS_SURFACE_STRIDE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BS_SURFACE_STRIDE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BS_SURFACE_STRIDE_0_READ_MASK (_MK_MASK_CONST(0xffffffe0))
+#define SDP_RDMA_D_BS_SURFACE_STRIDE_0_WRITE_MASK (_MK_MASK_CONST(0xffffffe0))
+#define SDP_RDMA_D_BS_SURFACE_STRIDE_0_BS_SURFACE_STRIDE_SHIFT \
+	(_MK_SHIFT_CONST(5))
+#define SDP_RDMA_D_BS_SURFACE_STRIDE_0_BS_SURFACE_STRIDE_FIELD \
+	(_MK_FIELD_CONST(                                      \
+		0x7ffffff,                                     \
+		SDP_RDMA_D_BS_SURFACE_STRIDE_0_BS_SURFACE_STRIDE_SHIFT))
+#define SDP_RDMA_D_BS_SURFACE_STRIDE_0_BS_SURFACE_STRIDE_RANGE (31 : 5)
+#define SDP_RDMA_D_BS_SURFACE_STRIDE_0_BS_SURFACE_STRIDE_WOFFSET (0x0)
+#define SDP_RDMA_D_BS_SURFACE_STRIDE_0_BS_SURFACE_STRIDE_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BS_SURFACE_STRIDE_0_BS_SURFACE_STRIDE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffffff))
+#define SDP_RDMA_D_BS_SURFACE_STRIDE_0_BS_SURFACE_STRIDE_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BS_SURFACE_STRIDE_0_BS_SURFACE_STRIDE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BS_SURFACE_STRIDE_0_BS_SURFACE_STRIDE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BS_SURFACE_STRIDE_0_BS_SURFACE_STRIDE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_RDMA_D_BS_BATCH_STRIDE_0
+#define SDP_RDMA_D_BS_BATCH_STRIDE_0 (_MK_ADDR_CONST(0xa03c))
+#define SDP_RDMA_D_BS_BATCH_STRIDE_0_SECURE (0x0)
+#define SDP_RDMA_D_BS_BATCH_STRIDE_0_DUAL (0x0)
+#define SDP_RDMA_D_BS_BATCH_STRIDE_0_SCR (0)
+#define SDP_RDMA_D_BS_BATCH_STRIDE_0_WORD_COUNT (0x1)
+#define SDP_RDMA_D_BS_BATCH_STRIDE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BS_BATCH_STRIDE_0_RESET_MASK (_MK_MASK_CONST(0xffffffe0))
+#define SDP_RDMA_D_BS_BATCH_STRIDE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BS_BATCH_STRIDE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BS_BATCH_STRIDE_0_READ_MASK (_MK_MASK_CONST(0xffffffe0))
+#define SDP_RDMA_D_BS_BATCH_STRIDE_0_WRITE_MASK (_MK_MASK_CONST(0xffffffe0))
+#define SDP_RDMA_D_BS_BATCH_STRIDE_0_BS_BATCH_STRIDE_SHIFT (_MK_SHIFT_CONST(5))
+#define SDP_RDMA_D_BS_BATCH_STRIDE_0_BS_BATCH_STRIDE_FIELD \
+	(_MK_FIELD_CONST(0x7ffffff,                        \
+			 SDP_RDMA_D_BS_BATCH_STRIDE_0_BS_BATCH_STRIDE_SHIFT))
+#define SDP_RDMA_D_BS_BATCH_STRIDE_0_BS_BATCH_STRIDE_RANGE (31 : 5)
+#define SDP_RDMA_D_BS_BATCH_STRIDE_0_BS_BATCH_STRIDE_WOFFSET (0x0)
+#define SDP_RDMA_D_BS_BATCH_STRIDE_0_BS_BATCH_STRIDE_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BS_BATCH_STRIDE_0_BS_BATCH_STRIDE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffffff))
+#define SDP_RDMA_D_BS_BATCH_STRIDE_0_BS_BATCH_STRIDE_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BS_BATCH_STRIDE_0_BS_BATCH_STRIDE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BS_BATCH_STRIDE_0_BS_BATCH_STRIDE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BS_BATCH_STRIDE_0_BS_BATCH_STRIDE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_RDMA_D_NRDMA_CFG_0
+#define SDP_RDMA_D_NRDMA_CFG_0 (_MK_ADDR_CONST(0xa040))
+#define SDP_RDMA_D_NRDMA_CFG_0_SECURE (0x0)
+#define SDP_RDMA_D_NRDMA_CFG_0_DUAL (0x0)
+#define SDP_RDMA_D_NRDMA_CFG_0_SCR (0)
+#define SDP_RDMA_D_NRDMA_CFG_0_WORD_COUNT (0x1)
+#define SDP_RDMA_D_NRDMA_CFG_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_NRDMA_CFG_0_RESET_MASK (_MK_MASK_CONST(0x3f))
+#define SDP_RDMA_D_NRDMA_CFG_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_NRDMA_CFG_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_NRDMA_CFG_0_READ_MASK (_MK_MASK_CONST(0x3f))
+#define SDP_RDMA_D_NRDMA_CFG_0_WRITE_MASK (_MK_MASK_CONST(0x3f))
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_DISABLE_SHIFT (_MK_SHIFT_CONST(0))
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_DISABLE_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_RDMA_D_NRDMA_CFG_0_NRDMA_DISABLE_SHIFT))
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_DISABLE_RANGE (0 : 0)
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_DISABLE_WOFFSET (0x0)
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_DISABLE_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_DISABLE_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_DISABLE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_DISABLE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_DISABLE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_DISABLE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_DISABLE_NO (_MK_ENUM_CONST(0))
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_DISABLE_YES (_MK_ENUM_CONST(1))
+
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_DATA_USE_SHIFT (_MK_SHIFT_CONST(1))
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_DATA_USE_FIELD \
+	(_MK_FIELD_CONST(0x3, SDP_RDMA_D_NRDMA_CFG_0_NRDMA_DATA_USE_SHIFT))
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_DATA_USE_RANGE (2 : 1)
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_DATA_USE_WOFFSET (0x0)
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_DATA_USE_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_DATA_USE_DEFAULT_MASK (_MK_MASK_CONST(0x3))
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_DATA_USE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_DATA_USE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_DATA_USE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_DATA_USE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_DATA_USE_MUL (_MK_ENUM_CONST(0))
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_DATA_USE_ALU (_MK_ENUM_CONST(1))
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_DATA_USE_BOTH (_MK_ENUM_CONST(2))
+
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_DATA_SIZE_SHIFT (_MK_SHIFT_CONST(3))
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_DATA_SIZE_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_RDMA_D_NRDMA_CFG_0_NRDMA_DATA_SIZE_SHIFT))
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_DATA_SIZE_RANGE (3 : 3)
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_DATA_SIZE_WOFFSET (0x0)
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_DATA_SIZE_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_DATA_SIZE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1))
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_DATA_SIZE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_DATA_SIZE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_DATA_SIZE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_DATA_SIZE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_DATA_SIZE_ONE_BYTE (_MK_ENUM_CONST(0))
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_DATA_SIZE_TWO_BYTE (_MK_ENUM_CONST(1))
+
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_DATA_MODE_SHIFT (_MK_SHIFT_CONST(4))
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_DATA_MODE_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_RDMA_D_NRDMA_CFG_0_NRDMA_DATA_MODE_SHIFT))
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_DATA_MODE_RANGE (4 : 4)
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_DATA_MODE_WOFFSET (0x0)
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_DATA_MODE_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_DATA_MODE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1))
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_DATA_MODE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_DATA_MODE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_DATA_MODE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_DATA_MODE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_DATA_MODE_PER_KERNEL (_MK_ENUM_CONST(0))
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_DATA_MODE_PER_ELEMENT (_MK_ENUM_CONST(1))
+
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_RAM_TYPE_SHIFT (_MK_SHIFT_CONST(5))
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_RAM_TYPE_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_RDMA_D_NRDMA_CFG_0_NRDMA_RAM_TYPE_SHIFT))
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_RAM_TYPE_RANGE (5 : 5)
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_RAM_TYPE_WOFFSET (0x0)
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_RAM_TYPE_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_RAM_TYPE_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_RAM_TYPE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_RAM_TYPE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_RAM_TYPE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_RAM_TYPE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_RAM_TYPE_CV (_MK_ENUM_CONST(0))
+#define SDP_RDMA_D_NRDMA_CFG_0_NRDMA_RAM_TYPE_MC (_MK_ENUM_CONST(1))
+
+// Register SDP_RDMA_D_BN_BASE_ADDR_LOW_0
+#define SDP_RDMA_D_BN_BASE_ADDR_LOW_0 (_MK_ADDR_CONST(0xa044))
+#define SDP_RDMA_D_BN_BASE_ADDR_LOW_0_SECURE (0x0)
+#define SDP_RDMA_D_BN_BASE_ADDR_LOW_0_DUAL (0x0)
+#define SDP_RDMA_D_BN_BASE_ADDR_LOW_0_SCR (0)
+#define SDP_RDMA_D_BN_BASE_ADDR_LOW_0_WORD_COUNT (0x1)
+#define SDP_RDMA_D_BN_BASE_ADDR_LOW_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BN_BASE_ADDR_LOW_0_RESET_MASK (_MK_MASK_CONST(0xffffffe0))
+#define SDP_RDMA_D_BN_BASE_ADDR_LOW_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BN_BASE_ADDR_LOW_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BN_BASE_ADDR_LOW_0_READ_MASK (_MK_MASK_CONST(0xffffffe0))
+#define SDP_RDMA_D_BN_BASE_ADDR_LOW_0_WRITE_MASK (_MK_MASK_CONST(0xffffffe0))
+#define SDP_RDMA_D_BN_BASE_ADDR_LOW_0_BN_BASE_ADDR_LOW_SHIFT \
+	(_MK_SHIFT_CONST(5))
+#define SDP_RDMA_D_BN_BASE_ADDR_LOW_0_BN_BASE_ADDR_LOW_FIELD \
+	(_MK_FIELD_CONST(0x7ffffff,                          \
+			 SDP_RDMA_D_BN_BASE_ADDR_LOW_0_BN_BASE_ADDR_LOW_SHIFT))
+#define SDP_RDMA_D_BN_BASE_ADDR_LOW_0_BN_BASE_ADDR_LOW_RANGE (31 : 5)
+#define SDP_RDMA_D_BN_BASE_ADDR_LOW_0_BN_BASE_ADDR_LOW_WOFFSET (0x0)
+#define SDP_RDMA_D_BN_BASE_ADDR_LOW_0_BN_BASE_ADDR_LOW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BN_BASE_ADDR_LOW_0_BN_BASE_ADDR_LOW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffffff))
+#define SDP_RDMA_D_BN_BASE_ADDR_LOW_0_BN_BASE_ADDR_LOW_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BN_BASE_ADDR_LOW_0_BN_BASE_ADDR_LOW_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BN_BASE_ADDR_LOW_0_BN_BASE_ADDR_LOW_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BN_BASE_ADDR_LOW_0_BN_BASE_ADDR_LOW_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_RDMA_D_BN_BASE_ADDR_HIGH_0
+#define SDP_RDMA_D_BN_BASE_ADDR_HIGH_0 (_MK_ADDR_CONST(0xa048))
+#define SDP_RDMA_D_BN_BASE_ADDR_HIGH_0_SECURE (0x0)
+#define SDP_RDMA_D_BN_BASE_ADDR_HIGH_0_DUAL (0x0)
+#define SDP_RDMA_D_BN_BASE_ADDR_HIGH_0_SCR (0)
+#define SDP_RDMA_D_BN_BASE_ADDR_HIGH_0_WORD_COUNT (0x1)
+#define SDP_RDMA_D_BN_BASE_ADDR_HIGH_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BN_BASE_ADDR_HIGH_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_RDMA_D_BN_BASE_ADDR_HIGH_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BN_BASE_ADDR_HIGH_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BN_BASE_ADDR_HIGH_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_RDMA_D_BN_BASE_ADDR_HIGH_0_WRITE_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_RDMA_D_BN_BASE_ADDR_HIGH_0_BN_BASE_ADDR_HIGH_SHIFT \
+	(_MK_SHIFT_CONST(0))
+#define SDP_RDMA_D_BN_BASE_ADDR_HIGH_0_BN_BASE_ADDR_HIGH_FIELD \
+	(_MK_FIELD_CONST(                                      \
+		0xffffffff,                                    \
+		SDP_RDMA_D_BN_BASE_ADDR_HIGH_0_BN_BASE_ADDR_HIGH_SHIFT))
+#define SDP_RDMA_D_BN_BASE_ADDR_HIGH_0_BN_BASE_ADDR_HIGH_RANGE (31 : 0)
+#define SDP_RDMA_D_BN_BASE_ADDR_HIGH_0_BN_BASE_ADDR_HIGH_WOFFSET (0x0)
+#define SDP_RDMA_D_BN_BASE_ADDR_HIGH_0_BN_BASE_ADDR_HIGH_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BN_BASE_ADDR_HIGH_0_BN_BASE_ADDR_HIGH_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define SDP_RDMA_D_BN_BASE_ADDR_HIGH_0_BN_BASE_ADDR_HIGH_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BN_BASE_ADDR_HIGH_0_BN_BASE_ADDR_HIGH_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BN_BASE_ADDR_HIGH_0_BN_BASE_ADDR_HIGH_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BN_BASE_ADDR_HIGH_0_BN_BASE_ADDR_HIGH_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_RDMA_D_BN_LINE_STRIDE_0
+#define SDP_RDMA_D_BN_LINE_STRIDE_0 (_MK_ADDR_CONST(0xa04c))
+#define SDP_RDMA_D_BN_LINE_STRIDE_0_SECURE (0x0)
+#define SDP_RDMA_D_BN_LINE_STRIDE_0_DUAL (0x0)
+#define SDP_RDMA_D_BN_LINE_STRIDE_0_SCR (0)
+#define SDP_RDMA_D_BN_LINE_STRIDE_0_WORD_COUNT (0x1)
+#define SDP_RDMA_D_BN_LINE_STRIDE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BN_LINE_STRIDE_0_RESET_MASK (_MK_MASK_CONST(0xffffffe0))
+#define SDP_RDMA_D_BN_LINE_STRIDE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BN_LINE_STRIDE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BN_LINE_STRIDE_0_READ_MASK (_MK_MASK_CONST(0xffffffe0))
+#define SDP_RDMA_D_BN_LINE_STRIDE_0_WRITE_MASK (_MK_MASK_CONST(0xffffffe0))
+#define SDP_RDMA_D_BN_LINE_STRIDE_0_BN_LINE_STRIDE_SHIFT (_MK_SHIFT_CONST(5))
+#define SDP_RDMA_D_BN_LINE_STRIDE_0_BN_LINE_STRIDE_FIELD \
+	(_MK_FIELD_CONST(0x7ffffff,                      \
+			 SDP_RDMA_D_BN_LINE_STRIDE_0_BN_LINE_STRIDE_SHIFT))
+#define SDP_RDMA_D_BN_LINE_STRIDE_0_BN_LINE_STRIDE_RANGE (31 : 5)
+#define SDP_RDMA_D_BN_LINE_STRIDE_0_BN_LINE_STRIDE_WOFFSET (0x0)
+#define SDP_RDMA_D_BN_LINE_STRIDE_0_BN_LINE_STRIDE_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BN_LINE_STRIDE_0_BN_LINE_STRIDE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffffff))
+#define SDP_RDMA_D_BN_LINE_STRIDE_0_BN_LINE_STRIDE_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BN_LINE_STRIDE_0_BN_LINE_STRIDE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BN_LINE_STRIDE_0_BN_LINE_STRIDE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BN_LINE_STRIDE_0_BN_LINE_STRIDE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_RDMA_D_BN_SURFACE_STRIDE_0
+#define SDP_RDMA_D_BN_SURFACE_STRIDE_0 (_MK_ADDR_CONST(0xa050))
+#define SDP_RDMA_D_BN_SURFACE_STRIDE_0_SECURE (0x0)
+#define SDP_RDMA_D_BN_SURFACE_STRIDE_0_DUAL (0x0)
+#define SDP_RDMA_D_BN_SURFACE_STRIDE_0_SCR (0)
+#define SDP_RDMA_D_BN_SURFACE_STRIDE_0_WORD_COUNT (0x1)
+#define SDP_RDMA_D_BN_SURFACE_STRIDE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BN_SURFACE_STRIDE_0_RESET_MASK (_MK_MASK_CONST(0xffffffe0))
+#define SDP_RDMA_D_BN_SURFACE_STRIDE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BN_SURFACE_STRIDE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BN_SURFACE_STRIDE_0_READ_MASK (_MK_MASK_CONST(0xffffffe0))
+#define SDP_RDMA_D_BN_SURFACE_STRIDE_0_WRITE_MASK (_MK_MASK_CONST(0xffffffe0))
+#define SDP_RDMA_D_BN_SURFACE_STRIDE_0_BN_SURFACE_STRIDE_SHIFT \
+	(_MK_SHIFT_CONST(5))
+#define SDP_RDMA_D_BN_SURFACE_STRIDE_0_BN_SURFACE_STRIDE_FIELD \
+	(_MK_FIELD_CONST(                                      \
+		0x7ffffff,                                     \
+		SDP_RDMA_D_BN_SURFACE_STRIDE_0_BN_SURFACE_STRIDE_SHIFT))
+#define SDP_RDMA_D_BN_SURFACE_STRIDE_0_BN_SURFACE_STRIDE_RANGE (31 : 5)
+#define SDP_RDMA_D_BN_SURFACE_STRIDE_0_BN_SURFACE_STRIDE_WOFFSET (0x0)
+#define SDP_RDMA_D_BN_SURFACE_STRIDE_0_BN_SURFACE_STRIDE_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BN_SURFACE_STRIDE_0_BN_SURFACE_STRIDE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffffff))
+#define SDP_RDMA_D_BN_SURFACE_STRIDE_0_BN_SURFACE_STRIDE_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BN_SURFACE_STRIDE_0_BN_SURFACE_STRIDE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BN_SURFACE_STRIDE_0_BN_SURFACE_STRIDE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BN_SURFACE_STRIDE_0_BN_SURFACE_STRIDE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_RDMA_D_BN_BATCH_STRIDE_0
+#define SDP_RDMA_D_BN_BATCH_STRIDE_0 (_MK_ADDR_CONST(0xa054))
+#define SDP_RDMA_D_BN_BATCH_STRIDE_0_SECURE (0x0)
+#define SDP_RDMA_D_BN_BATCH_STRIDE_0_DUAL (0x0)
+#define SDP_RDMA_D_BN_BATCH_STRIDE_0_SCR (0)
+#define SDP_RDMA_D_BN_BATCH_STRIDE_0_WORD_COUNT (0x1)
+#define SDP_RDMA_D_BN_BATCH_STRIDE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BN_BATCH_STRIDE_0_RESET_MASK (_MK_MASK_CONST(0xffffffe0))
+#define SDP_RDMA_D_BN_BATCH_STRIDE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BN_BATCH_STRIDE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BN_BATCH_STRIDE_0_READ_MASK (_MK_MASK_CONST(0xffffffe0))
+#define SDP_RDMA_D_BN_BATCH_STRIDE_0_WRITE_MASK (_MK_MASK_CONST(0xffffffe0))
+#define SDP_RDMA_D_BN_BATCH_STRIDE_0_BN_BATCH_STRIDE_SHIFT (_MK_SHIFT_CONST(5))
+#define SDP_RDMA_D_BN_BATCH_STRIDE_0_BN_BATCH_STRIDE_FIELD \
+	(_MK_FIELD_CONST(0x7ffffff,                        \
+			 SDP_RDMA_D_BN_BATCH_STRIDE_0_BN_BATCH_STRIDE_SHIFT))
+#define SDP_RDMA_D_BN_BATCH_STRIDE_0_BN_BATCH_STRIDE_RANGE (31 : 5)
+#define SDP_RDMA_D_BN_BATCH_STRIDE_0_BN_BATCH_STRIDE_WOFFSET (0x0)
+#define SDP_RDMA_D_BN_BATCH_STRIDE_0_BN_BATCH_STRIDE_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BN_BATCH_STRIDE_0_BN_BATCH_STRIDE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffffff))
+#define SDP_RDMA_D_BN_BATCH_STRIDE_0_BN_BATCH_STRIDE_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BN_BATCH_STRIDE_0_BN_BATCH_STRIDE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BN_BATCH_STRIDE_0_BN_BATCH_STRIDE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_BN_BATCH_STRIDE_0_BN_BATCH_STRIDE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_RDMA_D_ERDMA_CFG_0
+#define SDP_RDMA_D_ERDMA_CFG_0 (_MK_ADDR_CONST(0xa058))
+#define SDP_RDMA_D_ERDMA_CFG_0_SECURE (0x0)
+#define SDP_RDMA_D_ERDMA_CFG_0_DUAL (0x0)
+#define SDP_RDMA_D_ERDMA_CFG_0_SCR (0)
+#define SDP_RDMA_D_ERDMA_CFG_0_WORD_COUNT (0x1)
+#define SDP_RDMA_D_ERDMA_CFG_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_ERDMA_CFG_0_RESET_MASK (_MK_MASK_CONST(0x3f))
+#define SDP_RDMA_D_ERDMA_CFG_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_ERDMA_CFG_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_ERDMA_CFG_0_READ_MASK (_MK_MASK_CONST(0x3f))
+#define SDP_RDMA_D_ERDMA_CFG_0_WRITE_MASK (_MK_MASK_CONST(0x3f))
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_DISABLE_SHIFT (_MK_SHIFT_CONST(0))
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_DISABLE_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_RDMA_D_ERDMA_CFG_0_ERDMA_DISABLE_SHIFT))
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_DISABLE_RANGE (0 : 0)
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_DISABLE_WOFFSET (0x0)
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_DISABLE_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_DISABLE_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_DISABLE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_DISABLE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_DISABLE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_DISABLE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_DISABLE_NO (_MK_ENUM_CONST(0))
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_DISABLE_YES (_MK_ENUM_CONST(1))
+
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_DATA_USE_SHIFT (_MK_SHIFT_CONST(1))
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_DATA_USE_FIELD \
+	(_MK_FIELD_CONST(0x3, SDP_RDMA_D_ERDMA_CFG_0_ERDMA_DATA_USE_SHIFT))
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_DATA_USE_RANGE (2 : 1)
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_DATA_USE_WOFFSET (0x0)
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_DATA_USE_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_DATA_USE_DEFAULT_MASK (_MK_MASK_CONST(0x3))
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_DATA_USE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_DATA_USE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_DATA_USE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_DATA_USE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_DATA_USE_MUL (_MK_ENUM_CONST(0))
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_DATA_USE_ALU (_MK_ENUM_CONST(1))
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_DATA_USE_BOTH (_MK_ENUM_CONST(2))
+
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_DATA_SIZE_SHIFT (_MK_SHIFT_CONST(3))
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_DATA_SIZE_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_RDMA_D_ERDMA_CFG_0_ERDMA_DATA_SIZE_SHIFT))
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_DATA_SIZE_RANGE (3 : 3)
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_DATA_SIZE_WOFFSET (0x0)
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_DATA_SIZE_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_DATA_SIZE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1))
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_DATA_SIZE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_DATA_SIZE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_DATA_SIZE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_DATA_SIZE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_DATA_SIZE_ONE_BYTE (_MK_ENUM_CONST(0))
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_DATA_SIZE_TWO_BYTE (_MK_ENUM_CONST(1))
+
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_DATA_MODE_SHIFT (_MK_SHIFT_CONST(4))
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_DATA_MODE_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_RDMA_D_ERDMA_CFG_0_ERDMA_DATA_MODE_SHIFT))
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_DATA_MODE_RANGE (4 : 4)
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_DATA_MODE_WOFFSET (0x0)
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_DATA_MODE_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_DATA_MODE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1))
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_DATA_MODE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_DATA_MODE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_DATA_MODE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_DATA_MODE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_DATA_MODE_PER_KERNEL (_MK_ENUM_CONST(0))
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_DATA_MODE_PER_ELEMENT (_MK_ENUM_CONST(1))
+
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_RAM_TYPE_SHIFT (_MK_SHIFT_CONST(5))
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_RAM_TYPE_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_RDMA_D_ERDMA_CFG_0_ERDMA_RAM_TYPE_SHIFT))
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_RAM_TYPE_RANGE (5 : 5)
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_RAM_TYPE_WOFFSET (0x0)
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_RAM_TYPE_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_RAM_TYPE_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_RAM_TYPE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_RAM_TYPE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_RAM_TYPE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_RAM_TYPE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_RAM_TYPE_CV (_MK_ENUM_CONST(0))
+#define SDP_RDMA_D_ERDMA_CFG_0_ERDMA_RAM_TYPE_MC (_MK_ENUM_CONST(1))
+
+// Register SDP_RDMA_D_EW_BASE_ADDR_LOW_0
+#define SDP_RDMA_D_EW_BASE_ADDR_LOW_0 (_MK_ADDR_CONST(0xa05c))
+#define SDP_RDMA_D_EW_BASE_ADDR_LOW_0_SECURE (0x0)
+#define SDP_RDMA_D_EW_BASE_ADDR_LOW_0_DUAL (0x0)
+#define SDP_RDMA_D_EW_BASE_ADDR_LOW_0_SCR (0)
+#define SDP_RDMA_D_EW_BASE_ADDR_LOW_0_WORD_COUNT (0x1)
+#define SDP_RDMA_D_EW_BASE_ADDR_LOW_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_EW_BASE_ADDR_LOW_0_RESET_MASK (_MK_MASK_CONST(0xffffffe0))
+#define SDP_RDMA_D_EW_BASE_ADDR_LOW_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_EW_BASE_ADDR_LOW_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_EW_BASE_ADDR_LOW_0_READ_MASK (_MK_MASK_CONST(0xffffffe0))
+#define SDP_RDMA_D_EW_BASE_ADDR_LOW_0_WRITE_MASK (_MK_MASK_CONST(0xffffffe0))
+#define SDP_RDMA_D_EW_BASE_ADDR_LOW_0_EW_BASE_ADDR_LOW_SHIFT \
+	(_MK_SHIFT_CONST(5))
+#define SDP_RDMA_D_EW_BASE_ADDR_LOW_0_EW_BASE_ADDR_LOW_FIELD \
+	(_MK_FIELD_CONST(0x7ffffff,                          \
+			 SDP_RDMA_D_EW_BASE_ADDR_LOW_0_EW_BASE_ADDR_LOW_SHIFT))
+#define SDP_RDMA_D_EW_BASE_ADDR_LOW_0_EW_BASE_ADDR_LOW_RANGE (31 : 5)
+#define SDP_RDMA_D_EW_BASE_ADDR_LOW_0_EW_BASE_ADDR_LOW_WOFFSET (0x0)
+#define SDP_RDMA_D_EW_BASE_ADDR_LOW_0_EW_BASE_ADDR_LOW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_EW_BASE_ADDR_LOW_0_EW_BASE_ADDR_LOW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffffff))
+#define SDP_RDMA_D_EW_BASE_ADDR_LOW_0_EW_BASE_ADDR_LOW_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_EW_BASE_ADDR_LOW_0_EW_BASE_ADDR_LOW_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_EW_BASE_ADDR_LOW_0_EW_BASE_ADDR_LOW_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_EW_BASE_ADDR_LOW_0_EW_BASE_ADDR_LOW_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_RDMA_D_EW_BASE_ADDR_HIGH_0
+#define SDP_RDMA_D_EW_BASE_ADDR_HIGH_0 (_MK_ADDR_CONST(0xa060))
+#define SDP_RDMA_D_EW_BASE_ADDR_HIGH_0_SECURE (0x0)
+#define SDP_RDMA_D_EW_BASE_ADDR_HIGH_0_DUAL (0x0)
+#define SDP_RDMA_D_EW_BASE_ADDR_HIGH_0_SCR (0)
+#define SDP_RDMA_D_EW_BASE_ADDR_HIGH_0_WORD_COUNT (0x1)
+#define SDP_RDMA_D_EW_BASE_ADDR_HIGH_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_EW_BASE_ADDR_HIGH_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_RDMA_D_EW_BASE_ADDR_HIGH_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_EW_BASE_ADDR_HIGH_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_EW_BASE_ADDR_HIGH_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_RDMA_D_EW_BASE_ADDR_HIGH_0_WRITE_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_RDMA_D_EW_BASE_ADDR_HIGH_0_EW_BASE_ADDR_HIGH_SHIFT \
+	(_MK_SHIFT_CONST(0))
+#define SDP_RDMA_D_EW_BASE_ADDR_HIGH_0_EW_BASE_ADDR_HIGH_FIELD \
+	(_MK_FIELD_CONST(                                      \
+		0xffffffff,                                    \
+		SDP_RDMA_D_EW_BASE_ADDR_HIGH_0_EW_BASE_ADDR_HIGH_SHIFT))
+#define SDP_RDMA_D_EW_BASE_ADDR_HIGH_0_EW_BASE_ADDR_HIGH_RANGE (31 : 0)
+#define SDP_RDMA_D_EW_BASE_ADDR_HIGH_0_EW_BASE_ADDR_HIGH_WOFFSET (0x0)
+#define SDP_RDMA_D_EW_BASE_ADDR_HIGH_0_EW_BASE_ADDR_HIGH_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_EW_BASE_ADDR_HIGH_0_EW_BASE_ADDR_HIGH_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define SDP_RDMA_D_EW_BASE_ADDR_HIGH_0_EW_BASE_ADDR_HIGH_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_EW_BASE_ADDR_HIGH_0_EW_BASE_ADDR_HIGH_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_EW_BASE_ADDR_HIGH_0_EW_BASE_ADDR_HIGH_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_EW_BASE_ADDR_HIGH_0_EW_BASE_ADDR_HIGH_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_RDMA_D_EW_LINE_STRIDE_0
+#define SDP_RDMA_D_EW_LINE_STRIDE_0 (_MK_ADDR_CONST(0xa064))
+#define SDP_RDMA_D_EW_LINE_STRIDE_0_SECURE (0x0)
+#define SDP_RDMA_D_EW_LINE_STRIDE_0_DUAL (0x0)
+#define SDP_RDMA_D_EW_LINE_STRIDE_0_SCR (0)
+#define SDP_RDMA_D_EW_LINE_STRIDE_0_WORD_COUNT (0x1)
+#define SDP_RDMA_D_EW_LINE_STRIDE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_EW_LINE_STRIDE_0_RESET_MASK (_MK_MASK_CONST(0xffffffe0))
+#define SDP_RDMA_D_EW_LINE_STRIDE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_EW_LINE_STRIDE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_EW_LINE_STRIDE_0_READ_MASK (_MK_MASK_CONST(0xffffffe0))
+#define SDP_RDMA_D_EW_LINE_STRIDE_0_WRITE_MASK (_MK_MASK_CONST(0xffffffe0))
+#define SDP_RDMA_D_EW_LINE_STRIDE_0_EW_LINE_STRIDE_SHIFT (_MK_SHIFT_CONST(5))
+#define SDP_RDMA_D_EW_LINE_STRIDE_0_EW_LINE_STRIDE_FIELD \
+	(_MK_FIELD_CONST(0x7ffffff,                      \
+			 SDP_RDMA_D_EW_LINE_STRIDE_0_EW_LINE_STRIDE_SHIFT))
+#define SDP_RDMA_D_EW_LINE_STRIDE_0_EW_LINE_STRIDE_RANGE (31 : 5)
+#define SDP_RDMA_D_EW_LINE_STRIDE_0_EW_LINE_STRIDE_WOFFSET (0x0)
+#define SDP_RDMA_D_EW_LINE_STRIDE_0_EW_LINE_STRIDE_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_EW_LINE_STRIDE_0_EW_LINE_STRIDE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffffff))
+#define SDP_RDMA_D_EW_LINE_STRIDE_0_EW_LINE_STRIDE_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_EW_LINE_STRIDE_0_EW_LINE_STRIDE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_EW_LINE_STRIDE_0_EW_LINE_STRIDE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_EW_LINE_STRIDE_0_EW_LINE_STRIDE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_RDMA_D_EW_SURFACE_STRIDE_0
+#define SDP_RDMA_D_EW_SURFACE_STRIDE_0 (_MK_ADDR_CONST(0xa068))
+#define SDP_RDMA_D_EW_SURFACE_STRIDE_0_SECURE (0x0)
+#define SDP_RDMA_D_EW_SURFACE_STRIDE_0_DUAL (0x0)
+#define SDP_RDMA_D_EW_SURFACE_STRIDE_0_SCR (0)
+#define SDP_RDMA_D_EW_SURFACE_STRIDE_0_WORD_COUNT (0x1)
+#define SDP_RDMA_D_EW_SURFACE_STRIDE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_EW_SURFACE_STRIDE_0_RESET_MASK (_MK_MASK_CONST(0xffffffe0))
+#define SDP_RDMA_D_EW_SURFACE_STRIDE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_EW_SURFACE_STRIDE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_EW_SURFACE_STRIDE_0_READ_MASK (_MK_MASK_CONST(0xffffffe0))
+#define SDP_RDMA_D_EW_SURFACE_STRIDE_0_WRITE_MASK (_MK_MASK_CONST(0xffffffe0))
+#define SDP_RDMA_D_EW_SURFACE_STRIDE_0_EW_SURFACE_STRIDE_SHIFT \
+	(_MK_SHIFT_CONST(5))
+#define SDP_RDMA_D_EW_SURFACE_STRIDE_0_EW_SURFACE_STRIDE_FIELD \
+	(_MK_FIELD_CONST(                                      \
+		0x7ffffff,                                     \
+		SDP_RDMA_D_EW_SURFACE_STRIDE_0_EW_SURFACE_STRIDE_SHIFT))
+#define SDP_RDMA_D_EW_SURFACE_STRIDE_0_EW_SURFACE_STRIDE_RANGE (31 : 5)
+#define SDP_RDMA_D_EW_SURFACE_STRIDE_0_EW_SURFACE_STRIDE_WOFFSET (0x0)
+#define SDP_RDMA_D_EW_SURFACE_STRIDE_0_EW_SURFACE_STRIDE_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_EW_SURFACE_STRIDE_0_EW_SURFACE_STRIDE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffffff))
+#define SDP_RDMA_D_EW_SURFACE_STRIDE_0_EW_SURFACE_STRIDE_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_EW_SURFACE_STRIDE_0_EW_SURFACE_STRIDE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_EW_SURFACE_STRIDE_0_EW_SURFACE_STRIDE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_EW_SURFACE_STRIDE_0_EW_SURFACE_STRIDE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_RDMA_D_EW_BATCH_STRIDE_0
+#define SDP_RDMA_D_EW_BATCH_STRIDE_0 (_MK_ADDR_CONST(0xa06c))
+#define SDP_RDMA_D_EW_BATCH_STRIDE_0_SECURE (0x0)
+#define SDP_RDMA_D_EW_BATCH_STRIDE_0_DUAL (0x0)
+#define SDP_RDMA_D_EW_BATCH_STRIDE_0_SCR (0)
+#define SDP_RDMA_D_EW_BATCH_STRIDE_0_WORD_COUNT (0x1)
+#define SDP_RDMA_D_EW_BATCH_STRIDE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_EW_BATCH_STRIDE_0_RESET_MASK (_MK_MASK_CONST(0xffffffe0))
+#define SDP_RDMA_D_EW_BATCH_STRIDE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_EW_BATCH_STRIDE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_EW_BATCH_STRIDE_0_READ_MASK (_MK_MASK_CONST(0xffffffe0))
+#define SDP_RDMA_D_EW_BATCH_STRIDE_0_WRITE_MASK (_MK_MASK_CONST(0xffffffe0))
+#define SDP_RDMA_D_EW_BATCH_STRIDE_0_EW_BATCH_STRIDE_SHIFT (_MK_SHIFT_CONST(5))
+#define SDP_RDMA_D_EW_BATCH_STRIDE_0_EW_BATCH_STRIDE_FIELD \
+	(_MK_FIELD_CONST(0x7ffffff,                        \
+			 SDP_RDMA_D_EW_BATCH_STRIDE_0_EW_BATCH_STRIDE_SHIFT))
+#define SDP_RDMA_D_EW_BATCH_STRIDE_0_EW_BATCH_STRIDE_RANGE (31 : 5)
+#define SDP_RDMA_D_EW_BATCH_STRIDE_0_EW_BATCH_STRIDE_WOFFSET (0x0)
+#define SDP_RDMA_D_EW_BATCH_STRIDE_0_EW_BATCH_STRIDE_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_EW_BATCH_STRIDE_0_EW_BATCH_STRIDE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffffff))
+#define SDP_RDMA_D_EW_BATCH_STRIDE_0_EW_BATCH_STRIDE_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_EW_BATCH_STRIDE_0_EW_BATCH_STRIDE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_EW_BATCH_STRIDE_0_EW_BATCH_STRIDE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_EW_BATCH_STRIDE_0_EW_BATCH_STRIDE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_RDMA_D_FEATURE_MODE_CFG_0
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0 (_MK_ADDR_CONST(0xa070))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_SECURE (0x0)
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_DUAL (0x0)
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_SCR (0)
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_WORD_COUNT (0x1)
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_RESET_VAL (_MK_MASK_CONST(0x14))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_RESET_MASK (_MK_MASK_CONST(0x1fff))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_READ_MASK (_MK_MASK_CONST(0x1fff))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_WRITE_MASK (_MK_MASK_CONST(0x1fff))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_FLYING_MODE_SHIFT (_MK_SHIFT_CONST(0))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_FLYING_MODE_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_RDMA_D_FEATURE_MODE_CFG_0_FLYING_MODE_SHIFT))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_FLYING_MODE_RANGE (0 : 0)
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_FLYING_MODE_WOFFSET (0x0)
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_FLYING_MODE_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_FLYING_MODE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_FLYING_MODE_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_FLYING_MODE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_FLYING_MODE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_FLYING_MODE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_FLYING_MODE_OFF (_MK_ENUM_CONST(0))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_FLYING_MODE_ON (_MK_ENUM_CONST(1))
+
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_WINOGRAD_SHIFT (_MK_SHIFT_CONST(1))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_WINOGRAD_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_RDMA_D_FEATURE_MODE_CFG_0_WINOGRAD_SHIFT))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_WINOGRAD_RANGE (1 : 1)
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_WINOGRAD_WOFFSET (0x0)
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_WINOGRAD_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_WINOGRAD_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_WINOGRAD_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_WINOGRAD_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_WINOGRAD_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_WINOGRAD_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_WINOGRAD_OFF (_MK_ENUM_CONST(0))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_WINOGRAD_ON (_MK_ENUM_CONST(1))
+
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_IN_PRECISION_SHIFT (_MK_SHIFT_CONST(2))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_IN_PRECISION_FIELD \
+	(_MK_FIELD_CONST(0x3, SDP_RDMA_D_FEATURE_MODE_CFG_0_IN_PRECISION_SHIFT))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_IN_PRECISION_RANGE (3 : 2)
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_IN_PRECISION_WOFFSET (0x0)
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_IN_PRECISION_DEFAULT (_MK_MASK_CONST(0x1))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_IN_PRECISION_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x3))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_IN_PRECISION_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_IN_PRECISION_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_IN_PRECISION_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_IN_PRECISION_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_IN_PRECISION_INT8 (_MK_ENUM_CONST(0))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_IN_PRECISION_INT16 (_MK_ENUM_CONST(1))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_IN_PRECISION_FP16 (_MK_ENUM_CONST(2))
+
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_PROC_PRECISION_SHIFT (_MK_SHIFT_CONST(4))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_PROC_PRECISION_FIELD \
+	(_MK_FIELD_CONST(0x3,                              \
+			 SDP_RDMA_D_FEATURE_MODE_CFG_0_PROC_PRECISION_SHIFT))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_PROC_PRECISION_RANGE (5 : 4)
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_PROC_PRECISION_WOFFSET (0x0)
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_PROC_PRECISION_DEFAULT \
+	(_MK_MASK_CONST(0x1))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_PROC_PRECISION_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x3))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_PROC_PRECISION_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_PROC_PRECISION_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_PROC_PRECISION_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_PROC_PRECISION_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_PROC_PRECISION_INT8 (_MK_ENUM_CONST(0))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_PROC_PRECISION_INT16 (_MK_ENUM_CONST(1))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_PROC_PRECISION_FP16 (_MK_ENUM_CONST(2))
+
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_OUT_PRECISION_SHIFT (_MK_SHIFT_CONST(6))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_OUT_PRECISION_FIELD \
+	(_MK_FIELD_CONST(0x3,                             \
+			 SDP_RDMA_D_FEATURE_MODE_CFG_0_OUT_PRECISION_SHIFT))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_OUT_PRECISION_RANGE (7 : 6)
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_OUT_PRECISION_WOFFSET (0x0)
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_OUT_PRECISION_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_OUT_PRECISION_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x3))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_OUT_PRECISION_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_OUT_PRECISION_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_OUT_PRECISION_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_OUT_PRECISION_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_OUT_PRECISION_INT8 (_MK_ENUM_CONST(0))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_OUT_PRECISION_INT16 (_MK_ENUM_CONST(1))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_OUT_PRECISION_FP16 (_MK_ENUM_CONST(2))
+
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_BATCH_NUMBER_SHIFT (_MK_SHIFT_CONST(8))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_BATCH_NUMBER_FIELD \
+	(_MK_FIELD_CONST(0x1f,                           \
+			 SDP_RDMA_D_FEATURE_MODE_CFG_0_BATCH_NUMBER_SHIFT))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_BATCH_NUMBER_RANGE (12 : 8)
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_BATCH_NUMBER_WOFFSET (0x0)
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_BATCH_NUMBER_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_BATCH_NUMBER_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1f))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_BATCH_NUMBER_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_BATCH_NUMBER_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_BATCH_NUMBER_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_FEATURE_MODE_CFG_0_BATCH_NUMBER_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_RDMA_D_SRC_DMA_CFG_0
+#define SDP_RDMA_D_SRC_DMA_CFG_0 (_MK_ADDR_CONST(0xa074))
+#define SDP_RDMA_D_SRC_DMA_CFG_0_SECURE (0x0)
+#define SDP_RDMA_D_SRC_DMA_CFG_0_DUAL (0x0)
+#define SDP_RDMA_D_SRC_DMA_CFG_0_SCR (0)
+#define SDP_RDMA_D_SRC_DMA_CFG_0_WORD_COUNT (0x1)
+#define SDP_RDMA_D_SRC_DMA_CFG_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_SRC_DMA_CFG_0_RESET_MASK (_MK_MASK_CONST(0x1))
+#define SDP_RDMA_D_SRC_DMA_CFG_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_SRC_DMA_CFG_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_SRC_DMA_CFG_0_READ_MASK (_MK_MASK_CONST(0x1))
+#define SDP_RDMA_D_SRC_DMA_CFG_0_WRITE_MASK (_MK_MASK_CONST(0x1))
+#define SDP_RDMA_D_SRC_DMA_CFG_0_SRC_RAM_TYPE_SHIFT (_MK_SHIFT_CONST(0))
+#define SDP_RDMA_D_SRC_DMA_CFG_0_SRC_RAM_TYPE_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_RDMA_D_SRC_DMA_CFG_0_SRC_RAM_TYPE_SHIFT))
+#define SDP_RDMA_D_SRC_DMA_CFG_0_SRC_RAM_TYPE_RANGE (0 : 0)
+#define SDP_RDMA_D_SRC_DMA_CFG_0_SRC_RAM_TYPE_WOFFSET (0x0)
+#define SDP_RDMA_D_SRC_DMA_CFG_0_SRC_RAM_TYPE_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_SRC_DMA_CFG_0_SRC_RAM_TYPE_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define SDP_RDMA_D_SRC_DMA_CFG_0_SRC_RAM_TYPE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_SRC_DMA_CFG_0_SRC_RAM_TYPE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_SRC_DMA_CFG_0_SRC_RAM_TYPE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_SRC_DMA_CFG_0_SRC_RAM_TYPE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define SDP_RDMA_D_SRC_DMA_CFG_0_SRC_RAM_TYPE_CV (_MK_ENUM_CONST(0))
+#define SDP_RDMA_D_SRC_DMA_CFG_0_SRC_RAM_TYPE_MC (_MK_ENUM_CONST(1))
+
+// Register SDP_RDMA_D_STATUS_NAN_INPUT_NUM_0
+#define SDP_RDMA_D_STATUS_NAN_INPUT_NUM_0 (_MK_ADDR_CONST(0xa078))
+#define SDP_RDMA_D_STATUS_NAN_INPUT_NUM_0_SECURE (0x0)
+#define SDP_RDMA_D_STATUS_NAN_INPUT_NUM_0_DUAL (0x0)
+#define SDP_RDMA_D_STATUS_NAN_INPUT_NUM_0_SCR (0)
+#define SDP_RDMA_D_STATUS_NAN_INPUT_NUM_0_WORD_COUNT (0x1)
+#define SDP_RDMA_D_STATUS_NAN_INPUT_NUM_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_STATUS_NAN_INPUT_NUM_0_RESET_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define SDP_RDMA_D_STATUS_NAN_INPUT_NUM_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_STATUS_NAN_INPUT_NUM_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_STATUS_NAN_INPUT_NUM_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_RDMA_D_STATUS_NAN_INPUT_NUM_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_STATUS_NAN_INPUT_NUM_0_STATUS_NAN_INPUT_NUM_SHIFT \
+	(_MK_SHIFT_CONST(0))
+#define SDP_RDMA_D_STATUS_NAN_INPUT_NUM_0_STATUS_NAN_INPUT_NUM_FIELD \
+	(_MK_FIELD_CONST(                                            \
+		0xffffffff,                                          \
+		SDP_RDMA_D_STATUS_NAN_INPUT_NUM_0_STATUS_NAN_INPUT_NUM_SHIFT))
+#define SDP_RDMA_D_STATUS_NAN_INPUT_NUM_0_STATUS_NAN_INPUT_NUM_RANGE (31 : 0)
+#define SDP_RDMA_D_STATUS_NAN_INPUT_NUM_0_STATUS_NAN_INPUT_NUM_WOFFSET (0x0)
+#define SDP_RDMA_D_STATUS_NAN_INPUT_NUM_0_STATUS_NAN_INPUT_NUM_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_STATUS_NAN_INPUT_NUM_0_STATUS_NAN_INPUT_NUM_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define SDP_RDMA_D_STATUS_NAN_INPUT_NUM_0_STATUS_NAN_INPUT_NUM_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_STATUS_NAN_INPUT_NUM_0_STATUS_NAN_INPUT_NUM_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_STATUS_NAN_INPUT_NUM_0_STATUS_NAN_INPUT_NUM_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_STATUS_NAN_INPUT_NUM_0_STATUS_NAN_INPUT_NUM_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_RDMA_D_STATUS_INF_INPUT_NUM_0
+#define SDP_RDMA_D_STATUS_INF_INPUT_NUM_0 (_MK_ADDR_CONST(0xa07c))
+#define SDP_RDMA_D_STATUS_INF_INPUT_NUM_0_SECURE (0x0)
+#define SDP_RDMA_D_STATUS_INF_INPUT_NUM_0_DUAL (0x0)
+#define SDP_RDMA_D_STATUS_INF_INPUT_NUM_0_SCR (0)
+#define SDP_RDMA_D_STATUS_INF_INPUT_NUM_0_WORD_COUNT (0x1)
+#define SDP_RDMA_D_STATUS_INF_INPUT_NUM_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_STATUS_INF_INPUT_NUM_0_RESET_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define SDP_RDMA_D_STATUS_INF_INPUT_NUM_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_STATUS_INF_INPUT_NUM_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_STATUS_INF_INPUT_NUM_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_RDMA_D_STATUS_INF_INPUT_NUM_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_STATUS_INF_INPUT_NUM_0_STATUS_INF_INPUT_NUM_SHIFT \
+	(_MK_SHIFT_CONST(0))
+#define SDP_RDMA_D_STATUS_INF_INPUT_NUM_0_STATUS_INF_INPUT_NUM_FIELD \
+	(_MK_FIELD_CONST(                                            \
+		0xffffffff,                                          \
+		SDP_RDMA_D_STATUS_INF_INPUT_NUM_0_STATUS_INF_INPUT_NUM_SHIFT))
+#define SDP_RDMA_D_STATUS_INF_INPUT_NUM_0_STATUS_INF_INPUT_NUM_RANGE (31 : 0)
+#define SDP_RDMA_D_STATUS_INF_INPUT_NUM_0_STATUS_INF_INPUT_NUM_WOFFSET (0x0)
+#define SDP_RDMA_D_STATUS_INF_INPUT_NUM_0_STATUS_INF_INPUT_NUM_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_STATUS_INF_INPUT_NUM_0_STATUS_INF_INPUT_NUM_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define SDP_RDMA_D_STATUS_INF_INPUT_NUM_0_STATUS_INF_INPUT_NUM_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_STATUS_INF_INPUT_NUM_0_STATUS_INF_INPUT_NUM_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_STATUS_INF_INPUT_NUM_0_STATUS_INF_INPUT_NUM_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_STATUS_INF_INPUT_NUM_0_STATUS_INF_INPUT_NUM_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_RDMA_D_PERF_ENABLE_0
+#define SDP_RDMA_D_PERF_ENABLE_0 (_MK_ADDR_CONST(0xa080))
+#define SDP_RDMA_D_PERF_ENABLE_0_SECURE (0x0)
+#define SDP_RDMA_D_PERF_ENABLE_0_DUAL (0x0)
+#define SDP_RDMA_D_PERF_ENABLE_0_SCR (0)
+#define SDP_RDMA_D_PERF_ENABLE_0_WORD_COUNT (0x1)
+#define SDP_RDMA_D_PERF_ENABLE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_PERF_ENABLE_0_RESET_MASK (_MK_MASK_CONST(0x3))
+#define SDP_RDMA_D_PERF_ENABLE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_PERF_ENABLE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_PERF_ENABLE_0_READ_MASK (_MK_MASK_CONST(0x3))
+#define SDP_RDMA_D_PERF_ENABLE_0_WRITE_MASK (_MK_MASK_CONST(0x3))
+#define SDP_RDMA_D_PERF_ENABLE_0_PERF_DMA_EN_SHIFT (_MK_SHIFT_CONST(0))
+#define SDP_RDMA_D_PERF_ENABLE_0_PERF_DMA_EN_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_RDMA_D_PERF_ENABLE_0_PERF_DMA_EN_SHIFT))
+#define SDP_RDMA_D_PERF_ENABLE_0_PERF_DMA_EN_RANGE (0 : 0)
+#define SDP_RDMA_D_PERF_ENABLE_0_PERF_DMA_EN_WOFFSET (0x0)
+#define SDP_RDMA_D_PERF_ENABLE_0_PERF_DMA_EN_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_PERF_ENABLE_0_PERF_DMA_EN_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define SDP_RDMA_D_PERF_ENABLE_0_PERF_DMA_EN_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_PERF_ENABLE_0_PERF_DMA_EN_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_PERF_ENABLE_0_PERF_DMA_EN_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_PERF_ENABLE_0_PERF_DMA_EN_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define SDP_RDMA_D_PERF_ENABLE_0_PERF_DMA_EN_INIT_ENUM (NO)
+#define SDP_RDMA_D_PERF_ENABLE_0_PERF_DMA_EN_NO (_MK_ENUM_CONST(0))
+#define SDP_RDMA_D_PERF_ENABLE_0_PERF_DMA_EN_YES (_MK_ENUM_CONST(1))
+
+#define SDP_RDMA_D_PERF_ENABLE_0_PERF_NAN_INF_COUNT_EN_SHIFT \
+	(_MK_SHIFT_CONST(1))
+#define SDP_RDMA_D_PERF_ENABLE_0_PERF_NAN_INF_COUNT_EN_FIELD \
+	(_MK_FIELD_CONST(                                    \
+		0x1, SDP_RDMA_D_PERF_ENABLE_0_PERF_NAN_INF_COUNT_EN_SHIFT))
+#define SDP_RDMA_D_PERF_ENABLE_0_PERF_NAN_INF_COUNT_EN_RANGE (1 : 1)
+#define SDP_RDMA_D_PERF_ENABLE_0_PERF_NAN_INF_COUNT_EN_WOFFSET (0x0)
+#define SDP_RDMA_D_PERF_ENABLE_0_PERF_NAN_INF_COUNT_EN_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_PERF_ENABLE_0_PERF_NAN_INF_COUNT_EN_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1))
+#define SDP_RDMA_D_PERF_ENABLE_0_PERF_NAN_INF_COUNT_EN_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_PERF_ENABLE_0_PERF_NAN_INF_COUNT_EN_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_PERF_ENABLE_0_PERF_NAN_INF_COUNT_EN_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_PERF_ENABLE_0_PERF_NAN_INF_COUNT_EN_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define SDP_RDMA_D_PERF_ENABLE_0_PERF_NAN_INF_COUNT_EN_INIT_ENUM (NO)
+#define SDP_RDMA_D_PERF_ENABLE_0_PERF_NAN_INF_COUNT_EN_NO (_MK_ENUM_CONST(0))
+#define SDP_RDMA_D_PERF_ENABLE_0_PERF_NAN_INF_COUNT_EN_YES (_MK_ENUM_CONST(1))
+
+// Register SDP_RDMA_D_PERF_MRDMA_READ_STALL_0
+#define SDP_RDMA_D_PERF_MRDMA_READ_STALL_0 (_MK_ADDR_CONST(0xa084))
+#define SDP_RDMA_D_PERF_MRDMA_READ_STALL_0_SECURE (0x0)
+#define SDP_RDMA_D_PERF_MRDMA_READ_STALL_0_DUAL (0x0)
+#define SDP_RDMA_D_PERF_MRDMA_READ_STALL_0_SCR (0)
+#define SDP_RDMA_D_PERF_MRDMA_READ_STALL_0_WORD_COUNT (0x1)
+#define SDP_RDMA_D_PERF_MRDMA_READ_STALL_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_PERF_MRDMA_READ_STALL_0_RESET_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define SDP_RDMA_D_PERF_MRDMA_READ_STALL_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_PERF_MRDMA_READ_STALL_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_PERF_MRDMA_READ_STALL_0_READ_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define SDP_RDMA_D_PERF_MRDMA_READ_STALL_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_PERF_MRDMA_READ_STALL_0_MRDMA_STALL_SHIFT \
+	(_MK_SHIFT_CONST(0))
+#define SDP_RDMA_D_PERF_MRDMA_READ_STALL_0_MRDMA_STALL_FIELD \
+	(_MK_FIELD_CONST(0xffffffff,                         \
+			 SDP_RDMA_D_PERF_MRDMA_READ_STALL_0_MRDMA_STALL_SHIFT))
+#define SDP_RDMA_D_PERF_MRDMA_READ_STALL_0_MRDMA_STALL_RANGE (31 : 0)
+#define SDP_RDMA_D_PERF_MRDMA_READ_STALL_0_MRDMA_STALL_WOFFSET (0x0)
+#define SDP_RDMA_D_PERF_MRDMA_READ_STALL_0_MRDMA_STALL_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_PERF_MRDMA_READ_STALL_0_MRDMA_STALL_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define SDP_RDMA_D_PERF_MRDMA_READ_STALL_0_MRDMA_STALL_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_PERF_MRDMA_READ_STALL_0_MRDMA_STALL_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_PERF_MRDMA_READ_STALL_0_MRDMA_STALL_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_PERF_MRDMA_READ_STALL_0_MRDMA_STALL_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_RDMA_D_PERF_BRDMA_READ_STALL_0
+#define SDP_RDMA_D_PERF_BRDMA_READ_STALL_0 (_MK_ADDR_CONST(0xa088))
+#define SDP_RDMA_D_PERF_BRDMA_READ_STALL_0_SECURE (0x0)
+#define SDP_RDMA_D_PERF_BRDMA_READ_STALL_0_DUAL (0x0)
+#define SDP_RDMA_D_PERF_BRDMA_READ_STALL_0_SCR (0)
+#define SDP_RDMA_D_PERF_BRDMA_READ_STALL_0_WORD_COUNT (0x1)
+#define SDP_RDMA_D_PERF_BRDMA_READ_STALL_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_PERF_BRDMA_READ_STALL_0_RESET_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define SDP_RDMA_D_PERF_BRDMA_READ_STALL_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_PERF_BRDMA_READ_STALL_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_PERF_BRDMA_READ_STALL_0_READ_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define SDP_RDMA_D_PERF_BRDMA_READ_STALL_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_PERF_BRDMA_READ_STALL_0_BRDMA_STALL_SHIFT \
+	(_MK_SHIFT_CONST(0))
+#define SDP_RDMA_D_PERF_BRDMA_READ_STALL_0_BRDMA_STALL_FIELD \
+	(_MK_FIELD_CONST(0xffffffff,                         \
+			 SDP_RDMA_D_PERF_BRDMA_READ_STALL_0_BRDMA_STALL_SHIFT))
+#define SDP_RDMA_D_PERF_BRDMA_READ_STALL_0_BRDMA_STALL_RANGE (31 : 0)
+#define SDP_RDMA_D_PERF_BRDMA_READ_STALL_0_BRDMA_STALL_WOFFSET (0x0)
+#define SDP_RDMA_D_PERF_BRDMA_READ_STALL_0_BRDMA_STALL_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_PERF_BRDMA_READ_STALL_0_BRDMA_STALL_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define SDP_RDMA_D_PERF_BRDMA_READ_STALL_0_BRDMA_STALL_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_PERF_BRDMA_READ_STALL_0_BRDMA_STALL_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_PERF_BRDMA_READ_STALL_0_BRDMA_STALL_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_PERF_BRDMA_READ_STALL_0_BRDMA_STALL_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_RDMA_D_PERF_NRDMA_READ_STALL_0
+#define SDP_RDMA_D_PERF_NRDMA_READ_STALL_0 (_MK_ADDR_CONST(0xa08c))
+#define SDP_RDMA_D_PERF_NRDMA_READ_STALL_0_SECURE (0x0)
+#define SDP_RDMA_D_PERF_NRDMA_READ_STALL_0_DUAL (0x0)
+#define SDP_RDMA_D_PERF_NRDMA_READ_STALL_0_SCR (0)
+#define SDP_RDMA_D_PERF_NRDMA_READ_STALL_0_WORD_COUNT (0x1)
+#define SDP_RDMA_D_PERF_NRDMA_READ_STALL_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_PERF_NRDMA_READ_STALL_0_RESET_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define SDP_RDMA_D_PERF_NRDMA_READ_STALL_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_PERF_NRDMA_READ_STALL_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_PERF_NRDMA_READ_STALL_0_READ_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define SDP_RDMA_D_PERF_NRDMA_READ_STALL_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_PERF_NRDMA_READ_STALL_0_NRDMA_STALL_SHIFT \
+	(_MK_SHIFT_CONST(0))
+#define SDP_RDMA_D_PERF_NRDMA_READ_STALL_0_NRDMA_STALL_FIELD \
+	(_MK_FIELD_CONST(0xffffffff,                         \
+			 SDP_RDMA_D_PERF_NRDMA_READ_STALL_0_NRDMA_STALL_SHIFT))
+#define SDP_RDMA_D_PERF_NRDMA_READ_STALL_0_NRDMA_STALL_RANGE (31 : 0)
+#define SDP_RDMA_D_PERF_NRDMA_READ_STALL_0_NRDMA_STALL_WOFFSET (0x0)
+#define SDP_RDMA_D_PERF_NRDMA_READ_STALL_0_NRDMA_STALL_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_PERF_NRDMA_READ_STALL_0_NRDMA_STALL_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define SDP_RDMA_D_PERF_NRDMA_READ_STALL_0_NRDMA_STALL_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_PERF_NRDMA_READ_STALL_0_NRDMA_STALL_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_PERF_NRDMA_READ_STALL_0_NRDMA_STALL_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_PERF_NRDMA_READ_STALL_0_NRDMA_STALL_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_RDMA_D_PERF_ERDMA_READ_STALL_0
+#define SDP_RDMA_D_PERF_ERDMA_READ_STALL_0 (_MK_ADDR_CONST(0xa090))
+#define SDP_RDMA_D_PERF_ERDMA_READ_STALL_0_SECURE (0x0)
+#define SDP_RDMA_D_PERF_ERDMA_READ_STALL_0_DUAL (0x0)
+#define SDP_RDMA_D_PERF_ERDMA_READ_STALL_0_SCR (0)
+#define SDP_RDMA_D_PERF_ERDMA_READ_STALL_0_WORD_COUNT (0x1)
+#define SDP_RDMA_D_PERF_ERDMA_READ_STALL_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_PERF_ERDMA_READ_STALL_0_RESET_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define SDP_RDMA_D_PERF_ERDMA_READ_STALL_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_PERF_ERDMA_READ_STALL_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_PERF_ERDMA_READ_STALL_0_READ_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define SDP_RDMA_D_PERF_ERDMA_READ_STALL_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_PERF_ERDMA_READ_STALL_0_ERDMA_STALL_SHIFT \
+	(_MK_SHIFT_CONST(0))
+#define SDP_RDMA_D_PERF_ERDMA_READ_STALL_0_ERDMA_STALL_FIELD \
+	(_MK_FIELD_CONST(0xffffffff,                         \
+			 SDP_RDMA_D_PERF_ERDMA_READ_STALL_0_ERDMA_STALL_SHIFT))
+#define SDP_RDMA_D_PERF_ERDMA_READ_STALL_0_ERDMA_STALL_RANGE (31 : 0)
+#define SDP_RDMA_D_PERF_ERDMA_READ_STALL_0_ERDMA_STALL_WOFFSET (0x0)
+#define SDP_RDMA_D_PERF_ERDMA_READ_STALL_0_ERDMA_STALL_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_PERF_ERDMA_READ_STALL_0_ERDMA_STALL_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define SDP_RDMA_D_PERF_ERDMA_READ_STALL_0_ERDMA_STALL_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_PERF_ERDMA_READ_STALL_0_ERDMA_STALL_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_PERF_ERDMA_READ_STALL_0_ERDMA_STALL_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_RDMA_D_PERF_ERDMA_READ_STALL_0_ERDMA_STALL_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_S_STATUS_0
+#define SDP_S_STATUS_0 (_MK_ADDR_CONST(0xb000))
+#define SDP_S_STATUS_0_SECURE (0x0)
+#define SDP_S_STATUS_0_DUAL (0x0)
+#define SDP_S_STATUS_0_SCR (0)
+#define SDP_S_STATUS_0_WORD_COUNT (0x1)
+#define SDP_S_STATUS_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_S_STATUS_0_RESET_MASK (_MK_MASK_CONST(0x30003))
+#define SDP_S_STATUS_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_S_STATUS_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_S_STATUS_0_READ_MASK (_MK_MASK_CONST(0x30003))
+#define SDP_S_STATUS_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define SDP_S_STATUS_0_STATUS_0_SHIFT (_MK_SHIFT_CONST(0))
+#define SDP_S_STATUS_0_STATUS_0_FIELD \
+	(_MK_FIELD_CONST(0x3, SDP_S_STATUS_0_STATUS_0_SHIFT))
+#define SDP_S_STATUS_0_STATUS_0_RANGE (1 : 0)
+#define SDP_S_STATUS_0_STATUS_0_WOFFSET (0x0)
+#define SDP_S_STATUS_0_STATUS_0_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_S_STATUS_0_STATUS_0_DEFAULT_MASK (_MK_MASK_CONST(0x3))
+#define SDP_S_STATUS_0_STATUS_0_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_S_STATUS_0_STATUS_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_S_STATUS_0_STATUS_0_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define SDP_S_STATUS_0_STATUS_0_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define SDP_S_STATUS_0_STATUS_0_INIT_ENUM (IDLE)
+#define SDP_S_STATUS_0_STATUS_0_IDLE (_MK_ENUM_CONST(0))
+#define SDP_S_STATUS_0_STATUS_0_RUNNING (_MK_ENUM_CONST(1))
+#define SDP_S_STATUS_0_STATUS_0_PENDING (_MK_ENUM_CONST(2))
+
+#define SDP_S_STATUS_0_STATUS_1_SHIFT (_MK_SHIFT_CONST(16))
+#define SDP_S_STATUS_0_STATUS_1_FIELD \
+	(_MK_FIELD_CONST(0x3, SDP_S_STATUS_0_STATUS_1_SHIFT))
+#define SDP_S_STATUS_0_STATUS_1_RANGE (17 : 16)
+#define SDP_S_STATUS_0_STATUS_1_WOFFSET (0x0)
+#define SDP_S_STATUS_0_STATUS_1_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_S_STATUS_0_STATUS_1_DEFAULT_MASK (_MK_MASK_CONST(0x3))
+#define SDP_S_STATUS_0_STATUS_1_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_S_STATUS_0_STATUS_1_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_S_STATUS_0_STATUS_1_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define SDP_S_STATUS_0_STATUS_1_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define SDP_S_STATUS_0_STATUS_1_INIT_ENUM (IDLE)
+#define SDP_S_STATUS_0_STATUS_1_IDLE (_MK_ENUM_CONST(0))
+#define SDP_S_STATUS_0_STATUS_1_RUNNING (_MK_ENUM_CONST(1))
+#define SDP_S_STATUS_0_STATUS_1_PENDING (_MK_ENUM_CONST(2))
+
+// Register SDP_S_POINTER_0
+#define SDP_S_POINTER_0 (_MK_ADDR_CONST(0xb004))
+#define SDP_S_POINTER_0_SECURE (0x0)
+#define SDP_S_POINTER_0_DUAL (0x0)
+#define SDP_S_POINTER_0_SCR (0)
+#define SDP_S_POINTER_0_WORD_COUNT (0x1)
+#define SDP_S_POINTER_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_S_POINTER_0_RESET_MASK (_MK_MASK_CONST(0x10001))
+#define SDP_S_POINTER_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_S_POINTER_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_S_POINTER_0_READ_MASK (_MK_MASK_CONST(0x10001))
+#define SDP_S_POINTER_0_WRITE_MASK (_MK_MASK_CONST(0x1))
+#define SDP_S_POINTER_0_PRODUCER_SHIFT (_MK_SHIFT_CONST(0))
+#define SDP_S_POINTER_0_PRODUCER_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_S_POINTER_0_PRODUCER_SHIFT))
+#define SDP_S_POINTER_0_PRODUCER_RANGE (0 : 0)
+#define SDP_S_POINTER_0_PRODUCER_WOFFSET (0x0)
+#define SDP_S_POINTER_0_PRODUCER_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_S_POINTER_0_PRODUCER_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define SDP_S_POINTER_0_PRODUCER_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_S_POINTER_0_PRODUCER_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_S_POINTER_0_PRODUCER_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define SDP_S_POINTER_0_PRODUCER_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define SDP_S_POINTER_0_PRODUCER_INIT_ENUM (GROUP_0)
+#define SDP_S_POINTER_0_PRODUCER_GROUP_0 (_MK_ENUM_CONST(0))
+#define SDP_S_POINTER_0_PRODUCER_GROUP_1 (_MK_ENUM_CONST(1))
+
+#define SDP_S_POINTER_0_CONSUMER_SHIFT (_MK_SHIFT_CONST(16))
+#define SDP_S_POINTER_0_CONSUMER_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_S_POINTER_0_CONSUMER_SHIFT))
+#define SDP_S_POINTER_0_CONSUMER_RANGE (16 : 16)
+#define SDP_S_POINTER_0_CONSUMER_WOFFSET (0x0)
+#define SDP_S_POINTER_0_CONSUMER_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_S_POINTER_0_CONSUMER_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define SDP_S_POINTER_0_CONSUMER_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_S_POINTER_0_CONSUMER_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_S_POINTER_0_CONSUMER_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define SDP_S_POINTER_0_CONSUMER_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define SDP_S_POINTER_0_CONSUMER_INIT_ENUM (GROUP_0)
+#define SDP_S_POINTER_0_CONSUMER_GROUP_0 (_MK_ENUM_CONST(0))
+#define SDP_S_POINTER_0_CONSUMER_GROUP_1 (_MK_ENUM_CONST(1))
+
+// Register SDP_S_LUT_ACCESS_CFG_0
+#define SDP_S_LUT_ACCESS_CFG_0 (_MK_ADDR_CONST(0xb008))
+#define SDP_S_LUT_ACCESS_CFG_0_SECURE (0x0)
+#define SDP_S_LUT_ACCESS_CFG_0_DUAL (0x0)
+#define SDP_S_LUT_ACCESS_CFG_0_SCR (0)
+#define SDP_S_LUT_ACCESS_CFG_0_WORD_COUNT (0x1)
+#define SDP_S_LUT_ACCESS_CFG_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_ACCESS_CFG_0_RESET_MASK (_MK_MASK_CONST(0x303ff))
+#define SDP_S_LUT_ACCESS_CFG_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_ACCESS_CFG_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_ACCESS_CFG_0_READ_MASK (_MK_MASK_CONST(0x303ff))
+#define SDP_S_LUT_ACCESS_CFG_0_WRITE_MASK (_MK_MASK_CONST(0x303ff))
+#define SDP_S_LUT_ACCESS_CFG_0_LUT_ADDR_SHIFT (_MK_SHIFT_CONST(0))
+#define SDP_S_LUT_ACCESS_CFG_0_LUT_ADDR_FIELD \
+	(_MK_FIELD_CONST(0x3ff, SDP_S_LUT_ACCESS_CFG_0_LUT_ADDR_SHIFT))
+#define SDP_S_LUT_ACCESS_CFG_0_LUT_ADDR_RANGE (9 : 0)
+#define SDP_S_LUT_ACCESS_CFG_0_LUT_ADDR_WOFFSET (0x0)
+#define SDP_S_LUT_ACCESS_CFG_0_LUT_ADDR_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_ACCESS_CFG_0_LUT_ADDR_DEFAULT_MASK (_MK_MASK_CONST(0x3ff))
+#define SDP_S_LUT_ACCESS_CFG_0_LUT_ADDR_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_ACCESS_CFG_0_LUT_ADDR_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_ACCESS_CFG_0_LUT_ADDR_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_ACCESS_CFG_0_LUT_ADDR_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+#define SDP_S_LUT_ACCESS_CFG_0_LUT_TABLE_ID_SHIFT (_MK_SHIFT_CONST(16))
+#define SDP_S_LUT_ACCESS_CFG_0_LUT_TABLE_ID_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_S_LUT_ACCESS_CFG_0_LUT_TABLE_ID_SHIFT))
+#define SDP_S_LUT_ACCESS_CFG_0_LUT_TABLE_ID_RANGE (16 : 16)
+#define SDP_S_LUT_ACCESS_CFG_0_LUT_TABLE_ID_WOFFSET (0x0)
+#define SDP_S_LUT_ACCESS_CFG_0_LUT_TABLE_ID_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_ACCESS_CFG_0_LUT_TABLE_ID_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define SDP_S_LUT_ACCESS_CFG_0_LUT_TABLE_ID_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_ACCESS_CFG_0_LUT_TABLE_ID_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_ACCESS_CFG_0_LUT_TABLE_ID_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_ACCESS_CFG_0_LUT_TABLE_ID_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define SDP_S_LUT_ACCESS_CFG_0_LUT_TABLE_ID_INIT_ENUM (LE)
+#define SDP_S_LUT_ACCESS_CFG_0_LUT_TABLE_ID_LE (_MK_ENUM_CONST(0))
+#define SDP_S_LUT_ACCESS_CFG_0_LUT_TABLE_ID_LO (_MK_ENUM_CONST(1))
+
+#define SDP_S_LUT_ACCESS_CFG_0_LUT_ACCESS_TYPE_SHIFT (_MK_SHIFT_CONST(17))
+#define SDP_S_LUT_ACCESS_CFG_0_LUT_ACCESS_TYPE_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_S_LUT_ACCESS_CFG_0_LUT_ACCESS_TYPE_SHIFT))
+#define SDP_S_LUT_ACCESS_CFG_0_LUT_ACCESS_TYPE_RANGE (17 : 17)
+#define SDP_S_LUT_ACCESS_CFG_0_LUT_ACCESS_TYPE_WOFFSET (0x0)
+#define SDP_S_LUT_ACCESS_CFG_0_LUT_ACCESS_TYPE_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_ACCESS_CFG_0_LUT_ACCESS_TYPE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1))
+#define SDP_S_LUT_ACCESS_CFG_0_LUT_ACCESS_TYPE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_ACCESS_CFG_0_LUT_ACCESS_TYPE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_ACCESS_CFG_0_LUT_ACCESS_TYPE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_ACCESS_CFG_0_LUT_ACCESS_TYPE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define SDP_S_LUT_ACCESS_CFG_0_LUT_ACCESS_TYPE_INIT_ENUM (READ)
+#define SDP_S_LUT_ACCESS_CFG_0_LUT_ACCESS_TYPE_READ (_MK_ENUM_CONST(0))
+#define SDP_S_LUT_ACCESS_CFG_0_LUT_ACCESS_TYPE_WRITE (_MK_ENUM_CONST(1))
+
+// Register SDP_S_LUT_ACCESS_DATA_0
+#define SDP_S_LUT_ACCESS_DATA_0 (_MK_ADDR_CONST(0xb00c))
+#define SDP_S_LUT_ACCESS_DATA_0_SECURE (0x0)
+#define SDP_S_LUT_ACCESS_DATA_0_DUAL (0x0)
+#define SDP_S_LUT_ACCESS_DATA_0_SCR (0)
+#define SDP_S_LUT_ACCESS_DATA_0_WORD_COUNT (0x1)
+#define SDP_S_LUT_ACCESS_DATA_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_ACCESS_DATA_0_RESET_MASK (_MK_MASK_CONST(0xffff))
+#define SDP_S_LUT_ACCESS_DATA_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_ACCESS_DATA_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_ACCESS_DATA_0_READ_MASK (_MK_MASK_CONST(0xffff))
+#define SDP_S_LUT_ACCESS_DATA_0_WRITE_MASK (_MK_MASK_CONST(0xffff))
+#define SDP_S_LUT_ACCESS_DATA_0_LUT_DATA_SHIFT (_MK_SHIFT_CONST(0))
+#define SDP_S_LUT_ACCESS_DATA_0_LUT_DATA_FIELD \
+	(_MK_FIELD_CONST(0xffff, SDP_S_LUT_ACCESS_DATA_0_LUT_DATA_SHIFT))
+#define SDP_S_LUT_ACCESS_DATA_0_LUT_DATA_RANGE (15 : 0)
+#define SDP_S_LUT_ACCESS_DATA_0_LUT_DATA_WOFFSET (0x0)
+#define SDP_S_LUT_ACCESS_DATA_0_LUT_DATA_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_ACCESS_DATA_0_LUT_DATA_DEFAULT_MASK (_MK_MASK_CONST(0xffff))
+#define SDP_S_LUT_ACCESS_DATA_0_LUT_DATA_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_ACCESS_DATA_0_LUT_DATA_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_ACCESS_DATA_0_LUT_DATA_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_ACCESS_DATA_0_LUT_DATA_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_S_LUT_CFG_0
+#define SDP_S_LUT_CFG_0 (_MK_ADDR_CONST(0xb010))
+#define SDP_S_LUT_CFG_0_SECURE (0x0)
+#define SDP_S_LUT_CFG_0_DUAL (0x0)
+#define SDP_S_LUT_CFG_0_SCR (0)
+#define SDP_S_LUT_CFG_0_WORD_COUNT (0x1)
+#define SDP_S_LUT_CFG_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_CFG_0_RESET_MASK (_MK_MASK_CONST(0x71))
+#define SDP_S_LUT_CFG_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_CFG_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_CFG_0_READ_MASK (_MK_MASK_CONST(0x71))
+#define SDP_S_LUT_CFG_0_WRITE_MASK (_MK_MASK_CONST(0x71))
+#define SDP_S_LUT_CFG_0_LUT_LE_FUNCTION_SHIFT (_MK_SHIFT_CONST(0))
+#define SDP_S_LUT_CFG_0_LUT_LE_FUNCTION_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_S_LUT_CFG_0_LUT_LE_FUNCTION_SHIFT))
+#define SDP_S_LUT_CFG_0_LUT_LE_FUNCTION_RANGE (0 : 0)
+#define SDP_S_LUT_CFG_0_LUT_LE_FUNCTION_WOFFSET (0x0)
+#define SDP_S_LUT_CFG_0_LUT_LE_FUNCTION_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_CFG_0_LUT_LE_FUNCTION_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define SDP_S_LUT_CFG_0_LUT_LE_FUNCTION_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_CFG_0_LUT_LE_FUNCTION_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_CFG_0_LUT_LE_FUNCTION_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_CFG_0_LUT_LE_FUNCTION_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define SDP_S_LUT_CFG_0_LUT_LE_FUNCTION_INIT_ENUM (EXPONENT)
+#define SDP_S_LUT_CFG_0_LUT_LE_FUNCTION_EXPONENT (_MK_ENUM_CONST(0))
+#define SDP_S_LUT_CFG_0_LUT_LE_FUNCTION_LINEAR (_MK_ENUM_CONST(1))
+
+#define SDP_S_LUT_CFG_0_LUT_UFLOW_PRIORITY_SHIFT (_MK_SHIFT_CONST(4))
+#define SDP_S_LUT_CFG_0_LUT_UFLOW_PRIORITY_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_S_LUT_CFG_0_LUT_UFLOW_PRIORITY_SHIFT))
+#define SDP_S_LUT_CFG_0_LUT_UFLOW_PRIORITY_RANGE (4 : 4)
+#define SDP_S_LUT_CFG_0_LUT_UFLOW_PRIORITY_WOFFSET (0x0)
+#define SDP_S_LUT_CFG_0_LUT_UFLOW_PRIORITY_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_CFG_0_LUT_UFLOW_PRIORITY_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define SDP_S_LUT_CFG_0_LUT_UFLOW_PRIORITY_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_CFG_0_LUT_UFLOW_PRIORITY_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_CFG_0_LUT_UFLOW_PRIORITY_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_CFG_0_LUT_UFLOW_PRIORITY_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define SDP_S_LUT_CFG_0_LUT_UFLOW_PRIORITY_LE (_MK_ENUM_CONST(0))
+#define SDP_S_LUT_CFG_0_LUT_UFLOW_PRIORITY_LO (_MK_ENUM_CONST(1))
+
+#define SDP_S_LUT_CFG_0_LUT_OFLOW_PRIORITY_SHIFT (_MK_SHIFT_CONST(5))
+#define SDP_S_LUT_CFG_0_LUT_OFLOW_PRIORITY_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_S_LUT_CFG_0_LUT_OFLOW_PRIORITY_SHIFT))
+#define SDP_S_LUT_CFG_0_LUT_OFLOW_PRIORITY_RANGE (5 : 5)
+#define SDP_S_LUT_CFG_0_LUT_OFLOW_PRIORITY_WOFFSET (0x0)
+#define SDP_S_LUT_CFG_0_LUT_OFLOW_PRIORITY_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_CFG_0_LUT_OFLOW_PRIORITY_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define SDP_S_LUT_CFG_0_LUT_OFLOW_PRIORITY_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_CFG_0_LUT_OFLOW_PRIORITY_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_CFG_0_LUT_OFLOW_PRIORITY_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_CFG_0_LUT_OFLOW_PRIORITY_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define SDP_S_LUT_CFG_0_LUT_OFLOW_PRIORITY_LE (_MK_ENUM_CONST(0))
+#define SDP_S_LUT_CFG_0_LUT_OFLOW_PRIORITY_LO (_MK_ENUM_CONST(1))
+
+#define SDP_S_LUT_CFG_0_LUT_HYBRID_PRIORITY_SHIFT (_MK_SHIFT_CONST(6))
+#define SDP_S_LUT_CFG_0_LUT_HYBRID_PRIORITY_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_S_LUT_CFG_0_LUT_HYBRID_PRIORITY_SHIFT))
+#define SDP_S_LUT_CFG_0_LUT_HYBRID_PRIORITY_RANGE (6 : 6)
+#define SDP_S_LUT_CFG_0_LUT_HYBRID_PRIORITY_WOFFSET (0x0)
+#define SDP_S_LUT_CFG_0_LUT_HYBRID_PRIORITY_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_CFG_0_LUT_HYBRID_PRIORITY_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define SDP_S_LUT_CFG_0_LUT_HYBRID_PRIORITY_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_CFG_0_LUT_HYBRID_PRIORITY_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_CFG_0_LUT_HYBRID_PRIORITY_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_CFG_0_LUT_HYBRID_PRIORITY_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define SDP_S_LUT_CFG_0_LUT_HYBRID_PRIORITY_LE (_MK_ENUM_CONST(0))
+#define SDP_S_LUT_CFG_0_LUT_HYBRID_PRIORITY_LO (_MK_ENUM_CONST(1))
+
+// Register SDP_S_LUT_INFO_0
+#define SDP_S_LUT_INFO_0 (_MK_ADDR_CONST(0xb014))
+#define SDP_S_LUT_INFO_0_SECURE (0x0)
+#define SDP_S_LUT_INFO_0_DUAL (0x0)
+#define SDP_S_LUT_INFO_0_SCR (0)
+#define SDP_S_LUT_INFO_0_WORD_COUNT (0x1)
+#define SDP_S_LUT_INFO_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_INFO_0_RESET_MASK (_MK_MASK_CONST(0xffffff))
+#define SDP_S_LUT_INFO_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_INFO_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_INFO_0_READ_MASK (_MK_MASK_CONST(0xffffff))
+#define SDP_S_LUT_INFO_0_WRITE_MASK (_MK_MASK_CONST(0xffffff))
+#define SDP_S_LUT_INFO_0_LUT_LE_INDEX_OFFSET_SHIFT (_MK_SHIFT_CONST(0))
+#define SDP_S_LUT_INFO_0_LUT_LE_INDEX_OFFSET_FIELD \
+	(_MK_FIELD_CONST(0xff, SDP_S_LUT_INFO_0_LUT_LE_INDEX_OFFSET_SHIFT))
+#define SDP_S_LUT_INFO_0_LUT_LE_INDEX_OFFSET_RANGE (7 : 0)
+#define SDP_S_LUT_INFO_0_LUT_LE_INDEX_OFFSET_WOFFSET (0x0)
+#define SDP_S_LUT_INFO_0_LUT_LE_INDEX_OFFSET_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_INFO_0_LUT_LE_INDEX_OFFSET_DEFAULT_MASK (_MK_MASK_CONST(0xff))
+#define SDP_S_LUT_INFO_0_LUT_LE_INDEX_OFFSET_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_INFO_0_LUT_LE_INDEX_OFFSET_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_INFO_0_LUT_LE_INDEX_OFFSET_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_INFO_0_LUT_LE_INDEX_OFFSET_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define SDP_S_LUT_INFO_0_LUT_LE_INDEX_SELECT_SHIFT (_MK_SHIFT_CONST(8))
+#define SDP_S_LUT_INFO_0_LUT_LE_INDEX_SELECT_FIELD \
+	(_MK_FIELD_CONST(0xff, SDP_S_LUT_INFO_0_LUT_LE_INDEX_SELECT_SHIFT))
+#define SDP_S_LUT_INFO_0_LUT_LE_INDEX_SELECT_RANGE (15 : 8)
+#define SDP_S_LUT_INFO_0_LUT_LE_INDEX_SELECT_WOFFSET (0x0)
+#define SDP_S_LUT_INFO_0_LUT_LE_INDEX_SELECT_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_INFO_0_LUT_LE_INDEX_SELECT_DEFAULT_MASK (_MK_MASK_CONST(0xff))
+#define SDP_S_LUT_INFO_0_LUT_LE_INDEX_SELECT_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_INFO_0_LUT_LE_INDEX_SELECT_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_INFO_0_LUT_LE_INDEX_SELECT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_INFO_0_LUT_LE_INDEX_SELECT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define SDP_S_LUT_INFO_0_LUT_LO_INDEX_SELECT_SHIFT (_MK_SHIFT_CONST(16))
+#define SDP_S_LUT_INFO_0_LUT_LO_INDEX_SELECT_FIELD \
+	(_MK_FIELD_CONST(0xff, SDP_S_LUT_INFO_0_LUT_LO_INDEX_SELECT_SHIFT))
+#define SDP_S_LUT_INFO_0_LUT_LO_INDEX_SELECT_RANGE (23 : 16)
+#define SDP_S_LUT_INFO_0_LUT_LO_INDEX_SELECT_WOFFSET (0x0)
+#define SDP_S_LUT_INFO_0_LUT_LO_INDEX_SELECT_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_INFO_0_LUT_LO_INDEX_SELECT_DEFAULT_MASK (_MK_MASK_CONST(0xff))
+#define SDP_S_LUT_INFO_0_LUT_LO_INDEX_SELECT_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_INFO_0_LUT_LO_INDEX_SELECT_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_INFO_0_LUT_LO_INDEX_SELECT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_INFO_0_LUT_LO_INDEX_SELECT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_S_LUT_LE_START_0
+#define SDP_S_LUT_LE_START_0 (_MK_ADDR_CONST(0xb018))
+#define SDP_S_LUT_LE_START_0_SECURE (0x0)
+#define SDP_S_LUT_LE_START_0_DUAL (0x0)
+#define SDP_S_LUT_LE_START_0_SCR (0)
+#define SDP_S_LUT_LE_START_0_WORD_COUNT (0x1)
+#define SDP_S_LUT_LE_START_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LE_START_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_S_LUT_LE_START_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LE_START_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LE_START_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_S_LUT_LE_START_0_WRITE_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_S_LUT_LE_START_0_LUT_LE_START_SHIFT (_MK_SHIFT_CONST(0))
+#define SDP_S_LUT_LE_START_0_LUT_LE_START_FIELD \
+	(_MK_FIELD_CONST(0xffffffff, SDP_S_LUT_LE_START_0_LUT_LE_START_SHIFT))
+#define SDP_S_LUT_LE_START_0_LUT_LE_START_RANGE (31 : 0)
+#define SDP_S_LUT_LE_START_0_LUT_LE_START_WOFFSET (0x0)
+#define SDP_S_LUT_LE_START_0_LUT_LE_START_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LE_START_0_LUT_LE_START_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define SDP_S_LUT_LE_START_0_LUT_LE_START_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LE_START_0_LUT_LE_START_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LE_START_0_LUT_LE_START_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LE_START_0_LUT_LE_START_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_S_LUT_LE_END_0
+#define SDP_S_LUT_LE_END_0 (_MK_ADDR_CONST(0xb01c))
+#define SDP_S_LUT_LE_END_0_SECURE (0x0)
+#define SDP_S_LUT_LE_END_0_DUAL (0x0)
+#define SDP_S_LUT_LE_END_0_SCR (0)
+#define SDP_S_LUT_LE_END_0_WORD_COUNT (0x1)
+#define SDP_S_LUT_LE_END_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LE_END_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_S_LUT_LE_END_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LE_END_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LE_END_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_S_LUT_LE_END_0_WRITE_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_S_LUT_LE_END_0_LUT_LE_END_SHIFT (_MK_SHIFT_CONST(0))
+#define SDP_S_LUT_LE_END_0_LUT_LE_END_FIELD \
+	(_MK_FIELD_CONST(0xffffffff, SDP_S_LUT_LE_END_0_LUT_LE_END_SHIFT))
+#define SDP_S_LUT_LE_END_0_LUT_LE_END_RANGE (31 : 0)
+#define SDP_S_LUT_LE_END_0_LUT_LE_END_WOFFSET (0x0)
+#define SDP_S_LUT_LE_END_0_LUT_LE_END_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LE_END_0_LUT_LE_END_DEFAULT_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_S_LUT_LE_END_0_LUT_LE_END_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LE_END_0_LUT_LE_END_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LE_END_0_LUT_LE_END_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LE_END_0_LUT_LE_END_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+// Register SDP_S_LUT_LO_START_0
+#define SDP_S_LUT_LO_START_0 (_MK_ADDR_CONST(0xb020))
+#define SDP_S_LUT_LO_START_0_SECURE (0x0)
+#define SDP_S_LUT_LO_START_0_DUAL (0x0)
+#define SDP_S_LUT_LO_START_0_SCR (0)
+#define SDP_S_LUT_LO_START_0_WORD_COUNT (0x1)
+#define SDP_S_LUT_LO_START_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LO_START_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_S_LUT_LO_START_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LO_START_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LO_START_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_S_LUT_LO_START_0_WRITE_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_S_LUT_LO_START_0_LUT_LO_START_SHIFT (_MK_SHIFT_CONST(0))
+#define SDP_S_LUT_LO_START_0_LUT_LO_START_FIELD \
+	(_MK_FIELD_CONST(0xffffffff, SDP_S_LUT_LO_START_0_LUT_LO_START_SHIFT))
+#define SDP_S_LUT_LO_START_0_LUT_LO_START_RANGE (31 : 0)
+#define SDP_S_LUT_LO_START_0_LUT_LO_START_WOFFSET (0x0)
+#define SDP_S_LUT_LO_START_0_LUT_LO_START_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LO_START_0_LUT_LO_START_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define SDP_S_LUT_LO_START_0_LUT_LO_START_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LO_START_0_LUT_LO_START_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LO_START_0_LUT_LO_START_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LO_START_0_LUT_LO_START_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_S_LUT_LO_END_0
+#define SDP_S_LUT_LO_END_0 (_MK_ADDR_CONST(0xb024))
+#define SDP_S_LUT_LO_END_0_SECURE (0x0)
+#define SDP_S_LUT_LO_END_0_DUAL (0x0)
+#define SDP_S_LUT_LO_END_0_SCR (0)
+#define SDP_S_LUT_LO_END_0_WORD_COUNT (0x1)
+#define SDP_S_LUT_LO_END_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LO_END_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_S_LUT_LO_END_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LO_END_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LO_END_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_S_LUT_LO_END_0_WRITE_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_S_LUT_LO_END_0_LUT_LO_END_SHIFT (_MK_SHIFT_CONST(0))
+#define SDP_S_LUT_LO_END_0_LUT_LO_END_FIELD \
+	(_MK_FIELD_CONST(0xffffffff, SDP_S_LUT_LO_END_0_LUT_LO_END_SHIFT))
+#define SDP_S_LUT_LO_END_0_LUT_LO_END_RANGE (31 : 0)
+#define SDP_S_LUT_LO_END_0_LUT_LO_END_WOFFSET (0x0)
+#define SDP_S_LUT_LO_END_0_LUT_LO_END_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LO_END_0_LUT_LO_END_DEFAULT_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_S_LUT_LO_END_0_LUT_LO_END_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LO_END_0_LUT_LO_END_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LO_END_0_LUT_LO_END_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LO_END_0_LUT_LO_END_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+// Register SDP_S_LUT_LE_SLOPE_SCALE_0
+#define SDP_S_LUT_LE_SLOPE_SCALE_0 (_MK_ADDR_CONST(0xb028))
+#define SDP_S_LUT_LE_SLOPE_SCALE_0_SECURE (0x0)
+#define SDP_S_LUT_LE_SLOPE_SCALE_0_DUAL (0x0)
+#define SDP_S_LUT_LE_SLOPE_SCALE_0_SCR (0)
+#define SDP_S_LUT_LE_SLOPE_SCALE_0_WORD_COUNT (0x1)
+#define SDP_S_LUT_LE_SLOPE_SCALE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LE_SLOPE_SCALE_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_S_LUT_LE_SLOPE_SCALE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LE_SLOPE_SCALE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LE_SLOPE_SCALE_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_S_LUT_LE_SLOPE_SCALE_0_WRITE_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_S_LUT_LE_SLOPE_SCALE_0_LUT_LE_SLOPE_UFLOW_SCALE_SHIFT \
+	(_MK_SHIFT_CONST(0))
+#define SDP_S_LUT_LE_SLOPE_SCALE_0_LUT_LE_SLOPE_UFLOW_SCALE_FIELD \
+	(_MK_FIELD_CONST(                                         \
+		0xffff,                                           \
+		SDP_S_LUT_LE_SLOPE_SCALE_0_LUT_LE_SLOPE_UFLOW_SCALE_SHIFT))
+#define SDP_S_LUT_LE_SLOPE_SCALE_0_LUT_LE_SLOPE_UFLOW_SCALE_RANGE (15 : 0)
+#define SDP_S_LUT_LE_SLOPE_SCALE_0_LUT_LE_SLOPE_UFLOW_SCALE_WOFFSET (0x0)
+#define SDP_S_LUT_LE_SLOPE_SCALE_0_LUT_LE_SLOPE_UFLOW_SCALE_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LE_SLOPE_SCALE_0_LUT_LE_SLOPE_UFLOW_SCALE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffff))
+#define SDP_S_LUT_LE_SLOPE_SCALE_0_LUT_LE_SLOPE_UFLOW_SCALE_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LE_SLOPE_SCALE_0_LUT_LE_SLOPE_UFLOW_SCALE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LE_SLOPE_SCALE_0_LUT_LE_SLOPE_UFLOW_SCALE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LE_SLOPE_SCALE_0_LUT_LE_SLOPE_UFLOW_SCALE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define SDP_S_LUT_LE_SLOPE_SCALE_0_LUT_LE_SLOPE_OFLOW_SCALE_SHIFT \
+	(_MK_SHIFT_CONST(16))
+#define SDP_S_LUT_LE_SLOPE_SCALE_0_LUT_LE_SLOPE_OFLOW_SCALE_FIELD \
+	(_MK_FIELD_CONST(                                         \
+		0xffff,                                           \
+		SDP_S_LUT_LE_SLOPE_SCALE_0_LUT_LE_SLOPE_OFLOW_SCALE_SHIFT))
+#define SDP_S_LUT_LE_SLOPE_SCALE_0_LUT_LE_SLOPE_OFLOW_SCALE_RANGE (31 : 16)
+#define SDP_S_LUT_LE_SLOPE_SCALE_0_LUT_LE_SLOPE_OFLOW_SCALE_WOFFSET (0x0)
+#define SDP_S_LUT_LE_SLOPE_SCALE_0_LUT_LE_SLOPE_OFLOW_SCALE_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LE_SLOPE_SCALE_0_LUT_LE_SLOPE_OFLOW_SCALE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffff))
+#define SDP_S_LUT_LE_SLOPE_SCALE_0_LUT_LE_SLOPE_OFLOW_SCALE_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LE_SLOPE_SCALE_0_LUT_LE_SLOPE_OFLOW_SCALE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LE_SLOPE_SCALE_0_LUT_LE_SLOPE_OFLOW_SCALE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LE_SLOPE_SCALE_0_LUT_LE_SLOPE_OFLOW_SCALE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_S_LUT_LE_SLOPE_SHIFT_0
+#define SDP_S_LUT_LE_SLOPE_SHIFT_0 (_MK_ADDR_CONST(0xb02c))
+#define SDP_S_LUT_LE_SLOPE_SHIFT_0_SECURE (0x0)
+#define SDP_S_LUT_LE_SLOPE_SHIFT_0_DUAL (0x0)
+#define SDP_S_LUT_LE_SLOPE_SHIFT_0_SCR (0)
+#define SDP_S_LUT_LE_SLOPE_SHIFT_0_WORD_COUNT (0x1)
+#define SDP_S_LUT_LE_SLOPE_SHIFT_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LE_SLOPE_SHIFT_0_RESET_MASK (_MK_MASK_CONST(0x3ff))
+#define SDP_S_LUT_LE_SLOPE_SHIFT_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LE_SLOPE_SHIFT_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LE_SLOPE_SHIFT_0_READ_MASK (_MK_MASK_CONST(0x3ff))
+#define SDP_S_LUT_LE_SLOPE_SHIFT_0_WRITE_MASK (_MK_MASK_CONST(0x3ff))
+#define SDP_S_LUT_LE_SLOPE_SHIFT_0_LUT_LE_SLOPE_UFLOW_SHIFT_SHIFT \
+	(_MK_SHIFT_CONST(0))
+#define SDP_S_LUT_LE_SLOPE_SHIFT_0_LUT_LE_SLOPE_UFLOW_SHIFT_FIELD \
+	(_MK_FIELD_CONST(                                         \
+		0x1f,                                             \
+		SDP_S_LUT_LE_SLOPE_SHIFT_0_LUT_LE_SLOPE_UFLOW_SHIFT_SHIFT))
+#define SDP_S_LUT_LE_SLOPE_SHIFT_0_LUT_LE_SLOPE_UFLOW_SHIFT_RANGE (4 : 0)
+#define SDP_S_LUT_LE_SLOPE_SHIFT_0_LUT_LE_SLOPE_UFLOW_SHIFT_WOFFSET (0x0)
+#define SDP_S_LUT_LE_SLOPE_SHIFT_0_LUT_LE_SLOPE_UFLOW_SHIFT_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LE_SLOPE_SHIFT_0_LUT_LE_SLOPE_UFLOW_SHIFT_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1f))
+#define SDP_S_LUT_LE_SLOPE_SHIFT_0_LUT_LE_SLOPE_UFLOW_SHIFT_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LE_SLOPE_SHIFT_0_LUT_LE_SLOPE_UFLOW_SHIFT_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LE_SLOPE_SHIFT_0_LUT_LE_SLOPE_UFLOW_SHIFT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LE_SLOPE_SHIFT_0_LUT_LE_SLOPE_UFLOW_SHIFT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define SDP_S_LUT_LE_SLOPE_SHIFT_0_LUT_LE_SLOPE_OFLOW_SHIFT_SHIFT \
+	(_MK_SHIFT_CONST(5))
+#define SDP_S_LUT_LE_SLOPE_SHIFT_0_LUT_LE_SLOPE_OFLOW_SHIFT_FIELD \
+	(_MK_FIELD_CONST(                                         \
+		0x1f,                                             \
+		SDP_S_LUT_LE_SLOPE_SHIFT_0_LUT_LE_SLOPE_OFLOW_SHIFT_SHIFT))
+#define SDP_S_LUT_LE_SLOPE_SHIFT_0_LUT_LE_SLOPE_OFLOW_SHIFT_RANGE (9 : 5)
+#define SDP_S_LUT_LE_SLOPE_SHIFT_0_LUT_LE_SLOPE_OFLOW_SHIFT_WOFFSET (0x0)
+#define SDP_S_LUT_LE_SLOPE_SHIFT_0_LUT_LE_SLOPE_OFLOW_SHIFT_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LE_SLOPE_SHIFT_0_LUT_LE_SLOPE_OFLOW_SHIFT_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1f))
+#define SDP_S_LUT_LE_SLOPE_SHIFT_0_LUT_LE_SLOPE_OFLOW_SHIFT_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LE_SLOPE_SHIFT_0_LUT_LE_SLOPE_OFLOW_SHIFT_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LE_SLOPE_SHIFT_0_LUT_LE_SLOPE_OFLOW_SHIFT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LE_SLOPE_SHIFT_0_LUT_LE_SLOPE_OFLOW_SHIFT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_S_LUT_LO_SLOPE_SCALE_0
+#define SDP_S_LUT_LO_SLOPE_SCALE_0 (_MK_ADDR_CONST(0xb030))
+#define SDP_S_LUT_LO_SLOPE_SCALE_0_SECURE (0x0)
+#define SDP_S_LUT_LO_SLOPE_SCALE_0_DUAL (0x0)
+#define SDP_S_LUT_LO_SLOPE_SCALE_0_SCR (0)
+#define SDP_S_LUT_LO_SLOPE_SCALE_0_WORD_COUNT (0x1)
+#define SDP_S_LUT_LO_SLOPE_SCALE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LO_SLOPE_SCALE_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_S_LUT_LO_SLOPE_SCALE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LO_SLOPE_SCALE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LO_SLOPE_SCALE_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_S_LUT_LO_SLOPE_SCALE_0_WRITE_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_S_LUT_LO_SLOPE_SCALE_0_LUT_LO_SLOPE_UFLOW_SCALE_SHIFT \
+	(_MK_SHIFT_CONST(0))
+#define SDP_S_LUT_LO_SLOPE_SCALE_0_LUT_LO_SLOPE_UFLOW_SCALE_FIELD \
+	(_MK_FIELD_CONST(                                         \
+		0xffff,                                           \
+		SDP_S_LUT_LO_SLOPE_SCALE_0_LUT_LO_SLOPE_UFLOW_SCALE_SHIFT))
+#define SDP_S_LUT_LO_SLOPE_SCALE_0_LUT_LO_SLOPE_UFLOW_SCALE_RANGE (15 : 0)
+#define SDP_S_LUT_LO_SLOPE_SCALE_0_LUT_LO_SLOPE_UFLOW_SCALE_WOFFSET (0x0)
+#define SDP_S_LUT_LO_SLOPE_SCALE_0_LUT_LO_SLOPE_UFLOW_SCALE_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LO_SLOPE_SCALE_0_LUT_LO_SLOPE_UFLOW_SCALE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffff))
+#define SDP_S_LUT_LO_SLOPE_SCALE_0_LUT_LO_SLOPE_UFLOW_SCALE_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LO_SLOPE_SCALE_0_LUT_LO_SLOPE_UFLOW_SCALE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LO_SLOPE_SCALE_0_LUT_LO_SLOPE_UFLOW_SCALE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LO_SLOPE_SCALE_0_LUT_LO_SLOPE_UFLOW_SCALE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define SDP_S_LUT_LO_SLOPE_SCALE_0_LUT_LO_SLOPE_OFLOW_SCALE_SHIFT \
+	(_MK_SHIFT_CONST(16))
+#define SDP_S_LUT_LO_SLOPE_SCALE_0_LUT_LO_SLOPE_OFLOW_SCALE_FIELD \
+	(_MK_FIELD_CONST(                                         \
+		0xffff,                                           \
+		SDP_S_LUT_LO_SLOPE_SCALE_0_LUT_LO_SLOPE_OFLOW_SCALE_SHIFT))
+#define SDP_S_LUT_LO_SLOPE_SCALE_0_LUT_LO_SLOPE_OFLOW_SCALE_RANGE (31 : 16)
+#define SDP_S_LUT_LO_SLOPE_SCALE_0_LUT_LO_SLOPE_OFLOW_SCALE_WOFFSET (0x0)
+#define SDP_S_LUT_LO_SLOPE_SCALE_0_LUT_LO_SLOPE_OFLOW_SCALE_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LO_SLOPE_SCALE_0_LUT_LO_SLOPE_OFLOW_SCALE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffff))
+#define SDP_S_LUT_LO_SLOPE_SCALE_0_LUT_LO_SLOPE_OFLOW_SCALE_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LO_SLOPE_SCALE_0_LUT_LO_SLOPE_OFLOW_SCALE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LO_SLOPE_SCALE_0_LUT_LO_SLOPE_OFLOW_SCALE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LO_SLOPE_SCALE_0_LUT_LO_SLOPE_OFLOW_SCALE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_S_LUT_LO_SLOPE_SHIFT_0
+#define SDP_S_LUT_LO_SLOPE_SHIFT_0 (_MK_ADDR_CONST(0xb034))
+#define SDP_S_LUT_LO_SLOPE_SHIFT_0_SECURE (0x0)
+#define SDP_S_LUT_LO_SLOPE_SHIFT_0_DUAL (0x0)
+#define SDP_S_LUT_LO_SLOPE_SHIFT_0_SCR (0)
+#define SDP_S_LUT_LO_SLOPE_SHIFT_0_WORD_COUNT (0x1)
+#define SDP_S_LUT_LO_SLOPE_SHIFT_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LO_SLOPE_SHIFT_0_RESET_MASK (_MK_MASK_CONST(0x3ff))
+#define SDP_S_LUT_LO_SLOPE_SHIFT_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LO_SLOPE_SHIFT_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LO_SLOPE_SHIFT_0_READ_MASK (_MK_MASK_CONST(0x3ff))
+#define SDP_S_LUT_LO_SLOPE_SHIFT_0_WRITE_MASK (_MK_MASK_CONST(0x3ff))
+#define SDP_S_LUT_LO_SLOPE_SHIFT_0_LUT_LO_SLOPE_UFLOW_SHIFT_SHIFT \
+	(_MK_SHIFT_CONST(0))
+#define SDP_S_LUT_LO_SLOPE_SHIFT_0_LUT_LO_SLOPE_UFLOW_SHIFT_FIELD \
+	(_MK_FIELD_CONST(                                         \
+		0x1f,                                             \
+		SDP_S_LUT_LO_SLOPE_SHIFT_0_LUT_LO_SLOPE_UFLOW_SHIFT_SHIFT))
+#define SDP_S_LUT_LO_SLOPE_SHIFT_0_LUT_LO_SLOPE_UFLOW_SHIFT_RANGE (4 : 0)
+#define SDP_S_LUT_LO_SLOPE_SHIFT_0_LUT_LO_SLOPE_UFLOW_SHIFT_WOFFSET (0x0)
+#define SDP_S_LUT_LO_SLOPE_SHIFT_0_LUT_LO_SLOPE_UFLOW_SHIFT_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LO_SLOPE_SHIFT_0_LUT_LO_SLOPE_UFLOW_SHIFT_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1f))
+#define SDP_S_LUT_LO_SLOPE_SHIFT_0_LUT_LO_SLOPE_UFLOW_SHIFT_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LO_SLOPE_SHIFT_0_LUT_LO_SLOPE_UFLOW_SHIFT_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LO_SLOPE_SHIFT_0_LUT_LO_SLOPE_UFLOW_SHIFT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LO_SLOPE_SHIFT_0_LUT_LO_SLOPE_UFLOW_SHIFT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define SDP_S_LUT_LO_SLOPE_SHIFT_0_LUT_LO_SLOPE_OFLOW_SHIFT_SHIFT \
+	(_MK_SHIFT_CONST(5))
+#define SDP_S_LUT_LO_SLOPE_SHIFT_0_LUT_LO_SLOPE_OFLOW_SHIFT_FIELD \
+	(_MK_FIELD_CONST(                                         \
+		0x1f,                                             \
+		SDP_S_LUT_LO_SLOPE_SHIFT_0_LUT_LO_SLOPE_OFLOW_SHIFT_SHIFT))
+#define SDP_S_LUT_LO_SLOPE_SHIFT_0_LUT_LO_SLOPE_OFLOW_SHIFT_RANGE (9 : 5)
+#define SDP_S_LUT_LO_SLOPE_SHIFT_0_LUT_LO_SLOPE_OFLOW_SHIFT_WOFFSET (0x0)
+#define SDP_S_LUT_LO_SLOPE_SHIFT_0_LUT_LO_SLOPE_OFLOW_SHIFT_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LO_SLOPE_SHIFT_0_LUT_LO_SLOPE_OFLOW_SHIFT_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1f))
+#define SDP_S_LUT_LO_SLOPE_SHIFT_0_LUT_LO_SLOPE_OFLOW_SHIFT_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LO_SLOPE_SHIFT_0_LUT_LO_SLOPE_OFLOW_SHIFT_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LO_SLOPE_SHIFT_0_LUT_LO_SLOPE_OFLOW_SHIFT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_S_LUT_LO_SLOPE_SHIFT_0_LUT_LO_SLOPE_OFLOW_SHIFT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_D_OP_ENABLE_0
+#define SDP_D_OP_ENABLE_0 (_MK_ADDR_CONST(0xb038))
+#define SDP_D_OP_ENABLE_0_SECURE (0x0)
+#define SDP_D_OP_ENABLE_0_DUAL (0x0)
+#define SDP_D_OP_ENABLE_0_SCR (0)
+#define SDP_D_OP_ENABLE_0_WORD_COUNT (0x1)
+#define SDP_D_OP_ENABLE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_OP_ENABLE_0_RESET_MASK (_MK_MASK_CONST(0x1))
+#define SDP_D_OP_ENABLE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_OP_ENABLE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_OP_ENABLE_0_READ_MASK (_MK_MASK_CONST(0x1))
+#define SDP_D_OP_ENABLE_0_WRITE_MASK (_MK_MASK_CONST(0x1))
+#define SDP_D_OP_ENABLE_0_OP_EN_SHIFT (_MK_SHIFT_CONST(0))
+#define SDP_D_OP_ENABLE_0_OP_EN_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_D_OP_ENABLE_0_OP_EN_SHIFT))
+#define SDP_D_OP_ENABLE_0_OP_EN_RANGE (0 : 0)
+#define SDP_D_OP_ENABLE_0_OP_EN_WOFFSET (0x0)
+#define SDP_D_OP_ENABLE_0_OP_EN_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_OP_ENABLE_0_OP_EN_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define SDP_D_OP_ENABLE_0_OP_EN_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_OP_ENABLE_0_OP_EN_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_OP_ENABLE_0_OP_EN_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define SDP_D_OP_ENABLE_0_OP_EN_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define SDP_D_OP_ENABLE_0_OP_EN_INIT_ENUM (DISABLE)
+#define SDP_D_OP_ENABLE_0_OP_EN_DISABLE (_MK_ENUM_CONST(0))
+#define SDP_D_OP_ENABLE_0_OP_EN_ENABLE (_MK_ENUM_CONST(1))
+
+// Register SDP_D_DATA_CUBE_WIDTH_0
+#define SDP_D_DATA_CUBE_WIDTH_0 (_MK_ADDR_CONST(0xb03c))
+#define SDP_D_DATA_CUBE_WIDTH_0_SECURE (0x0)
+#define SDP_D_DATA_CUBE_WIDTH_0_DUAL (0x0)
+#define SDP_D_DATA_CUBE_WIDTH_0_SCR (0)
+#define SDP_D_DATA_CUBE_WIDTH_0_WORD_COUNT (0x1)
+#define SDP_D_DATA_CUBE_WIDTH_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DATA_CUBE_WIDTH_0_RESET_MASK (_MK_MASK_CONST(0x1fff))
+#define SDP_D_DATA_CUBE_WIDTH_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DATA_CUBE_WIDTH_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_DATA_CUBE_WIDTH_0_READ_MASK (_MK_MASK_CONST(0x1fff))
+#define SDP_D_DATA_CUBE_WIDTH_0_WRITE_MASK (_MK_MASK_CONST(0x1fff))
+#define SDP_D_DATA_CUBE_WIDTH_0_WIDTH_SHIFT (_MK_SHIFT_CONST(0))
+#define SDP_D_DATA_CUBE_WIDTH_0_WIDTH_FIELD \
+	(_MK_FIELD_CONST(0x1fff, SDP_D_DATA_CUBE_WIDTH_0_WIDTH_SHIFT))
+#define SDP_D_DATA_CUBE_WIDTH_0_WIDTH_RANGE (12 : 0)
+#define SDP_D_DATA_CUBE_WIDTH_0_WIDTH_WOFFSET (0x0)
+#define SDP_D_DATA_CUBE_WIDTH_0_WIDTH_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DATA_CUBE_WIDTH_0_WIDTH_DEFAULT_MASK (_MK_MASK_CONST(0x1fff))
+#define SDP_D_DATA_CUBE_WIDTH_0_WIDTH_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DATA_CUBE_WIDTH_0_WIDTH_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_DATA_CUBE_WIDTH_0_WIDTH_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define SDP_D_DATA_CUBE_WIDTH_0_WIDTH_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+// Register SDP_D_DATA_CUBE_HEIGHT_0
+#define SDP_D_DATA_CUBE_HEIGHT_0 (_MK_ADDR_CONST(0xb040))
+#define SDP_D_DATA_CUBE_HEIGHT_0_SECURE (0x0)
+#define SDP_D_DATA_CUBE_HEIGHT_0_DUAL (0x0)
+#define SDP_D_DATA_CUBE_HEIGHT_0_SCR (0)
+#define SDP_D_DATA_CUBE_HEIGHT_0_WORD_COUNT (0x1)
+#define SDP_D_DATA_CUBE_HEIGHT_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DATA_CUBE_HEIGHT_0_RESET_MASK (_MK_MASK_CONST(0x1fff))
+#define SDP_D_DATA_CUBE_HEIGHT_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DATA_CUBE_HEIGHT_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_DATA_CUBE_HEIGHT_0_READ_MASK (_MK_MASK_CONST(0x1fff))
+#define SDP_D_DATA_CUBE_HEIGHT_0_WRITE_MASK (_MK_MASK_CONST(0x1fff))
+#define SDP_D_DATA_CUBE_HEIGHT_0_HEIGHT_SHIFT (_MK_SHIFT_CONST(0))
+#define SDP_D_DATA_CUBE_HEIGHT_0_HEIGHT_FIELD \
+	(_MK_FIELD_CONST(0x1fff, SDP_D_DATA_CUBE_HEIGHT_0_HEIGHT_SHIFT))
+#define SDP_D_DATA_CUBE_HEIGHT_0_HEIGHT_RANGE (12 : 0)
+#define SDP_D_DATA_CUBE_HEIGHT_0_HEIGHT_WOFFSET (0x0)
+#define SDP_D_DATA_CUBE_HEIGHT_0_HEIGHT_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DATA_CUBE_HEIGHT_0_HEIGHT_DEFAULT_MASK (_MK_MASK_CONST(0x1fff))
+#define SDP_D_DATA_CUBE_HEIGHT_0_HEIGHT_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DATA_CUBE_HEIGHT_0_HEIGHT_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_DATA_CUBE_HEIGHT_0_HEIGHT_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define SDP_D_DATA_CUBE_HEIGHT_0_HEIGHT_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+// Register SDP_D_DATA_CUBE_CHANNEL_0
+#define SDP_D_DATA_CUBE_CHANNEL_0 (_MK_ADDR_CONST(0xb044))
+#define SDP_D_DATA_CUBE_CHANNEL_0_SECURE (0x0)
+#define SDP_D_DATA_CUBE_CHANNEL_0_DUAL (0x0)
+#define SDP_D_DATA_CUBE_CHANNEL_0_SCR (0)
+#define SDP_D_DATA_CUBE_CHANNEL_0_WORD_COUNT (0x1)
+#define SDP_D_DATA_CUBE_CHANNEL_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DATA_CUBE_CHANNEL_0_RESET_MASK (_MK_MASK_CONST(0x1fff))
+#define SDP_D_DATA_CUBE_CHANNEL_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DATA_CUBE_CHANNEL_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_DATA_CUBE_CHANNEL_0_READ_MASK (_MK_MASK_CONST(0x1fff))
+#define SDP_D_DATA_CUBE_CHANNEL_0_WRITE_MASK (_MK_MASK_CONST(0x1fff))
+#define SDP_D_DATA_CUBE_CHANNEL_0_CHANNEL_SHIFT (_MK_SHIFT_CONST(0))
+#define SDP_D_DATA_CUBE_CHANNEL_0_CHANNEL_FIELD \
+	(_MK_FIELD_CONST(0x1fff, SDP_D_DATA_CUBE_CHANNEL_0_CHANNEL_SHIFT))
+#define SDP_D_DATA_CUBE_CHANNEL_0_CHANNEL_RANGE (12 : 0)
+#define SDP_D_DATA_CUBE_CHANNEL_0_CHANNEL_WOFFSET (0x0)
+#define SDP_D_DATA_CUBE_CHANNEL_0_CHANNEL_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DATA_CUBE_CHANNEL_0_CHANNEL_DEFAULT_MASK (_MK_MASK_CONST(0x1fff))
+#define SDP_D_DATA_CUBE_CHANNEL_0_CHANNEL_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DATA_CUBE_CHANNEL_0_CHANNEL_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_DATA_CUBE_CHANNEL_0_CHANNEL_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DATA_CUBE_CHANNEL_0_CHANNEL_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_D_DST_BASE_ADDR_LOW_0
+#define SDP_D_DST_BASE_ADDR_LOW_0 (_MK_ADDR_CONST(0xb048))
+#define SDP_D_DST_BASE_ADDR_LOW_0_SECURE (0x0)
+#define SDP_D_DST_BASE_ADDR_LOW_0_DUAL (0x0)
+#define SDP_D_DST_BASE_ADDR_LOW_0_SCR (0)
+#define SDP_D_DST_BASE_ADDR_LOW_0_WORD_COUNT (0x1)
+#define SDP_D_DST_BASE_ADDR_LOW_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DST_BASE_ADDR_LOW_0_RESET_MASK (_MK_MASK_CONST(0xffffffe0))
+#define SDP_D_DST_BASE_ADDR_LOW_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DST_BASE_ADDR_LOW_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_DST_BASE_ADDR_LOW_0_READ_MASK (_MK_MASK_CONST(0xffffffe0))
+#define SDP_D_DST_BASE_ADDR_LOW_0_WRITE_MASK (_MK_MASK_CONST(0xffffffe0))
+#define SDP_D_DST_BASE_ADDR_LOW_0_DST_BASE_ADDR_LOW_SHIFT (_MK_SHIFT_CONST(5))
+#define SDP_D_DST_BASE_ADDR_LOW_0_DST_BASE_ADDR_LOW_FIELD \
+	(_MK_FIELD_CONST(0x7ffffff,                       \
+			 SDP_D_DST_BASE_ADDR_LOW_0_DST_BASE_ADDR_LOW_SHIFT))
+#define SDP_D_DST_BASE_ADDR_LOW_0_DST_BASE_ADDR_LOW_RANGE (31 : 5)
+#define SDP_D_DST_BASE_ADDR_LOW_0_DST_BASE_ADDR_LOW_WOFFSET (0x0)
+#define SDP_D_DST_BASE_ADDR_LOW_0_DST_BASE_ADDR_LOW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DST_BASE_ADDR_LOW_0_DST_BASE_ADDR_LOW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffffff))
+#define SDP_D_DST_BASE_ADDR_LOW_0_DST_BASE_ADDR_LOW_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DST_BASE_ADDR_LOW_0_DST_BASE_ADDR_LOW_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DST_BASE_ADDR_LOW_0_DST_BASE_ADDR_LOW_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DST_BASE_ADDR_LOW_0_DST_BASE_ADDR_LOW_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_D_DST_BASE_ADDR_HIGH_0
+#define SDP_D_DST_BASE_ADDR_HIGH_0 (_MK_ADDR_CONST(0xb04c))
+#define SDP_D_DST_BASE_ADDR_HIGH_0_SECURE (0x0)
+#define SDP_D_DST_BASE_ADDR_HIGH_0_DUAL (0x0)
+#define SDP_D_DST_BASE_ADDR_HIGH_0_SCR (0)
+#define SDP_D_DST_BASE_ADDR_HIGH_0_WORD_COUNT (0x1)
+#define SDP_D_DST_BASE_ADDR_HIGH_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DST_BASE_ADDR_HIGH_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_D_DST_BASE_ADDR_HIGH_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DST_BASE_ADDR_HIGH_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_DST_BASE_ADDR_HIGH_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_D_DST_BASE_ADDR_HIGH_0_WRITE_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_D_DST_BASE_ADDR_HIGH_0_DST_BASE_ADDR_HIGH_SHIFT (_MK_SHIFT_CONST(0))
+#define SDP_D_DST_BASE_ADDR_HIGH_0_DST_BASE_ADDR_HIGH_FIELD \
+	(_MK_FIELD_CONST(0xffffffff,                        \
+			 SDP_D_DST_BASE_ADDR_HIGH_0_DST_BASE_ADDR_HIGH_SHIFT))
+#define SDP_D_DST_BASE_ADDR_HIGH_0_DST_BASE_ADDR_HIGH_RANGE (31 : 0)
+#define SDP_D_DST_BASE_ADDR_HIGH_0_DST_BASE_ADDR_HIGH_WOFFSET (0x0)
+#define SDP_D_DST_BASE_ADDR_HIGH_0_DST_BASE_ADDR_HIGH_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DST_BASE_ADDR_HIGH_0_DST_BASE_ADDR_HIGH_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define SDP_D_DST_BASE_ADDR_HIGH_0_DST_BASE_ADDR_HIGH_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DST_BASE_ADDR_HIGH_0_DST_BASE_ADDR_HIGH_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DST_BASE_ADDR_HIGH_0_DST_BASE_ADDR_HIGH_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DST_BASE_ADDR_HIGH_0_DST_BASE_ADDR_HIGH_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_D_DST_LINE_STRIDE_0
+#define SDP_D_DST_LINE_STRIDE_0 (_MK_ADDR_CONST(0xb050))
+#define SDP_D_DST_LINE_STRIDE_0_SECURE (0x0)
+#define SDP_D_DST_LINE_STRIDE_0_DUAL (0x0)
+#define SDP_D_DST_LINE_STRIDE_0_SCR (0)
+#define SDP_D_DST_LINE_STRIDE_0_WORD_COUNT (0x1)
+#define SDP_D_DST_LINE_STRIDE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DST_LINE_STRIDE_0_RESET_MASK (_MK_MASK_CONST(0xffffffe0))
+#define SDP_D_DST_LINE_STRIDE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DST_LINE_STRIDE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_DST_LINE_STRIDE_0_READ_MASK (_MK_MASK_CONST(0xffffffe0))
+#define SDP_D_DST_LINE_STRIDE_0_WRITE_MASK (_MK_MASK_CONST(0xffffffe0))
+#define SDP_D_DST_LINE_STRIDE_0_DST_LINE_STRIDE_SHIFT (_MK_SHIFT_CONST(5))
+#define SDP_D_DST_LINE_STRIDE_0_DST_LINE_STRIDE_FIELD \
+	(_MK_FIELD_CONST(0x7ffffff,                   \
+			 SDP_D_DST_LINE_STRIDE_0_DST_LINE_STRIDE_SHIFT))
+#define SDP_D_DST_LINE_STRIDE_0_DST_LINE_STRIDE_RANGE (31 : 5)
+#define SDP_D_DST_LINE_STRIDE_0_DST_LINE_STRIDE_WOFFSET (0x0)
+#define SDP_D_DST_LINE_STRIDE_0_DST_LINE_STRIDE_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DST_LINE_STRIDE_0_DST_LINE_STRIDE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffffff))
+#define SDP_D_DST_LINE_STRIDE_0_DST_LINE_STRIDE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DST_LINE_STRIDE_0_DST_LINE_STRIDE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DST_LINE_STRIDE_0_DST_LINE_STRIDE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DST_LINE_STRIDE_0_DST_LINE_STRIDE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_D_DST_SURFACE_STRIDE_0
+#define SDP_D_DST_SURFACE_STRIDE_0 (_MK_ADDR_CONST(0xb054))
+#define SDP_D_DST_SURFACE_STRIDE_0_SECURE (0x0)
+#define SDP_D_DST_SURFACE_STRIDE_0_DUAL (0x0)
+#define SDP_D_DST_SURFACE_STRIDE_0_SCR (0)
+#define SDP_D_DST_SURFACE_STRIDE_0_WORD_COUNT (0x1)
+#define SDP_D_DST_SURFACE_STRIDE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DST_SURFACE_STRIDE_0_RESET_MASK (_MK_MASK_CONST(0xffffffe0))
+#define SDP_D_DST_SURFACE_STRIDE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DST_SURFACE_STRIDE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_DST_SURFACE_STRIDE_0_READ_MASK (_MK_MASK_CONST(0xffffffe0))
+#define SDP_D_DST_SURFACE_STRIDE_0_WRITE_MASK (_MK_MASK_CONST(0xffffffe0))
+#define SDP_D_DST_SURFACE_STRIDE_0_DST_SURFACE_STRIDE_SHIFT (_MK_SHIFT_CONST(5))
+#define SDP_D_DST_SURFACE_STRIDE_0_DST_SURFACE_STRIDE_FIELD \
+	(_MK_FIELD_CONST(0x7ffffff,                         \
+			 SDP_D_DST_SURFACE_STRIDE_0_DST_SURFACE_STRIDE_SHIFT))
+#define SDP_D_DST_SURFACE_STRIDE_0_DST_SURFACE_STRIDE_RANGE (31 : 5)
+#define SDP_D_DST_SURFACE_STRIDE_0_DST_SURFACE_STRIDE_WOFFSET (0x0)
+#define SDP_D_DST_SURFACE_STRIDE_0_DST_SURFACE_STRIDE_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DST_SURFACE_STRIDE_0_DST_SURFACE_STRIDE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffffff))
+#define SDP_D_DST_SURFACE_STRIDE_0_DST_SURFACE_STRIDE_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DST_SURFACE_STRIDE_0_DST_SURFACE_STRIDE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DST_SURFACE_STRIDE_0_DST_SURFACE_STRIDE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DST_SURFACE_STRIDE_0_DST_SURFACE_STRIDE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_D_DP_BS_CFG_0
+#define SDP_D_DP_BS_CFG_0 (_MK_ADDR_CONST(0xb058))
+#define SDP_D_DP_BS_CFG_0_SECURE (0x0)
+#define SDP_D_DP_BS_CFG_0_DUAL (0x0)
+#define SDP_D_DP_BS_CFG_0_SCR (0)
+#define SDP_D_DP_BS_CFG_0_WORD_COUNT (0x1)
+#define SDP_D_DP_BS_CFG_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_CFG_0_RESET_MASK (_MK_MASK_CONST(0x7f))
+#define SDP_D_DP_BS_CFG_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_CFG_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_CFG_0_READ_MASK (_MK_MASK_CONST(0x7f))
+#define SDP_D_DP_BS_CFG_0_WRITE_MASK (_MK_MASK_CONST(0x7f))
+#define SDP_D_DP_BS_CFG_0_BS_BYPASS_SHIFT (_MK_SHIFT_CONST(0))
+#define SDP_D_DP_BS_CFG_0_BS_BYPASS_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_D_DP_BS_CFG_0_BS_BYPASS_SHIFT))
+#define SDP_D_DP_BS_CFG_0_BS_BYPASS_RANGE (0 : 0)
+#define SDP_D_DP_BS_CFG_0_BS_BYPASS_WOFFSET (0x0)
+#define SDP_D_DP_BS_CFG_0_BS_BYPASS_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_CFG_0_BS_BYPASS_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define SDP_D_DP_BS_CFG_0_BS_BYPASS_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_CFG_0_BS_BYPASS_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_CFG_0_BS_BYPASS_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_CFG_0_BS_BYPASS_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define SDP_D_DP_BS_CFG_0_BS_BYPASS_NO (_MK_ENUM_CONST(0))
+#define SDP_D_DP_BS_CFG_0_BS_BYPASS_YES (_MK_ENUM_CONST(1))
+
+#define SDP_D_DP_BS_CFG_0_BS_ALU_BYPASS_SHIFT (_MK_SHIFT_CONST(1))
+#define SDP_D_DP_BS_CFG_0_BS_ALU_BYPASS_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_D_DP_BS_CFG_0_BS_ALU_BYPASS_SHIFT))
+#define SDP_D_DP_BS_CFG_0_BS_ALU_BYPASS_RANGE (1 : 1)
+#define SDP_D_DP_BS_CFG_0_BS_ALU_BYPASS_WOFFSET (0x0)
+#define SDP_D_DP_BS_CFG_0_BS_ALU_BYPASS_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_CFG_0_BS_ALU_BYPASS_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define SDP_D_DP_BS_CFG_0_BS_ALU_BYPASS_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_CFG_0_BS_ALU_BYPASS_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_CFG_0_BS_ALU_BYPASS_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_CFG_0_BS_ALU_BYPASS_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define SDP_D_DP_BS_CFG_0_BS_ALU_BYPASS_NO (_MK_ENUM_CONST(0))
+#define SDP_D_DP_BS_CFG_0_BS_ALU_BYPASS_YES (_MK_ENUM_CONST(1))
+
+#define SDP_D_DP_BS_CFG_0_BS_ALU_ALGO_SHIFT (_MK_SHIFT_CONST(2))
+#define SDP_D_DP_BS_CFG_0_BS_ALU_ALGO_FIELD \
+	(_MK_FIELD_CONST(0x3, SDP_D_DP_BS_CFG_0_BS_ALU_ALGO_SHIFT))
+#define SDP_D_DP_BS_CFG_0_BS_ALU_ALGO_RANGE (3 : 2)
+#define SDP_D_DP_BS_CFG_0_BS_ALU_ALGO_WOFFSET (0x0)
+#define SDP_D_DP_BS_CFG_0_BS_ALU_ALGO_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_CFG_0_BS_ALU_ALGO_DEFAULT_MASK (_MK_MASK_CONST(0x3))
+#define SDP_D_DP_BS_CFG_0_BS_ALU_ALGO_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_CFG_0_BS_ALU_ALGO_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_CFG_0_BS_ALU_ALGO_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_CFG_0_BS_ALU_ALGO_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define SDP_D_DP_BS_CFG_0_BS_ALU_ALGO_MAX (_MK_ENUM_CONST(0))
+#define SDP_D_DP_BS_CFG_0_BS_ALU_ALGO_MIN (_MK_ENUM_CONST(1))
+#define SDP_D_DP_BS_CFG_0_BS_ALU_ALGO_SUM (_MK_ENUM_CONST(2))
+
+#define SDP_D_DP_BS_CFG_0_BS_MUL_BYPASS_SHIFT (_MK_SHIFT_CONST(4))
+#define SDP_D_DP_BS_CFG_0_BS_MUL_BYPASS_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_D_DP_BS_CFG_0_BS_MUL_BYPASS_SHIFT))
+#define SDP_D_DP_BS_CFG_0_BS_MUL_BYPASS_RANGE (4 : 4)
+#define SDP_D_DP_BS_CFG_0_BS_MUL_BYPASS_WOFFSET (0x0)
+#define SDP_D_DP_BS_CFG_0_BS_MUL_BYPASS_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_CFG_0_BS_MUL_BYPASS_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define SDP_D_DP_BS_CFG_0_BS_MUL_BYPASS_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_CFG_0_BS_MUL_BYPASS_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_CFG_0_BS_MUL_BYPASS_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_CFG_0_BS_MUL_BYPASS_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define SDP_D_DP_BS_CFG_0_BS_MUL_BYPASS_NO (_MK_ENUM_CONST(0))
+#define SDP_D_DP_BS_CFG_0_BS_MUL_BYPASS_YES (_MK_ENUM_CONST(1))
+
+#define SDP_D_DP_BS_CFG_0_BS_MUL_PRELU_SHIFT (_MK_SHIFT_CONST(5))
+#define SDP_D_DP_BS_CFG_0_BS_MUL_PRELU_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_D_DP_BS_CFG_0_BS_MUL_PRELU_SHIFT))
+#define SDP_D_DP_BS_CFG_0_BS_MUL_PRELU_RANGE (5 : 5)
+#define SDP_D_DP_BS_CFG_0_BS_MUL_PRELU_WOFFSET (0x0)
+#define SDP_D_DP_BS_CFG_0_BS_MUL_PRELU_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_CFG_0_BS_MUL_PRELU_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define SDP_D_DP_BS_CFG_0_BS_MUL_PRELU_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_CFG_0_BS_MUL_PRELU_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_CFG_0_BS_MUL_PRELU_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_CFG_0_BS_MUL_PRELU_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define SDP_D_DP_BS_CFG_0_BS_MUL_PRELU_NO (_MK_ENUM_CONST(0))
+#define SDP_D_DP_BS_CFG_0_BS_MUL_PRELU_YES (_MK_ENUM_CONST(1))
+
+#define SDP_D_DP_BS_CFG_0_BS_RELU_BYPASS_SHIFT (_MK_SHIFT_CONST(6))
+#define SDP_D_DP_BS_CFG_0_BS_RELU_BYPASS_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_D_DP_BS_CFG_0_BS_RELU_BYPASS_SHIFT))
+#define SDP_D_DP_BS_CFG_0_BS_RELU_BYPASS_RANGE (6 : 6)
+#define SDP_D_DP_BS_CFG_0_BS_RELU_BYPASS_WOFFSET (0x0)
+#define SDP_D_DP_BS_CFG_0_BS_RELU_BYPASS_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_CFG_0_BS_RELU_BYPASS_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define SDP_D_DP_BS_CFG_0_BS_RELU_BYPASS_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_CFG_0_BS_RELU_BYPASS_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_CFG_0_BS_RELU_BYPASS_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_CFG_0_BS_RELU_BYPASS_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define SDP_D_DP_BS_CFG_0_BS_RELU_BYPASS_NO (_MK_ENUM_CONST(0))
+#define SDP_D_DP_BS_CFG_0_BS_RELU_BYPASS_YES (_MK_ENUM_CONST(1))
+
+// Register SDP_D_DP_BS_ALU_CFG_0
+#define SDP_D_DP_BS_ALU_CFG_0 (_MK_ADDR_CONST(0xb05c))
+#define SDP_D_DP_BS_ALU_CFG_0_SECURE (0x0)
+#define SDP_D_DP_BS_ALU_CFG_0_DUAL (0x0)
+#define SDP_D_DP_BS_ALU_CFG_0_SCR (0)
+#define SDP_D_DP_BS_ALU_CFG_0_WORD_COUNT (0x1)
+#define SDP_D_DP_BS_ALU_CFG_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_ALU_CFG_0_RESET_MASK (_MK_MASK_CONST(0x3f01))
+#define SDP_D_DP_BS_ALU_CFG_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_ALU_CFG_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_ALU_CFG_0_READ_MASK (_MK_MASK_CONST(0x3f01))
+#define SDP_D_DP_BS_ALU_CFG_0_WRITE_MASK (_MK_MASK_CONST(0x3f01))
+#define SDP_D_DP_BS_ALU_CFG_0_BS_ALU_SRC_SHIFT (_MK_SHIFT_CONST(0))
+#define SDP_D_DP_BS_ALU_CFG_0_BS_ALU_SRC_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_D_DP_BS_ALU_CFG_0_BS_ALU_SRC_SHIFT))
+#define SDP_D_DP_BS_ALU_CFG_0_BS_ALU_SRC_RANGE (0 : 0)
+#define SDP_D_DP_BS_ALU_CFG_0_BS_ALU_SRC_WOFFSET (0x0)
+#define SDP_D_DP_BS_ALU_CFG_0_BS_ALU_SRC_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_ALU_CFG_0_BS_ALU_SRC_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define SDP_D_DP_BS_ALU_CFG_0_BS_ALU_SRC_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_ALU_CFG_0_BS_ALU_SRC_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_ALU_CFG_0_BS_ALU_SRC_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_ALU_CFG_0_BS_ALU_SRC_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define SDP_D_DP_BS_ALU_CFG_0_BS_ALU_SRC_REG (_MK_ENUM_CONST(0))
+#define SDP_D_DP_BS_ALU_CFG_0_BS_ALU_SRC_MEM (_MK_ENUM_CONST(1))
+
+#define SDP_D_DP_BS_ALU_CFG_0_BS_ALU_SHIFT_VALUE_SHIFT (_MK_SHIFT_CONST(8))
+#define SDP_D_DP_BS_ALU_CFG_0_BS_ALU_SHIFT_VALUE_FIELD \
+	(_MK_FIELD_CONST(0x3f, SDP_D_DP_BS_ALU_CFG_0_BS_ALU_SHIFT_VALUE_SHIFT))
+#define SDP_D_DP_BS_ALU_CFG_0_BS_ALU_SHIFT_VALUE_RANGE (13 : 8)
+#define SDP_D_DP_BS_ALU_CFG_0_BS_ALU_SHIFT_VALUE_WOFFSET (0x0)
+#define SDP_D_DP_BS_ALU_CFG_0_BS_ALU_SHIFT_VALUE_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_ALU_CFG_0_BS_ALU_SHIFT_VALUE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x3f))
+#define SDP_D_DP_BS_ALU_CFG_0_BS_ALU_SHIFT_VALUE_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_ALU_CFG_0_BS_ALU_SHIFT_VALUE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_ALU_CFG_0_BS_ALU_SHIFT_VALUE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_ALU_CFG_0_BS_ALU_SHIFT_VALUE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_D_DP_BS_ALU_SRC_VALUE_0
+#define SDP_D_DP_BS_ALU_SRC_VALUE_0 (_MK_ADDR_CONST(0xb060))
+#define SDP_D_DP_BS_ALU_SRC_VALUE_0_SECURE (0x0)
+#define SDP_D_DP_BS_ALU_SRC_VALUE_0_DUAL (0x0)
+#define SDP_D_DP_BS_ALU_SRC_VALUE_0_SCR (0)
+#define SDP_D_DP_BS_ALU_SRC_VALUE_0_WORD_COUNT (0x1)
+#define SDP_D_DP_BS_ALU_SRC_VALUE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_ALU_SRC_VALUE_0_RESET_MASK (_MK_MASK_CONST(0xffff))
+#define SDP_D_DP_BS_ALU_SRC_VALUE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_ALU_SRC_VALUE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_ALU_SRC_VALUE_0_READ_MASK (_MK_MASK_CONST(0xffff))
+#define SDP_D_DP_BS_ALU_SRC_VALUE_0_WRITE_MASK (_MK_MASK_CONST(0xffff))
+#define SDP_D_DP_BS_ALU_SRC_VALUE_0_BS_ALU_OPERAND_SHIFT (_MK_SHIFT_CONST(0))
+#define SDP_D_DP_BS_ALU_SRC_VALUE_0_BS_ALU_OPERAND_FIELD \
+	(_MK_FIELD_CONST(0xffff,                         \
+			 SDP_D_DP_BS_ALU_SRC_VALUE_0_BS_ALU_OPERAND_SHIFT))
+#define SDP_D_DP_BS_ALU_SRC_VALUE_0_BS_ALU_OPERAND_RANGE (15 : 0)
+#define SDP_D_DP_BS_ALU_SRC_VALUE_0_BS_ALU_OPERAND_WOFFSET (0x0)
+#define SDP_D_DP_BS_ALU_SRC_VALUE_0_BS_ALU_OPERAND_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_ALU_SRC_VALUE_0_BS_ALU_OPERAND_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffff))
+#define SDP_D_DP_BS_ALU_SRC_VALUE_0_BS_ALU_OPERAND_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_ALU_SRC_VALUE_0_BS_ALU_OPERAND_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_ALU_SRC_VALUE_0_BS_ALU_OPERAND_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_ALU_SRC_VALUE_0_BS_ALU_OPERAND_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_D_DP_BS_MUL_CFG_0
+#define SDP_D_DP_BS_MUL_CFG_0 (_MK_ADDR_CONST(0xb064))
+#define SDP_D_DP_BS_MUL_CFG_0_SECURE (0x0)
+#define SDP_D_DP_BS_MUL_CFG_0_DUAL (0x0)
+#define SDP_D_DP_BS_MUL_CFG_0_SCR (0)
+#define SDP_D_DP_BS_MUL_CFG_0_WORD_COUNT (0x1)
+#define SDP_D_DP_BS_MUL_CFG_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_MUL_CFG_0_RESET_MASK (_MK_MASK_CONST(0xff01))
+#define SDP_D_DP_BS_MUL_CFG_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_MUL_CFG_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_MUL_CFG_0_READ_MASK (_MK_MASK_CONST(0xff01))
+#define SDP_D_DP_BS_MUL_CFG_0_WRITE_MASK (_MK_MASK_CONST(0xff01))
+#define SDP_D_DP_BS_MUL_CFG_0_BS_MUL_SRC_SHIFT (_MK_SHIFT_CONST(0))
+#define SDP_D_DP_BS_MUL_CFG_0_BS_MUL_SRC_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_D_DP_BS_MUL_CFG_0_BS_MUL_SRC_SHIFT))
+#define SDP_D_DP_BS_MUL_CFG_0_BS_MUL_SRC_RANGE (0 : 0)
+#define SDP_D_DP_BS_MUL_CFG_0_BS_MUL_SRC_WOFFSET (0x0)
+#define SDP_D_DP_BS_MUL_CFG_0_BS_MUL_SRC_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_MUL_CFG_0_BS_MUL_SRC_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define SDP_D_DP_BS_MUL_CFG_0_BS_MUL_SRC_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_MUL_CFG_0_BS_MUL_SRC_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_MUL_CFG_0_BS_MUL_SRC_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_MUL_CFG_0_BS_MUL_SRC_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define SDP_D_DP_BS_MUL_CFG_0_BS_MUL_SRC_REG (_MK_ENUM_CONST(0))
+#define SDP_D_DP_BS_MUL_CFG_0_BS_MUL_SRC_MEM (_MK_ENUM_CONST(1))
+
+#define SDP_D_DP_BS_MUL_CFG_0_BS_MUL_SHIFT_VALUE_SHIFT (_MK_SHIFT_CONST(8))
+#define SDP_D_DP_BS_MUL_CFG_0_BS_MUL_SHIFT_VALUE_FIELD \
+	(_MK_FIELD_CONST(0xff, SDP_D_DP_BS_MUL_CFG_0_BS_MUL_SHIFT_VALUE_SHIFT))
+#define SDP_D_DP_BS_MUL_CFG_0_BS_MUL_SHIFT_VALUE_RANGE (15 : 8)
+#define SDP_D_DP_BS_MUL_CFG_0_BS_MUL_SHIFT_VALUE_WOFFSET (0x0)
+#define SDP_D_DP_BS_MUL_CFG_0_BS_MUL_SHIFT_VALUE_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_MUL_CFG_0_BS_MUL_SHIFT_VALUE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xff))
+#define SDP_D_DP_BS_MUL_CFG_0_BS_MUL_SHIFT_VALUE_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_MUL_CFG_0_BS_MUL_SHIFT_VALUE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_MUL_CFG_0_BS_MUL_SHIFT_VALUE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_MUL_CFG_0_BS_MUL_SHIFT_VALUE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_D_DP_BS_MUL_SRC_VALUE_0
+#define SDP_D_DP_BS_MUL_SRC_VALUE_0 (_MK_ADDR_CONST(0xb068))
+#define SDP_D_DP_BS_MUL_SRC_VALUE_0_SECURE (0x0)
+#define SDP_D_DP_BS_MUL_SRC_VALUE_0_DUAL (0x0)
+#define SDP_D_DP_BS_MUL_SRC_VALUE_0_SCR (0)
+#define SDP_D_DP_BS_MUL_SRC_VALUE_0_WORD_COUNT (0x1)
+#define SDP_D_DP_BS_MUL_SRC_VALUE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_MUL_SRC_VALUE_0_RESET_MASK (_MK_MASK_CONST(0xffff))
+#define SDP_D_DP_BS_MUL_SRC_VALUE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_MUL_SRC_VALUE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_MUL_SRC_VALUE_0_READ_MASK (_MK_MASK_CONST(0xffff))
+#define SDP_D_DP_BS_MUL_SRC_VALUE_0_WRITE_MASK (_MK_MASK_CONST(0xffff))
+#define SDP_D_DP_BS_MUL_SRC_VALUE_0_BS_MUL_OPERAND_SHIFT (_MK_SHIFT_CONST(0))
+#define SDP_D_DP_BS_MUL_SRC_VALUE_0_BS_MUL_OPERAND_FIELD \
+	(_MK_FIELD_CONST(0xffff,                         \
+			 SDP_D_DP_BS_MUL_SRC_VALUE_0_BS_MUL_OPERAND_SHIFT))
+#define SDP_D_DP_BS_MUL_SRC_VALUE_0_BS_MUL_OPERAND_RANGE (15 : 0)
+#define SDP_D_DP_BS_MUL_SRC_VALUE_0_BS_MUL_OPERAND_WOFFSET (0x0)
+#define SDP_D_DP_BS_MUL_SRC_VALUE_0_BS_MUL_OPERAND_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_MUL_SRC_VALUE_0_BS_MUL_OPERAND_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffff))
+#define SDP_D_DP_BS_MUL_SRC_VALUE_0_BS_MUL_OPERAND_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_MUL_SRC_VALUE_0_BS_MUL_OPERAND_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_MUL_SRC_VALUE_0_BS_MUL_OPERAND_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BS_MUL_SRC_VALUE_0_BS_MUL_OPERAND_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_D_DP_BN_CFG_0
+#define SDP_D_DP_BN_CFG_0 (_MK_ADDR_CONST(0xb06c))
+#define SDP_D_DP_BN_CFG_0_SECURE (0x0)
+#define SDP_D_DP_BN_CFG_0_DUAL (0x0)
+#define SDP_D_DP_BN_CFG_0_SCR (0)
+#define SDP_D_DP_BN_CFG_0_WORD_COUNT (0x1)
+#define SDP_D_DP_BN_CFG_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_CFG_0_RESET_MASK (_MK_MASK_CONST(0x7f))
+#define SDP_D_DP_BN_CFG_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_CFG_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_CFG_0_READ_MASK (_MK_MASK_CONST(0x7f))
+#define SDP_D_DP_BN_CFG_0_WRITE_MASK (_MK_MASK_CONST(0x7f))
+#define SDP_D_DP_BN_CFG_0_BN_BYPASS_SHIFT (_MK_SHIFT_CONST(0))
+#define SDP_D_DP_BN_CFG_0_BN_BYPASS_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_D_DP_BN_CFG_0_BN_BYPASS_SHIFT))
+#define SDP_D_DP_BN_CFG_0_BN_BYPASS_RANGE (0 : 0)
+#define SDP_D_DP_BN_CFG_0_BN_BYPASS_WOFFSET (0x0)
+#define SDP_D_DP_BN_CFG_0_BN_BYPASS_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_CFG_0_BN_BYPASS_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define SDP_D_DP_BN_CFG_0_BN_BYPASS_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_CFG_0_BN_BYPASS_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_CFG_0_BN_BYPASS_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_CFG_0_BN_BYPASS_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define SDP_D_DP_BN_CFG_0_BN_BYPASS_NO (_MK_ENUM_CONST(0))
+#define SDP_D_DP_BN_CFG_0_BN_BYPASS_YES (_MK_ENUM_CONST(1))
+
+#define SDP_D_DP_BN_CFG_0_BN_ALU_BYPASS_SHIFT (_MK_SHIFT_CONST(1))
+#define SDP_D_DP_BN_CFG_0_BN_ALU_BYPASS_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_D_DP_BN_CFG_0_BN_ALU_BYPASS_SHIFT))
+#define SDP_D_DP_BN_CFG_0_BN_ALU_BYPASS_RANGE (1 : 1)
+#define SDP_D_DP_BN_CFG_0_BN_ALU_BYPASS_WOFFSET (0x0)
+#define SDP_D_DP_BN_CFG_0_BN_ALU_BYPASS_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_CFG_0_BN_ALU_BYPASS_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define SDP_D_DP_BN_CFG_0_BN_ALU_BYPASS_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_CFG_0_BN_ALU_BYPASS_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_CFG_0_BN_ALU_BYPASS_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_CFG_0_BN_ALU_BYPASS_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define SDP_D_DP_BN_CFG_0_BN_ALU_BYPASS_NO (_MK_ENUM_CONST(0))
+#define SDP_D_DP_BN_CFG_0_BN_ALU_BYPASS_YES (_MK_ENUM_CONST(1))
+
+#define SDP_D_DP_BN_CFG_0_BN_ALU_ALGO_SHIFT (_MK_SHIFT_CONST(2))
+#define SDP_D_DP_BN_CFG_0_BN_ALU_ALGO_FIELD \
+	(_MK_FIELD_CONST(0x3, SDP_D_DP_BN_CFG_0_BN_ALU_ALGO_SHIFT))
+#define SDP_D_DP_BN_CFG_0_BN_ALU_ALGO_RANGE (3 : 2)
+#define SDP_D_DP_BN_CFG_0_BN_ALU_ALGO_WOFFSET (0x0)
+#define SDP_D_DP_BN_CFG_0_BN_ALU_ALGO_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_CFG_0_BN_ALU_ALGO_DEFAULT_MASK (_MK_MASK_CONST(0x3))
+#define SDP_D_DP_BN_CFG_0_BN_ALU_ALGO_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_CFG_0_BN_ALU_ALGO_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_CFG_0_BN_ALU_ALGO_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_CFG_0_BN_ALU_ALGO_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define SDP_D_DP_BN_CFG_0_BN_ALU_ALGO_MAX (_MK_ENUM_CONST(0))
+#define SDP_D_DP_BN_CFG_0_BN_ALU_ALGO_MIN (_MK_ENUM_CONST(1))
+#define SDP_D_DP_BN_CFG_0_BN_ALU_ALGO_SUM (_MK_ENUM_CONST(2))
+
+#define SDP_D_DP_BN_CFG_0_BN_MUL_BYPASS_SHIFT (_MK_SHIFT_CONST(4))
+#define SDP_D_DP_BN_CFG_0_BN_MUL_BYPASS_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_D_DP_BN_CFG_0_BN_MUL_BYPASS_SHIFT))
+#define SDP_D_DP_BN_CFG_0_BN_MUL_BYPASS_RANGE (4 : 4)
+#define SDP_D_DP_BN_CFG_0_BN_MUL_BYPASS_WOFFSET (0x0)
+#define SDP_D_DP_BN_CFG_0_BN_MUL_BYPASS_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_CFG_0_BN_MUL_BYPASS_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define SDP_D_DP_BN_CFG_0_BN_MUL_BYPASS_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_CFG_0_BN_MUL_BYPASS_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_CFG_0_BN_MUL_BYPASS_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_CFG_0_BN_MUL_BYPASS_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define SDP_D_DP_BN_CFG_0_BN_MUL_BYPASS_NO (_MK_ENUM_CONST(0))
+#define SDP_D_DP_BN_CFG_0_BN_MUL_BYPASS_YES (_MK_ENUM_CONST(1))
+
+#define SDP_D_DP_BN_CFG_0_BN_MUL_PRELU_SHIFT (_MK_SHIFT_CONST(5))
+#define SDP_D_DP_BN_CFG_0_BN_MUL_PRELU_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_D_DP_BN_CFG_0_BN_MUL_PRELU_SHIFT))
+#define SDP_D_DP_BN_CFG_0_BN_MUL_PRELU_RANGE (5 : 5)
+#define SDP_D_DP_BN_CFG_0_BN_MUL_PRELU_WOFFSET (0x0)
+#define SDP_D_DP_BN_CFG_0_BN_MUL_PRELU_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_CFG_0_BN_MUL_PRELU_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define SDP_D_DP_BN_CFG_0_BN_MUL_PRELU_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_CFG_0_BN_MUL_PRELU_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_CFG_0_BN_MUL_PRELU_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_CFG_0_BN_MUL_PRELU_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define SDP_D_DP_BN_CFG_0_BN_MUL_PRELU_NO (_MK_ENUM_CONST(0))
+#define SDP_D_DP_BN_CFG_0_BN_MUL_PRELU_YES (_MK_ENUM_CONST(1))
+
+#define SDP_D_DP_BN_CFG_0_BN_RELU_BYPASS_SHIFT (_MK_SHIFT_CONST(6))
+#define SDP_D_DP_BN_CFG_0_BN_RELU_BYPASS_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_D_DP_BN_CFG_0_BN_RELU_BYPASS_SHIFT))
+#define SDP_D_DP_BN_CFG_0_BN_RELU_BYPASS_RANGE (6 : 6)
+#define SDP_D_DP_BN_CFG_0_BN_RELU_BYPASS_WOFFSET (0x0)
+#define SDP_D_DP_BN_CFG_0_BN_RELU_BYPASS_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_CFG_0_BN_RELU_BYPASS_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define SDP_D_DP_BN_CFG_0_BN_RELU_BYPASS_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_CFG_0_BN_RELU_BYPASS_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_CFG_0_BN_RELU_BYPASS_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_CFG_0_BN_RELU_BYPASS_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define SDP_D_DP_BN_CFG_0_BN_RELU_BYPASS_NO (_MK_ENUM_CONST(0))
+#define SDP_D_DP_BN_CFG_0_BN_RELU_BYPASS_YES (_MK_ENUM_CONST(1))
+
+// Register SDP_D_DP_BN_ALU_CFG_0
+#define SDP_D_DP_BN_ALU_CFG_0 (_MK_ADDR_CONST(0xb070))
+#define SDP_D_DP_BN_ALU_CFG_0_SECURE (0x0)
+#define SDP_D_DP_BN_ALU_CFG_0_DUAL (0x0)
+#define SDP_D_DP_BN_ALU_CFG_0_SCR (0)
+#define SDP_D_DP_BN_ALU_CFG_0_WORD_COUNT (0x1)
+#define SDP_D_DP_BN_ALU_CFG_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_ALU_CFG_0_RESET_MASK (_MK_MASK_CONST(0x3f01))
+#define SDP_D_DP_BN_ALU_CFG_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_ALU_CFG_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_ALU_CFG_0_READ_MASK (_MK_MASK_CONST(0x3f01))
+#define SDP_D_DP_BN_ALU_CFG_0_WRITE_MASK (_MK_MASK_CONST(0x3f01))
+#define SDP_D_DP_BN_ALU_CFG_0_BN_ALU_SRC_SHIFT (_MK_SHIFT_CONST(0))
+#define SDP_D_DP_BN_ALU_CFG_0_BN_ALU_SRC_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_D_DP_BN_ALU_CFG_0_BN_ALU_SRC_SHIFT))
+#define SDP_D_DP_BN_ALU_CFG_0_BN_ALU_SRC_RANGE (0 : 0)
+#define SDP_D_DP_BN_ALU_CFG_0_BN_ALU_SRC_WOFFSET (0x0)
+#define SDP_D_DP_BN_ALU_CFG_0_BN_ALU_SRC_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_ALU_CFG_0_BN_ALU_SRC_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define SDP_D_DP_BN_ALU_CFG_0_BN_ALU_SRC_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_ALU_CFG_0_BN_ALU_SRC_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_ALU_CFG_0_BN_ALU_SRC_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_ALU_CFG_0_BN_ALU_SRC_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define SDP_D_DP_BN_ALU_CFG_0_BN_ALU_SRC_REG (_MK_ENUM_CONST(0))
+#define SDP_D_DP_BN_ALU_CFG_0_BN_ALU_SRC_MEM (_MK_ENUM_CONST(1))
+
+#define SDP_D_DP_BN_ALU_CFG_0_BN_ALU_SHIFT_VALUE_SHIFT (_MK_SHIFT_CONST(8))
+#define SDP_D_DP_BN_ALU_CFG_0_BN_ALU_SHIFT_VALUE_FIELD \
+	(_MK_FIELD_CONST(0x3f, SDP_D_DP_BN_ALU_CFG_0_BN_ALU_SHIFT_VALUE_SHIFT))
+#define SDP_D_DP_BN_ALU_CFG_0_BN_ALU_SHIFT_VALUE_RANGE (13 : 8)
+#define SDP_D_DP_BN_ALU_CFG_0_BN_ALU_SHIFT_VALUE_WOFFSET (0x0)
+#define SDP_D_DP_BN_ALU_CFG_0_BN_ALU_SHIFT_VALUE_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_ALU_CFG_0_BN_ALU_SHIFT_VALUE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x3f))
+#define SDP_D_DP_BN_ALU_CFG_0_BN_ALU_SHIFT_VALUE_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_ALU_CFG_0_BN_ALU_SHIFT_VALUE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_ALU_CFG_0_BN_ALU_SHIFT_VALUE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_ALU_CFG_0_BN_ALU_SHIFT_VALUE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_D_DP_BN_ALU_SRC_VALUE_0
+#define SDP_D_DP_BN_ALU_SRC_VALUE_0 (_MK_ADDR_CONST(0xb074))
+#define SDP_D_DP_BN_ALU_SRC_VALUE_0_SECURE (0x0)
+#define SDP_D_DP_BN_ALU_SRC_VALUE_0_DUAL (0x0)
+#define SDP_D_DP_BN_ALU_SRC_VALUE_0_SCR (0)
+#define SDP_D_DP_BN_ALU_SRC_VALUE_0_WORD_COUNT (0x1)
+#define SDP_D_DP_BN_ALU_SRC_VALUE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_ALU_SRC_VALUE_0_RESET_MASK (_MK_MASK_CONST(0xffff))
+#define SDP_D_DP_BN_ALU_SRC_VALUE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_ALU_SRC_VALUE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_ALU_SRC_VALUE_0_READ_MASK (_MK_MASK_CONST(0xffff))
+#define SDP_D_DP_BN_ALU_SRC_VALUE_0_WRITE_MASK (_MK_MASK_CONST(0xffff))
+#define SDP_D_DP_BN_ALU_SRC_VALUE_0_BN_ALU_OPERAND_SHIFT (_MK_SHIFT_CONST(0))
+#define SDP_D_DP_BN_ALU_SRC_VALUE_0_BN_ALU_OPERAND_FIELD \
+	(_MK_FIELD_CONST(0xffff,                         \
+			 SDP_D_DP_BN_ALU_SRC_VALUE_0_BN_ALU_OPERAND_SHIFT))
+#define SDP_D_DP_BN_ALU_SRC_VALUE_0_BN_ALU_OPERAND_RANGE (15 : 0)
+#define SDP_D_DP_BN_ALU_SRC_VALUE_0_BN_ALU_OPERAND_WOFFSET (0x0)
+#define SDP_D_DP_BN_ALU_SRC_VALUE_0_BN_ALU_OPERAND_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_ALU_SRC_VALUE_0_BN_ALU_OPERAND_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffff))
+#define SDP_D_DP_BN_ALU_SRC_VALUE_0_BN_ALU_OPERAND_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_ALU_SRC_VALUE_0_BN_ALU_OPERAND_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_ALU_SRC_VALUE_0_BN_ALU_OPERAND_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_ALU_SRC_VALUE_0_BN_ALU_OPERAND_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_D_DP_BN_MUL_CFG_0
+#define SDP_D_DP_BN_MUL_CFG_0 (_MK_ADDR_CONST(0xb078))
+#define SDP_D_DP_BN_MUL_CFG_0_SECURE (0x0)
+#define SDP_D_DP_BN_MUL_CFG_0_DUAL (0x0)
+#define SDP_D_DP_BN_MUL_CFG_0_SCR (0)
+#define SDP_D_DP_BN_MUL_CFG_0_WORD_COUNT (0x1)
+#define SDP_D_DP_BN_MUL_CFG_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_MUL_CFG_0_RESET_MASK (_MK_MASK_CONST(0xff01))
+#define SDP_D_DP_BN_MUL_CFG_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_MUL_CFG_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_MUL_CFG_0_READ_MASK (_MK_MASK_CONST(0xff01))
+#define SDP_D_DP_BN_MUL_CFG_0_WRITE_MASK (_MK_MASK_CONST(0xff01))
+#define SDP_D_DP_BN_MUL_CFG_0_BN_MUL_SRC_SHIFT (_MK_SHIFT_CONST(0))
+#define SDP_D_DP_BN_MUL_CFG_0_BN_MUL_SRC_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_D_DP_BN_MUL_CFG_0_BN_MUL_SRC_SHIFT))
+#define SDP_D_DP_BN_MUL_CFG_0_BN_MUL_SRC_RANGE (0 : 0)
+#define SDP_D_DP_BN_MUL_CFG_0_BN_MUL_SRC_WOFFSET (0x0)
+#define SDP_D_DP_BN_MUL_CFG_0_BN_MUL_SRC_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_MUL_CFG_0_BN_MUL_SRC_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define SDP_D_DP_BN_MUL_CFG_0_BN_MUL_SRC_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_MUL_CFG_0_BN_MUL_SRC_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_MUL_CFG_0_BN_MUL_SRC_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_MUL_CFG_0_BN_MUL_SRC_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define SDP_D_DP_BN_MUL_CFG_0_BN_MUL_SRC_REG (_MK_ENUM_CONST(0))
+#define SDP_D_DP_BN_MUL_CFG_0_BN_MUL_SRC_MEM (_MK_ENUM_CONST(1))
+
+#define SDP_D_DP_BN_MUL_CFG_0_BN_MUL_SHIFT_VALUE_SHIFT (_MK_SHIFT_CONST(8))
+#define SDP_D_DP_BN_MUL_CFG_0_BN_MUL_SHIFT_VALUE_FIELD \
+	(_MK_FIELD_CONST(0xff, SDP_D_DP_BN_MUL_CFG_0_BN_MUL_SHIFT_VALUE_SHIFT))
+#define SDP_D_DP_BN_MUL_CFG_0_BN_MUL_SHIFT_VALUE_RANGE (15 : 8)
+#define SDP_D_DP_BN_MUL_CFG_0_BN_MUL_SHIFT_VALUE_WOFFSET (0x0)
+#define SDP_D_DP_BN_MUL_CFG_0_BN_MUL_SHIFT_VALUE_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_MUL_CFG_0_BN_MUL_SHIFT_VALUE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xff))
+#define SDP_D_DP_BN_MUL_CFG_0_BN_MUL_SHIFT_VALUE_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_MUL_CFG_0_BN_MUL_SHIFT_VALUE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_MUL_CFG_0_BN_MUL_SHIFT_VALUE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_MUL_CFG_0_BN_MUL_SHIFT_VALUE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_D_DP_BN_MUL_SRC_VALUE_0
+#define SDP_D_DP_BN_MUL_SRC_VALUE_0 (_MK_ADDR_CONST(0xb07c))
+#define SDP_D_DP_BN_MUL_SRC_VALUE_0_SECURE (0x0)
+#define SDP_D_DP_BN_MUL_SRC_VALUE_0_DUAL (0x0)
+#define SDP_D_DP_BN_MUL_SRC_VALUE_0_SCR (0)
+#define SDP_D_DP_BN_MUL_SRC_VALUE_0_WORD_COUNT (0x1)
+#define SDP_D_DP_BN_MUL_SRC_VALUE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_MUL_SRC_VALUE_0_RESET_MASK (_MK_MASK_CONST(0xffff))
+#define SDP_D_DP_BN_MUL_SRC_VALUE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_MUL_SRC_VALUE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_MUL_SRC_VALUE_0_READ_MASK (_MK_MASK_CONST(0xffff))
+#define SDP_D_DP_BN_MUL_SRC_VALUE_0_WRITE_MASK (_MK_MASK_CONST(0xffff))
+#define SDP_D_DP_BN_MUL_SRC_VALUE_0_BN_MUL_OPERAND_SHIFT (_MK_SHIFT_CONST(0))
+#define SDP_D_DP_BN_MUL_SRC_VALUE_0_BN_MUL_OPERAND_FIELD \
+	(_MK_FIELD_CONST(0xffff,                         \
+			 SDP_D_DP_BN_MUL_SRC_VALUE_0_BN_MUL_OPERAND_SHIFT))
+#define SDP_D_DP_BN_MUL_SRC_VALUE_0_BN_MUL_OPERAND_RANGE (15 : 0)
+#define SDP_D_DP_BN_MUL_SRC_VALUE_0_BN_MUL_OPERAND_WOFFSET (0x0)
+#define SDP_D_DP_BN_MUL_SRC_VALUE_0_BN_MUL_OPERAND_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_MUL_SRC_VALUE_0_BN_MUL_OPERAND_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffff))
+#define SDP_D_DP_BN_MUL_SRC_VALUE_0_BN_MUL_OPERAND_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_MUL_SRC_VALUE_0_BN_MUL_OPERAND_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_MUL_SRC_VALUE_0_BN_MUL_OPERAND_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_BN_MUL_SRC_VALUE_0_BN_MUL_OPERAND_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_D_DP_EW_CFG_0
+#define SDP_D_DP_EW_CFG_0 (_MK_ADDR_CONST(0xb080))
+#define SDP_D_DP_EW_CFG_0_SECURE (0x0)
+#define SDP_D_DP_EW_CFG_0_DUAL (0x0)
+#define SDP_D_DP_EW_CFG_0_SCR (0)
+#define SDP_D_DP_EW_CFG_0_WORD_COUNT (0x1)
+#define SDP_D_DP_EW_CFG_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_CFG_0_RESET_MASK (_MK_MASK_CONST(0x7f))
+#define SDP_D_DP_EW_CFG_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_CFG_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_CFG_0_READ_MASK (_MK_MASK_CONST(0x7f))
+#define SDP_D_DP_EW_CFG_0_WRITE_MASK (_MK_MASK_CONST(0x7f))
+#define SDP_D_DP_EW_CFG_0_EW_BYPASS_SHIFT (_MK_SHIFT_CONST(0))
+#define SDP_D_DP_EW_CFG_0_EW_BYPASS_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_D_DP_EW_CFG_0_EW_BYPASS_SHIFT))
+#define SDP_D_DP_EW_CFG_0_EW_BYPASS_RANGE (0 : 0)
+#define SDP_D_DP_EW_CFG_0_EW_BYPASS_WOFFSET (0x0)
+#define SDP_D_DP_EW_CFG_0_EW_BYPASS_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_CFG_0_EW_BYPASS_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define SDP_D_DP_EW_CFG_0_EW_BYPASS_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_CFG_0_EW_BYPASS_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_CFG_0_EW_BYPASS_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_CFG_0_EW_BYPASS_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define SDP_D_DP_EW_CFG_0_EW_BYPASS_NO (_MK_ENUM_CONST(0))
+#define SDP_D_DP_EW_CFG_0_EW_BYPASS_YES (_MK_ENUM_CONST(1))
+
+#define SDP_D_DP_EW_CFG_0_EW_ALU_BYPASS_SHIFT (_MK_SHIFT_CONST(1))
+#define SDP_D_DP_EW_CFG_0_EW_ALU_BYPASS_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_D_DP_EW_CFG_0_EW_ALU_BYPASS_SHIFT))
+#define SDP_D_DP_EW_CFG_0_EW_ALU_BYPASS_RANGE (1 : 1)
+#define SDP_D_DP_EW_CFG_0_EW_ALU_BYPASS_WOFFSET (0x0)
+#define SDP_D_DP_EW_CFG_0_EW_ALU_BYPASS_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_CFG_0_EW_ALU_BYPASS_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define SDP_D_DP_EW_CFG_0_EW_ALU_BYPASS_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_CFG_0_EW_ALU_BYPASS_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_CFG_0_EW_ALU_BYPASS_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_CFG_0_EW_ALU_BYPASS_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define SDP_D_DP_EW_CFG_0_EW_ALU_BYPASS_NO (_MK_ENUM_CONST(0))
+#define SDP_D_DP_EW_CFG_0_EW_ALU_BYPASS_YES (_MK_ENUM_CONST(1))
+
+#define SDP_D_DP_EW_CFG_0_EW_ALU_ALGO_SHIFT (_MK_SHIFT_CONST(2))
+#define SDP_D_DP_EW_CFG_0_EW_ALU_ALGO_FIELD \
+	(_MK_FIELD_CONST(0x3, SDP_D_DP_EW_CFG_0_EW_ALU_ALGO_SHIFT))
+#define SDP_D_DP_EW_CFG_0_EW_ALU_ALGO_RANGE (3 : 2)
+#define SDP_D_DP_EW_CFG_0_EW_ALU_ALGO_WOFFSET (0x0)
+#define SDP_D_DP_EW_CFG_0_EW_ALU_ALGO_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_CFG_0_EW_ALU_ALGO_DEFAULT_MASK (_MK_MASK_CONST(0x3))
+#define SDP_D_DP_EW_CFG_0_EW_ALU_ALGO_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_CFG_0_EW_ALU_ALGO_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_CFG_0_EW_ALU_ALGO_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_CFG_0_EW_ALU_ALGO_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define SDP_D_DP_EW_CFG_0_EW_ALU_ALGO_MAX (_MK_ENUM_CONST(0))
+#define SDP_D_DP_EW_CFG_0_EW_ALU_ALGO_MIN (_MK_ENUM_CONST(1))
+#define SDP_D_DP_EW_CFG_0_EW_ALU_ALGO_SUM (_MK_ENUM_CONST(2))
+#define SDP_D_DP_EW_CFG_0_EW_ALU_ALGO_EQL (_MK_ENUM_CONST(3))
+
+#define SDP_D_DP_EW_CFG_0_EW_MUL_BYPASS_SHIFT (_MK_SHIFT_CONST(4))
+#define SDP_D_DP_EW_CFG_0_EW_MUL_BYPASS_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_D_DP_EW_CFG_0_EW_MUL_BYPASS_SHIFT))
+#define SDP_D_DP_EW_CFG_0_EW_MUL_BYPASS_RANGE (4 : 4)
+#define SDP_D_DP_EW_CFG_0_EW_MUL_BYPASS_WOFFSET (0x0)
+#define SDP_D_DP_EW_CFG_0_EW_MUL_BYPASS_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_CFG_0_EW_MUL_BYPASS_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define SDP_D_DP_EW_CFG_0_EW_MUL_BYPASS_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_CFG_0_EW_MUL_BYPASS_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_CFG_0_EW_MUL_BYPASS_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_CFG_0_EW_MUL_BYPASS_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define SDP_D_DP_EW_CFG_0_EW_MUL_BYPASS_NO (_MK_ENUM_CONST(0))
+#define SDP_D_DP_EW_CFG_0_EW_MUL_BYPASS_YES (_MK_ENUM_CONST(1))
+
+#define SDP_D_DP_EW_CFG_0_EW_MUL_PRELU_SHIFT (_MK_SHIFT_CONST(5))
+#define SDP_D_DP_EW_CFG_0_EW_MUL_PRELU_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_D_DP_EW_CFG_0_EW_MUL_PRELU_SHIFT))
+#define SDP_D_DP_EW_CFG_0_EW_MUL_PRELU_RANGE (5 : 5)
+#define SDP_D_DP_EW_CFG_0_EW_MUL_PRELU_WOFFSET (0x0)
+#define SDP_D_DP_EW_CFG_0_EW_MUL_PRELU_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_CFG_0_EW_MUL_PRELU_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define SDP_D_DP_EW_CFG_0_EW_MUL_PRELU_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_CFG_0_EW_MUL_PRELU_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_CFG_0_EW_MUL_PRELU_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_CFG_0_EW_MUL_PRELU_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define SDP_D_DP_EW_CFG_0_EW_MUL_PRELU_NO (_MK_ENUM_CONST(0))
+#define SDP_D_DP_EW_CFG_0_EW_MUL_PRELU_YES (_MK_ENUM_CONST(1))
+
+#define SDP_D_DP_EW_CFG_0_EW_LUT_BYPASS_SHIFT (_MK_SHIFT_CONST(6))
+#define SDP_D_DP_EW_CFG_0_EW_LUT_BYPASS_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_D_DP_EW_CFG_0_EW_LUT_BYPASS_SHIFT))
+#define SDP_D_DP_EW_CFG_0_EW_LUT_BYPASS_RANGE (6 : 6)
+#define SDP_D_DP_EW_CFG_0_EW_LUT_BYPASS_WOFFSET (0x0)
+#define SDP_D_DP_EW_CFG_0_EW_LUT_BYPASS_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_CFG_0_EW_LUT_BYPASS_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define SDP_D_DP_EW_CFG_0_EW_LUT_BYPASS_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_CFG_0_EW_LUT_BYPASS_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_CFG_0_EW_LUT_BYPASS_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_CFG_0_EW_LUT_BYPASS_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define SDP_D_DP_EW_CFG_0_EW_LUT_BYPASS_NO (_MK_ENUM_CONST(0))
+#define SDP_D_DP_EW_CFG_0_EW_LUT_BYPASS_YES (_MK_ENUM_CONST(1))
+
+// Register SDP_D_DP_EW_ALU_CFG_0
+#define SDP_D_DP_EW_ALU_CFG_0 (_MK_ADDR_CONST(0xb084))
+#define SDP_D_DP_EW_ALU_CFG_0_SECURE (0x0)
+#define SDP_D_DP_EW_ALU_CFG_0_DUAL (0x0)
+#define SDP_D_DP_EW_ALU_CFG_0_SCR (0)
+#define SDP_D_DP_EW_ALU_CFG_0_WORD_COUNT (0x1)
+#define SDP_D_DP_EW_ALU_CFG_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_ALU_CFG_0_RESET_MASK (_MK_MASK_CONST(0x3))
+#define SDP_D_DP_EW_ALU_CFG_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_ALU_CFG_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_ALU_CFG_0_READ_MASK (_MK_MASK_CONST(0x3))
+#define SDP_D_DP_EW_ALU_CFG_0_WRITE_MASK (_MK_MASK_CONST(0x3))
+#define SDP_D_DP_EW_ALU_CFG_0_EW_ALU_SRC_SHIFT (_MK_SHIFT_CONST(0))
+#define SDP_D_DP_EW_ALU_CFG_0_EW_ALU_SRC_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_D_DP_EW_ALU_CFG_0_EW_ALU_SRC_SHIFT))
+#define SDP_D_DP_EW_ALU_CFG_0_EW_ALU_SRC_RANGE (0 : 0)
+#define SDP_D_DP_EW_ALU_CFG_0_EW_ALU_SRC_WOFFSET (0x0)
+#define SDP_D_DP_EW_ALU_CFG_0_EW_ALU_SRC_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_ALU_CFG_0_EW_ALU_SRC_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define SDP_D_DP_EW_ALU_CFG_0_EW_ALU_SRC_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_ALU_CFG_0_EW_ALU_SRC_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_ALU_CFG_0_EW_ALU_SRC_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_ALU_CFG_0_EW_ALU_SRC_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define SDP_D_DP_EW_ALU_CFG_0_EW_ALU_SRC_REG (_MK_ENUM_CONST(0))
+#define SDP_D_DP_EW_ALU_CFG_0_EW_ALU_SRC_MEM (_MK_ENUM_CONST(1))
+
+#define SDP_D_DP_EW_ALU_CFG_0_EW_ALU_CVT_BYPASS_SHIFT (_MK_SHIFT_CONST(1))
+#define SDP_D_DP_EW_ALU_CFG_0_EW_ALU_CVT_BYPASS_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_D_DP_EW_ALU_CFG_0_EW_ALU_CVT_BYPASS_SHIFT))
+#define SDP_D_DP_EW_ALU_CFG_0_EW_ALU_CVT_BYPASS_RANGE (1 : 1)
+#define SDP_D_DP_EW_ALU_CFG_0_EW_ALU_CVT_BYPASS_WOFFSET (0x0)
+#define SDP_D_DP_EW_ALU_CFG_0_EW_ALU_CVT_BYPASS_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_ALU_CFG_0_EW_ALU_CVT_BYPASS_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1))
+#define SDP_D_DP_EW_ALU_CFG_0_EW_ALU_CVT_BYPASS_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_ALU_CFG_0_EW_ALU_CVT_BYPASS_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_ALU_CFG_0_EW_ALU_CVT_BYPASS_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_ALU_CFG_0_EW_ALU_CVT_BYPASS_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define SDP_D_DP_EW_ALU_CFG_0_EW_ALU_CVT_BYPASS_NO (_MK_ENUM_CONST(0))
+#define SDP_D_DP_EW_ALU_CFG_0_EW_ALU_CVT_BYPASS_YES (_MK_ENUM_CONST(1))
+
+// Register SDP_D_DP_EW_ALU_SRC_VALUE_0
+#define SDP_D_DP_EW_ALU_SRC_VALUE_0 (_MK_ADDR_CONST(0xb088))
+#define SDP_D_DP_EW_ALU_SRC_VALUE_0_SECURE (0x0)
+#define SDP_D_DP_EW_ALU_SRC_VALUE_0_DUAL (0x0)
+#define SDP_D_DP_EW_ALU_SRC_VALUE_0_SCR (0)
+#define SDP_D_DP_EW_ALU_SRC_VALUE_0_WORD_COUNT (0x1)
+#define SDP_D_DP_EW_ALU_SRC_VALUE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_ALU_SRC_VALUE_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_D_DP_EW_ALU_SRC_VALUE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_ALU_SRC_VALUE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_ALU_SRC_VALUE_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_D_DP_EW_ALU_SRC_VALUE_0_WRITE_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_D_DP_EW_ALU_SRC_VALUE_0_EW_ALU_OPERAND_SHIFT (_MK_SHIFT_CONST(0))
+#define SDP_D_DP_EW_ALU_SRC_VALUE_0_EW_ALU_OPERAND_FIELD \
+	(_MK_FIELD_CONST(0xffffffff,                     \
+			 SDP_D_DP_EW_ALU_SRC_VALUE_0_EW_ALU_OPERAND_SHIFT))
+#define SDP_D_DP_EW_ALU_SRC_VALUE_0_EW_ALU_OPERAND_RANGE (31 : 0)
+#define SDP_D_DP_EW_ALU_SRC_VALUE_0_EW_ALU_OPERAND_WOFFSET (0x0)
+#define SDP_D_DP_EW_ALU_SRC_VALUE_0_EW_ALU_OPERAND_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_ALU_SRC_VALUE_0_EW_ALU_OPERAND_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define SDP_D_DP_EW_ALU_SRC_VALUE_0_EW_ALU_OPERAND_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_ALU_SRC_VALUE_0_EW_ALU_OPERAND_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_ALU_SRC_VALUE_0_EW_ALU_OPERAND_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_ALU_SRC_VALUE_0_EW_ALU_OPERAND_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_D_DP_EW_ALU_CVT_OFFSET_VALUE_0
+#define SDP_D_DP_EW_ALU_CVT_OFFSET_VALUE_0 (_MK_ADDR_CONST(0xb08c))
+#define SDP_D_DP_EW_ALU_CVT_OFFSET_VALUE_0_SECURE (0x0)
+#define SDP_D_DP_EW_ALU_CVT_OFFSET_VALUE_0_DUAL (0x0)
+#define SDP_D_DP_EW_ALU_CVT_OFFSET_VALUE_0_SCR (0)
+#define SDP_D_DP_EW_ALU_CVT_OFFSET_VALUE_0_WORD_COUNT (0x1)
+#define SDP_D_DP_EW_ALU_CVT_OFFSET_VALUE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_ALU_CVT_OFFSET_VALUE_0_RESET_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define SDP_D_DP_EW_ALU_CVT_OFFSET_VALUE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_ALU_CVT_OFFSET_VALUE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_ALU_CVT_OFFSET_VALUE_0_READ_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define SDP_D_DP_EW_ALU_CVT_OFFSET_VALUE_0_WRITE_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define SDP_D_DP_EW_ALU_CVT_OFFSET_VALUE_0_EW_ALU_CVT_OFFSET_SHIFT \
+	(_MK_SHIFT_CONST(0))
+#define SDP_D_DP_EW_ALU_CVT_OFFSET_VALUE_0_EW_ALU_CVT_OFFSET_FIELD \
+	(_MK_FIELD_CONST(                                          \
+		0xffffffff,                                        \
+		SDP_D_DP_EW_ALU_CVT_OFFSET_VALUE_0_EW_ALU_CVT_OFFSET_SHIFT))
+#define SDP_D_DP_EW_ALU_CVT_OFFSET_VALUE_0_EW_ALU_CVT_OFFSET_RANGE (31 : 0)
+#define SDP_D_DP_EW_ALU_CVT_OFFSET_VALUE_0_EW_ALU_CVT_OFFSET_WOFFSET (0x0)
+#define SDP_D_DP_EW_ALU_CVT_OFFSET_VALUE_0_EW_ALU_CVT_OFFSET_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_ALU_CVT_OFFSET_VALUE_0_EW_ALU_CVT_OFFSET_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define SDP_D_DP_EW_ALU_CVT_OFFSET_VALUE_0_EW_ALU_CVT_OFFSET_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_ALU_CVT_OFFSET_VALUE_0_EW_ALU_CVT_OFFSET_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_ALU_CVT_OFFSET_VALUE_0_EW_ALU_CVT_OFFSET_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_ALU_CVT_OFFSET_VALUE_0_EW_ALU_CVT_OFFSET_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_D_DP_EW_ALU_CVT_SCALE_VALUE_0
+#define SDP_D_DP_EW_ALU_CVT_SCALE_VALUE_0 (_MK_ADDR_CONST(0xb090))
+#define SDP_D_DP_EW_ALU_CVT_SCALE_VALUE_0_SECURE (0x0)
+#define SDP_D_DP_EW_ALU_CVT_SCALE_VALUE_0_DUAL (0x0)
+#define SDP_D_DP_EW_ALU_CVT_SCALE_VALUE_0_SCR (0)
+#define SDP_D_DP_EW_ALU_CVT_SCALE_VALUE_0_WORD_COUNT (0x1)
+#define SDP_D_DP_EW_ALU_CVT_SCALE_VALUE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_ALU_CVT_SCALE_VALUE_0_RESET_MASK (_MK_MASK_CONST(0xffff))
+#define SDP_D_DP_EW_ALU_CVT_SCALE_VALUE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_ALU_CVT_SCALE_VALUE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_ALU_CVT_SCALE_VALUE_0_READ_MASK (_MK_MASK_CONST(0xffff))
+#define SDP_D_DP_EW_ALU_CVT_SCALE_VALUE_0_WRITE_MASK (_MK_MASK_CONST(0xffff))
+#define SDP_D_DP_EW_ALU_CVT_SCALE_VALUE_0_EW_ALU_CVT_SCALE_SHIFT \
+	(_MK_SHIFT_CONST(0))
+#define SDP_D_DP_EW_ALU_CVT_SCALE_VALUE_0_EW_ALU_CVT_SCALE_FIELD \
+	(_MK_FIELD_CONST(                                        \
+		0xffff,                                          \
+		SDP_D_DP_EW_ALU_CVT_SCALE_VALUE_0_EW_ALU_CVT_SCALE_SHIFT))
+#define SDP_D_DP_EW_ALU_CVT_SCALE_VALUE_0_EW_ALU_CVT_SCALE_RANGE (15 : 0)
+#define SDP_D_DP_EW_ALU_CVT_SCALE_VALUE_0_EW_ALU_CVT_SCALE_WOFFSET (0x0)
+#define SDP_D_DP_EW_ALU_CVT_SCALE_VALUE_0_EW_ALU_CVT_SCALE_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_ALU_CVT_SCALE_VALUE_0_EW_ALU_CVT_SCALE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffff))
+#define SDP_D_DP_EW_ALU_CVT_SCALE_VALUE_0_EW_ALU_CVT_SCALE_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_ALU_CVT_SCALE_VALUE_0_EW_ALU_CVT_SCALE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_ALU_CVT_SCALE_VALUE_0_EW_ALU_CVT_SCALE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_ALU_CVT_SCALE_VALUE_0_EW_ALU_CVT_SCALE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_D_DP_EW_ALU_CVT_TRUNCATE_VALUE_0
+#define SDP_D_DP_EW_ALU_CVT_TRUNCATE_VALUE_0 (_MK_ADDR_CONST(0xb094))
+#define SDP_D_DP_EW_ALU_CVT_TRUNCATE_VALUE_0_SECURE (0x0)
+#define SDP_D_DP_EW_ALU_CVT_TRUNCATE_VALUE_0_DUAL (0x0)
+#define SDP_D_DP_EW_ALU_CVT_TRUNCATE_VALUE_0_SCR (0)
+#define SDP_D_DP_EW_ALU_CVT_TRUNCATE_VALUE_0_WORD_COUNT (0x1)
+#define SDP_D_DP_EW_ALU_CVT_TRUNCATE_VALUE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_ALU_CVT_TRUNCATE_VALUE_0_RESET_MASK (_MK_MASK_CONST(0x3f))
+#define SDP_D_DP_EW_ALU_CVT_TRUNCATE_VALUE_0_SW_DEFAULT_VAL \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_ALU_CVT_TRUNCATE_VALUE_0_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_ALU_CVT_TRUNCATE_VALUE_0_READ_MASK (_MK_MASK_CONST(0x3f))
+#define SDP_D_DP_EW_ALU_CVT_TRUNCATE_VALUE_0_WRITE_MASK (_MK_MASK_CONST(0x3f))
+#define SDP_D_DP_EW_ALU_CVT_TRUNCATE_VALUE_0_EW_ALU_CVT_TRUNCATE_SHIFT \
+	(_MK_SHIFT_CONST(0))
+#define SDP_D_DP_EW_ALU_CVT_TRUNCATE_VALUE_0_EW_ALU_CVT_TRUNCATE_FIELD \
+	(_MK_FIELD_CONST(                                              \
+		0x3f,                                                  \
+		SDP_D_DP_EW_ALU_CVT_TRUNCATE_VALUE_0_EW_ALU_CVT_TRUNCATE_SHIFT))
+#define SDP_D_DP_EW_ALU_CVT_TRUNCATE_VALUE_0_EW_ALU_CVT_TRUNCATE_RANGE (5 : 0)
+#define SDP_D_DP_EW_ALU_CVT_TRUNCATE_VALUE_0_EW_ALU_CVT_TRUNCATE_WOFFSET (0x0)
+#define SDP_D_DP_EW_ALU_CVT_TRUNCATE_VALUE_0_EW_ALU_CVT_TRUNCATE_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_ALU_CVT_TRUNCATE_VALUE_0_EW_ALU_CVT_TRUNCATE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x3f))
+#define SDP_D_DP_EW_ALU_CVT_TRUNCATE_VALUE_0_EW_ALU_CVT_TRUNCATE_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_ALU_CVT_TRUNCATE_VALUE_0_EW_ALU_CVT_TRUNCATE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_ALU_CVT_TRUNCATE_VALUE_0_EW_ALU_CVT_TRUNCATE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_ALU_CVT_TRUNCATE_VALUE_0_EW_ALU_CVT_TRUNCATE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_D_DP_EW_MUL_CFG_0
+#define SDP_D_DP_EW_MUL_CFG_0 (_MK_ADDR_CONST(0xb098))
+#define SDP_D_DP_EW_MUL_CFG_0_SECURE (0x0)
+#define SDP_D_DP_EW_MUL_CFG_0_DUAL (0x0)
+#define SDP_D_DP_EW_MUL_CFG_0_SCR (0)
+#define SDP_D_DP_EW_MUL_CFG_0_WORD_COUNT (0x1)
+#define SDP_D_DP_EW_MUL_CFG_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_MUL_CFG_0_RESET_MASK (_MK_MASK_CONST(0x3))
+#define SDP_D_DP_EW_MUL_CFG_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_MUL_CFG_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_MUL_CFG_0_READ_MASK (_MK_MASK_CONST(0x3))
+#define SDP_D_DP_EW_MUL_CFG_0_WRITE_MASK (_MK_MASK_CONST(0x3))
+#define SDP_D_DP_EW_MUL_CFG_0_EW_MUL_SRC_SHIFT (_MK_SHIFT_CONST(0))
+#define SDP_D_DP_EW_MUL_CFG_0_EW_MUL_SRC_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_D_DP_EW_MUL_CFG_0_EW_MUL_SRC_SHIFT))
+#define SDP_D_DP_EW_MUL_CFG_0_EW_MUL_SRC_RANGE (0 : 0)
+#define SDP_D_DP_EW_MUL_CFG_0_EW_MUL_SRC_WOFFSET (0x0)
+#define SDP_D_DP_EW_MUL_CFG_0_EW_MUL_SRC_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_MUL_CFG_0_EW_MUL_SRC_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define SDP_D_DP_EW_MUL_CFG_0_EW_MUL_SRC_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_MUL_CFG_0_EW_MUL_SRC_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_MUL_CFG_0_EW_MUL_SRC_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_MUL_CFG_0_EW_MUL_SRC_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define SDP_D_DP_EW_MUL_CFG_0_EW_MUL_SRC_REG (_MK_ENUM_CONST(0))
+#define SDP_D_DP_EW_MUL_CFG_0_EW_MUL_SRC_MEM (_MK_ENUM_CONST(1))
+
+#define SDP_D_DP_EW_MUL_CFG_0_EW_MUL_CVT_BYPASS_SHIFT (_MK_SHIFT_CONST(1))
+#define SDP_D_DP_EW_MUL_CFG_0_EW_MUL_CVT_BYPASS_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_D_DP_EW_MUL_CFG_0_EW_MUL_CVT_BYPASS_SHIFT))
+#define SDP_D_DP_EW_MUL_CFG_0_EW_MUL_CVT_BYPASS_RANGE (1 : 1)
+#define SDP_D_DP_EW_MUL_CFG_0_EW_MUL_CVT_BYPASS_WOFFSET (0x0)
+#define SDP_D_DP_EW_MUL_CFG_0_EW_MUL_CVT_BYPASS_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_MUL_CFG_0_EW_MUL_CVT_BYPASS_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1))
+#define SDP_D_DP_EW_MUL_CFG_0_EW_MUL_CVT_BYPASS_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_MUL_CFG_0_EW_MUL_CVT_BYPASS_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_MUL_CFG_0_EW_MUL_CVT_BYPASS_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_MUL_CFG_0_EW_MUL_CVT_BYPASS_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define SDP_D_DP_EW_MUL_CFG_0_EW_MUL_CVT_BYPASS_NO (_MK_ENUM_CONST(0))
+#define SDP_D_DP_EW_MUL_CFG_0_EW_MUL_CVT_BYPASS_YES (_MK_ENUM_CONST(1))
+
+// Register SDP_D_DP_EW_MUL_SRC_VALUE_0
+#define SDP_D_DP_EW_MUL_SRC_VALUE_0 (_MK_ADDR_CONST(0xb09c))
+#define SDP_D_DP_EW_MUL_SRC_VALUE_0_SECURE (0x0)
+#define SDP_D_DP_EW_MUL_SRC_VALUE_0_DUAL (0x0)
+#define SDP_D_DP_EW_MUL_SRC_VALUE_0_SCR (0)
+#define SDP_D_DP_EW_MUL_SRC_VALUE_0_WORD_COUNT (0x1)
+#define SDP_D_DP_EW_MUL_SRC_VALUE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_MUL_SRC_VALUE_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_D_DP_EW_MUL_SRC_VALUE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_MUL_SRC_VALUE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_MUL_SRC_VALUE_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_D_DP_EW_MUL_SRC_VALUE_0_WRITE_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_D_DP_EW_MUL_SRC_VALUE_0_EW_MUL_OPERAND_SHIFT (_MK_SHIFT_CONST(0))
+#define SDP_D_DP_EW_MUL_SRC_VALUE_0_EW_MUL_OPERAND_FIELD \
+	(_MK_FIELD_CONST(0xffffffff,                     \
+			 SDP_D_DP_EW_MUL_SRC_VALUE_0_EW_MUL_OPERAND_SHIFT))
+#define SDP_D_DP_EW_MUL_SRC_VALUE_0_EW_MUL_OPERAND_RANGE (31 : 0)
+#define SDP_D_DP_EW_MUL_SRC_VALUE_0_EW_MUL_OPERAND_WOFFSET (0x0)
+#define SDP_D_DP_EW_MUL_SRC_VALUE_0_EW_MUL_OPERAND_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_MUL_SRC_VALUE_0_EW_MUL_OPERAND_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define SDP_D_DP_EW_MUL_SRC_VALUE_0_EW_MUL_OPERAND_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_MUL_SRC_VALUE_0_EW_MUL_OPERAND_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_MUL_SRC_VALUE_0_EW_MUL_OPERAND_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_MUL_SRC_VALUE_0_EW_MUL_OPERAND_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_D_DP_EW_MUL_CVT_OFFSET_VALUE_0
+#define SDP_D_DP_EW_MUL_CVT_OFFSET_VALUE_0 (_MK_ADDR_CONST(0xb0a0))
+#define SDP_D_DP_EW_MUL_CVT_OFFSET_VALUE_0_SECURE (0x0)
+#define SDP_D_DP_EW_MUL_CVT_OFFSET_VALUE_0_DUAL (0x0)
+#define SDP_D_DP_EW_MUL_CVT_OFFSET_VALUE_0_SCR (0)
+#define SDP_D_DP_EW_MUL_CVT_OFFSET_VALUE_0_WORD_COUNT (0x1)
+#define SDP_D_DP_EW_MUL_CVT_OFFSET_VALUE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_MUL_CVT_OFFSET_VALUE_0_RESET_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define SDP_D_DP_EW_MUL_CVT_OFFSET_VALUE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_MUL_CVT_OFFSET_VALUE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_MUL_CVT_OFFSET_VALUE_0_READ_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define SDP_D_DP_EW_MUL_CVT_OFFSET_VALUE_0_WRITE_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define SDP_D_DP_EW_MUL_CVT_OFFSET_VALUE_0_EW_MUL_CVT_OFFSET_SHIFT \
+	(_MK_SHIFT_CONST(0))
+#define SDP_D_DP_EW_MUL_CVT_OFFSET_VALUE_0_EW_MUL_CVT_OFFSET_FIELD \
+	(_MK_FIELD_CONST(                                          \
+		0xffffffff,                                        \
+		SDP_D_DP_EW_MUL_CVT_OFFSET_VALUE_0_EW_MUL_CVT_OFFSET_SHIFT))
+#define SDP_D_DP_EW_MUL_CVT_OFFSET_VALUE_0_EW_MUL_CVT_OFFSET_RANGE (31 : 0)
+#define SDP_D_DP_EW_MUL_CVT_OFFSET_VALUE_0_EW_MUL_CVT_OFFSET_WOFFSET (0x0)
+#define SDP_D_DP_EW_MUL_CVT_OFFSET_VALUE_0_EW_MUL_CVT_OFFSET_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_MUL_CVT_OFFSET_VALUE_0_EW_MUL_CVT_OFFSET_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define SDP_D_DP_EW_MUL_CVT_OFFSET_VALUE_0_EW_MUL_CVT_OFFSET_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_MUL_CVT_OFFSET_VALUE_0_EW_MUL_CVT_OFFSET_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_MUL_CVT_OFFSET_VALUE_0_EW_MUL_CVT_OFFSET_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_MUL_CVT_OFFSET_VALUE_0_EW_MUL_CVT_OFFSET_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_D_DP_EW_MUL_CVT_SCALE_VALUE_0
+#define SDP_D_DP_EW_MUL_CVT_SCALE_VALUE_0 (_MK_ADDR_CONST(0xb0a4))
+#define SDP_D_DP_EW_MUL_CVT_SCALE_VALUE_0_SECURE (0x0)
+#define SDP_D_DP_EW_MUL_CVT_SCALE_VALUE_0_DUAL (0x0)
+#define SDP_D_DP_EW_MUL_CVT_SCALE_VALUE_0_SCR (0)
+#define SDP_D_DP_EW_MUL_CVT_SCALE_VALUE_0_WORD_COUNT (0x1)
+#define SDP_D_DP_EW_MUL_CVT_SCALE_VALUE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_MUL_CVT_SCALE_VALUE_0_RESET_MASK (_MK_MASK_CONST(0xffff))
+#define SDP_D_DP_EW_MUL_CVT_SCALE_VALUE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_MUL_CVT_SCALE_VALUE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_MUL_CVT_SCALE_VALUE_0_READ_MASK (_MK_MASK_CONST(0xffff))
+#define SDP_D_DP_EW_MUL_CVT_SCALE_VALUE_0_WRITE_MASK (_MK_MASK_CONST(0xffff))
+#define SDP_D_DP_EW_MUL_CVT_SCALE_VALUE_0_EW_MUL_CVT_SCALE_SHIFT \
+	(_MK_SHIFT_CONST(0))
+#define SDP_D_DP_EW_MUL_CVT_SCALE_VALUE_0_EW_MUL_CVT_SCALE_FIELD \
+	(_MK_FIELD_CONST(                                        \
+		0xffff,                                          \
+		SDP_D_DP_EW_MUL_CVT_SCALE_VALUE_0_EW_MUL_CVT_SCALE_SHIFT))
+#define SDP_D_DP_EW_MUL_CVT_SCALE_VALUE_0_EW_MUL_CVT_SCALE_RANGE (15 : 0)
+#define SDP_D_DP_EW_MUL_CVT_SCALE_VALUE_0_EW_MUL_CVT_SCALE_WOFFSET (0x0)
+#define SDP_D_DP_EW_MUL_CVT_SCALE_VALUE_0_EW_MUL_CVT_SCALE_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_MUL_CVT_SCALE_VALUE_0_EW_MUL_CVT_SCALE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffff))
+#define SDP_D_DP_EW_MUL_CVT_SCALE_VALUE_0_EW_MUL_CVT_SCALE_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_MUL_CVT_SCALE_VALUE_0_EW_MUL_CVT_SCALE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_MUL_CVT_SCALE_VALUE_0_EW_MUL_CVT_SCALE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_MUL_CVT_SCALE_VALUE_0_EW_MUL_CVT_SCALE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_D_DP_EW_MUL_CVT_TRUNCATE_VALUE_0
+#define SDP_D_DP_EW_MUL_CVT_TRUNCATE_VALUE_0 (_MK_ADDR_CONST(0xb0a8))
+#define SDP_D_DP_EW_MUL_CVT_TRUNCATE_VALUE_0_SECURE (0x0)
+#define SDP_D_DP_EW_MUL_CVT_TRUNCATE_VALUE_0_DUAL (0x0)
+#define SDP_D_DP_EW_MUL_CVT_TRUNCATE_VALUE_0_SCR (0)
+#define SDP_D_DP_EW_MUL_CVT_TRUNCATE_VALUE_0_WORD_COUNT (0x1)
+#define SDP_D_DP_EW_MUL_CVT_TRUNCATE_VALUE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_MUL_CVT_TRUNCATE_VALUE_0_RESET_MASK (_MK_MASK_CONST(0x3f))
+#define SDP_D_DP_EW_MUL_CVT_TRUNCATE_VALUE_0_SW_DEFAULT_VAL \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_MUL_CVT_TRUNCATE_VALUE_0_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_MUL_CVT_TRUNCATE_VALUE_0_READ_MASK (_MK_MASK_CONST(0x3f))
+#define SDP_D_DP_EW_MUL_CVT_TRUNCATE_VALUE_0_WRITE_MASK (_MK_MASK_CONST(0x3f))
+#define SDP_D_DP_EW_MUL_CVT_TRUNCATE_VALUE_0_EW_MUL_CVT_TRUNCATE_SHIFT \
+	(_MK_SHIFT_CONST(0))
+#define SDP_D_DP_EW_MUL_CVT_TRUNCATE_VALUE_0_EW_MUL_CVT_TRUNCATE_FIELD \
+	(_MK_FIELD_CONST(                                              \
+		0x3f,                                                  \
+		SDP_D_DP_EW_MUL_CVT_TRUNCATE_VALUE_0_EW_MUL_CVT_TRUNCATE_SHIFT))
+#define SDP_D_DP_EW_MUL_CVT_TRUNCATE_VALUE_0_EW_MUL_CVT_TRUNCATE_RANGE (5 : 0)
+#define SDP_D_DP_EW_MUL_CVT_TRUNCATE_VALUE_0_EW_MUL_CVT_TRUNCATE_WOFFSET (0x0)
+#define SDP_D_DP_EW_MUL_CVT_TRUNCATE_VALUE_0_EW_MUL_CVT_TRUNCATE_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_MUL_CVT_TRUNCATE_VALUE_0_EW_MUL_CVT_TRUNCATE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x3f))
+#define SDP_D_DP_EW_MUL_CVT_TRUNCATE_VALUE_0_EW_MUL_CVT_TRUNCATE_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_MUL_CVT_TRUNCATE_VALUE_0_EW_MUL_CVT_TRUNCATE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_MUL_CVT_TRUNCATE_VALUE_0_EW_MUL_CVT_TRUNCATE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_MUL_CVT_TRUNCATE_VALUE_0_EW_MUL_CVT_TRUNCATE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_D_DP_EW_TRUNCATE_VALUE_0
+#define SDP_D_DP_EW_TRUNCATE_VALUE_0 (_MK_ADDR_CONST(0xb0ac))
+#define SDP_D_DP_EW_TRUNCATE_VALUE_0_SECURE (0x0)
+#define SDP_D_DP_EW_TRUNCATE_VALUE_0_DUAL (0x0)
+#define SDP_D_DP_EW_TRUNCATE_VALUE_0_SCR (0)
+#define SDP_D_DP_EW_TRUNCATE_VALUE_0_WORD_COUNT (0x1)
+#define SDP_D_DP_EW_TRUNCATE_VALUE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_TRUNCATE_VALUE_0_RESET_MASK (_MK_MASK_CONST(0x3ff))
+#define SDP_D_DP_EW_TRUNCATE_VALUE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_TRUNCATE_VALUE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_TRUNCATE_VALUE_0_READ_MASK (_MK_MASK_CONST(0x3ff))
+#define SDP_D_DP_EW_TRUNCATE_VALUE_0_WRITE_MASK (_MK_MASK_CONST(0x3ff))
+#define SDP_D_DP_EW_TRUNCATE_VALUE_0_EW_TRUNCATE_SHIFT (_MK_SHIFT_CONST(0))
+#define SDP_D_DP_EW_TRUNCATE_VALUE_0_EW_TRUNCATE_FIELD \
+	(_MK_FIELD_CONST(0x3ff, SDP_D_DP_EW_TRUNCATE_VALUE_0_EW_TRUNCATE_SHIFT))
+#define SDP_D_DP_EW_TRUNCATE_VALUE_0_EW_TRUNCATE_RANGE (9 : 0)
+#define SDP_D_DP_EW_TRUNCATE_VALUE_0_EW_TRUNCATE_WOFFSET (0x0)
+#define SDP_D_DP_EW_TRUNCATE_VALUE_0_EW_TRUNCATE_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_TRUNCATE_VALUE_0_EW_TRUNCATE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x3ff))
+#define SDP_D_DP_EW_TRUNCATE_VALUE_0_EW_TRUNCATE_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_TRUNCATE_VALUE_0_EW_TRUNCATE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_TRUNCATE_VALUE_0_EW_TRUNCATE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DP_EW_TRUNCATE_VALUE_0_EW_TRUNCATE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_D_FEATURE_MODE_CFG_0
+#define SDP_D_FEATURE_MODE_CFG_0 (_MK_ADDR_CONST(0xb0b0))
+#define SDP_D_FEATURE_MODE_CFG_0_SECURE (0x0)
+#define SDP_D_FEATURE_MODE_CFG_0_DUAL (0x0)
+#define SDP_D_FEATURE_MODE_CFG_0_SCR (0)
+#define SDP_D_FEATURE_MODE_CFG_0_WORD_COUNT (0x1)
+#define SDP_D_FEATURE_MODE_CFG_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_FEATURE_MODE_CFG_0_RESET_MASK (_MK_MASK_CONST(0x1f0f))
+#define SDP_D_FEATURE_MODE_CFG_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_FEATURE_MODE_CFG_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_FEATURE_MODE_CFG_0_READ_MASK (_MK_MASK_CONST(0x1f0f))
+#define SDP_D_FEATURE_MODE_CFG_0_WRITE_MASK (_MK_MASK_CONST(0x1f0f))
+#define SDP_D_FEATURE_MODE_CFG_0_FLYING_MODE_SHIFT (_MK_SHIFT_CONST(0))
+#define SDP_D_FEATURE_MODE_CFG_0_FLYING_MODE_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_D_FEATURE_MODE_CFG_0_FLYING_MODE_SHIFT))
+#define SDP_D_FEATURE_MODE_CFG_0_FLYING_MODE_RANGE (0 : 0)
+#define SDP_D_FEATURE_MODE_CFG_0_FLYING_MODE_WOFFSET (0x0)
+#define SDP_D_FEATURE_MODE_CFG_0_FLYING_MODE_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_FEATURE_MODE_CFG_0_FLYING_MODE_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define SDP_D_FEATURE_MODE_CFG_0_FLYING_MODE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_FEATURE_MODE_CFG_0_FLYING_MODE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_FEATURE_MODE_CFG_0_FLYING_MODE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_FEATURE_MODE_CFG_0_FLYING_MODE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define SDP_D_FEATURE_MODE_CFG_0_FLYING_MODE_OFF (_MK_ENUM_CONST(0))
+#define SDP_D_FEATURE_MODE_CFG_0_FLYING_MODE_ON (_MK_ENUM_CONST(1))
+
+#define SDP_D_FEATURE_MODE_CFG_0_OUTPUT_DST_SHIFT (_MK_SHIFT_CONST(1))
+#define SDP_D_FEATURE_MODE_CFG_0_OUTPUT_DST_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_D_FEATURE_MODE_CFG_0_OUTPUT_DST_SHIFT))
+#define SDP_D_FEATURE_MODE_CFG_0_OUTPUT_DST_RANGE (1 : 1)
+#define SDP_D_FEATURE_MODE_CFG_0_OUTPUT_DST_WOFFSET (0x0)
+#define SDP_D_FEATURE_MODE_CFG_0_OUTPUT_DST_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_FEATURE_MODE_CFG_0_OUTPUT_DST_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define SDP_D_FEATURE_MODE_CFG_0_OUTPUT_DST_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_FEATURE_MODE_CFG_0_OUTPUT_DST_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_FEATURE_MODE_CFG_0_OUTPUT_DST_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_FEATURE_MODE_CFG_0_OUTPUT_DST_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define SDP_D_FEATURE_MODE_CFG_0_OUTPUT_DST_MEM (_MK_ENUM_CONST(0))
+#define SDP_D_FEATURE_MODE_CFG_0_OUTPUT_DST_PDP (_MK_ENUM_CONST(1))
+
+#define SDP_D_FEATURE_MODE_CFG_0_WINOGRAD_SHIFT (_MK_SHIFT_CONST(2))
+#define SDP_D_FEATURE_MODE_CFG_0_WINOGRAD_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_D_FEATURE_MODE_CFG_0_WINOGRAD_SHIFT))
+#define SDP_D_FEATURE_MODE_CFG_0_WINOGRAD_RANGE (2 : 2)
+#define SDP_D_FEATURE_MODE_CFG_0_WINOGRAD_WOFFSET (0x0)
+#define SDP_D_FEATURE_MODE_CFG_0_WINOGRAD_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_FEATURE_MODE_CFG_0_WINOGRAD_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define SDP_D_FEATURE_MODE_CFG_0_WINOGRAD_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_FEATURE_MODE_CFG_0_WINOGRAD_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_FEATURE_MODE_CFG_0_WINOGRAD_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_FEATURE_MODE_CFG_0_WINOGRAD_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define SDP_D_FEATURE_MODE_CFG_0_WINOGRAD_OFF (_MK_ENUM_CONST(0))
+#define SDP_D_FEATURE_MODE_CFG_0_WINOGRAD_ON (_MK_ENUM_CONST(1))
+
+#define SDP_D_FEATURE_MODE_CFG_0_NAN_TO_ZERO_SHIFT (_MK_SHIFT_CONST(3))
+#define SDP_D_FEATURE_MODE_CFG_0_NAN_TO_ZERO_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_D_FEATURE_MODE_CFG_0_NAN_TO_ZERO_SHIFT))
+#define SDP_D_FEATURE_MODE_CFG_0_NAN_TO_ZERO_RANGE (3 : 3)
+#define SDP_D_FEATURE_MODE_CFG_0_NAN_TO_ZERO_WOFFSET (0x0)
+#define SDP_D_FEATURE_MODE_CFG_0_NAN_TO_ZERO_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_FEATURE_MODE_CFG_0_NAN_TO_ZERO_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define SDP_D_FEATURE_MODE_CFG_0_NAN_TO_ZERO_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_FEATURE_MODE_CFG_0_NAN_TO_ZERO_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_FEATURE_MODE_CFG_0_NAN_TO_ZERO_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_FEATURE_MODE_CFG_0_NAN_TO_ZERO_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define SDP_D_FEATURE_MODE_CFG_0_NAN_TO_ZERO_INIT_ENUM (DISABLE)
+#define SDP_D_FEATURE_MODE_CFG_0_NAN_TO_ZERO_DISABLE (_MK_ENUM_CONST(0))
+#define SDP_D_FEATURE_MODE_CFG_0_NAN_TO_ZERO_ENABLE (_MK_ENUM_CONST(1))
+
+#define SDP_D_FEATURE_MODE_CFG_0_BATCH_NUMBER_SHIFT (_MK_SHIFT_CONST(8))
+#define SDP_D_FEATURE_MODE_CFG_0_BATCH_NUMBER_FIELD \
+	(_MK_FIELD_CONST(0x1f, SDP_D_FEATURE_MODE_CFG_0_BATCH_NUMBER_SHIFT))
+#define SDP_D_FEATURE_MODE_CFG_0_BATCH_NUMBER_RANGE (12 : 8)
+#define SDP_D_FEATURE_MODE_CFG_0_BATCH_NUMBER_WOFFSET (0x0)
+#define SDP_D_FEATURE_MODE_CFG_0_BATCH_NUMBER_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_FEATURE_MODE_CFG_0_BATCH_NUMBER_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1f))
+#define SDP_D_FEATURE_MODE_CFG_0_BATCH_NUMBER_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_FEATURE_MODE_CFG_0_BATCH_NUMBER_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_FEATURE_MODE_CFG_0_BATCH_NUMBER_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_FEATURE_MODE_CFG_0_BATCH_NUMBER_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_D_DST_DMA_CFG_0
+#define SDP_D_DST_DMA_CFG_0 (_MK_ADDR_CONST(0xb0b4))
+#define SDP_D_DST_DMA_CFG_0_SECURE (0x0)
+#define SDP_D_DST_DMA_CFG_0_DUAL (0x0)
+#define SDP_D_DST_DMA_CFG_0_SCR (0)
+#define SDP_D_DST_DMA_CFG_0_WORD_COUNT (0x1)
+#define SDP_D_DST_DMA_CFG_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DST_DMA_CFG_0_RESET_MASK (_MK_MASK_CONST(0x1))
+#define SDP_D_DST_DMA_CFG_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DST_DMA_CFG_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_DST_DMA_CFG_0_READ_MASK (_MK_MASK_CONST(0x1))
+#define SDP_D_DST_DMA_CFG_0_WRITE_MASK (_MK_MASK_CONST(0x1))
+#define SDP_D_DST_DMA_CFG_0_DST_RAM_TYPE_SHIFT (_MK_SHIFT_CONST(0))
+#define SDP_D_DST_DMA_CFG_0_DST_RAM_TYPE_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_D_DST_DMA_CFG_0_DST_RAM_TYPE_SHIFT))
+#define SDP_D_DST_DMA_CFG_0_DST_RAM_TYPE_RANGE (0 : 0)
+#define SDP_D_DST_DMA_CFG_0_DST_RAM_TYPE_WOFFSET (0x0)
+#define SDP_D_DST_DMA_CFG_0_DST_RAM_TYPE_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DST_DMA_CFG_0_DST_RAM_TYPE_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define SDP_D_DST_DMA_CFG_0_DST_RAM_TYPE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DST_DMA_CFG_0_DST_RAM_TYPE_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_DST_DMA_CFG_0_DST_RAM_TYPE_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define SDP_D_DST_DMA_CFG_0_DST_RAM_TYPE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define SDP_D_DST_DMA_CFG_0_DST_RAM_TYPE_CV (_MK_ENUM_CONST(0))
+#define SDP_D_DST_DMA_CFG_0_DST_RAM_TYPE_MC (_MK_ENUM_CONST(1))
+
+// Register SDP_D_DST_BATCH_STRIDE_0
+#define SDP_D_DST_BATCH_STRIDE_0 (_MK_ADDR_CONST(0xb0b8))
+#define SDP_D_DST_BATCH_STRIDE_0_SECURE (0x0)
+#define SDP_D_DST_BATCH_STRIDE_0_DUAL (0x0)
+#define SDP_D_DST_BATCH_STRIDE_0_SCR (0)
+#define SDP_D_DST_BATCH_STRIDE_0_WORD_COUNT (0x1)
+#define SDP_D_DST_BATCH_STRIDE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DST_BATCH_STRIDE_0_RESET_MASK (_MK_MASK_CONST(0xffffffe0))
+#define SDP_D_DST_BATCH_STRIDE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DST_BATCH_STRIDE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_DST_BATCH_STRIDE_0_READ_MASK (_MK_MASK_CONST(0xffffffe0))
+#define SDP_D_DST_BATCH_STRIDE_0_WRITE_MASK (_MK_MASK_CONST(0xffffffe0))
+#define SDP_D_DST_BATCH_STRIDE_0_DST_BATCH_STRIDE_SHIFT (_MK_SHIFT_CONST(5))
+#define SDP_D_DST_BATCH_STRIDE_0_DST_BATCH_STRIDE_FIELD \
+	(_MK_FIELD_CONST(0x7ffffff,                     \
+			 SDP_D_DST_BATCH_STRIDE_0_DST_BATCH_STRIDE_SHIFT))
+#define SDP_D_DST_BATCH_STRIDE_0_DST_BATCH_STRIDE_RANGE (31 : 5)
+#define SDP_D_DST_BATCH_STRIDE_0_DST_BATCH_STRIDE_WOFFSET (0x0)
+#define SDP_D_DST_BATCH_STRIDE_0_DST_BATCH_STRIDE_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DST_BATCH_STRIDE_0_DST_BATCH_STRIDE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffffff))
+#define SDP_D_DST_BATCH_STRIDE_0_DST_BATCH_STRIDE_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DST_BATCH_STRIDE_0_DST_BATCH_STRIDE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DST_BATCH_STRIDE_0_DST_BATCH_STRIDE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DST_BATCH_STRIDE_0_DST_BATCH_STRIDE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_D_DATA_FORMAT_0
+#define SDP_D_DATA_FORMAT_0 (_MK_ADDR_CONST(0xb0bc))
+#define SDP_D_DATA_FORMAT_0_SECURE (0x0)
+#define SDP_D_DATA_FORMAT_0_DUAL (0x0)
+#define SDP_D_DATA_FORMAT_0_SCR (0)
+#define SDP_D_DATA_FORMAT_0_WORD_COUNT (0x1)
+#define SDP_D_DATA_FORMAT_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DATA_FORMAT_0_RESET_MASK (_MK_MASK_CONST(0xf))
+#define SDP_D_DATA_FORMAT_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_DATA_FORMAT_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_DATA_FORMAT_0_READ_MASK (_MK_MASK_CONST(0xf))
+#define SDP_D_DATA_FORMAT_0_WRITE_MASK (_MK_MASK_CONST(0xf))
+#define SDP_D_DATA_FORMAT_0_PROC_PRECISION_SHIFT (_MK_SHIFT_CONST(0))
+#define SDP_D_DATA_FORMAT_0_PROC_PRECISION_FIELD \
+	(_MK_FIELD_CONST(0x3, SDP_D_DATA_FORMAT_0_PROC_PRECISION_SHIFT))
+#define SDP_D_DATA_FORMAT_0_PROC_PRECISION_RANGE (1 : 0)
+#define SDP_D_DATA_FORMAT_0_PROC_PRECISION_WOFFSET (0x0)
+#define SDP_D_DATA_FORMAT_0_PROC_PRECISION_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DATA_FORMAT_0_PROC_PRECISION_DEFAULT_MASK (_MK_MASK_CONST(0x3))
+#define SDP_D_DATA_FORMAT_0_PROC_PRECISION_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DATA_FORMAT_0_PROC_PRECISION_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_DATA_FORMAT_0_PROC_PRECISION_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DATA_FORMAT_0_PROC_PRECISION_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define SDP_D_DATA_FORMAT_0_PROC_PRECISION_INT8 (_MK_ENUM_CONST(0))
+#define SDP_D_DATA_FORMAT_0_PROC_PRECISION_INT16 (_MK_ENUM_CONST(1))
+#define SDP_D_DATA_FORMAT_0_PROC_PRECISION_FP16 (_MK_ENUM_CONST(2))
+
+#define SDP_D_DATA_FORMAT_0_OUT_PRECISION_SHIFT (_MK_SHIFT_CONST(2))
+#define SDP_D_DATA_FORMAT_0_OUT_PRECISION_FIELD \
+	(_MK_FIELD_CONST(0x3, SDP_D_DATA_FORMAT_0_OUT_PRECISION_SHIFT))
+#define SDP_D_DATA_FORMAT_0_OUT_PRECISION_RANGE (3 : 2)
+#define SDP_D_DATA_FORMAT_0_OUT_PRECISION_WOFFSET (0x0)
+#define SDP_D_DATA_FORMAT_0_OUT_PRECISION_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DATA_FORMAT_0_OUT_PRECISION_DEFAULT_MASK (_MK_MASK_CONST(0x3))
+#define SDP_D_DATA_FORMAT_0_OUT_PRECISION_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_DATA_FORMAT_0_OUT_PRECISION_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_DATA_FORMAT_0_OUT_PRECISION_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_DATA_FORMAT_0_OUT_PRECISION_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define SDP_D_DATA_FORMAT_0_OUT_PRECISION_INT8 (_MK_ENUM_CONST(0))
+#define SDP_D_DATA_FORMAT_0_OUT_PRECISION_INT16 (_MK_ENUM_CONST(1))
+#define SDP_D_DATA_FORMAT_0_OUT_PRECISION_FP16 (_MK_ENUM_CONST(2))
+
+// Register SDP_D_CVT_OFFSET_0
+#define SDP_D_CVT_OFFSET_0 (_MK_ADDR_CONST(0xb0c0))
+#define SDP_D_CVT_OFFSET_0_SECURE (0x0)
+#define SDP_D_CVT_OFFSET_0_DUAL (0x0)
+#define SDP_D_CVT_OFFSET_0_SCR (0)
+#define SDP_D_CVT_OFFSET_0_WORD_COUNT (0x1)
+#define SDP_D_CVT_OFFSET_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_CVT_OFFSET_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_D_CVT_OFFSET_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_CVT_OFFSET_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_CVT_OFFSET_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_D_CVT_OFFSET_0_WRITE_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_D_CVT_OFFSET_0_CVT_OFFSET_SHIFT (_MK_SHIFT_CONST(0))
+#define SDP_D_CVT_OFFSET_0_CVT_OFFSET_FIELD \
+	(_MK_FIELD_CONST(0xffffffff, SDP_D_CVT_OFFSET_0_CVT_OFFSET_SHIFT))
+#define SDP_D_CVT_OFFSET_0_CVT_OFFSET_RANGE (31 : 0)
+#define SDP_D_CVT_OFFSET_0_CVT_OFFSET_WOFFSET (0x0)
+#define SDP_D_CVT_OFFSET_0_CVT_OFFSET_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_CVT_OFFSET_0_CVT_OFFSET_DEFAULT_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_D_CVT_OFFSET_0_CVT_OFFSET_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_CVT_OFFSET_0_CVT_OFFSET_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_CVT_OFFSET_0_CVT_OFFSET_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define SDP_D_CVT_OFFSET_0_CVT_OFFSET_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+// Register SDP_D_CVT_SCALE_0
+#define SDP_D_CVT_SCALE_0 (_MK_ADDR_CONST(0xb0c4))
+#define SDP_D_CVT_SCALE_0_SECURE (0x0)
+#define SDP_D_CVT_SCALE_0_DUAL (0x0)
+#define SDP_D_CVT_SCALE_0_SCR (0)
+#define SDP_D_CVT_SCALE_0_WORD_COUNT (0x1)
+#define SDP_D_CVT_SCALE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_CVT_SCALE_0_RESET_MASK (_MK_MASK_CONST(0xffff))
+#define SDP_D_CVT_SCALE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_CVT_SCALE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_CVT_SCALE_0_READ_MASK (_MK_MASK_CONST(0xffff))
+#define SDP_D_CVT_SCALE_0_WRITE_MASK (_MK_MASK_CONST(0xffff))
+#define SDP_D_CVT_SCALE_0_CVT_SCALE_SHIFT (_MK_SHIFT_CONST(0))
+#define SDP_D_CVT_SCALE_0_CVT_SCALE_FIELD \
+	(_MK_FIELD_CONST(0xffff, SDP_D_CVT_SCALE_0_CVT_SCALE_SHIFT))
+#define SDP_D_CVT_SCALE_0_CVT_SCALE_RANGE (15 : 0)
+#define SDP_D_CVT_SCALE_0_CVT_SCALE_WOFFSET (0x0)
+#define SDP_D_CVT_SCALE_0_CVT_SCALE_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_CVT_SCALE_0_CVT_SCALE_DEFAULT_MASK (_MK_MASK_CONST(0xffff))
+#define SDP_D_CVT_SCALE_0_CVT_SCALE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_CVT_SCALE_0_CVT_SCALE_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_CVT_SCALE_0_CVT_SCALE_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define SDP_D_CVT_SCALE_0_CVT_SCALE_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+// Register SDP_D_CVT_SHIFT_0
+#define SDP_D_CVT_SHIFT_0 (_MK_ADDR_CONST(0xb0c8))
+#define SDP_D_CVT_SHIFT_0_SECURE (0x0)
+#define SDP_D_CVT_SHIFT_0_DUAL (0x0)
+#define SDP_D_CVT_SHIFT_0_SCR (0)
+#define SDP_D_CVT_SHIFT_0_WORD_COUNT (0x1)
+#define SDP_D_CVT_SHIFT_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_CVT_SHIFT_0_RESET_MASK (_MK_MASK_CONST(0x3f))
+#define SDP_D_CVT_SHIFT_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_CVT_SHIFT_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_CVT_SHIFT_0_READ_MASK (_MK_MASK_CONST(0x3f))
+#define SDP_D_CVT_SHIFT_0_WRITE_MASK (_MK_MASK_CONST(0x3f))
+#define SDP_D_CVT_SHIFT_0_CVT_SHIFT_SHIFT (_MK_SHIFT_CONST(0))
+#define SDP_D_CVT_SHIFT_0_CVT_SHIFT_FIELD \
+	(_MK_FIELD_CONST(0x3f, SDP_D_CVT_SHIFT_0_CVT_SHIFT_SHIFT))
+#define SDP_D_CVT_SHIFT_0_CVT_SHIFT_RANGE (5 : 0)
+#define SDP_D_CVT_SHIFT_0_CVT_SHIFT_WOFFSET (0x0)
+#define SDP_D_CVT_SHIFT_0_CVT_SHIFT_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_CVT_SHIFT_0_CVT_SHIFT_DEFAULT_MASK (_MK_MASK_CONST(0x3f))
+#define SDP_D_CVT_SHIFT_0_CVT_SHIFT_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_CVT_SHIFT_0_CVT_SHIFT_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_CVT_SHIFT_0_CVT_SHIFT_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define SDP_D_CVT_SHIFT_0_CVT_SHIFT_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+// Register SDP_D_STATUS_0
+#define SDP_D_STATUS_0 (_MK_ADDR_CONST(0xb0cc))
+#define SDP_D_STATUS_0_SECURE (0x0)
+#define SDP_D_STATUS_0_DUAL (0x0)
+#define SDP_D_STATUS_0_SCR (0)
+#define SDP_D_STATUS_0_WORD_COUNT (0x1)
+#define SDP_D_STATUS_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_STATUS_0_RESET_MASK (_MK_MASK_CONST(0x1))
+#define SDP_D_STATUS_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_STATUS_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_STATUS_0_READ_MASK (_MK_MASK_CONST(0x1))
+#define SDP_D_STATUS_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_STATUS_0_STATUS_UNEQUAL_SHIFT (_MK_SHIFT_CONST(0))
+#define SDP_D_STATUS_0_STATUS_UNEQUAL_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_D_STATUS_0_STATUS_UNEQUAL_SHIFT))
+#define SDP_D_STATUS_0_STATUS_UNEQUAL_RANGE (0 : 0)
+#define SDP_D_STATUS_0_STATUS_UNEQUAL_WOFFSET (0x0)
+#define SDP_D_STATUS_0_STATUS_UNEQUAL_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_STATUS_0_STATUS_UNEQUAL_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define SDP_D_STATUS_0_STATUS_UNEQUAL_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_STATUS_0_STATUS_UNEQUAL_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_STATUS_0_STATUS_UNEQUAL_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define SDP_D_STATUS_0_STATUS_UNEQUAL_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+// Register SDP_D_STATUS_NAN_INPUT_NUM_0
+#define SDP_D_STATUS_NAN_INPUT_NUM_0 (_MK_ADDR_CONST(0xb0d0))
+#define SDP_D_STATUS_NAN_INPUT_NUM_0_SECURE (0x0)
+#define SDP_D_STATUS_NAN_INPUT_NUM_0_DUAL (0x0)
+#define SDP_D_STATUS_NAN_INPUT_NUM_0_SCR (0)
+#define SDP_D_STATUS_NAN_INPUT_NUM_0_WORD_COUNT (0x1)
+#define SDP_D_STATUS_NAN_INPUT_NUM_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_STATUS_NAN_INPUT_NUM_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_D_STATUS_NAN_INPUT_NUM_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_STATUS_NAN_INPUT_NUM_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_STATUS_NAN_INPUT_NUM_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_D_STATUS_NAN_INPUT_NUM_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_STATUS_NAN_INPUT_NUM_0_STATUS_NAN_INPUT_NUM_SHIFT \
+	(_MK_SHIFT_CONST(0))
+#define SDP_D_STATUS_NAN_INPUT_NUM_0_STATUS_NAN_INPUT_NUM_FIELD \
+	(_MK_FIELD_CONST(                                       \
+		0xffffffff,                                     \
+		SDP_D_STATUS_NAN_INPUT_NUM_0_STATUS_NAN_INPUT_NUM_SHIFT))
+#define SDP_D_STATUS_NAN_INPUT_NUM_0_STATUS_NAN_INPUT_NUM_RANGE (31 : 0)
+#define SDP_D_STATUS_NAN_INPUT_NUM_0_STATUS_NAN_INPUT_NUM_WOFFSET (0x0)
+#define SDP_D_STATUS_NAN_INPUT_NUM_0_STATUS_NAN_INPUT_NUM_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_STATUS_NAN_INPUT_NUM_0_STATUS_NAN_INPUT_NUM_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define SDP_D_STATUS_NAN_INPUT_NUM_0_STATUS_NAN_INPUT_NUM_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_STATUS_NAN_INPUT_NUM_0_STATUS_NAN_INPUT_NUM_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_STATUS_NAN_INPUT_NUM_0_STATUS_NAN_INPUT_NUM_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_STATUS_NAN_INPUT_NUM_0_STATUS_NAN_INPUT_NUM_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_D_STATUS_INF_INPUT_NUM_0
+#define SDP_D_STATUS_INF_INPUT_NUM_0 (_MK_ADDR_CONST(0xb0d4))
+#define SDP_D_STATUS_INF_INPUT_NUM_0_SECURE (0x0)
+#define SDP_D_STATUS_INF_INPUT_NUM_0_DUAL (0x0)
+#define SDP_D_STATUS_INF_INPUT_NUM_0_SCR (0)
+#define SDP_D_STATUS_INF_INPUT_NUM_0_WORD_COUNT (0x1)
+#define SDP_D_STATUS_INF_INPUT_NUM_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_STATUS_INF_INPUT_NUM_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_D_STATUS_INF_INPUT_NUM_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_STATUS_INF_INPUT_NUM_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_STATUS_INF_INPUT_NUM_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_D_STATUS_INF_INPUT_NUM_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_STATUS_INF_INPUT_NUM_0_STATUS_INF_INPUT_NUM_SHIFT \
+	(_MK_SHIFT_CONST(0))
+#define SDP_D_STATUS_INF_INPUT_NUM_0_STATUS_INF_INPUT_NUM_FIELD \
+	(_MK_FIELD_CONST(                                       \
+		0xffffffff,                                     \
+		SDP_D_STATUS_INF_INPUT_NUM_0_STATUS_INF_INPUT_NUM_SHIFT))
+#define SDP_D_STATUS_INF_INPUT_NUM_0_STATUS_INF_INPUT_NUM_RANGE (31 : 0)
+#define SDP_D_STATUS_INF_INPUT_NUM_0_STATUS_INF_INPUT_NUM_WOFFSET (0x0)
+#define SDP_D_STATUS_INF_INPUT_NUM_0_STATUS_INF_INPUT_NUM_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_STATUS_INF_INPUT_NUM_0_STATUS_INF_INPUT_NUM_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define SDP_D_STATUS_INF_INPUT_NUM_0_STATUS_INF_INPUT_NUM_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_STATUS_INF_INPUT_NUM_0_STATUS_INF_INPUT_NUM_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_STATUS_INF_INPUT_NUM_0_STATUS_INF_INPUT_NUM_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_STATUS_INF_INPUT_NUM_0_STATUS_INF_INPUT_NUM_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_D_STATUS_NAN_OUTPUT_NUM_0
+#define SDP_D_STATUS_NAN_OUTPUT_NUM_0 (_MK_ADDR_CONST(0xb0d8))
+#define SDP_D_STATUS_NAN_OUTPUT_NUM_0_SECURE (0x0)
+#define SDP_D_STATUS_NAN_OUTPUT_NUM_0_DUAL (0x0)
+#define SDP_D_STATUS_NAN_OUTPUT_NUM_0_SCR (0)
+#define SDP_D_STATUS_NAN_OUTPUT_NUM_0_WORD_COUNT (0x1)
+#define SDP_D_STATUS_NAN_OUTPUT_NUM_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_STATUS_NAN_OUTPUT_NUM_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_D_STATUS_NAN_OUTPUT_NUM_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_STATUS_NAN_OUTPUT_NUM_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_STATUS_NAN_OUTPUT_NUM_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_D_STATUS_NAN_OUTPUT_NUM_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_STATUS_NAN_OUTPUT_NUM_0_STATUS_NAN_OUTPUT_NUM_SHIFT \
+	(_MK_SHIFT_CONST(0))
+#define SDP_D_STATUS_NAN_OUTPUT_NUM_0_STATUS_NAN_OUTPUT_NUM_FIELD \
+	(_MK_FIELD_CONST(                                         \
+		0xffffffff,                                       \
+		SDP_D_STATUS_NAN_OUTPUT_NUM_0_STATUS_NAN_OUTPUT_NUM_SHIFT))
+#define SDP_D_STATUS_NAN_OUTPUT_NUM_0_STATUS_NAN_OUTPUT_NUM_RANGE (31 : 0)
+#define SDP_D_STATUS_NAN_OUTPUT_NUM_0_STATUS_NAN_OUTPUT_NUM_WOFFSET (0x0)
+#define SDP_D_STATUS_NAN_OUTPUT_NUM_0_STATUS_NAN_OUTPUT_NUM_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_STATUS_NAN_OUTPUT_NUM_0_STATUS_NAN_OUTPUT_NUM_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define SDP_D_STATUS_NAN_OUTPUT_NUM_0_STATUS_NAN_OUTPUT_NUM_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_STATUS_NAN_OUTPUT_NUM_0_STATUS_NAN_OUTPUT_NUM_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_STATUS_NAN_OUTPUT_NUM_0_STATUS_NAN_OUTPUT_NUM_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_STATUS_NAN_OUTPUT_NUM_0_STATUS_NAN_OUTPUT_NUM_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_D_PERF_ENABLE_0
+#define SDP_D_PERF_ENABLE_0 (_MK_ADDR_CONST(0xb0dc))
+#define SDP_D_PERF_ENABLE_0_SECURE (0x0)
+#define SDP_D_PERF_ENABLE_0_DUAL (0x0)
+#define SDP_D_PERF_ENABLE_0_SCR (0)
+#define SDP_D_PERF_ENABLE_0_WORD_COUNT (0x1)
+#define SDP_D_PERF_ENABLE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_ENABLE_0_RESET_MASK (_MK_MASK_CONST(0xf))
+#define SDP_D_PERF_ENABLE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_ENABLE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_ENABLE_0_READ_MASK (_MK_MASK_CONST(0xf))
+#define SDP_D_PERF_ENABLE_0_WRITE_MASK (_MK_MASK_CONST(0xf))
+#define SDP_D_PERF_ENABLE_0_PERF_DMA_EN_SHIFT (_MK_SHIFT_CONST(0))
+#define SDP_D_PERF_ENABLE_0_PERF_DMA_EN_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_D_PERF_ENABLE_0_PERF_DMA_EN_SHIFT))
+#define SDP_D_PERF_ENABLE_0_PERF_DMA_EN_RANGE (0 : 0)
+#define SDP_D_PERF_ENABLE_0_PERF_DMA_EN_WOFFSET (0x0)
+#define SDP_D_PERF_ENABLE_0_PERF_DMA_EN_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_ENABLE_0_PERF_DMA_EN_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define SDP_D_PERF_ENABLE_0_PERF_DMA_EN_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_ENABLE_0_PERF_DMA_EN_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_ENABLE_0_PERF_DMA_EN_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_ENABLE_0_PERF_DMA_EN_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define SDP_D_PERF_ENABLE_0_PERF_DMA_EN_INIT_ENUM (NO)
+#define SDP_D_PERF_ENABLE_0_PERF_DMA_EN_NO (_MK_ENUM_CONST(0))
+#define SDP_D_PERF_ENABLE_0_PERF_DMA_EN_YES (_MK_ENUM_CONST(1))
+
+#define SDP_D_PERF_ENABLE_0_PERF_LUT_EN_SHIFT (_MK_SHIFT_CONST(1))
+#define SDP_D_PERF_ENABLE_0_PERF_LUT_EN_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_D_PERF_ENABLE_0_PERF_LUT_EN_SHIFT))
+#define SDP_D_PERF_ENABLE_0_PERF_LUT_EN_RANGE (1 : 1)
+#define SDP_D_PERF_ENABLE_0_PERF_LUT_EN_WOFFSET (0x0)
+#define SDP_D_PERF_ENABLE_0_PERF_LUT_EN_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_ENABLE_0_PERF_LUT_EN_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define SDP_D_PERF_ENABLE_0_PERF_LUT_EN_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_ENABLE_0_PERF_LUT_EN_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_ENABLE_0_PERF_LUT_EN_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_ENABLE_0_PERF_LUT_EN_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define SDP_D_PERF_ENABLE_0_PERF_LUT_EN_INIT_ENUM (NO)
+#define SDP_D_PERF_ENABLE_0_PERF_LUT_EN_NO (_MK_ENUM_CONST(0))
+#define SDP_D_PERF_ENABLE_0_PERF_LUT_EN_YES (_MK_ENUM_CONST(1))
+
+#define SDP_D_PERF_ENABLE_0_PERF_SAT_EN_SHIFT (_MK_SHIFT_CONST(2))
+#define SDP_D_PERF_ENABLE_0_PERF_SAT_EN_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_D_PERF_ENABLE_0_PERF_SAT_EN_SHIFT))
+#define SDP_D_PERF_ENABLE_0_PERF_SAT_EN_RANGE (2 : 2)
+#define SDP_D_PERF_ENABLE_0_PERF_SAT_EN_WOFFSET (0x0)
+#define SDP_D_PERF_ENABLE_0_PERF_SAT_EN_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_ENABLE_0_PERF_SAT_EN_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define SDP_D_PERF_ENABLE_0_PERF_SAT_EN_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_ENABLE_0_PERF_SAT_EN_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_ENABLE_0_PERF_SAT_EN_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_ENABLE_0_PERF_SAT_EN_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define SDP_D_PERF_ENABLE_0_PERF_SAT_EN_INIT_ENUM (NO)
+#define SDP_D_PERF_ENABLE_0_PERF_SAT_EN_NO (_MK_ENUM_CONST(0))
+#define SDP_D_PERF_ENABLE_0_PERF_SAT_EN_YES (_MK_ENUM_CONST(1))
+
+#define SDP_D_PERF_ENABLE_0_PERF_NAN_INF_COUNT_EN_SHIFT (_MK_SHIFT_CONST(3))
+#define SDP_D_PERF_ENABLE_0_PERF_NAN_INF_COUNT_EN_FIELD \
+	(_MK_FIELD_CONST(0x1, SDP_D_PERF_ENABLE_0_PERF_NAN_INF_COUNT_EN_SHIFT))
+#define SDP_D_PERF_ENABLE_0_PERF_NAN_INF_COUNT_EN_RANGE (3 : 3)
+#define SDP_D_PERF_ENABLE_0_PERF_NAN_INF_COUNT_EN_WOFFSET (0x0)
+#define SDP_D_PERF_ENABLE_0_PERF_NAN_INF_COUNT_EN_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_ENABLE_0_PERF_NAN_INF_COUNT_EN_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1))
+#define SDP_D_PERF_ENABLE_0_PERF_NAN_INF_COUNT_EN_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_ENABLE_0_PERF_NAN_INF_COUNT_EN_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_ENABLE_0_PERF_NAN_INF_COUNT_EN_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_ENABLE_0_PERF_NAN_INF_COUNT_EN_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define SDP_D_PERF_ENABLE_0_PERF_NAN_INF_COUNT_EN_INIT_ENUM (NO)
+#define SDP_D_PERF_ENABLE_0_PERF_NAN_INF_COUNT_EN_NO (_MK_ENUM_CONST(0))
+#define SDP_D_PERF_ENABLE_0_PERF_NAN_INF_COUNT_EN_YES (_MK_ENUM_CONST(1))
+
+// Register SDP_D_PERF_WDMA_WRITE_STALL_0
+#define SDP_D_PERF_WDMA_WRITE_STALL_0 (_MK_ADDR_CONST(0xb0e0))
+#define SDP_D_PERF_WDMA_WRITE_STALL_0_SECURE (0x0)
+#define SDP_D_PERF_WDMA_WRITE_STALL_0_DUAL (0x0)
+#define SDP_D_PERF_WDMA_WRITE_STALL_0_SCR (0)
+#define SDP_D_PERF_WDMA_WRITE_STALL_0_WORD_COUNT (0x1)
+#define SDP_D_PERF_WDMA_WRITE_STALL_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_WDMA_WRITE_STALL_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_D_PERF_WDMA_WRITE_STALL_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_WDMA_WRITE_STALL_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_WDMA_WRITE_STALL_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_D_PERF_WDMA_WRITE_STALL_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_WDMA_WRITE_STALL_0_WDMA_STALL_SHIFT (_MK_SHIFT_CONST(0))
+#define SDP_D_PERF_WDMA_WRITE_STALL_0_WDMA_STALL_FIELD \
+	(_MK_FIELD_CONST(0xffffffff,                   \
+			 SDP_D_PERF_WDMA_WRITE_STALL_0_WDMA_STALL_SHIFT))
+#define SDP_D_PERF_WDMA_WRITE_STALL_0_WDMA_STALL_RANGE (31 : 0)
+#define SDP_D_PERF_WDMA_WRITE_STALL_0_WDMA_STALL_WOFFSET (0x0)
+#define SDP_D_PERF_WDMA_WRITE_STALL_0_WDMA_STALL_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_WDMA_WRITE_STALL_0_WDMA_STALL_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define SDP_D_PERF_WDMA_WRITE_STALL_0_WDMA_STALL_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_WDMA_WRITE_STALL_0_WDMA_STALL_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_WDMA_WRITE_STALL_0_WDMA_STALL_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_WDMA_WRITE_STALL_0_WDMA_STALL_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_D_PERF_LUT_UFLOW_0
+#define SDP_D_PERF_LUT_UFLOW_0 (_MK_ADDR_CONST(0xb0e4))
+#define SDP_D_PERF_LUT_UFLOW_0_SECURE (0x0)
+#define SDP_D_PERF_LUT_UFLOW_0_DUAL (0x0)
+#define SDP_D_PERF_LUT_UFLOW_0_SCR (0)
+#define SDP_D_PERF_LUT_UFLOW_0_WORD_COUNT (0x1)
+#define SDP_D_PERF_LUT_UFLOW_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_LUT_UFLOW_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_D_PERF_LUT_UFLOW_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_LUT_UFLOW_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_LUT_UFLOW_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_D_PERF_LUT_UFLOW_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_LUT_UFLOW_0_LUT_UFLOW_SHIFT (_MK_SHIFT_CONST(0))
+#define SDP_D_PERF_LUT_UFLOW_0_LUT_UFLOW_FIELD \
+	(_MK_FIELD_CONST(0xffffffff, SDP_D_PERF_LUT_UFLOW_0_LUT_UFLOW_SHIFT))
+#define SDP_D_PERF_LUT_UFLOW_0_LUT_UFLOW_RANGE (31 : 0)
+#define SDP_D_PERF_LUT_UFLOW_0_LUT_UFLOW_WOFFSET (0x0)
+#define SDP_D_PERF_LUT_UFLOW_0_LUT_UFLOW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_LUT_UFLOW_0_LUT_UFLOW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define SDP_D_PERF_LUT_UFLOW_0_LUT_UFLOW_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_LUT_UFLOW_0_LUT_UFLOW_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_LUT_UFLOW_0_LUT_UFLOW_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_LUT_UFLOW_0_LUT_UFLOW_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_D_PERF_LUT_OFLOW_0
+#define SDP_D_PERF_LUT_OFLOW_0 (_MK_ADDR_CONST(0xb0e8))
+#define SDP_D_PERF_LUT_OFLOW_0_SECURE (0x0)
+#define SDP_D_PERF_LUT_OFLOW_0_DUAL (0x0)
+#define SDP_D_PERF_LUT_OFLOW_0_SCR (0)
+#define SDP_D_PERF_LUT_OFLOW_0_WORD_COUNT (0x1)
+#define SDP_D_PERF_LUT_OFLOW_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_LUT_OFLOW_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_D_PERF_LUT_OFLOW_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_LUT_OFLOW_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_LUT_OFLOW_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_D_PERF_LUT_OFLOW_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_LUT_OFLOW_0_LUT_OFLOW_SHIFT (_MK_SHIFT_CONST(0))
+#define SDP_D_PERF_LUT_OFLOW_0_LUT_OFLOW_FIELD \
+	(_MK_FIELD_CONST(0xffffffff, SDP_D_PERF_LUT_OFLOW_0_LUT_OFLOW_SHIFT))
+#define SDP_D_PERF_LUT_OFLOW_0_LUT_OFLOW_RANGE (31 : 0)
+#define SDP_D_PERF_LUT_OFLOW_0_LUT_OFLOW_WOFFSET (0x0)
+#define SDP_D_PERF_LUT_OFLOW_0_LUT_OFLOW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_LUT_OFLOW_0_LUT_OFLOW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define SDP_D_PERF_LUT_OFLOW_0_LUT_OFLOW_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_LUT_OFLOW_0_LUT_OFLOW_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_LUT_OFLOW_0_LUT_OFLOW_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_LUT_OFLOW_0_LUT_OFLOW_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_D_PERF_OUT_SATURATION_0
+#define SDP_D_PERF_OUT_SATURATION_0 (_MK_ADDR_CONST(0xb0ec))
+#define SDP_D_PERF_OUT_SATURATION_0_SECURE (0x0)
+#define SDP_D_PERF_OUT_SATURATION_0_DUAL (0x0)
+#define SDP_D_PERF_OUT_SATURATION_0_SCR (0)
+#define SDP_D_PERF_OUT_SATURATION_0_WORD_COUNT (0x1)
+#define SDP_D_PERF_OUT_SATURATION_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_OUT_SATURATION_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_D_PERF_OUT_SATURATION_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_OUT_SATURATION_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_OUT_SATURATION_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_D_PERF_OUT_SATURATION_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_OUT_SATURATION_0_OUT_SATURATION_SHIFT (_MK_SHIFT_CONST(0))
+#define SDP_D_PERF_OUT_SATURATION_0_OUT_SATURATION_FIELD \
+	(_MK_FIELD_CONST(0xffffffff,                     \
+			 SDP_D_PERF_OUT_SATURATION_0_OUT_SATURATION_SHIFT))
+#define SDP_D_PERF_OUT_SATURATION_0_OUT_SATURATION_RANGE (31 : 0)
+#define SDP_D_PERF_OUT_SATURATION_0_OUT_SATURATION_WOFFSET (0x0)
+#define SDP_D_PERF_OUT_SATURATION_0_OUT_SATURATION_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_OUT_SATURATION_0_OUT_SATURATION_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define SDP_D_PERF_OUT_SATURATION_0_OUT_SATURATION_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_OUT_SATURATION_0_OUT_SATURATION_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_OUT_SATURATION_0_OUT_SATURATION_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_OUT_SATURATION_0_OUT_SATURATION_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_D_PERF_LUT_HYBRID_0
+#define SDP_D_PERF_LUT_HYBRID_0 (_MK_ADDR_CONST(0xb0f0))
+#define SDP_D_PERF_LUT_HYBRID_0_SECURE (0x0)
+#define SDP_D_PERF_LUT_HYBRID_0_DUAL (0x0)
+#define SDP_D_PERF_LUT_HYBRID_0_SCR (0)
+#define SDP_D_PERF_LUT_HYBRID_0_WORD_COUNT (0x1)
+#define SDP_D_PERF_LUT_HYBRID_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_LUT_HYBRID_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_D_PERF_LUT_HYBRID_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_LUT_HYBRID_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_LUT_HYBRID_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_D_PERF_LUT_HYBRID_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_LUT_HYBRID_0_LUT_HYBRID_SHIFT (_MK_SHIFT_CONST(0))
+#define SDP_D_PERF_LUT_HYBRID_0_LUT_HYBRID_FIELD \
+	(_MK_FIELD_CONST(0xffffffff, SDP_D_PERF_LUT_HYBRID_0_LUT_HYBRID_SHIFT))
+#define SDP_D_PERF_LUT_HYBRID_0_LUT_HYBRID_RANGE (31 : 0)
+#define SDP_D_PERF_LUT_HYBRID_0_LUT_HYBRID_WOFFSET (0x0)
+#define SDP_D_PERF_LUT_HYBRID_0_LUT_HYBRID_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_LUT_HYBRID_0_LUT_HYBRID_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define SDP_D_PERF_LUT_HYBRID_0_LUT_HYBRID_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_LUT_HYBRID_0_LUT_HYBRID_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_LUT_HYBRID_0_LUT_HYBRID_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_LUT_HYBRID_0_LUT_HYBRID_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_D_PERF_LUT_LE_HIT_0
+#define SDP_D_PERF_LUT_LE_HIT_0 (_MK_ADDR_CONST(0xb0f4))
+#define SDP_D_PERF_LUT_LE_HIT_0_SECURE (0x0)
+#define SDP_D_PERF_LUT_LE_HIT_0_DUAL (0x0)
+#define SDP_D_PERF_LUT_LE_HIT_0_SCR (0)
+#define SDP_D_PERF_LUT_LE_HIT_0_WORD_COUNT (0x1)
+#define SDP_D_PERF_LUT_LE_HIT_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_LUT_LE_HIT_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_D_PERF_LUT_LE_HIT_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_LUT_LE_HIT_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_LUT_LE_HIT_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_D_PERF_LUT_LE_HIT_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_LUT_LE_HIT_0_LUT_LE_HIT_SHIFT (_MK_SHIFT_CONST(0))
+#define SDP_D_PERF_LUT_LE_HIT_0_LUT_LE_HIT_FIELD \
+	(_MK_FIELD_CONST(0xffffffff, SDP_D_PERF_LUT_LE_HIT_0_LUT_LE_HIT_SHIFT))
+#define SDP_D_PERF_LUT_LE_HIT_0_LUT_LE_HIT_RANGE (31 : 0)
+#define SDP_D_PERF_LUT_LE_HIT_0_LUT_LE_HIT_WOFFSET (0x0)
+#define SDP_D_PERF_LUT_LE_HIT_0_LUT_LE_HIT_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_LUT_LE_HIT_0_LUT_LE_HIT_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define SDP_D_PERF_LUT_LE_HIT_0_LUT_LE_HIT_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_LUT_LE_HIT_0_LUT_LE_HIT_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_LUT_LE_HIT_0_LUT_LE_HIT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_LUT_LE_HIT_0_LUT_LE_HIT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register SDP_D_PERF_LUT_LO_HIT_0
+#define SDP_D_PERF_LUT_LO_HIT_0 (_MK_ADDR_CONST(0xb0f8))
+#define SDP_D_PERF_LUT_LO_HIT_0_SECURE (0x0)
+#define SDP_D_PERF_LUT_LO_HIT_0_DUAL (0x0)
+#define SDP_D_PERF_LUT_LO_HIT_0_SCR (0)
+#define SDP_D_PERF_LUT_LO_HIT_0_WORD_COUNT (0x1)
+#define SDP_D_PERF_LUT_LO_HIT_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_LUT_LO_HIT_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_D_PERF_LUT_LO_HIT_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_LUT_LO_HIT_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_LUT_LO_HIT_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define SDP_D_PERF_LUT_LO_HIT_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_LUT_LO_HIT_0_LUT_LO_HIT_SHIFT (_MK_SHIFT_CONST(0))
+#define SDP_D_PERF_LUT_LO_HIT_0_LUT_LO_HIT_FIELD \
+	(_MK_FIELD_CONST(0xffffffff, SDP_D_PERF_LUT_LO_HIT_0_LUT_LO_HIT_SHIFT))
+#define SDP_D_PERF_LUT_LO_HIT_0_LUT_LO_HIT_RANGE (31 : 0)
+#define SDP_D_PERF_LUT_LO_HIT_0_LUT_LO_HIT_WOFFSET (0x0)
+#define SDP_D_PERF_LUT_LO_HIT_0_LUT_LO_HIT_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_LUT_LO_HIT_0_LUT_LO_HIT_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define SDP_D_PERF_LUT_LO_HIT_0_LUT_LO_HIT_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_LUT_LO_HIT_0_LUT_LO_HIT_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_LUT_LO_HIT_0_LUT_LO_HIT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define SDP_D_PERF_LUT_LO_HIT_0_LUT_LO_HIT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register PDP_RDMA_S_STATUS_0
+#define PDP_RDMA_S_STATUS_0 (_MK_ADDR_CONST(0xc000))
+#define PDP_RDMA_S_STATUS_0_SECURE (0x0)
+#define PDP_RDMA_S_STATUS_0_DUAL (0x0)
+#define PDP_RDMA_S_STATUS_0_SCR (0)
+#define PDP_RDMA_S_STATUS_0_WORD_COUNT (0x1)
+#define PDP_RDMA_S_STATUS_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_S_STATUS_0_RESET_MASK (_MK_MASK_CONST(0x30003))
+#define PDP_RDMA_S_STATUS_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_S_STATUS_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_S_STATUS_0_READ_MASK (_MK_MASK_CONST(0x30003))
+#define PDP_RDMA_S_STATUS_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_S_STATUS_0_STATUS_0_SHIFT (_MK_SHIFT_CONST(0))
+#define PDP_RDMA_S_STATUS_0_STATUS_0_FIELD \
+	(_MK_FIELD_CONST(0x3, PDP_RDMA_S_STATUS_0_STATUS_0_SHIFT))
+#define PDP_RDMA_S_STATUS_0_STATUS_0_RANGE (1 : 0)
+#define PDP_RDMA_S_STATUS_0_STATUS_0_WOFFSET (0x0)
+#define PDP_RDMA_S_STATUS_0_STATUS_0_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_S_STATUS_0_STATUS_0_DEFAULT_MASK (_MK_MASK_CONST(0x3))
+#define PDP_RDMA_S_STATUS_0_STATUS_0_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_S_STATUS_0_STATUS_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_S_STATUS_0_STATUS_0_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_S_STATUS_0_STATUS_0_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define PDP_RDMA_S_STATUS_0_STATUS_0_INIT_ENUM (IDLE)
+#define PDP_RDMA_S_STATUS_0_STATUS_0_IDLE (_MK_ENUM_CONST(0))
+#define PDP_RDMA_S_STATUS_0_STATUS_0_RUNNING (_MK_ENUM_CONST(1))
+#define PDP_RDMA_S_STATUS_0_STATUS_0_PENDING (_MK_ENUM_CONST(2))
+
+#define PDP_RDMA_S_STATUS_0_STATUS_1_SHIFT (_MK_SHIFT_CONST(16))
+#define PDP_RDMA_S_STATUS_0_STATUS_1_FIELD \
+	(_MK_FIELD_CONST(0x3, PDP_RDMA_S_STATUS_0_STATUS_1_SHIFT))
+#define PDP_RDMA_S_STATUS_0_STATUS_1_RANGE (17 : 16)
+#define PDP_RDMA_S_STATUS_0_STATUS_1_WOFFSET (0x0)
+#define PDP_RDMA_S_STATUS_0_STATUS_1_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_S_STATUS_0_STATUS_1_DEFAULT_MASK (_MK_MASK_CONST(0x3))
+#define PDP_RDMA_S_STATUS_0_STATUS_1_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_S_STATUS_0_STATUS_1_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_S_STATUS_0_STATUS_1_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_S_STATUS_0_STATUS_1_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define PDP_RDMA_S_STATUS_0_STATUS_1_INIT_ENUM (IDLE)
+#define PDP_RDMA_S_STATUS_0_STATUS_1_IDLE (_MK_ENUM_CONST(0))
+#define PDP_RDMA_S_STATUS_0_STATUS_1_RUNNING (_MK_ENUM_CONST(1))
+#define PDP_RDMA_S_STATUS_0_STATUS_1_PENDING (_MK_ENUM_CONST(2))
+
+// Register PDP_RDMA_S_POINTER_0
+#define PDP_RDMA_S_POINTER_0 (_MK_ADDR_CONST(0xc004))
+#define PDP_RDMA_S_POINTER_0_SECURE (0x0)
+#define PDP_RDMA_S_POINTER_0_DUAL (0x0)
+#define PDP_RDMA_S_POINTER_0_SCR (0)
+#define PDP_RDMA_S_POINTER_0_WORD_COUNT (0x1)
+#define PDP_RDMA_S_POINTER_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_S_POINTER_0_RESET_MASK (_MK_MASK_CONST(0x10001))
+#define PDP_RDMA_S_POINTER_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_S_POINTER_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_S_POINTER_0_READ_MASK (_MK_MASK_CONST(0x10001))
+#define PDP_RDMA_S_POINTER_0_WRITE_MASK (_MK_MASK_CONST(0x1))
+#define PDP_RDMA_S_POINTER_0_PRODUCER_SHIFT (_MK_SHIFT_CONST(0))
+#define PDP_RDMA_S_POINTER_0_PRODUCER_FIELD \
+	(_MK_FIELD_CONST(0x1, PDP_RDMA_S_POINTER_0_PRODUCER_SHIFT))
+#define PDP_RDMA_S_POINTER_0_PRODUCER_RANGE (0 : 0)
+#define PDP_RDMA_S_POINTER_0_PRODUCER_WOFFSET (0x0)
+#define PDP_RDMA_S_POINTER_0_PRODUCER_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_S_POINTER_0_PRODUCER_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define PDP_RDMA_S_POINTER_0_PRODUCER_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_S_POINTER_0_PRODUCER_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_S_POINTER_0_PRODUCER_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_S_POINTER_0_PRODUCER_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define PDP_RDMA_S_POINTER_0_PRODUCER_INIT_ENUM (GROUP_0)
+#define PDP_RDMA_S_POINTER_0_PRODUCER_GROUP_0 (_MK_ENUM_CONST(0))
+#define PDP_RDMA_S_POINTER_0_PRODUCER_GROUP_1 (_MK_ENUM_CONST(1))
+
+#define PDP_RDMA_S_POINTER_0_CONSUMER_SHIFT (_MK_SHIFT_CONST(16))
+#define PDP_RDMA_S_POINTER_0_CONSUMER_FIELD \
+	(_MK_FIELD_CONST(0x1, PDP_RDMA_S_POINTER_0_CONSUMER_SHIFT))
+#define PDP_RDMA_S_POINTER_0_CONSUMER_RANGE (16 : 16)
+#define PDP_RDMA_S_POINTER_0_CONSUMER_WOFFSET (0x0)
+#define PDP_RDMA_S_POINTER_0_CONSUMER_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_S_POINTER_0_CONSUMER_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define PDP_RDMA_S_POINTER_0_CONSUMER_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_S_POINTER_0_CONSUMER_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_S_POINTER_0_CONSUMER_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_S_POINTER_0_CONSUMER_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define PDP_RDMA_S_POINTER_0_CONSUMER_INIT_ENUM (GROUP_0)
+#define PDP_RDMA_S_POINTER_0_CONSUMER_GROUP_0 (_MK_ENUM_CONST(0))
+#define PDP_RDMA_S_POINTER_0_CONSUMER_GROUP_1 (_MK_ENUM_CONST(1))
+
+// Register PDP_RDMA_D_OP_ENABLE_0
+#define PDP_RDMA_D_OP_ENABLE_0 (_MK_ADDR_CONST(0xc008))
+#define PDP_RDMA_D_OP_ENABLE_0_SECURE (0x0)
+#define PDP_RDMA_D_OP_ENABLE_0_DUAL (0x0)
+#define PDP_RDMA_D_OP_ENABLE_0_SCR (0)
+#define PDP_RDMA_D_OP_ENABLE_0_WORD_COUNT (0x1)
+#define PDP_RDMA_D_OP_ENABLE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_OP_ENABLE_0_RESET_MASK (_MK_MASK_CONST(0x1))
+#define PDP_RDMA_D_OP_ENABLE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_OP_ENABLE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_OP_ENABLE_0_READ_MASK (_MK_MASK_CONST(0x1))
+#define PDP_RDMA_D_OP_ENABLE_0_WRITE_MASK (_MK_MASK_CONST(0x1))
+#define PDP_RDMA_D_OP_ENABLE_0_OP_EN_SHIFT (_MK_SHIFT_CONST(0))
+#define PDP_RDMA_D_OP_ENABLE_0_OP_EN_FIELD \
+	(_MK_FIELD_CONST(0x1, PDP_RDMA_D_OP_ENABLE_0_OP_EN_SHIFT))
+#define PDP_RDMA_D_OP_ENABLE_0_OP_EN_RANGE (0 : 0)
+#define PDP_RDMA_D_OP_ENABLE_0_OP_EN_WOFFSET (0x0)
+#define PDP_RDMA_D_OP_ENABLE_0_OP_EN_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_OP_ENABLE_0_OP_EN_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define PDP_RDMA_D_OP_ENABLE_0_OP_EN_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_OP_ENABLE_0_OP_EN_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_OP_ENABLE_0_OP_EN_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_OP_ENABLE_0_OP_EN_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define PDP_RDMA_D_OP_ENABLE_0_OP_EN_INIT_ENUM (DISABLE)
+#define PDP_RDMA_D_OP_ENABLE_0_OP_EN_DISABLE (_MK_ENUM_CONST(0))
+#define PDP_RDMA_D_OP_ENABLE_0_OP_EN_ENABLE (_MK_ENUM_CONST(1))
+
+// Register PDP_RDMA_D_DATA_CUBE_IN_WIDTH_0
+#define PDP_RDMA_D_DATA_CUBE_IN_WIDTH_0 (_MK_ADDR_CONST(0xc00c))
+#define PDP_RDMA_D_DATA_CUBE_IN_WIDTH_0_SECURE (0x0)
+#define PDP_RDMA_D_DATA_CUBE_IN_WIDTH_0_DUAL (0x0)
+#define PDP_RDMA_D_DATA_CUBE_IN_WIDTH_0_SCR (0)
+#define PDP_RDMA_D_DATA_CUBE_IN_WIDTH_0_WORD_COUNT (0x1)
+#define PDP_RDMA_D_DATA_CUBE_IN_WIDTH_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_DATA_CUBE_IN_WIDTH_0_RESET_MASK (_MK_MASK_CONST(0x1fff))
+#define PDP_RDMA_D_DATA_CUBE_IN_WIDTH_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_DATA_CUBE_IN_WIDTH_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_DATA_CUBE_IN_WIDTH_0_READ_MASK (_MK_MASK_CONST(0x1fff))
+#define PDP_RDMA_D_DATA_CUBE_IN_WIDTH_0_WRITE_MASK (_MK_MASK_CONST(0x1fff))
+#define PDP_RDMA_D_DATA_CUBE_IN_WIDTH_0_CUBE_IN_WIDTH_SHIFT (_MK_SHIFT_CONST(0))
+#define PDP_RDMA_D_DATA_CUBE_IN_WIDTH_0_CUBE_IN_WIDTH_FIELD \
+	(_MK_FIELD_CONST(0x1fff,                            \
+			 PDP_RDMA_D_DATA_CUBE_IN_WIDTH_0_CUBE_IN_WIDTH_SHIFT))
+#define PDP_RDMA_D_DATA_CUBE_IN_WIDTH_0_CUBE_IN_WIDTH_RANGE (12 : 0)
+#define PDP_RDMA_D_DATA_CUBE_IN_WIDTH_0_CUBE_IN_WIDTH_WOFFSET (0x0)
+#define PDP_RDMA_D_DATA_CUBE_IN_WIDTH_0_CUBE_IN_WIDTH_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_DATA_CUBE_IN_WIDTH_0_CUBE_IN_WIDTH_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1fff))
+#define PDP_RDMA_D_DATA_CUBE_IN_WIDTH_0_CUBE_IN_WIDTH_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_DATA_CUBE_IN_WIDTH_0_CUBE_IN_WIDTH_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_DATA_CUBE_IN_WIDTH_0_CUBE_IN_WIDTH_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_DATA_CUBE_IN_WIDTH_0_CUBE_IN_WIDTH_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register PDP_RDMA_D_DATA_CUBE_IN_HEIGHT_0
+#define PDP_RDMA_D_DATA_CUBE_IN_HEIGHT_0 (_MK_ADDR_CONST(0xc010))
+#define PDP_RDMA_D_DATA_CUBE_IN_HEIGHT_0_SECURE (0x0)
+#define PDP_RDMA_D_DATA_CUBE_IN_HEIGHT_0_DUAL (0x0)
+#define PDP_RDMA_D_DATA_CUBE_IN_HEIGHT_0_SCR (0)
+#define PDP_RDMA_D_DATA_CUBE_IN_HEIGHT_0_WORD_COUNT (0x1)
+#define PDP_RDMA_D_DATA_CUBE_IN_HEIGHT_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_DATA_CUBE_IN_HEIGHT_0_RESET_MASK (_MK_MASK_CONST(0x1fff))
+#define PDP_RDMA_D_DATA_CUBE_IN_HEIGHT_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_DATA_CUBE_IN_HEIGHT_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_DATA_CUBE_IN_HEIGHT_0_READ_MASK (_MK_MASK_CONST(0x1fff))
+#define PDP_RDMA_D_DATA_CUBE_IN_HEIGHT_0_WRITE_MASK (_MK_MASK_CONST(0x1fff))
+#define PDP_RDMA_D_DATA_CUBE_IN_HEIGHT_0_CUBE_IN_HEIGHT_SHIFT \
+	(_MK_SHIFT_CONST(0))
+#define PDP_RDMA_D_DATA_CUBE_IN_HEIGHT_0_CUBE_IN_HEIGHT_FIELD \
+	(_MK_FIELD_CONST(                                     \
+		0x1fff,                                       \
+		PDP_RDMA_D_DATA_CUBE_IN_HEIGHT_0_CUBE_IN_HEIGHT_SHIFT))
+#define PDP_RDMA_D_DATA_CUBE_IN_HEIGHT_0_CUBE_IN_HEIGHT_RANGE (12 : 0)
+#define PDP_RDMA_D_DATA_CUBE_IN_HEIGHT_0_CUBE_IN_HEIGHT_WOFFSET (0x0)
+#define PDP_RDMA_D_DATA_CUBE_IN_HEIGHT_0_CUBE_IN_HEIGHT_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_DATA_CUBE_IN_HEIGHT_0_CUBE_IN_HEIGHT_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1fff))
+#define PDP_RDMA_D_DATA_CUBE_IN_HEIGHT_0_CUBE_IN_HEIGHT_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_DATA_CUBE_IN_HEIGHT_0_CUBE_IN_HEIGHT_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_DATA_CUBE_IN_HEIGHT_0_CUBE_IN_HEIGHT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_DATA_CUBE_IN_HEIGHT_0_CUBE_IN_HEIGHT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register PDP_RDMA_D_DATA_CUBE_IN_CHANNEL_0
+#define PDP_RDMA_D_DATA_CUBE_IN_CHANNEL_0 (_MK_ADDR_CONST(0xc014))
+#define PDP_RDMA_D_DATA_CUBE_IN_CHANNEL_0_SECURE (0x0)
+#define PDP_RDMA_D_DATA_CUBE_IN_CHANNEL_0_DUAL (0x0)
+#define PDP_RDMA_D_DATA_CUBE_IN_CHANNEL_0_SCR (0)
+#define PDP_RDMA_D_DATA_CUBE_IN_CHANNEL_0_WORD_COUNT (0x1)
+#define PDP_RDMA_D_DATA_CUBE_IN_CHANNEL_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_DATA_CUBE_IN_CHANNEL_0_RESET_MASK (_MK_MASK_CONST(0x1fff))
+#define PDP_RDMA_D_DATA_CUBE_IN_CHANNEL_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_DATA_CUBE_IN_CHANNEL_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_DATA_CUBE_IN_CHANNEL_0_READ_MASK (_MK_MASK_CONST(0x1fff))
+#define PDP_RDMA_D_DATA_CUBE_IN_CHANNEL_0_WRITE_MASK (_MK_MASK_CONST(0x1fff))
+#define PDP_RDMA_D_DATA_CUBE_IN_CHANNEL_0_CUBE_IN_CHANNEL_SHIFT \
+	(_MK_SHIFT_CONST(0))
+#define PDP_RDMA_D_DATA_CUBE_IN_CHANNEL_0_CUBE_IN_CHANNEL_FIELD \
+	(_MK_FIELD_CONST(                                       \
+		0x1fff,                                         \
+		PDP_RDMA_D_DATA_CUBE_IN_CHANNEL_0_CUBE_IN_CHANNEL_SHIFT))
+#define PDP_RDMA_D_DATA_CUBE_IN_CHANNEL_0_CUBE_IN_CHANNEL_RANGE (12 : 0)
+#define PDP_RDMA_D_DATA_CUBE_IN_CHANNEL_0_CUBE_IN_CHANNEL_WOFFSET (0x0)
+#define PDP_RDMA_D_DATA_CUBE_IN_CHANNEL_0_CUBE_IN_CHANNEL_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_DATA_CUBE_IN_CHANNEL_0_CUBE_IN_CHANNEL_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1fff))
+#define PDP_RDMA_D_DATA_CUBE_IN_CHANNEL_0_CUBE_IN_CHANNEL_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_DATA_CUBE_IN_CHANNEL_0_CUBE_IN_CHANNEL_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_DATA_CUBE_IN_CHANNEL_0_CUBE_IN_CHANNEL_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_DATA_CUBE_IN_CHANNEL_0_CUBE_IN_CHANNEL_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register PDP_RDMA_D_FLYING_MODE_0
+#define PDP_RDMA_D_FLYING_MODE_0 (_MK_ADDR_CONST(0xc018))
+#define PDP_RDMA_D_FLYING_MODE_0_SECURE (0x0)
+#define PDP_RDMA_D_FLYING_MODE_0_DUAL (0x0)
+#define PDP_RDMA_D_FLYING_MODE_0_SCR (0)
+#define PDP_RDMA_D_FLYING_MODE_0_WORD_COUNT (0x1)
+#define PDP_RDMA_D_FLYING_MODE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_FLYING_MODE_0_RESET_MASK (_MK_MASK_CONST(0x1))
+#define PDP_RDMA_D_FLYING_MODE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_FLYING_MODE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_FLYING_MODE_0_READ_MASK (_MK_MASK_CONST(0x1))
+#define PDP_RDMA_D_FLYING_MODE_0_WRITE_MASK (_MK_MASK_CONST(0x1))
+#define PDP_RDMA_D_FLYING_MODE_0_FLYING_MODE_SHIFT (_MK_SHIFT_CONST(0))
+#define PDP_RDMA_D_FLYING_MODE_0_FLYING_MODE_FIELD \
+	(_MK_FIELD_CONST(0x1, PDP_RDMA_D_FLYING_MODE_0_FLYING_MODE_SHIFT))
+#define PDP_RDMA_D_FLYING_MODE_0_FLYING_MODE_RANGE (0 : 0)
+#define PDP_RDMA_D_FLYING_MODE_0_FLYING_MODE_WOFFSET (0x0)
+#define PDP_RDMA_D_FLYING_MODE_0_FLYING_MODE_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_FLYING_MODE_0_FLYING_MODE_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define PDP_RDMA_D_FLYING_MODE_0_FLYING_MODE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_FLYING_MODE_0_FLYING_MODE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_FLYING_MODE_0_FLYING_MODE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_FLYING_MODE_0_FLYING_MODE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define PDP_RDMA_D_FLYING_MODE_0_FLYING_MODE_ON_FLYING (_MK_ENUM_CONST(0))
+#define PDP_RDMA_D_FLYING_MODE_0_FLYING_MODE_OFF_FLYING (_MK_ENUM_CONST(1))
+
+// Register PDP_RDMA_D_SRC_BASE_ADDR_LOW_0
+#define PDP_RDMA_D_SRC_BASE_ADDR_LOW_0 (_MK_ADDR_CONST(0xc01c))
+#define PDP_RDMA_D_SRC_BASE_ADDR_LOW_0_SECURE (0x0)
+#define PDP_RDMA_D_SRC_BASE_ADDR_LOW_0_DUAL (0x0)
+#define PDP_RDMA_D_SRC_BASE_ADDR_LOW_0_SCR (0)
+#define PDP_RDMA_D_SRC_BASE_ADDR_LOW_0_WORD_COUNT (0x1)
+#define PDP_RDMA_D_SRC_BASE_ADDR_LOW_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_SRC_BASE_ADDR_LOW_0_RESET_MASK (_MK_MASK_CONST(0xffffffe0))
+#define PDP_RDMA_D_SRC_BASE_ADDR_LOW_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_SRC_BASE_ADDR_LOW_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_SRC_BASE_ADDR_LOW_0_READ_MASK (_MK_MASK_CONST(0xffffffe0))
+#define PDP_RDMA_D_SRC_BASE_ADDR_LOW_0_WRITE_MASK (_MK_MASK_CONST(0xffffffe0))
+#define PDP_RDMA_D_SRC_BASE_ADDR_LOW_0_SRC_BASE_ADDR_LOW_SHIFT \
+	(_MK_SHIFT_CONST(5))
+#define PDP_RDMA_D_SRC_BASE_ADDR_LOW_0_SRC_BASE_ADDR_LOW_FIELD \
+	(_MK_FIELD_CONST(                                      \
+		0x7ffffff,                                     \
+		PDP_RDMA_D_SRC_BASE_ADDR_LOW_0_SRC_BASE_ADDR_LOW_SHIFT))
+#define PDP_RDMA_D_SRC_BASE_ADDR_LOW_0_SRC_BASE_ADDR_LOW_RANGE (31 : 5)
+#define PDP_RDMA_D_SRC_BASE_ADDR_LOW_0_SRC_BASE_ADDR_LOW_WOFFSET (0x0)
+#define PDP_RDMA_D_SRC_BASE_ADDR_LOW_0_SRC_BASE_ADDR_LOW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_SRC_BASE_ADDR_LOW_0_SRC_BASE_ADDR_LOW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffffff))
+#define PDP_RDMA_D_SRC_BASE_ADDR_LOW_0_SRC_BASE_ADDR_LOW_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_SRC_BASE_ADDR_LOW_0_SRC_BASE_ADDR_LOW_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_SRC_BASE_ADDR_LOW_0_SRC_BASE_ADDR_LOW_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_SRC_BASE_ADDR_LOW_0_SRC_BASE_ADDR_LOW_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register PDP_RDMA_D_SRC_BASE_ADDR_HIGH_0
+#define PDP_RDMA_D_SRC_BASE_ADDR_HIGH_0 (_MK_ADDR_CONST(0xc020))
+#define PDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_SECURE (0x0)
+#define PDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_DUAL (0x0)
+#define PDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_SCR (0)
+#define PDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_WORD_COUNT (0x1)
+#define PDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define PDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define PDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_WRITE_MASK (_MK_MASK_CONST(0xffffffff))
+#define PDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_SRC_BASE_ADDR_HIGH_SHIFT \
+	(_MK_SHIFT_CONST(0))
+#define PDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_SRC_BASE_ADDR_HIGH_FIELD \
+	(_MK_FIELD_CONST(                                        \
+		0xffffffff,                                      \
+		PDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_SRC_BASE_ADDR_HIGH_SHIFT))
+#define PDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_SRC_BASE_ADDR_HIGH_RANGE (31 : 0)
+#define PDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_SRC_BASE_ADDR_HIGH_WOFFSET (0x0)
+#define PDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_SRC_BASE_ADDR_HIGH_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_SRC_BASE_ADDR_HIGH_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define PDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_SRC_BASE_ADDR_HIGH_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_SRC_BASE_ADDR_HIGH_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_SRC_BASE_ADDR_HIGH_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_SRC_BASE_ADDR_HIGH_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register PDP_RDMA_D_SRC_LINE_STRIDE_0
+#define PDP_RDMA_D_SRC_LINE_STRIDE_0 (_MK_ADDR_CONST(0xc024))
+#define PDP_RDMA_D_SRC_LINE_STRIDE_0_SECURE (0x0)
+#define PDP_RDMA_D_SRC_LINE_STRIDE_0_DUAL (0x0)
+#define PDP_RDMA_D_SRC_LINE_STRIDE_0_SCR (0)
+#define PDP_RDMA_D_SRC_LINE_STRIDE_0_WORD_COUNT (0x1)
+#define PDP_RDMA_D_SRC_LINE_STRIDE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_SRC_LINE_STRIDE_0_RESET_MASK (_MK_MASK_CONST(0xffffffe0))
+#define PDP_RDMA_D_SRC_LINE_STRIDE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_SRC_LINE_STRIDE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_SRC_LINE_STRIDE_0_READ_MASK (_MK_MASK_CONST(0xffffffe0))
+#define PDP_RDMA_D_SRC_LINE_STRIDE_0_WRITE_MASK (_MK_MASK_CONST(0xffffffe0))
+#define PDP_RDMA_D_SRC_LINE_STRIDE_0_SRC_LINE_STRIDE_SHIFT (_MK_SHIFT_CONST(5))
+#define PDP_RDMA_D_SRC_LINE_STRIDE_0_SRC_LINE_STRIDE_FIELD \
+	(_MK_FIELD_CONST(0x7ffffff,                        \
+			 PDP_RDMA_D_SRC_LINE_STRIDE_0_SRC_LINE_STRIDE_SHIFT))
+#define PDP_RDMA_D_SRC_LINE_STRIDE_0_SRC_LINE_STRIDE_RANGE (31 : 5)
+#define PDP_RDMA_D_SRC_LINE_STRIDE_0_SRC_LINE_STRIDE_WOFFSET (0x0)
+#define PDP_RDMA_D_SRC_LINE_STRIDE_0_SRC_LINE_STRIDE_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_SRC_LINE_STRIDE_0_SRC_LINE_STRIDE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffffff))
+#define PDP_RDMA_D_SRC_LINE_STRIDE_0_SRC_LINE_STRIDE_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_SRC_LINE_STRIDE_0_SRC_LINE_STRIDE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_SRC_LINE_STRIDE_0_SRC_LINE_STRIDE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_SRC_LINE_STRIDE_0_SRC_LINE_STRIDE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register PDP_RDMA_D_SRC_SURFACE_STRIDE_0
+#define PDP_RDMA_D_SRC_SURFACE_STRIDE_0 (_MK_ADDR_CONST(0xc028))
+#define PDP_RDMA_D_SRC_SURFACE_STRIDE_0_SECURE (0x0)
+#define PDP_RDMA_D_SRC_SURFACE_STRIDE_0_DUAL (0x0)
+#define PDP_RDMA_D_SRC_SURFACE_STRIDE_0_SCR (0)
+#define PDP_RDMA_D_SRC_SURFACE_STRIDE_0_WORD_COUNT (0x1)
+#define PDP_RDMA_D_SRC_SURFACE_STRIDE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_SRC_SURFACE_STRIDE_0_RESET_MASK (_MK_MASK_CONST(0xffffffe0))
+#define PDP_RDMA_D_SRC_SURFACE_STRIDE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_SRC_SURFACE_STRIDE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_SRC_SURFACE_STRIDE_0_READ_MASK (_MK_MASK_CONST(0xffffffe0))
+#define PDP_RDMA_D_SRC_SURFACE_STRIDE_0_WRITE_MASK (_MK_MASK_CONST(0xffffffe0))
+#define PDP_RDMA_D_SRC_SURFACE_STRIDE_0_SRC_SURFACE_STRIDE_SHIFT \
+	(_MK_SHIFT_CONST(5))
+#define PDP_RDMA_D_SRC_SURFACE_STRIDE_0_SRC_SURFACE_STRIDE_FIELD \
+	(_MK_FIELD_CONST(                                        \
+		0x7ffffff,                                       \
+		PDP_RDMA_D_SRC_SURFACE_STRIDE_0_SRC_SURFACE_STRIDE_SHIFT))
+#define PDP_RDMA_D_SRC_SURFACE_STRIDE_0_SRC_SURFACE_STRIDE_RANGE (31 : 5)
+#define PDP_RDMA_D_SRC_SURFACE_STRIDE_0_SRC_SURFACE_STRIDE_WOFFSET (0x0)
+#define PDP_RDMA_D_SRC_SURFACE_STRIDE_0_SRC_SURFACE_STRIDE_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_SRC_SURFACE_STRIDE_0_SRC_SURFACE_STRIDE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffffff))
+#define PDP_RDMA_D_SRC_SURFACE_STRIDE_0_SRC_SURFACE_STRIDE_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_SRC_SURFACE_STRIDE_0_SRC_SURFACE_STRIDE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_SRC_SURFACE_STRIDE_0_SRC_SURFACE_STRIDE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_SRC_SURFACE_STRIDE_0_SRC_SURFACE_STRIDE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register PDP_RDMA_D_SRC_RAM_CFG_0
+#define PDP_RDMA_D_SRC_RAM_CFG_0 (_MK_ADDR_CONST(0xc02c))
+#define PDP_RDMA_D_SRC_RAM_CFG_0_SECURE (0x0)
+#define PDP_RDMA_D_SRC_RAM_CFG_0_DUAL (0x0)
+#define PDP_RDMA_D_SRC_RAM_CFG_0_SCR (0)
+#define PDP_RDMA_D_SRC_RAM_CFG_0_WORD_COUNT (0x1)
+#define PDP_RDMA_D_SRC_RAM_CFG_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_SRC_RAM_CFG_0_RESET_MASK (_MK_MASK_CONST(0x1))
+#define PDP_RDMA_D_SRC_RAM_CFG_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_SRC_RAM_CFG_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_SRC_RAM_CFG_0_READ_MASK (_MK_MASK_CONST(0x1))
+#define PDP_RDMA_D_SRC_RAM_CFG_0_WRITE_MASK (_MK_MASK_CONST(0x1))
+#define PDP_RDMA_D_SRC_RAM_CFG_0_SRC_RAM_TYPE_SHIFT (_MK_SHIFT_CONST(0))
+#define PDP_RDMA_D_SRC_RAM_CFG_0_SRC_RAM_TYPE_FIELD \
+	(_MK_FIELD_CONST(0x1, PDP_RDMA_D_SRC_RAM_CFG_0_SRC_RAM_TYPE_SHIFT))
+#define PDP_RDMA_D_SRC_RAM_CFG_0_SRC_RAM_TYPE_RANGE (0 : 0)
+#define PDP_RDMA_D_SRC_RAM_CFG_0_SRC_RAM_TYPE_WOFFSET (0x0)
+#define PDP_RDMA_D_SRC_RAM_CFG_0_SRC_RAM_TYPE_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_SRC_RAM_CFG_0_SRC_RAM_TYPE_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define PDP_RDMA_D_SRC_RAM_CFG_0_SRC_RAM_TYPE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_SRC_RAM_CFG_0_SRC_RAM_TYPE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_SRC_RAM_CFG_0_SRC_RAM_TYPE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_SRC_RAM_CFG_0_SRC_RAM_TYPE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define PDP_RDMA_D_SRC_RAM_CFG_0_SRC_RAM_TYPE_CV (_MK_ENUM_CONST(0))
+#define PDP_RDMA_D_SRC_RAM_CFG_0_SRC_RAM_TYPE_MC (_MK_ENUM_CONST(1))
+
+// Register PDP_RDMA_D_DATA_FORMAT_0
+#define PDP_RDMA_D_DATA_FORMAT_0 (_MK_ADDR_CONST(0xc030))
+#define PDP_RDMA_D_DATA_FORMAT_0_SECURE (0x0)
+#define PDP_RDMA_D_DATA_FORMAT_0_DUAL (0x0)
+#define PDP_RDMA_D_DATA_FORMAT_0_SCR (0)
+#define PDP_RDMA_D_DATA_FORMAT_0_WORD_COUNT (0x1)
+#define PDP_RDMA_D_DATA_FORMAT_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_DATA_FORMAT_0_RESET_MASK (_MK_MASK_CONST(0x3))
+#define PDP_RDMA_D_DATA_FORMAT_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_DATA_FORMAT_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_DATA_FORMAT_0_READ_MASK (_MK_MASK_CONST(0x3))
+#define PDP_RDMA_D_DATA_FORMAT_0_WRITE_MASK (_MK_MASK_CONST(0x3))
+#define PDP_RDMA_D_DATA_FORMAT_0_INPUT_DATA_SHIFT (_MK_SHIFT_CONST(0))
+#define PDP_RDMA_D_DATA_FORMAT_0_INPUT_DATA_FIELD \
+	(_MK_FIELD_CONST(0x3, PDP_RDMA_D_DATA_FORMAT_0_INPUT_DATA_SHIFT))
+#define PDP_RDMA_D_DATA_FORMAT_0_INPUT_DATA_RANGE (1 : 0)
+#define PDP_RDMA_D_DATA_FORMAT_0_INPUT_DATA_WOFFSET (0x0)
+#define PDP_RDMA_D_DATA_FORMAT_0_INPUT_DATA_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_DATA_FORMAT_0_INPUT_DATA_DEFAULT_MASK (_MK_MASK_CONST(0x3))
+#define PDP_RDMA_D_DATA_FORMAT_0_INPUT_DATA_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_DATA_FORMAT_0_INPUT_DATA_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_DATA_FORMAT_0_INPUT_DATA_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_DATA_FORMAT_0_INPUT_DATA_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define PDP_RDMA_D_DATA_FORMAT_0_INPUT_DATA_INT8 (_MK_ENUM_CONST(0))
+#define PDP_RDMA_D_DATA_FORMAT_0_INPUT_DATA_INT16 (_MK_ENUM_CONST(1))
+#define PDP_RDMA_D_DATA_FORMAT_0_INPUT_DATA_FP16 (_MK_ENUM_CONST(2))
+
+// Register PDP_RDMA_D_OPERATION_MODE_CFG_0
+#define PDP_RDMA_D_OPERATION_MODE_CFG_0 (_MK_ADDR_CONST(0xc034))
+#define PDP_RDMA_D_OPERATION_MODE_CFG_0_SECURE (0x0)
+#define PDP_RDMA_D_OPERATION_MODE_CFG_0_DUAL (0x0)
+#define PDP_RDMA_D_OPERATION_MODE_CFG_0_SCR (0)
+#define PDP_RDMA_D_OPERATION_MODE_CFG_0_WORD_COUNT (0x1)
+#define PDP_RDMA_D_OPERATION_MODE_CFG_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_OPERATION_MODE_CFG_0_RESET_MASK (_MK_MASK_CONST(0xff))
+#define PDP_RDMA_D_OPERATION_MODE_CFG_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_OPERATION_MODE_CFG_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_OPERATION_MODE_CFG_0_READ_MASK (_MK_MASK_CONST(0xff))
+#define PDP_RDMA_D_OPERATION_MODE_CFG_0_WRITE_MASK (_MK_MASK_CONST(0xff))
+#define PDP_RDMA_D_OPERATION_MODE_CFG_0_SPLIT_NUM_SHIFT (_MK_SHIFT_CONST(0))
+#define PDP_RDMA_D_OPERATION_MODE_CFG_0_SPLIT_NUM_FIELD \
+	(_MK_FIELD_CONST(0xff, PDP_RDMA_D_OPERATION_MODE_CFG_0_SPLIT_NUM_SHIFT))
+#define PDP_RDMA_D_OPERATION_MODE_CFG_0_SPLIT_NUM_RANGE (7 : 0)
+#define PDP_RDMA_D_OPERATION_MODE_CFG_0_SPLIT_NUM_WOFFSET (0x0)
+#define PDP_RDMA_D_OPERATION_MODE_CFG_0_SPLIT_NUM_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_OPERATION_MODE_CFG_0_SPLIT_NUM_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xff))
+#define PDP_RDMA_D_OPERATION_MODE_CFG_0_SPLIT_NUM_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_OPERATION_MODE_CFG_0_SPLIT_NUM_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_OPERATION_MODE_CFG_0_SPLIT_NUM_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_OPERATION_MODE_CFG_0_SPLIT_NUM_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register PDP_RDMA_D_POOLING_KERNEL_CFG_0
+#define PDP_RDMA_D_POOLING_KERNEL_CFG_0 (_MK_ADDR_CONST(0xc038))
+#define PDP_RDMA_D_POOLING_KERNEL_CFG_0_SECURE (0x0)
+#define PDP_RDMA_D_POOLING_KERNEL_CFG_0_DUAL (0x0)
+#define PDP_RDMA_D_POOLING_KERNEL_CFG_0_SCR (0)
+#define PDP_RDMA_D_POOLING_KERNEL_CFG_0_WORD_COUNT (0x1)
+#define PDP_RDMA_D_POOLING_KERNEL_CFG_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_POOLING_KERNEL_CFG_0_RESET_MASK (_MK_MASK_CONST(0xff))
+#define PDP_RDMA_D_POOLING_KERNEL_CFG_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_POOLING_KERNEL_CFG_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_POOLING_KERNEL_CFG_0_READ_MASK (_MK_MASK_CONST(0xff))
+#define PDP_RDMA_D_POOLING_KERNEL_CFG_0_WRITE_MASK (_MK_MASK_CONST(0xff))
+#define PDP_RDMA_D_POOLING_KERNEL_CFG_0_KERNEL_WIDTH_SHIFT (_MK_SHIFT_CONST(0))
+#define PDP_RDMA_D_POOLING_KERNEL_CFG_0_KERNEL_WIDTH_FIELD \
+	(_MK_FIELD_CONST(0xf,                              \
+			 PDP_RDMA_D_POOLING_KERNEL_CFG_0_KERNEL_WIDTH_SHIFT))
+#define PDP_RDMA_D_POOLING_KERNEL_CFG_0_KERNEL_WIDTH_RANGE (3 : 0)
+#define PDP_RDMA_D_POOLING_KERNEL_CFG_0_KERNEL_WIDTH_WOFFSET (0x0)
+#define PDP_RDMA_D_POOLING_KERNEL_CFG_0_KERNEL_WIDTH_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_POOLING_KERNEL_CFG_0_KERNEL_WIDTH_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xf))
+#define PDP_RDMA_D_POOLING_KERNEL_CFG_0_KERNEL_WIDTH_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_POOLING_KERNEL_CFG_0_KERNEL_WIDTH_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_POOLING_KERNEL_CFG_0_KERNEL_WIDTH_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_POOLING_KERNEL_CFG_0_KERNEL_WIDTH_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define PDP_RDMA_D_POOLING_KERNEL_CFG_0_KERNEL_WIDTH_KERNEL_WIDTH_1 \
+	(_MK_ENUM_CONST(0))
+#define PDP_RDMA_D_POOLING_KERNEL_CFG_0_KERNEL_WIDTH_KERNEL_WIDTH_2 \
+	(_MK_ENUM_CONST(1))
+#define PDP_RDMA_D_POOLING_KERNEL_CFG_0_KERNEL_WIDTH_KERNEL_WIDTH_3 \
+	(_MK_ENUM_CONST(2))
+#define PDP_RDMA_D_POOLING_KERNEL_CFG_0_KERNEL_WIDTH_KERNEL_WIDTH_4 \
+	(_MK_ENUM_CONST(3))
+#define PDP_RDMA_D_POOLING_KERNEL_CFG_0_KERNEL_WIDTH_KERNEL_WIDTH_5 \
+	(_MK_ENUM_CONST(4))
+#define PDP_RDMA_D_POOLING_KERNEL_CFG_0_KERNEL_WIDTH_KERNEL_WIDTH_6 \
+	(_MK_ENUM_CONST(5))
+#define PDP_RDMA_D_POOLING_KERNEL_CFG_0_KERNEL_WIDTH_KERNEL_WIDTH_7 \
+	(_MK_ENUM_CONST(6))
+#define PDP_RDMA_D_POOLING_KERNEL_CFG_0_KERNEL_WIDTH_KERNEL_WIDTH_8 \
+	(_MK_ENUM_CONST(7))
+
+#define PDP_RDMA_D_POOLING_KERNEL_CFG_0_KERNEL_STRIDE_WIDTH_SHIFT \
+	(_MK_SHIFT_CONST(4))
+#define PDP_RDMA_D_POOLING_KERNEL_CFG_0_KERNEL_STRIDE_WIDTH_FIELD \
+	(_MK_FIELD_CONST(                                         \
+		0xf,                                              \
+		PDP_RDMA_D_POOLING_KERNEL_CFG_0_KERNEL_STRIDE_WIDTH_SHIFT))
+#define PDP_RDMA_D_POOLING_KERNEL_CFG_0_KERNEL_STRIDE_WIDTH_RANGE (7 : 4)
+#define PDP_RDMA_D_POOLING_KERNEL_CFG_0_KERNEL_STRIDE_WIDTH_WOFFSET (0x0)
+#define PDP_RDMA_D_POOLING_KERNEL_CFG_0_KERNEL_STRIDE_WIDTH_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_POOLING_KERNEL_CFG_0_KERNEL_STRIDE_WIDTH_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xf))
+#define PDP_RDMA_D_POOLING_KERNEL_CFG_0_KERNEL_STRIDE_WIDTH_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_POOLING_KERNEL_CFG_0_KERNEL_STRIDE_WIDTH_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_POOLING_KERNEL_CFG_0_KERNEL_STRIDE_WIDTH_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_POOLING_KERNEL_CFG_0_KERNEL_STRIDE_WIDTH_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register PDP_RDMA_D_POOLING_PADDING_CFG_0
+#define PDP_RDMA_D_POOLING_PADDING_CFG_0 (_MK_ADDR_CONST(0xc03c))
+#define PDP_RDMA_D_POOLING_PADDING_CFG_0_SECURE (0x0)
+#define PDP_RDMA_D_POOLING_PADDING_CFG_0_DUAL (0x0)
+#define PDP_RDMA_D_POOLING_PADDING_CFG_0_SCR (0)
+#define PDP_RDMA_D_POOLING_PADDING_CFG_0_WORD_COUNT (0x1)
+#define PDP_RDMA_D_POOLING_PADDING_CFG_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_POOLING_PADDING_CFG_0_RESET_MASK (_MK_MASK_CONST(0xf))
+#define PDP_RDMA_D_POOLING_PADDING_CFG_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_POOLING_PADDING_CFG_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_POOLING_PADDING_CFG_0_READ_MASK (_MK_MASK_CONST(0xf))
+#define PDP_RDMA_D_POOLING_PADDING_CFG_0_WRITE_MASK (_MK_MASK_CONST(0xf))
+#define PDP_RDMA_D_POOLING_PADDING_CFG_0_PAD_WIDTH_SHIFT (_MK_SHIFT_CONST(0))
+#define PDP_RDMA_D_POOLING_PADDING_CFG_0_PAD_WIDTH_FIELD \
+	(_MK_FIELD_CONST(0xf, PDP_RDMA_D_POOLING_PADDING_CFG_0_PAD_WIDTH_SHIFT))
+#define PDP_RDMA_D_POOLING_PADDING_CFG_0_PAD_WIDTH_RANGE (3 : 0)
+#define PDP_RDMA_D_POOLING_PADDING_CFG_0_PAD_WIDTH_WOFFSET (0x0)
+#define PDP_RDMA_D_POOLING_PADDING_CFG_0_PAD_WIDTH_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_POOLING_PADDING_CFG_0_PAD_WIDTH_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xf))
+#define PDP_RDMA_D_POOLING_PADDING_CFG_0_PAD_WIDTH_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_POOLING_PADDING_CFG_0_PAD_WIDTH_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_POOLING_PADDING_CFG_0_PAD_WIDTH_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_POOLING_PADDING_CFG_0_PAD_WIDTH_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register PDP_RDMA_D_PARTIAL_WIDTH_IN_0
+#define PDP_RDMA_D_PARTIAL_WIDTH_IN_0 (_MK_ADDR_CONST(0xc040))
+#define PDP_RDMA_D_PARTIAL_WIDTH_IN_0_SECURE (0x0)
+#define PDP_RDMA_D_PARTIAL_WIDTH_IN_0_DUAL (0x0)
+#define PDP_RDMA_D_PARTIAL_WIDTH_IN_0_SCR (0)
+#define PDP_RDMA_D_PARTIAL_WIDTH_IN_0_WORD_COUNT (0x1)
+#define PDP_RDMA_D_PARTIAL_WIDTH_IN_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_PARTIAL_WIDTH_IN_0_RESET_MASK (_MK_MASK_CONST(0x3fffffff))
+#define PDP_RDMA_D_PARTIAL_WIDTH_IN_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_PARTIAL_WIDTH_IN_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_PARTIAL_WIDTH_IN_0_READ_MASK (_MK_MASK_CONST(0x3fffffff))
+#define PDP_RDMA_D_PARTIAL_WIDTH_IN_0_WRITE_MASK (_MK_MASK_CONST(0x3fffffff))
+#define PDP_RDMA_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_FIRST_SHIFT \
+	(_MK_SHIFT_CONST(0))
+#define PDP_RDMA_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_FIRST_FIELD \
+	(_MK_FIELD_CONST(                                          \
+		0x3ff,                                             \
+		PDP_RDMA_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_FIRST_SHIFT))
+#define PDP_RDMA_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_FIRST_RANGE (9 : 0)
+#define PDP_RDMA_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_FIRST_WOFFSET (0x0)
+#define PDP_RDMA_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_FIRST_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_FIRST_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x3ff))
+#define PDP_RDMA_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_FIRST_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_FIRST_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_FIRST_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_FIRST_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define PDP_RDMA_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_LAST_SHIFT \
+	(_MK_SHIFT_CONST(10))
+#define PDP_RDMA_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_LAST_FIELD \
+	(_MK_FIELD_CONST(                                         \
+		0x3ff,                                            \
+		PDP_RDMA_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_LAST_SHIFT))
+#define PDP_RDMA_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_LAST_RANGE (19 : 10)
+#define PDP_RDMA_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_LAST_WOFFSET (0x0)
+#define PDP_RDMA_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_LAST_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_LAST_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x3ff))
+#define PDP_RDMA_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_LAST_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_LAST_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_LAST_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_LAST_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define PDP_RDMA_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_MID_SHIFT \
+	(_MK_SHIFT_CONST(20))
+#define PDP_RDMA_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_MID_FIELD \
+	(_MK_FIELD_CONST(                                        \
+		0x3ff,                                           \
+		PDP_RDMA_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_MID_SHIFT))
+#define PDP_RDMA_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_MID_RANGE (29 : 20)
+#define PDP_RDMA_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_MID_WOFFSET (0x0)
+#define PDP_RDMA_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_MID_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_MID_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x3ff))
+#define PDP_RDMA_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_MID_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_MID_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_MID_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_MID_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register PDP_RDMA_D_PERF_ENABLE_0
+#define PDP_RDMA_D_PERF_ENABLE_0 (_MK_ADDR_CONST(0xc044))
+#define PDP_RDMA_D_PERF_ENABLE_0_SECURE (0x0)
+#define PDP_RDMA_D_PERF_ENABLE_0_DUAL (0x0)
+#define PDP_RDMA_D_PERF_ENABLE_0_SCR (0)
+#define PDP_RDMA_D_PERF_ENABLE_0_WORD_COUNT (0x1)
+#define PDP_RDMA_D_PERF_ENABLE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_PERF_ENABLE_0_RESET_MASK (_MK_MASK_CONST(0x1))
+#define PDP_RDMA_D_PERF_ENABLE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_PERF_ENABLE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_PERF_ENABLE_0_READ_MASK (_MK_MASK_CONST(0x1))
+#define PDP_RDMA_D_PERF_ENABLE_0_WRITE_MASK (_MK_MASK_CONST(0x1))
+#define PDP_RDMA_D_PERF_ENABLE_0_DMA_EN_SHIFT (_MK_SHIFT_CONST(0))
+#define PDP_RDMA_D_PERF_ENABLE_0_DMA_EN_FIELD \
+	(_MK_FIELD_CONST(0x1, PDP_RDMA_D_PERF_ENABLE_0_DMA_EN_SHIFT))
+#define PDP_RDMA_D_PERF_ENABLE_0_DMA_EN_RANGE (0 : 0)
+#define PDP_RDMA_D_PERF_ENABLE_0_DMA_EN_WOFFSET (0x0)
+#define PDP_RDMA_D_PERF_ENABLE_0_DMA_EN_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_PERF_ENABLE_0_DMA_EN_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define PDP_RDMA_D_PERF_ENABLE_0_DMA_EN_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_PERF_ENABLE_0_DMA_EN_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_PERF_ENABLE_0_DMA_EN_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_PERF_ENABLE_0_DMA_EN_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define PDP_RDMA_D_PERF_ENABLE_0_DMA_EN_INIT_ENUM (DISABLE)
+#define PDP_RDMA_D_PERF_ENABLE_0_DMA_EN_DISABLE (_MK_ENUM_CONST(0))
+#define PDP_RDMA_D_PERF_ENABLE_0_DMA_EN_ENABLE (_MK_ENUM_CONST(1))
+
+// Register PDP_RDMA_D_PERF_READ_STALL_0
+#define PDP_RDMA_D_PERF_READ_STALL_0 (_MK_ADDR_CONST(0xc048))
+#define PDP_RDMA_D_PERF_READ_STALL_0_SECURE (0x0)
+#define PDP_RDMA_D_PERF_READ_STALL_0_DUAL (0x0)
+#define PDP_RDMA_D_PERF_READ_STALL_0_SCR (0)
+#define PDP_RDMA_D_PERF_READ_STALL_0_WORD_COUNT (0x1)
+#define PDP_RDMA_D_PERF_READ_STALL_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_PERF_READ_STALL_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define PDP_RDMA_D_PERF_READ_STALL_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_PERF_READ_STALL_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_PERF_READ_STALL_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define PDP_RDMA_D_PERF_READ_STALL_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_PERF_READ_STALL_0_PERF_READ_STALL_SHIFT (_MK_SHIFT_CONST(0))
+#define PDP_RDMA_D_PERF_READ_STALL_0_PERF_READ_STALL_FIELD \
+	(_MK_FIELD_CONST(0xffffffff,                       \
+			 PDP_RDMA_D_PERF_READ_STALL_0_PERF_READ_STALL_SHIFT))
+#define PDP_RDMA_D_PERF_READ_STALL_0_PERF_READ_STALL_RANGE (31 : 0)
+#define PDP_RDMA_D_PERF_READ_STALL_0_PERF_READ_STALL_WOFFSET (0x0)
+#define PDP_RDMA_D_PERF_READ_STALL_0_PERF_READ_STALL_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_PERF_READ_STALL_0_PERF_READ_STALL_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define PDP_RDMA_D_PERF_READ_STALL_0_PERF_READ_STALL_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_PERF_READ_STALL_0_PERF_READ_STALL_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_PERF_READ_STALL_0_PERF_READ_STALL_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_PERF_READ_STALL_0_PERF_READ_STALL_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register PDP_RDMA_D_CYA_0
+#define PDP_RDMA_D_CYA_0 (_MK_ADDR_CONST(0xc04c))
+#define PDP_RDMA_D_CYA_0_SECURE (0x0)
+#define PDP_RDMA_D_CYA_0_DUAL (0x0)
+#define PDP_RDMA_D_CYA_0_SCR (0)
+#define PDP_RDMA_D_CYA_0_WORD_COUNT (0x1)
+#define PDP_RDMA_D_CYA_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_CYA_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define PDP_RDMA_D_CYA_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_CYA_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_CYA_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define PDP_RDMA_D_CYA_0_WRITE_MASK (_MK_MASK_CONST(0xffffffff))
+#define PDP_RDMA_D_CYA_0_CYA_SHIFT (_MK_SHIFT_CONST(0))
+#define PDP_RDMA_D_CYA_0_CYA_FIELD \
+	(_MK_FIELD_CONST(0xffffffff, PDP_RDMA_D_CYA_0_CYA_SHIFT))
+#define PDP_RDMA_D_CYA_0_CYA_RANGE (31 : 0)
+#define PDP_RDMA_D_CYA_0_CYA_WOFFSET (0x0)
+#define PDP_RDMA_D_CYA_0_CYA_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_CYA_0_CYA_DEFAULT_MASK (_MK_MASK_CONST(0xffffffff))
+#define PDP_RDMA_D_CYA_0_CYA_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_CYA_0_CYA_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_CYA_0_CYA_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define PDP_RDMA_D_CYA_0_CYA_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+// Register PDP_S_STATUS_0
+#define PDP_S_STATUS_0 (_MK_ADDR_CONST(0xd000))
+#define PDP_S_STATUS_0_SECURE (0x0)
+#define PDP_S_STATUS_0_DUAL (0x0)
+#define PDP_S_STATUS_0_SCR (0)
+#define PDP_S_STATUS_0_WORD_COUNT (0x1)
+#define PDP_S_STATUS_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define PDP_S_STATUS_0_RESET_MASK (_MK_MASK_CONST(0x30003))
+#define PDP_S_STATUS_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define PDP_S_STATUS_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_S_STATUS_0_READ_MASK (_MK_MASK_CONST(0x30003))
+#define PDP_S_STATUS_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define PDP_S_STATUS_0_STATUS_0_SHIFT (_MK_SHIFT_CONST(0))
+#define PDP_S_STATUS_0_STATUS_0_FIELD \
+	(_MK_FIELD_CONST(0x3, PDP_S_STATUS_0_STATUS_0_SHIFT))
+#define PDP_S_STATUS_0_STATUS_0_RANGE (1 : 0)
+#define PDP_S_STATUS_0_STATUS_0_WOFFSET (0x0)
+#define PDP_S_STATUS_0_STATUS_0_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_S_STATUS_0_STATUS_0_DEFAULT_MASK (_MK_MASK_CONST(0x3))
+#define PDP_S_STATUS_0_STATUS_0_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_S_STATUS_0_STATUS_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_S_STATUS_0_STATUS_0_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define PDP_S_STATUS_0_STATUS_0_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define PDP_S_STATUS_0_STATUS_0_INIT_ENUM (IDLE)
+#define PDP_S_STATUS_0_STATUS_0_IDLE (_MK_ENUM_CONST(0))
+#define PDP_S_STATUS_0_STATUS_0_RUNNING (_MK_ENUM_CONST(1))
+#define PDP_S_STATUS_0_STATUS_0_PENDING (_MK_ENUM_CONST(2))
+
+#define PDP_S_STATUS_0_STATUS_1_SHIFT (_MK_SHIFT_CONST(16))
+#define PDP_S_STATUS_0_STATUS_1_FIELD \
+	(_MK_FIELD_CONST(0x3, PDP_S_STATUS_0_STATUS_1_SHIFT))
+#define PDP_S_STATUS_0_STATUS_1_RANGE (17 : 16)
+#define PDP_S_STATUS_0_STATUS_1_WOFFSET (0x0)
+#define PDP_S_STATUS_0_STATUS_1_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_S_STATUS_0_STATUS_1_DEFAULT_MASK (_MK_MASK_CONST(0x3))
+#define PDP_S_STATUS_0_STATUS_1_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_S_STATUS_0_STATUS_1_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_S_STATUS_0_STATUS_1_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define PDP_S_STATUS_0_STATUS_1_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define PDP_S_STATUS_0_STATUS_1_INIT_ENUM (IDLE)
+#define PDP_S_STATUS_0_STATUS_1_IDLE (_MK_ENUM_CONST(0))
+#define PDP_S_STATUS_0_STATUS_1_RUNNING (_MK_ENUM_CONST(1))
+#define PDP_S_STATUS_0_STATUS_1_PENDING (_MK_ENUM_CONST(2))
+
+// Register PDP_S_POINTER_0
+#define PDP_S_POINTER_0 (_MK_ADDR_CONST(0xd004))
+#define PDP_S_POINTER_0_SECURE (0x0)
+#define PDP_S_POINTER_0_DUAL (0x0)
+#define PDP_S_POINTER_0_SCR (0)
+#define PDP_S_POINTER_0_WORD_COUNT (0x1)
+#define PDP_S_POINTER_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define PDP_S_POINTER_0_RESET_MASK (_MK_MASK_CONST(0x10001))
+#define PDP_S_POINTER_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define PDP_S_POINTER_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_S_POINTER_0_READ_MASK (_MK_MASK_CONST(0x10001))
+#define PDP_S_POINTER_0_WRITE_MASK (_MK_MASK_CONST(0x1))
+#define PDP_S_POINTER_0_PRODUCER_SHIFT (_MK_SHIFT_CONST(0))
+#define PDP_S_POINTER_0_PRODUCER_FIELD \
+	(_MK_FIELD_CONST(0x1, PDP_S_POINTER_0_PRODUCER_SHIFT))
+#define PDP_S_POINTER_0_PRODUCER_RANGE (0 : 0)
+#define PDP_S_POINTER_0_PRODUCER_WOFFSET (0x0)
+#define PDP_S_POINTER_0_PRODUCER_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_S_POINTER_0_PRODUCER_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define PDP_S_POINTER_0_PRODUCER_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_S_POINTER_0_PRODUCER_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_S_POINTER_0_PRODUCER_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define PDP_S_POINTER_0_PRODUCER_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define PDP_S_POINTER_0_PRODUCER_INIT_ENUM (GROUP_0)
+#define PDP_S_POINTER_0_PRODUCER_GROUP_0 (_MK_ENUM_CONST(0))
+#define PDP_S_POINTER_0_PRODUCER_GROUP_1 (_MK_ENUM_CONST(1))
+
+#define PDP_S_POINTER_0_CONSUMER_SHIFT (_MK_SHIFT_CONST(16))
+#define PDP_S_POINTER_0_CONSUMER_FIELD \
+	(_MK_FIELD_CONST(0x1, PDP_S_POINTER_0_CONSUMER_SHIFT))
+#define PDP_S_POINTER_0_CONSUMER_RANGE (16 : 16)
+#define PDP_S_POINTER_0_CONSUMER_WOFFSET (0x0)
+#define PDP_S_POINTER_0_CONSUMER_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_S_POINTER_0_CONSUMER_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define PDP_S_POINTER_0_CONSUMER_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_S_POINTER_0_CONSUMER_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_S_POINTER_0_CONSUMER_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define PDP_S_POINTER_0_CONSUMER_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define PDP_S_POINTER_0_CONSUMER_INIT_ENUM (GROUP_0)
+#define PDP_S_POINTER_0_CONSUMER_GROUP_0 (_MK_ENUM_CONST(0))
+#define PDP_S_POINTER_0_CONSUMER_GROUP_1 (_MK_ENUM_CONST(1))
+
+// Register PDP_D_OP_ENABLE_0
+#define PDP_D_OP_ENABLE_0 (_MK_ADDR_CONST(0xd008))
+#define PDP_D_OP_ENABLE_0_SECURE (0x0)
+#define PDP_D_OP_ENABLE_0_DUAL (0x0)
+#define PDP_D_OP_ENABLE_0_SCR (0)
+#define PDP_D_OP_ENABLE_0_WORD_COUNT (0x1)
+#define PDP_D_OP_ENABLE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_OP_ENABLE_0_RESET_MASK (_MK_MASK_CONST(0x1))
+#define PDP_D_OP_ENABLE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_OP_ENABLE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_D_OP_ENABLE_0_READ_MASK (_MK_MASK_CONST(0x1))
+#define PDP_D_OP_ENABLE_0_WRITE_MASK (_MK_MASK_CONST(0x1))
+#define PDP_D_OP_ENABLE_0_OP_EN_SHIFT (_MK_SHIFT_CONST(0))
+#define PDP_D_OP_ENABLE_0_OP_EN_FIELD \
+	(_MK_FIELD_CONST(0x1, PDP_D_OP_ENABLE_0_OP_EN_SHIFT))
+#define PDP_D_OP_ENABLE_0_OP_EN_RANGE (0 : 0)
+#define PDP_D_OP_ENABLE_0_OP_EN_WOFFSET (0x0)
+#define PDP_D_OP_ENABLE_0_OP_EN_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_D_OP_ENABLE_0_OP_EN_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define PDP_D_OP_ENABLE_0_OP_EN_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_D_OP_ENABLE_0_OP_EN_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_D_OP_ENABLE_0_OP_EN_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define PDP_D_OP_ENABLE_0_OP_EN_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define PDP_D_OP_ENABLE_0_OP_EN_INIT_ENUM (DISABLE)
+#define PDP_D_OP_ENABLE_0_OP_EN_DISABLE (_MK_ENUM_CONST(0))
+#define PDP_D_OP_ENABLE_0_OP_EN_ENABLE (_MK_ENUM_CONST(1))
+
+// Register PDP_D_DATA_CUBE_IN_WIDTH_0
+#define PDP_D_DATA_CUBE_IN_WIDTH_0 (_MK_ADDR_CONST(0xd00c))
+#define PDP_D_DATA_CUBE_IN_WIDTH_0_SECURE (0x0)
+#define PDP_D_DATA_CUBE_IN_WIDTH_0_DUAL (0x0)
+#define PDP_D_DATA_CUBE_IN_WIDTH_0_SCR (0)
+#define PDP_D_DATA_CUBE_IN_WIDTH_0_WORD_COUNT (0x1)
+#define PDP_D_DATA_CUBE_IN_WIDTH_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_DATA_CUBE_IN_WIDTH_0_RESET_MASK (_MK_MASK_CONST(0x1fff))
+#define PDP_D_DATA_CUBE_IN_WIDTH_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_DATA_CUBE_IN_WIDTH_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_D_DATA_CUBE_IN_WIDTH_0_READ_MASK (_MK_MASK_CONST(0x1fff))
+#define PDP_D_DATA_CUBE_IN_WIDTH_0_WRITE_MASK (_MK_MASK_CONST(0x1fff))
+#define PDP_D_DATA_CUBE_IN_WIDTH_0_CUBE_IN_WIDTH_SHIFT (_MK_SHIFT_CONST(0))
+#define PDP_D_DATA_CUBE_IN_WIDTH_0_CUBE_IN_WIDTH_FIELD \
+	(_MK_FIELD_CONST(0x1fff,                       \
+			 PDP_D_DATA_CUBE_IN_WIDTH_0_CUBE_IN_WIDTH_SHIFT))
+#define PDP_D_DATA_CUBE_IN_WIDTH_0_CUBE_IN_WIDTH_RANGE (12 : 0)
+#define PDP_D_DATA_CUBE_IN_WIDTH_0_CUBE_IN_WIDTH_WOFFSET (0x0)
+#define PDP_D_DATA_CUBE_IN_WIDTH_0_CUBE_IN_WIDTH_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_D_DATA_CUBE_IN_WIDTH_0_CUBE_IN_WIDTH_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1fff))
+#define PDP_D_DATA_CUBE_IN_WIDTH_0_CUBE_IN_WIDTH_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_DATA_CUBE_IN_WIDTH_0_CUBE_IN_WIDTH_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_DATA_CUBE_IN_WIDTH_0_CUBE_IN_WIDTH_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_DATA_CUBE_IN_WIDTH_0_CUBE_IN_WIDTH_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register PDP_D_DATA_CUBE_IN_HEIGHT_0
+#define PDP_D_DATA_CUBE_IN_HEIGHT_0 (_MK_ADDR_CONST(0xd010))
+#define PDP_D_DATA_CUBE_IN_HEIGHT_0_SECURE (0x0)
+#define PDP_D_DATA_CUBE_IN_HEIGHT_0_DUAL (0x0)
+#define PDP_D_DATA_CUBE_IN_HEIGHT_0_SCR (0)
+#define PDP_D_DATA_CUBE_IN_HEIGHT_0_WORD_COUNT (0x1)
+#define PDP_D_DATA_CUBE_IN_HEIGHT_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_DATA_CUBE_IN_HEIGHT_0_RESET_MASK (_MK_MASK_CONST(0x1fff))
+#define PDP_D_DATA_CUBE_IN_HEIGHT_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_DATA_CUBE_IN_HEIGHT_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_D_DATA_CUBE_IN_HEIGHT_0_READ_MASK (_MK_MASK_CONST(0x1fff))
+#define PDP_D_DATA_CUBE_IN_HEIGHT_0_WRITE_MASK (_MK_MASK_CONST(0x1fff))
+#define PDP_D_DATA_CUBE_IN_HEIGHT_0_CUBE_IN_HEIGHT_SHIFT (_MK_SHIFT_CONST(0))
+#define PDP_D_DATA_CUBE_IN_HEIGHT_0_CUBE_IN_HEIGHT_FIELD \
+	(_MK_FIELD_CONST(0x1fff,                         \
+			 PDP_D_DATA_CUBE_IN_HEIGHT_0_CUBE_IN_HEIGHT_SHIFT))
+#define PDP_D_DATA_CUBE_IN_HEIGHT_0_CUBE_IN_HEIGHT_RANGE (12 : 0)
+#define PDP_D_DATA_CUBE_IN_HEIGHT_0_CUBE_IN_HEIGHT_WOFFSET (0x0)
+#define PDP_D_DATA_CUBE_IN_HEIGHT_0_CUBE_IN_HEIGHT_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_D_DATA_CUBE_IN_HEIGHT_0_CUBE_IN_HEIGHT_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1fff))
+#define PDP_D_DATA_CUBE_IN_HEIGHT_0_CUBE_IN_HEIGHT_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_DATA_CUBE_IN_HEIGHT_0_CUBE_IN_HEIGHT_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_DATA_CUBE_IN_HEIGHT_0_CUBE_IN_HEIGHT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_DATA_CUBE_IN_HEIGHT_0_CUBE_IN_HEIGHT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register PDP_D_DATA_CUBE_IN_CHANNEL_0
+#define PDP_D_DATA_CUBE_IN_CHANNEL_0 (_MK_ADDR_CONST(0xd014))
+#define PDP_D_DATA_CUBE_IN_CHANNEL_0_SECURE (0x0)
+#define PDP_D_DATA_CUBE_IN_CHANNEL_0_DUAL (0x0)
+#define PDP_D_DATA_CUBE_IN_CHANNEL_0_SCR (0)
+#define PDP_D_DATA_CUBE_IN_CHANNEL_0_WORD_COUNT (0x1)
+#define PDP_D_DATA_CUBE_IN_CHANNEL_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_DATA_CUBE_IN_CHANNEL_0_RESET_MASK (_MK_MASK_CONST(0x1fff))
+#define PDP_D_DATA_CUBE_IN_CHANNEL_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_DATA_CUBE_IN_CHANNEL_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_D_DATA_CUBE_IN_CHANNEL_0_READ_MASK (_MK_MASK_CONST(0x1fff))
+#define PDP_D_DATA_CUBE_IN_CHANNEL_0_WRITE_MASK (_MK_MASK_CONST(0x1fff))
+#define PDP_D_DATA_CUBE_IN_CHANNEL_0_CUBE_IN_CHANNEL_SHIFT (_MK_SHIFT_CONST(0))
+#define PDP_D_DATA_CUBE_IN_CHANNEL_0_CUBE_IN_CHANNEL_FIELD \
+	(_MK_FIELD_CONST(0x1fff,                           \
+			 PDP_D_DATA_CUBE_IN_CHANNEL_0_CUBE_IN_CHANNEL_SHIFT))
+#define PDP_D_DATA_CUBE_IN_CHANNEL_0_CUBE_IN_CHANNEL_RANGE (12 : 0)
+#define PDP_D_DATA_CUBE_IN_CHANNEL_0_CUBE_IN_CHANNEL_WOFFSET (0x0)
+#define PDP_D_DATA_CUBE_IN_CHANNEL_0_CUBE_IN_CHANNEL_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_DATA_CUBE_IN_CHANNEL_0_CUBE_IN_CHANNEL_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1fff))
+#define PDP_D_DATA_CUBE_IN_CHANNEL_0_CUBE_IN_CHANNEL_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_DATA_CUBE_IN_CHANNEL_0_CUBE_IN_CHANNEL_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_DATA_CUBE_IN_CHANNEL_0_CUBE_IN_CHANNEL_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_DATA_CUBE_IN_CHANNEL_0_CUBE_IN_CHANNEL_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register PDP_D_DATA_CUBE_OUT_WIDTH_0
+#define PDP_D_DATA_CUBE_OUT_WIDTH_0 (_MK_ADDR_CONST(0xd018))
+#define PDP_D_DATA_CUBE_OUT_WIDTH_0_SECURE (0x0)
+#define PDP_D_DATA_CUBE_OUT_WIDTH_0_DUAL (0x0)
+#define PDP_D_DATA_CUBE_OUT_WIDTH_0_SCR (0)
+#define PDP_D_DATA_CUBE_OUT_WIDTH_0_WORD_COUNT (0x1)
+#define PDP_D_DATA_CUBE_OUT_WIDTH_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_DATA_CUBE_OUT_WIDTH_0_RESET_MASK (_MK_MASK_CONST(0x1fff))
+#define PDP_D_DATA_CUBE_OUT_WIDTH_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_DATA_CUBE_OUT_WIDTH_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_D_DATA_CUBE_OUT_WIDTH_0_READ_MASK (_MK_MASK_CONST(0x1fff))
+#define PDP_D_DATA_CUBE_OUT_WIDTH_0_WRITE_MASK (_MK_MASK_CONST(0x1fff))
+#define PDP_D_DATA_CUBE_OUT_WIDTH_0_CUBE_OUT_WIDTH_SHIFT (_MK_SHIFT_CONST(0))
+#define PDP_D_DATA_CUBE_OUT_WIDTH_0_CUBE_OUT_WIDTH_FIELD \
+	(_MK_FIELD_CONST(0x1fff,                         \
+			 PDP_D_DATA_CUBE_OUT_WIDTH_0_CUBE_OUT_WIDTH_SHIFT))
+#define PDP_D_DATA_CUBE_OUT_WIDTH_0_CUBE_OUT_WIDTH_RANGE (12 : 0)
+#define PDP_D_DATA_CUBE_OUT_WIDTH_0_CUBE_OUT_WIDTH_WOFFSET (0x0)
+#define PDP_D_DATA_CUBE_OUT_WIDTH_0_CUBE_OUT_WIDTH_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_D_DATA_CUBE_OUT_WIDTH_0_CUBE_OUT_WIDTH_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1fff))
+#define PDP_D_DATA_CUBE_OUT_WIDTH_0_CUBE_OUT_WIDTH_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_DATA_CUBE_OUT_WIDTH_0_CUBE_OUT_WIDTH_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_DATA_CUBE_OUT_WIDTH_0_CUBE_OUT_WIDTH_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_DATA_CUBE_OUT_WIDTH_0_CUBE_OUT_WIDTH_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register PDP_D_DATA_CUBE_OUT_HEIGHT_0
+#define PDP_D_DATA_CUBE_OUT_HEIGHT_0 (_MK_ADDR_CONST(0xd01c))
+#define PDP_D_DATA_CUBE_OUT_HEIGHT_0_SECURE (0x0)
+#define PDP_D_DATA_CUBE_OUT_HEIGHT_0_DUAL (0x0)
+#define PDP_D_DATA_CUBE_OUT_HEIGHT_0_SCR (0)
+#define PDP_D_DATA_CUBE_OUT_HEIGHT_0_WORD_COUNT (0x1)
+#define PDP_D_DATA_CUBE_OUT_HEIGHT_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_DATA_CUBE_OUT_HEIGHT_0_RESET_MASK (_MK_MASK_CONST(0x1fff))
+#define PDP_D_DATA_CUBE_OUT_HEIGHT_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_DATA_CUBE_OUT_HEIGHT_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_D_DATA_CUBE_OUT_HEIGHT_0_READ_MASK (_MK_MASK_CONST(0x1fff))
+#define PDP_D_DATA_CUBE_OUT_HEIGHT_0_WRITE_MASK (_MK_MASK_CONST(0x1fff))
+#define PDP_D_DATA_CUBE_OUT_HEIGHT_0_CUBE_OUT_HEIGHT_SHIFT (_MK_SHIFT_CONST(0))
+#define PDP_D_DATA_CUBE_OUT_HEIGHT_0_CUBE_OUT_HEIGHT_FIELD \
+	(_MK_FIELD_CONST(0x1fff,                           \
+			 PDP_D_DATA_CUBE_OUT_HEIGHT_0_CUBE_OUT_HEIGHT_SHIFT))
+#define PDP_D_DATA_CUBE_OUT_HEIGHT_0_CUBE_OUT_HEIGHT_RANGE (12 : 0)
+#define PDP_D_DATA_CUBE_OUT_HEIGHT_0_CUBE_OUT_HEIGHT_WOFFSET (0x0)
+#define PDP_D_DATA_CUBE_OUT_HEIGHT_0_CUBE_OUT_HEIGHT_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_DATA_CUBE_OUT_HEIGHT_0_CUBE_OUT_HEIGHT_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1fff))
+#define PDP_D_DATA_CUBE_OUT_HEIGHT_0_CUBE_OUT_HEIGHT_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_DATA_CUBE_OUT_HEIGHT_0_CUBE_OUT_HEIGHT_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_DATA_CUBE_OUT_HEIGHT_0_CUBE_OUT_HEIGHT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_DATA_CUBE_OUT_HEIGHT_0_CUBE_OUT_HEIGHT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register PDP_D_DATA_CUBE_OUT_CHANNEL_0
+#define PDP_D_DATA_CUBE_OUT_CHANNEL_0 (_MK_ADDR_CONST(0xd020))
+#define PDP_D_DATA_CUBE_OUT_CHANNEL_0_SECURE (0x0)
+#define PDP_D_DATA_CUBE_OUT_CHANNEL_0_DUAL (0x0)
+#define PDP_D_DATA_CUBE_OUT_CHANNEL_0_SCR (0)
+#define PDP_D_DATA_CUBE_OUT_CHANNEL_0_WORD_COUNT (0x1)
+#define PDP_D_DATA_CUBE_OUT_CHANNEL_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_DATA_CUBE_OUT_CHANNEL_0_RESET_MASK (_MK_MASK_CONST(0x1fff))
+#define PDP_D_DATA_CUBE_OUT_CHANNEL_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_DATA_CUBE_OUT_CHANNEL_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_D_DATA_CUBE_OUT_CHANNEL_0_READ_MASK (_MK_MASK_CONST(0x1fff))
+#define PDP_D_DATA_CUBE_OUT_CHANNEL_0_WRITE_MASK (_MK_MASK_CONST(0x1fff))
+#define PDP_D_DATA_CUBE_OUT_CHANNEL_0_CUBE_OUT_CHANNEL_SHIFT \
+	(_MK_SHIFT_CONST(0))
+#define PDP_D_DATA_CUBE_OUT_CHANNEL_0_CUBE_OUT_CHANNEL_FIELD \
+	(_MK_FIELD_CONST(                                    \
+		0x1fff, PDP_D_DATA_CUBE_OUT_CHANNEL_0_CUBE_OUT_CHANNEL_SHIFT))
+#define PDP_D_DATA_CUBE_OUT_CHANNEL_0_CUBE_OUT_CHANNEL_RANGE (12 : 0)
+#define PDP_D_DATA_CUBE_OUT_CHANNEL_0_CUBE_OUT_CHANNEL_WOFFSET (0x0)
+#define PDP_D_DATA_CUBE_OUT_CHANNEL_0_CUBE_OUT_CHANNEL_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_DATA_CUBE_OUT_CHANNEL_0_CUBE_OUT_CHANNEL_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1fff))
+#define PDP_D_DATA_CUBE_OUT_CHANNEL_0_CUBE_OUT_CHANNEL_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_DATA_CUBE_OUT_CHANNEL_0_CUBE_OUT_CHANNEL_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_DATA_CUBE_OUT_CHANNEL_0_CUBE_OUT_CHANNEL_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_DATA_CUBE_OUT_CHANNEL_0_CUBE_OUT_CHANNEL_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register PDP_D_OPERATION_MODE_CFG_0
+#define PDP_D_OPERATION_MODE_CFG_0 (_MK_ADDR_CONST(0xd024))
+#define PDP_D_OPERATION_MODE_CFG_0_SECURE (0x0)
+#define PDP_D_OPERATION_MODE_CFG_0_DUAL (0x0)
+#define PDP_D_OPERATION_MODE_CFG_0_SCR (0)
+#define PDP_D_OPERATION_MODE_CFG_0_WORD_COUNT (0x1)
+#define PDP_D_OPERATION_MODE_CFG_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_OPERATION_MODE_CFG_0_RESET_MASK (_MK_MASK_CONST(0xff13))
+#define PDP_D_OPERATION_MODE_CFG_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_OPERATION_MODE_CFG_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_D_OPERATION_MODE_CFG_0_READ_MASK (_MK_MASK_CONST(0xff13))
+#define PDP_D_OPERATION_MODE_CFG_0_WRITE_MASK (_MK_MASK_CONST(0xff13))
+#define PDP_D_OPERATION_MODE_CFG_0_POOLING_METHOD_SHIFT (_MK_SHIFT_CONST(0))
+#define PDP_D_OPERATION_MODE_CFG_0_POOLING_METHOD_FIELD \
+	(_MK_FIELD_CONST(0x3, PDP_D_OPERATION_MODE_CFG_0_POOLING_METHOD_SHIFT))
+#define PDP_D_OPERATION_MODE_CFG_0_POOLING_METHOD_RANGE (1 : 0)
+#define PDP_D_OPERATION_MODE_CFG_0_POOLING_METHOD_WOFFSET (0x0)
+#define PDP_D_OPERATION_MODE_CFG_0_POOLING_METHOD_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_D_OPERATION_MODE_CFG_0_POOLING_METHOD_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x3))
+#define PDP_D_OPERATION_MODE_CFG_0_POOLING_METHOD_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_OPERATION_MODE_CFG_0_POOLING_METHOD_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_OPERATION_MODE_CFG_0_POOLING_METHOD_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_OPERATION_MODE_CFG_0_POOLING_METHOD_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define PDP_D_OPERATION_MODE_CFG_0_POOLING_METHOD_POOLING_METHOD_AVERAGE \
+	(_MK_ENUM_CONST(0))
+#define PDP_D_OPERATION_MODE_CFG_0_POOLING_METHOD_POOLING_METHOD_MAX \
+	(_MK_ENUM_CONST(1))
+#define PDP_D_OPERATION_MODE_CFG_0_POOLING_METHOD_POOLING_METHOD_MIN \
+	(_MK_ENUM_CONST(2))
+
+#define PDP_D_OPERATION_MODE_CFG_0_FLYING_MODE_SHIFT (_MK_SHIFT_CONST(4))
+#define PDP_D_OPERATION_MODE_CFG_0_FLYING_MODE_FIELD \
+	(_MK_FIELD_CONST(0x1, PDP_D_OPERATION_MODE_CFG_0_FLYING_MODE_SHIFT))
+#define PDP_D_OPERATION_MODE_CFG_0_FLYING_MODE_RANGE (4 : 4)
+#define PDP_D_OPERATION_MODE_CFG_0_FLYING_MODE_WOFFSET (0x0)
+#define PDP_D_OPERATION_MODE_CFG_0_FLYING_MODE_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_D_OPERATION_MODE_CFG_0_FLYING_MODE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1))
+#define PDP_D_OPERATION_MODE_CFG_0_FLYING_MODE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_D_OPERATION_MODE_CFG_0_FLYING_MODE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_OPERATION_MODE_CFG_0_FLYING_MODE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_OPERATION_MODE_CFG_0_FLYING_MODE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define PDP_D_OPERATION_MODE_CFG_0_FLYING_MODE_ON_FLYING (_MK_ENUM_CONST(0))
+#define PDP_D_OPERATION_MODE_CFG_0_FLYING_MODE_OFF_FLYING (_MK_ENUM_CONST(1))
+
+#define PDP_D_OPERATION_MODE_CFG_0_SPLIT_NUM_SHIFT (_MK_SHIFT_CONST(8))
+#define PDP_D_OPERATION_MODE_CFG_0_SPLIT_NUM_FIELD \
+	(_MK_FIELD_CONST(0xff, PDP_D_OPERATION_MODE_CFG_0_SPLIT_NUM_SHIFT))
+#define PDP_D_OPERATION_MODE_CFG_0_SPLIT_NUM_RANGE (15 : 8)
+#define PDP_D_OPERATION_MODE_CFG_0_SPLIT_NUM_WOFFSET (0x0)
+#define PDP_D_OPERATION_MODE_CFG_0_SPLIT_NUM_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_D_OPERATION_MODE_CFG_0_SPLIT_NUM_DEFAULT_MASK (_MK_MASK_CONST(0xff))
+#define PDP_D_OPERATION_MODE_CFG_0_SPLIT_NUM_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_D_OPERATION_MODE_CFG_0_SPLIT_NUM_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_OPERATION_MODE_CFG_0_SPLIT_NUM_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_OPERATION_MODE_CFG_0_SPLIT_NUM_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register PDP_D_NAN_FLUSH_TO_ZERO_0
+#define PDP_D_NAN_FLUSH_TO_ZERO_0 (_MK_ADDR_CONST(0xd028))
+#define PDP_D_NAN_FLUSH_TO_ZERO_0_SECURE (0x0)
+#define PDP_D_NAN_FLUSH_TO_ZERO_0_DUAL (0x0)
+#define PDP_D_NAN_FLUSH_TO_ZERO_0_SCR (0)
+#define PDP_D_NAN_FLUSH_TO_ZERO_0_WORD_COUNT (0x1)
+#define PDP_D_NAN_FLUSH_TO_ZERO_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_NAN_FLUSH_TO_ZERO_0_RESET_MASK (_MK_MASK_CONST(0x1))
+#define PDP_D_NAN_FLUSH_TO_ZERO_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_NAN_FLUSH_TO_ZERO_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_D_NAN_FLUSH_TO_ZERO_0_READ_MASK (_MK_MASK_CONST(0x1))
+#define PDP_D_NAN_FLUSH_TO_ZERO_0_WRITE_MASK (_MK_MASK_CONST(0x1))
+#define PDP_D_NAN_FLUSH_TO_ZERO_0_NAN_TO_ZERO_SHIFT (_MK_SHIFT_CONST(0))
+#define PDP_D_NAN_FLUSH_TO_ZERO_0_NAN_TO_ZERO_FIELD \
+	(_MK_FIELD_CONST(0x1, PDP_D_NAN_FLUSH_TO_ZERO_0_NAN_TO_ZERO_SHIFT))
+#define PDP_D_NAN_FLUSH_TO_ZERO_0_NAN_TO_ZERO_RANGE (0 : 0)
+#define PDP_D_NAN_FLUSH_TO_ZERO_0_NAN_TO_ZERO_WOFFSET (0x0)
+#define PDP_D_NAN_FLUSH_TO_ZERO_0_NAN_TO_ZERO_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_D_NAN_FLUSH_TO_ZERO_0_NAN_TO_ZERO_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define PDP_D_NAN_FLUSH_TO_ZERO_0_NAN_TO_ZERO_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_D_NAN_FLUSH_TO_ZERO_0_NAN_TO_ZERO_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_NAN_FLUSH_TO_ZERO_0_NAN_TO_ZERO_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_NAN_FLUSH_TO_ZERO_0_NAN_TO_ZERO_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define PDP_D_NAN_FLUSH_TO_ZERO_0_NAN_TO_ZERO_INIT_ENUM (DISABLE)
+#define PDP_D_NAN_FLUSH_TO_ZERO_0_NAN_TO_ZERO_DISABLE (_MK_ENUM_CONST(0))
+#define PDP_D_NAN_FLUSH_TO_ZERO_0_NAN_TO_ZERO_ENABLE (_MK_ENUM_CONST(1))
+
+// Register PDP_D_PARTIAL_WIDTH_IN_0
+#define PDP_D_PARTIAL_WIDTH_IN_0 (_MK_ADDR_CONST(0xd02c))
+#define PDP_D_PARTIAL_WIDTH_IN_0_SECURE (0x0)
+#define PDP_D_PARTIAL_WIDTH_IN_0_DUAL (0x0)
+#define PDP_D_PARTIAL_WIDTH_IN_0_SCR (0)
+#define PDP_D_PARTIAL_WIDTH_IN_0_WORD_COUNT (0x1)
+#define PDP_D_PARTIAL_WIDTH_IN_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_PARTIAL_WIDTH_IN_0_RESET_MASK (_MK_MASK_CONST(0x3fffffff))
+#define PDP_D_PARTIAL_WIDTH_IN_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_PARTIAL_WIDTH_IN_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_D_PARTIAL_WIDTH_IN_0_READ_MASK (_MK_MASK_CONST(0x3fffffff))
+#define PDP_D_PARTIAL_WIDTH_IN_0_WRITE_MASK (_MK_MASK_CONST(0x3fffffff))
+#define PDP_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_FIRST_SHIFT \
+	(_MK_SHIFT_CONST(0))
+#define PDP_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_FIRST_FIELD \
+	(_MK_FIELD_CONST(                                     \
+		0x3ff, PDP_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_FIRST_SHIFT))
+#define PDP_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_FIRST_RANGE (9 : 0)
+#define PDP_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_FIRST_WOFFSET (0x0)
+#define PDP_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_FIRST_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_FIRST_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x3ff))
+#define PDP_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_FIRST_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_FIRST_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_FIRST_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_FIRST_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define PDP_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_LAST_SHIFT \
+	(_MK_SHIFT_CONST(10))
+#define PDP_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_LAST_FIELD \
+	(_MK_FIELD_CONST(                                    \
+		0x3ff, PDP_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_LAST_SHIFT))
+#define PDP_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_LAST_RANGE (19 : 10)
+#define PDP_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_LAST_WOFFSET (0x0)
+#define PDP_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_LAST_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_LAST_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x3ff))
+#define PDP_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_LAST_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_LAST_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_LAST_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_LAST_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define PDP_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_MID_SHIFT \
+	(_MK_SHIFT_CONST(20))
+#define PDP_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_MID_FIELD \
+	(_MK_FIELD_CONST(0x3ff,                             \
+			 PDP_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_MID_SHIFT))
+#define PDP_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_MID_RANGE (29 : 20)
+#define PDP_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_MID_WOFFSET (0x0)
+#define PDP_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_MID_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_MID_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x3ff))
+#define PDP_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_MID_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_MID_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_MID_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_PARTIAL_WIDTH_IN_0_PARTIAL_WIDTH_IN_MID_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register PDP_D_PARTIAL_WIDTH_OUT_0
+#define PDP_D_PARTIAL_WIDTH_OUT_0 (_MK_ADDR_CONST(0xd030))
+#define PDP_D_PARTIAL_WIDTH_OUT_0_SECURE (0x0)
+#define PDP_D_PARTIAL_WIDTH_OUT_0_DUAL (0x0)
+#define PDP_D_PARTIAL_WIDTH_OUT_0_SCR (0)
+#define PDP_D_PARTIAL_WIDTH_OUT_0_WORD_COUNT (0x1)
+#define PDP_D_PARTIAL_WIDTH_OUT_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_PARTIAL_WIDTH_OUT_0_RESET_MASK (_MK_MASK_CONST(0x3fffffff))
+#define PDP_D_PARTIAL_WIDTH_OUT_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_PARTIAL_WIDTH_OUT_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_D_PARTIAL_WIDTH_OUT_0_READ_MASK (_MK_MASK_CONST(0x3fffffff))
+#define PDP_D_PARTIAL_WIDTH_OUT_0_WRITE_MASK (_MK_MASK_CONST(0x3fffffff))
+#define PDP_D_PARTIAL_WIDTH_OUT_0_PARTIAL_WIDTH_OUT_FIRST_SHIFT \
+	(_MK_SHIFT_CONST(0))
+#define PDP_D_PARTIAL_WIDTH_OUT_0_PARTIAL_WIDTH_OUT_FIRST_FIELD \
+	(_MK_FIELD_CONST(                                       \
+		0x3ff,                                          \
+		PDP_D_PARTIAL_WIDTH_OUT_0_PARTIAL_WIDTH_OUT_FIRST_SHIFT))
+#define PDP_D_PARTIAL_WIDTH_OUT_0_PARTIAL_WIDTH_OUT_FIRST_RANGE (9 : 0)
+#define PDP_D_PARTIAL_WIDTH_OUT_0_PARTIAL_WIDTH_OUT_FIRST_WOFFSET (0x0)
+#define PDP_D_PARTIAL_WIDTH_OUT_0_PARTIAL_WIDTH_OUT_FIRST_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_PARTIAL_WIDTH_OUT_0_PARTIAL_WIDTH_OUT_FIRST_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x3ff))
+#define PDP_D_PARTIAL_WIDTH_OUT_0_PARTIAL_WIDTH_OUT_FIRST_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_PARTIAL_WIDTH_OUT_0_PARTIAL_WIDTH_OUT_FIRST_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_PARTIAL_WIDTH_OUT_0_PARTIAL_WIDTH_OUT_FIRST_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_PARTIAL_WIDTH_OUT_0_PARTIAL_WIDTH_OUT_FIRST_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define PDP_D_PARTIAL_WIDTH_OUT_0_PARTIAL_WIDTH_OUT_LAST_SHIFT \
+	(_MK_SHIFT_CONST(10))
+#define PDP_D_PARTIAL_WIDTH_OUT_0_PARTIAL_WIDTH_OUT_LAST_FIELD \
+	(_MK_FIELD_CONST(                                      \
+		0x3ff,                                         \
+		PDP_D_PARTIAL_WIDTH_OUT_0_PARTIAL_WIDTH_OUT_LAST_SHIFT))
+#define PDP_D_PARTIAL_WIDTH_OUT_0_PARTIAL_WIDTH_OUT_LAST_RANGE (19 : 10)
+#define PDP_D_PARTIAL_WIDTH_OUT_0_PARTIAL_WIDTH_OUT_LAST_WOFFSET (0x0)
+#define PDP_D_PARTIAL_WIDTH_OUT_0_PARTIAL_WIDTH_OUT_LAST_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_PARTIAL_WIDTH_OUT_0_PARTIAL_WIDTH_OUT_LAST_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x3ff))
+#define PDP_D_PARTIAL_WIDTH_OUT_0_PARTIAL_WIDTH_OUT_LAST_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_PARTIAL_WIDTH_OUT_0_PARTIAL_WIDTH_OUT_LAST_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_PARTIAL_WIDTH_OUT_0_PARTIAL_WIDTH_OUT_LAST_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_PARTIAL_WIDTH_OUT_0_PARTIAL_WIDTH_OUT_LAST_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define PDP_D_PARTIAL_WIDTH_OUT_0_PARTIAL_WIDTH_OUT_MID_SHIFT \
+	(_MK_SHIFT_CONST(20))
+#define PDP_D_PARTIAL_WIDTH_OUT_0_PARTIAL_WIDTH_OUT_MID_FIELD \
+	(_MK_FIELD_CONST(                                     \
+		0x3ff, PDP_D_PARTIAL_WIDTH_OUT_0_PARTIAL_WIDTH_OUT_MID_SHIFT))
+#define PDP_D_PARTIAL_WIDTH_OUT_0_PARTIAL_WIDTH_OUT_MID_RANGE (29 : 20)
+#define PDP_D_PARTIAL_WIDTH_OUT_0_PARTIAL_WIDTH_OUT_MID_WOFFSET (0x0)
+#define PDP_D_PARTIAL_WIDTH_OUT_0_PARTIAL_WIDTH_OUT_MID_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_PARTIAL_WIDTH_OUT_0_PARTIAL_WIDTH_OUT_MID_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x3ff))
+#define PDP_D_PARTIAL_WIDTH_OUT_0_PARTIAL_WIDTH_OUT_MID_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_PARTIAL_WIDTH_OUT_0_PARTIAL_WIDTH_OUT_MID_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_PARTIAL_WIDTH_OUT_0_PARTIAL_WIDTH_OUT_MID_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_PARTIAL_WIDTH_OUT_0_PARTIAL_WIDTH_OUT_MID_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register PDP_D_POOLING_KERNEL_CFG_0
+#define PDP_D_POOLING_KERNEL_CFG_0 (_MK_ADDR_CONST(0xd034))
+#define PDP_D_POOLING_KERNEL_CFG_0_SECURE (0x0)
+#define PDP_D_POOLING_KERNEL_CFG_0_DUAL (0x0)
+#define PDP_D_POOLING_KERNEL_CFG_0_SCR (0)
+#define PDP_D_POOLING_KERNEL_CFG_0_WORD_COUNT (0x1)
+#define PDP_D_POOLING_KERNEL_CFG_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_KERNEL_CFG_0_RESET_MASK (_MK_MASK_CONST(0xff0f0f))
+#define PDP_D_POOLING_KERNEL_CFG_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_KERNEL_CFG_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_KERNEL_CFG_0_READ_MASK (_MK_MASK_CONST(0xff0f0f))
+#define PDP_D_POOLING_KERNEL_CFG_0_WRITE_MASK (_MK_MASK_CONST(0xff0f0f))
+#define PDP_D_POOLING_KERNEL_CFG_0_KERNEL_WIDTH_SHIFT (_MK_SHIFT_CONST(0))
+#define PDP_D_POOLING_KERNEL_CFG_0_KERNEL_WIDTH_FIELD \
+	(_MK_FIELD_CONST(0xf, PDP_D_POOLING_KERNEL_CFG_0_KERNEL_WIDTH_SHIFT))
+#define PDP_D_POOLING_KERNEL_CFG_0_KERNEL_WIDTH_RANGE (3 : 0)
+#define PDP_D_POOLING_KERNEL_CFG_0_KERNEL_WIDTH_WOFFSET (0x0)
+#define PDP_D_POOLING_KERNEL_CFG_0_KERNEL_WIDTH_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_KERNEL_CFG_0_KERNEL_WIDTH_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xf))
+#define PDP_D_POOLING_KERNEL_CFG_0_KERNEL_WIDTH_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_KERNEL_CFG_0_KERNEL_WIDTH_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_KERNEL_CFG_0_KERNEL_WIDTH_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_KERNEL_CFG_0_KERNEL_WIDTH_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define PDP_D_POOLING_KERNEL_CFG_0_KERNEL_WIDTH_KERNEL_WIDTH_1 \
+	(_MK_ENUM_CONST(0))
+#define PDP_D_POOLING_KERNEL_CFG_0_KERNEL_WIDTH_KERNEL_WIDTH_2 \
+	(_MK_ENUM_CONST(1))
+#define PDP_D_POOLING_KERNEL_CFG_0_KERNEL_WIDTH_KERNEL_WIDTH_3 \
+	(_MK_ENUM_CONST(2))
+#define PDP_D_POOLING_KERNEL_CFG_0_KERNEL_WIDTH_KERNEL_WIDTH_4 \
+	(_MK_ENUM_CONST(3))
+#define PDP_D_POOLING_KERNEL_CFG_0_KERNEL_WIDTH_KERNEL_WIDTH_5 \
+	(_MK_ENUM_CONST(4))
+#define PDP_D_POOLING_KERNEL_CFG_0_KERNEL_WIDTH_KERNEL_WIDTH_6 \
+	(_MK_ENUM_CONST(5))
+#define PDP_D_POOLING_KERNEL_CFG_0_KERNEL_WIDTH_KERNEL_WIDTH_7 \
+	(_MK_ENUM_CONST(6))
+#define PDP_D_POOLING_KERNEL_CFG_0_KERNEL_WIDTH_KERNEL_WIDTH_8 \
+	(_MK_ENUM_CONST(7))
+
+#define PDP_D_POOLING_KERNEL_CFG_0_KERNEL_HEIGHT_SHIFT (_MK_SHIFT_CONST(8))
+#define PDP_D_POOLING_KERNEL_CFG_0_KERNEL_HEIGHT_FIELD \
+	(_MK_FIELD_CONST(0xf, PDP_D_POOLING_KERNEL_CFG_0_KERNEL_HEIGHT_SHIFT))
+#define PDP_D_POOLING_KERNEL_CFG_0_KERNEL_HEIGHT_RANGE (11 : 8)
+#define PDP_D_POOLING_KERNEL_CFG_0_KERNEL_HEIGHT_WOFFSET (0x0)
+#define PDP_D_POOLING_KERNEL_CFG_0_KERNEL_HEIGHT_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_KERNEL_CFG_0_KERNEL_HEIGHT_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xf))
+#define PDP_D_POOLING_KERNEL_CFG_0_KERNEL_HEIGHT_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_KERNEL_CFG_0_KERNEL_HEIGHT_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_KERNEL_CFG_0_KERNEL_HEIGHT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_KERNEL_CFG_0_KERNEL_HEIGHT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define PDP_D_POOLING_KERNEL_CFG_0_KERNEL_HEIGHT_KERNEL_HEIGHT_1 \
+	(_MK_ENUM_CONST(0))
+#define PDP_D_POOLING_KERNEL_CFG_0_KERNEL_HEIGHT_KERNEL_HEIGHT_2 \
+	(_MK_ENUM_CONST(1))
+#define PDP_D_POOLING_KERNEL_CFG_0_KERNEL_HEIGHT_KERNEL_HEIGHT_3 \
+	(_MK_ENUM_CONST(2))
+#define PDP_D_POOLING_KERNEL_CFG_0_KERNEL_HEIGHT_KERNEL_HEIGHT_4 \
+	(_MK_ENUM_CONST(3))
+#define PDP_D_POOLING_KERNEL_CFG_0_KERNEL_HEIGHT_KERNEL_HEIGHT_5 \
+	(_MK_ENUM_CONST(4))
+#define PDP_D_POOLING_KERNEL_CFG_0_KERNEL_HEIGHT_KERNEL_HEIGHT_6 \
+	(_MK_ENUM_CONST(5))
+#define PDP_D_POOLING_KERNEL_CFG_0_KERNEL_HEIGHT_KERNEL_HEIGHT_7 \
+	(_MK_ENUM_CONST(6))
+#define PDP_D_POOLING_KERNEL_CFG_0_KERNEL_HEIGHT_KERNEL_HEIGHT_8 \
+	(_MK_ENUM_CONST(7))
+
+#define PDP_D_POOLING_KERNEL_CFG_0_KERNEL_STRIDE_WIDTH_SHIFT \
+	(_MK_SHIFT_CONST(16))
+#define PDP_D_POOLING_KERNEL_CFG_0_KERNEL_STRIDE_WIDTH_FIELD \
+	(_MK_FIELD_CONST(                                    \
+		0xf, PDP_D_POOLING_KERNEL_CFG_0_KERNEL_STRIDE_WIDTH_SHIFT))
+#define PDP_D_POOLING_KERNEL_CFG_0_KERNEL_STRIDE_WIDTH_RANGE (19 : 16)
+#define PDP_D_POOLING_KERNEL_CFG_0_KERNEL_STRIDE_WIDTH_WOFFSET (0x0)
+#define PDP_D_POOLING_KERNEL_CFG_0_KERNEL_STRIDE_WIDTH_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_KERNEL_CFG_0_KERNEL_STRIDE_WIDTH_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xf))
+#define PDP_D_POOLING_KERNEL_CFG_0_KERNEL_STRIDE_WIDTH_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_KERNEL_CFG_0_KERNEL_STRIDE_WIDTH_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_KERNEL_CFG_0_KERNEL_STRIDE_WIDTH_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_KERNEL_CFG_0_KERNEL_STRIDE_WIDTH_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define PDP_D_POOLING_KERNEL_CFG_0_KERNEL_STRIDE_HEIGHT_SHIFT \
+	(_MK_SHIFT_CONST(20))
+#define PDP_D_POOLING_KERNEL_CFG_0_KERNEL_STRIDE_HEIGHT_FIELD \
+	(_MK_FIELD_CONST(                                     \
+		0xf, PDP_D_POOLING_KERNEL_CFG_0_KERNEL_STRIDE_HEIGHT_SHIFT))
+#define PDP_D_POOLING_KERNEL_CFG_0_KERNEL_STRIDE_HEIGHT_RANGE (23 : 20)
+#define PDP_D_POOLING_KERNEL_CFG_0_KERNEL_STRIDE_HEIGHT_WOFFSET (0x0)
+#define PDP_D_POOLING_KERNEL_CFG_0_KERNEL_STRIDE_HEIGHT_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_KERNEL_CFG_0_KERNEL_STRIDE_HEIGHT_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xf))
+#define PDP_D_POOLING_KERNEL_CFG_0_KERNEL_STRIDE_HEIGHT_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_KERNEL_CFG_0_KERNEL_STRIDE_HEIGHT_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_KERNEL_CFG_0_KERNEL_STRIDE_HEIGHT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_KERNEL_CFG_0_KERNEL_STRIDE_HEIGHT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register PDP_D_RECIP_KERNEL_WIDTH_0
+#define PDP_D_RECIP_KERNEL_WIDTH_0 (_MK_ADDR_CONST(0xd038))
+#define PDP_D_RECIP_KERNEL_WIDTH_0_SECURE (0x0)
+#define PDP_D_RECIP_KERNEL_WIDTH_0_DUAL (0x0)
+#define PDP_D_RECIP_KERNEL_WIDTH_0_SCR (0)
+#define PDP_D_RECIP_KERNEL_WIDTH_0_WORD_COUNT (0x1)
+#define PDP_D_RECIP_KERNEL_WIDTH_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_RECIP_KERNEL_WIDTH_0_RESET_MASK (_MK_MASK_CONST(0x1ffff))
+#define PDP_D_RECIP_KERNEL_WIDTH_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_RECIP_KERNEL_WIDTH_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_D_RECIP_KERNEL_WIDTH_0_READ_MASK (_MK_MASK_CONST(0x1ffff))
+#define PDP_D_RECIP_KERNEL_WIDTH_0_WRITE_MASK (_MK_MASK_CONST(0x1ffff))
+#define PDP_D_RECIP_KERNEL_WIDTH_0_RECIP_KERNEL_WIDTH_SHIFT (_MK_SHIFT_CONST(0))
+#define PDP_D_RECIP_KERNEL_WIDTH_0_RECIP_KERNEL_WIDTH_FIELD \
+	(_MK_FIELD_CONST(0x1ffff,                           \
+			 PDP_D_RECIP_KERNEL_WIDTH_0_RECIP_KERNEL_WIDTH_SHIFT))
+#define PDP_D_RECIP_KERNEL_WIDTH_0_RECIP_KERNEL_WIDTH_RANGE (16 : 0)
+#define PDP_D_RECIP_KERNEL_WIDTH_0_RECIP_KERNEL_WIDTH_WOFFSET (0x0)
+#define PDP_D_RECIP_KERNEL_WIDTH_0_RECIP_KERNEL_WIDTH_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_RECIP_KERNEL_WIDTH_0_RECIP_KERNEL_WIDTH_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1ffff))
+#define PDP_D_RECIP_KERNEL_WIDTH_0_RECIP_KERNEL_WIDTH_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_RECIP_KERNEL_WIDTH_0_RECIP_KERNEL_WIDTH_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_RECIP_KERNEL_WIDTH_0_RECIP_KERNEL_WIDTH_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_RECIP_KERNEL_WIDTH_0_RECIP_KERNEL_WIDTH_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register PDP_D_RECIP_KERNEL_HEIGHT_0
+#define PDP_D_RECIP_KERNEL_HEIGHT_0 (_MK_ADDR_CONST(0xd03c))
+#define PDP_D_RECIP_KERNEL_HEIGHT_0_SECURE (0x0)
+#define PDP_D_RECIP_KERNEL_HEIGHT_0_DUAL (0x0)
+#define PDP_D_RECIP_KERNEL_HEIGHT_0_SCR (0)
+#define PDP_D_RECIP_KERNEL_HEIGHT_0_WORD_COUNT (0x1)
+#define PDP_D_RECIP_KERNEL_HEIGHT_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_RECIP_KERNEL_HEIGHT_0_RESET_MASK (_MK_MASK_CONST(0x1ffff))
+#define PDP_D_RECIP_KERNEL_HEIGHT_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_RECIP_KERNEL_HEIGHT_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_D_RECIP_KERNEL_HEIGHT_0_READ_MASK (_MK_MASK_CONST(0x1ffff))
+#define PDP_D_RECIP_KERNEL_HEIGHT_0_WRITE_MASK (_MK_MASK_CONST(0x1ffff))
+#define PDP_D_RECIP_KERNEL_HEIGHT_0_RECIP_KERNEL_HEIGHT_SHIFT \
+	(_MK_SHIFT_CONST(0))
+#define PDP_D_RECIP_KERNEL_HEIGHT_0_RECIP_KERNEL_HEIGHT_FIELD \
+	(_MK_FIELD_CONST(                                     \
+		0x1ffff,                                      \
+		PDP_D_RECIP_KERNEL_HEIGHT_0_RECIP_KERNEL_HEIGHT_SHIFT))
+#define PDP_D_RECIP_KERNEL_HEIGHT_0_RECIP_KERNEL_HEIGHT_RANGE (16 : 0)
+#define PDP_D_RECIP_KERNEL_HEIGHT_0_RECIP_KERNEL_HEIGHT_WOFFSET (0x0)
+#define PDP_D_RECIP_KERNEL_HEIGHT_0_RECIP_KERNEL_HEIGHT_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_RECIP_KERNEL_HEIGHT_0_RECIP_KERNEL_HEIGHT_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1ffff))
+#define PDP_D_RECIP_KERNEL_HEIGHT_0_RECIP_KERNEL_HEIGHT_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_RECIP_KERNEL_HEIGHT_0_RECIP_KERNEL_HEIGHT_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_RECIP_KERNEL_HEIGHT_0_RECIP_KERNEL_HEIGHT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_RECIP_KERNEL_HEIGHT_0_RECIP_KERNEL_HEIGHT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register PDP_D_POOLING_PADDING_CFG_0
+#define PDP_D_POOLING_PADDING_CFG_0 (_MK_ADDR_CONST(0xd040))
+#define PDP_D_POOLING_PADDING_CFG_0_SECURE (0x0)
+#define PDP_D_POOLING_PADDING_CFG_0_DUAL (0x0)
+#define PDP_D_POOLING_PADDING_CFG_0_SCR (0)
+#define PDP_D_POOLING_PADDING_CFG_0_WORD_COUNT (0x1)
+#define PDP_D_POOLING_PADDING_CFG_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_CFG_0_RESET_MASK (_MK_MASK_CONST(0x7777))
+#define PDP_D_POOLING_PADDING_CFG_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_CFG_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_CFG_0_READ_MASK (_MK_MASK_CONST(0x7777))
+#define PDP_D_POOLING_PADDING_CFG_0_WRITE_MASK (_MK_MASK_CONST(0x7777))
+#define PDP_D_POOLING_PADDING_CFG_0_PAD_LEFT_SHIFT (_MK_SHIFT_CONST(0))
+#define PDP_D_POOLING_PADDING_CFG_0_PAD_LEFT_FIELD \
+	(_MK_FIELD_CONST(0x7, PDP_D_POOLING_PADDING_CFG_0_PAD_LEFT_SHIFT))
+#define PDP_D_POOLING_PADDING_CFG_0_PAD_LEFT_RANGE (2 : 0)
+#define PDP_D_POOLING_PADDING_CFG_0_PAD_LEFT_WOFFSET (0x0)
+#define PDP_D_POOLING_PADDING_CFG_0_PAD_LEFT_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_CFG_0_PAD_LEFT_DEFAULT_MASK (_MK_MASK_CONST(0x7))
+#define PDP_D_POOLING_PADDING_CFG_0_PAD_LEFT_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_CFG_0_PAD_LEFT_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_CFG_0_PAD_LEFT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_CFG_0_PAD_LEFT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define PDP_D_POOLING_PADDING_CFG_0_PAD_TOP_SHIFT (_MK_SHIFT_CONST(4))
+#define PDP_D_POOLING_PADDING_CFG_0_PAD_TOP_FIELD \
+	(_MK_FIELD_CONST(0x7, PDP_D_POOLING_PADDING_CFG_0_PAD_TOP_SHIFT))
+#define PDP_D_POOLING_PADDING_CFG_0_PAD_TOP_RANGE (6 : 4)
+#define PDP_D_POOLING_PADDING_CFG_0_PAD_TOP_WOFFSET (0x0)
+#define PDP_D_POOLING_PADDING_CFG_0_PAD_TOP_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_CFG_0_PAD_TOP_DEFAULT_MASK (_MK_MASK_CONST(0x7))
+#define PDP_D_POOLING_PADDING_CFG_0_PAD_TOP_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_CFG_0_PAD_TOP_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_CFG_0_PAD_TOP_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_CFG_0_PAD_TOP_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define PDP_D_POOLING_PADDING_CFG_0_PAD_RIGHT_SHIFT (_MK_SHIFT_CONST(8))
+#define PDP_D_POOLING_PADDING_CFG_0_PAD_RIGHT_FIELD \
+	(_MK_FIELD_CONST(0x7, PDP_D_POOLING_PADDING_CFG_0_PAD_RIGHT_SHIFT))
+#define PDP_D_POOLING_PADDING_CFG_0_PAD_RIGHT_RANGE (10 : 8)
+#define PDP_D_POOLING_PADDING_CFG_0_PAD_RIGHT_WOFFSET (0x0)
+#define PDP_D_POOLING_PADDING_CFG_0_PAD_RIGHT_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_CFG_0_PAD_RIGHT_DEFAULT_MASK (_MK_MASK_CONST(0x7))
+#define PDP_D_POOLING_PADDING_CFG_0_PAD_RIGHT_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_CFG_0_PAD_RIGHT_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_CFG_0_PAD_RIGHT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_CFG_0_PAD_RIGHT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define PDP_D_POOLING_PADDING_CFG_0_PAD_BOTTOM_SHIFT (_MK_SHIFT_CONST(12))
+#define PDP_D_POOLING_PADDING_CFG_0_PAD_BOTTOM_FIELD \
+	(_MK_FIELD_CONST(0x7, PDP_D_POOLING_PADDING_CFG_0_PAD_BOTTOM_SHIFT))
+#define PDP_D_POOLING_PADDING_CFG_0_PAD_BOTTOM_RANGE (14 : 12)
+#define PDP_D_POOLING_PADDING_CFG_0_PAD_BOTTOM_WOFFSET (0x0)
+#define PDP_D_POOLING_PADDING_CFG_0_PAD_BOTTOM_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_CFG_0_PAD_BOTTOM_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7))
+#define PDP_D_POOLING_PADDING_CFG_0_PAD_BOTTOM_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_CFG_0_PAD_BOTTOM_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_CFG_0_PAD_BOTTOM_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_CFG_0_PAD_BOTTOM_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register PDP_D_POOLING_PADDING_VALUE_1_CFG_0
+#define PDP_D_POOLING_PADDING_VALUE_1_CFG_0 (_MK_ADDR_CONST(0xd044))
+#define PDP_D_POOLING_PADDING_VALUE_1_CFG_0_SECURE (0x0)
+#define PDP_D_POOLING_PADDING_VALUE_1_CFG_0_DUAL (0x0)
+#define PDP_D_POOLING_PADDING_VALUE_1_CFG_0_SCR (0)
+#define PDP_D_POOLING_PADDING_VALUE_1_CFG_0_WORD_COUNT (0x1)
+#define PDP_D_POOLING_PADDING_VALUE_1_CFG_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_VALUE_1_CFG_0_RESET_MASK (_MK_MASK_CONST(0x7ffff))
+#define PDP_D_POOLING_PADDING_VALUE_1_CFG_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_VALUE_1_CFG_0_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_VALUE_1_CFG_0_READ_MASK (_MK_MASK_CONST(0x7ffff))
+#define PDP_D_POOLING_PADDING_VALUE_1_CFG_0_WRITE_MASK (_MK_MASK_CONST(0x7ffff))
+#define PDP_D_POOLING_PADDING_VALUE_1_CFG_0_PAD_VALUE_1X_SHIFT \
+	(_MK_SHIFT_CONST(0))
+#define PDP_D_POOLING_PADDING_VALUE_1_CFG_0_PAD_VALUE_1X_FIELD \
+	(_MK_FIELD_CONST(                                      \
+		0x7ffff,                                       \
+		PDP_D_POOLING_PADDING_VALUE_1_CFG_0_PAD_VALUE_1X_SHIFT))
+#define PDP_D_POOLING_PADDING_VALUE_1_CFG_0_PAD_VALUE_1X_RANGE (18 : 0)
+#define PDP_D_POOLING_PADDING_VALUE_1_CFG_0_PAD_VALUE_1X_WOFFSET (0x0)
+#define PDP_D_POOLING_PADDING_VALUE_1_CFG_0_PAD_VALUE_1X_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_VALUE_1_CFG_0_PAD_VALUE_1X_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffff))
+#define PDP_D_POOLING_PADDING_VALUE_1_CFG_0_PAD_VALUE_1X_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_VALUE_1_CFG_0_PAD_VALUE_1X_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_VALUE_1_CFG_0_PAD_VALUE_1X_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_VALUE_1_CFG_0_PAD_VALUE_1X_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register PDP_D_POOLING_PADDING_VALUE_2_CFG_0
+#define PDP_D_POOLING_PADDING_VALUE_2_CFG_0 (_MK_ADDR_CONST(0xd048))
+#define PDP_D_POOLING_PADDING_VALUE_2_CFG_0_SECURE (0x0)
+#define PDP_D_POOLING_PADDING_VALUE_2_CFG_0_DUAL (0x0)
+#define PDP_D_POOLING_PADDING_VALUE_2_CFG_0_SCR (0)
+#define PDP_D_POOLING_PADDING_VALUE_2_CFG_0_WORD_COUNT (0x1)
+#define PDP_D_POOLING_PADDING_VALUE_2_CFG_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_VALUE_2_CFG_0_RESET_MASK (_MK_MASK_CONST(0x7ffff))
+#define PDP_D_POOLING_PADDING_VALUE_2_CFG_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_VALUE_2_CFG_0_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_VALUE_2_CFG_0_READ_MASK (_MK_MASK_CONST(0x7ffff))
+#define PDP_D_POOLING_PADDING_VALUE_2_CFG_0_WRITE_MASK (_MK_MASK_CONST(0x7ffff))
+#define PDP_D_POOLING_PADDING_VALUE_2_CFG_0_PAD_VALUE_2X_SHIFT \
+	(_MK_SHIFT_CONST(0))
+#define PDP_D_POOLING_PADDING_VALUE_2_CFG_0_PAD_VALUE_2X_FIELD \
+	(_MK_FIELD_CONST(                                      \
+		0x7ffff,                                       \
+		PDP_D_POOLING_PADDING_VALUE_2_CFG_0_PAD_VALUE_2X_SHIFT))
+#define PDP_D_POOLING_PADDING_VALUE_2_CFG_0_PAD_VALUE_2X_RANGE (18 : 0)
+#define PDP_D_POOLING_PADDING_VALUE_2_CFG_0_PAD_VALUE_2X_WOFFSET (0x0)
+#define PDP_D_POOLING_PADDING_VALUE_2_CFG_0_PAD_VALUE_2X_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_VALUE_2_CFG_0_PAD_VALUE_2X_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffff))
+#define PDP_D_POOLING_PADDING_VALUE_2_CFG_0_PAD_VALUE_2X_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_VALUE_2_CFG_0_PAD_VALUE_2X_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_VALUE_2_CFG_0_PAD_VALUE_2X_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_VALUE_2_CFG_0_PAD_VALUE_2X_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register PDP_D_POOLING_PADDING_VALUE_3_CFG_0
+#define PDP_D_POOLING_PADDING_VALUE_3_CFG_0 (_MK_ADDR_CONST(0xd04c))
+#define PDP_D_POOLING_PADDING_VALUE_3_CFG_0_SECURE (0x0)
+#define PDP_D_POOLING_PADDING_VALUE_3_CFG_0_DUAL (0x0)
+#define PDP_D_POOLING_PADDING_VALUE_3_CFG_0_SCR (0)
+#define PDP_D_POOLING_PADDING_VALUE_3_CFG_0_WORD_COUNT (0x1)
+#define PDP_D_POOLING_PADDING_VALUE_3_CFG_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_VALUE_3_CFG_0_RESET_MASK (_MK_MASK_CONST(0x7ffff))
+#define PDP_D_POOLING_PADDING_VALUE_3_CFG_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_VALUE_3_CFG_0_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_VALUE_3_CFG_0_READ_MASK (_MK_MASK_CONST(0x7ffff))
+#define PDP_D_POOLING_PADDING_VALUE_3_CFG_0_WRITE_MASK (_MK_MASK_CONST(0x7ffff))
+#define PDP_D_POOLING_PADDING_VALUE_3_CFG_0_PAD_VALUE_3X_SHIFT \
+	(_MK_SHIFT_CONST(0))
+#define PDP_D_POOLING_PADDING_VALUE_3_CFG_0_PAD_VALUE_3X_FIELD \
+	(_MK_FIELD_CONST(                                      \
+		0x7ffff,                                       \
+		PDP_D_POOLING_PADDING_VALUE_3_CFG_0_PAD_VALUE_3X_SHIFT))
+#define PDP_D_POOLING_PADDING_VALUE_3_CFG_0_PAD_VALUE_3X_RANGE (18 : 0)
+#define PDP_D_POOLING_PADDING_VALUE_3_CFG_0_PAD_VALUE_3X_WOFFSET (0x0)
+#define PDP_D_POOLING_PADDING_VALUE_3_CFG_0_PAD_VALUE_3X_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_VALUE_3_CFG_0_PAD_VALUE_3X_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffff))
+#define PDP_D_POOLING_PADDING_VALUE_3_CFG_0_PAD_VALUE_3X_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_VALUE_3_CFG_0_PAD_VALUE_3X_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_VALUE_3_CFG_0_PAD_VALUE_3X_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_VALUE_3_CFG_0_PAD_VALUE_3X_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register PDP_D_POOLING_PADDING_VALUE_4_CFG_0
+#define PDP_D_POOLING_PADDING_VALUE_4_CFG_0 (_MK_ADDR_CONST(0xd050))
+#define PDP_D_POOLING_PADDING_VALUE_4_CFG_0_SECURE (0x0)
+#define PDP_D_POOLING_PADDING_VALUE_4_CFG_0_DUAL (0x0)
+#define PDP_D_POOLING_PADDING_VALUE_4_CFG_0_SCR (0)
+#define PDP_D_POOLING_PADDING_VALUE_4_CFG_0_WORD_COUNT (0x1)
+#define PDP_D_POOLING_PADDING_VALUE_4_CFG_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_VALUE_4_CFG_0_RESET_MASK (_MK_MASK_CONST(0x7ffff))
+#define PDP_D_POOLING_PADDING_VALUE_4_CFG_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_VALUE_4_CFG_0_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_VALUE_4_CFG_0_READ_MASK (_MK_MASK_CONST(0x7ffff))
+#define PDP_D_POOLING_PADDING_VALUE_4_CFG_0_WRITE_MASK (_MK_MASK_CONST(0x7ffff))
+#define PDP_D_POOLING_PADDING_VALUE_4_CFG_0_PAD_VALUE_4X_SHIFT \
+	(_MK_SHIFT_CONST(0))
+#define PDP_D_POOLING_PADDING_VALUE_4_CFG_0_PAD_VALUE_4X_FIELD \
+	(_MK_FIELD_CONST(                                      \
+		0x7ffff,                                       \
+		PDP_D_POOLING_PADDING_VALUE_4_CFG_0_PAD_VALUE_4X_SHIFT))
+#define PDP_D_POOLING_PADDING_VALUE_4_CFG_0_PAD_VALUE_4X_RANGE (18 : 0)
+#define PDP_D_POOLING_PADDING_VALUE_4_CFG_0_PAD_VALUE_4X_WOFFSET (0x0)
+#define PDP_D_POOLING_PADDING_VALUE_4_CFG_0_PAD_VALUE_4X_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_VALUE_4_CFG_0_PAD_VALUE_4X_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffff))
+#define PDP_D_POOLING_PADDING_VALUE_4_CFG_0_PAD_VALUE_4X_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_VALUE_4_CFG_0_PAD_VALUE_4X_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_VALUE_4_CFG_0_PAD_VALUE_4X_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_VALUE_4_CFG_0_PAD_VALUE_4X_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register PDP_D_POOLING_PADDING_VALUE_5_CFG_0
+#define PDP_D_POOLING_PADDING_VALUE_5_CFG_0 (_MK_ADDR_CONST(0xd054))
+#define PDP_D_POOLING_PADDING_VALUE_5_CFG_0_SECURE (0x0)
+#define PDP_D_POOLING_PADDING_VALUE_5_CFG_0_DUAL (0x0)
+#define PDP_D_POOLING_PADDING_VALUE_5_CFG_0_SCR (0)
+#define PDP_D_POOLING_PADDING_VALUE_5_CFG_0_WORD_COUNT (0x1)
+#define PDP_D_POOLING_PADDING_VALUE_5_CFG_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_VALUE_5_CFG_0_RESET_MASK (_MK_MASK_CONST(0x7ffff))
+#define PDP_D_POOLING_PADDING_VALUE_5_CFG_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_VALUE_5_CFG_0_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_VALUE_5_CFG_0_READ_MASK (_MK_MASK_CONST(0x7ffff))
+#define PDP_D_POOLING_PADDING_VALUE_5_CFG_0_WRITE_MASK (_MK_MASK_CONST(0x7ffff))
+#define PDP_D_POOLING_PADDING_VALUE_5_CFG_0_PAD_VALUE_5X_SHIFT \
+	(_MK_SHIFT_CONST(0))
+#define PDP_D_POOLING_PADDING_VALUE_5_CFG_0_PAD_VALUE_5X_FIELD \
+	(_MK_FIELD_CONST(                                      \
+		0x7ffff,                                       \
+		PDP_D_POOLING_PADDING_VALUE_5_CFG_0_PAD_VALUE_5X_SHIFT))
+#define PDP_D_POOLING_PADDING_VALUE_5_CFG_0_PAD_VALUE_5X_RANGE (18 : 0)
+#define PDP_D_POOLING_PADDING_VALUE_5_CFG_0_PAD_VALUE_5X_WOFFSET (0x0)
+#define PDP_D_POOLING_PADDING_VALUE_5_CFG_0_PAD_VALUE_5X_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_VALUE_5_CFG_0_PAD_VALUE_5X_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffff))
+#define PDP_D_POOLING_PADDING_VALUE_5_CFG_0_PAD_VALUE_5X_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_VALUE_5_CFG_0_PAD_VALUE_5X_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_VALUE_5_CFG_0_PAD_VALUE_5X_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_VALUE_5_CFG_0_PAD_VALUE_5X_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register PDP_D_POOLING_PADDING_VALUE_6_CFG_0
+#define PDP_D_POOLING_PADDING_VALUE_6_CFG_0 (_MK_ADDR_CONST(0xd058))
+#define PDP_D_POOLING_PADDING_VALUE_6_CFG_0_SECURE (0x0)
+#define PDP_D_POOLING_PADDING_VALUE_6_CFG_0_DUAL (0x0)
+#define PDP_D_POOLING_PADDING_VALUE_6_CFG_0_SCR (0)
+#define PDP_D_POOLING_PADDING_VALUE_6_CFG_0_WORD_COUNT (0x1)
+#define PDP_D_POOLING_PADDING_VALUE_6_CFG_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_VALUE_6_CFG_0_RESET_MASK (_MK_MASK_CONST(0x7ffff))
+#define PDP_D_POOLING_PADDING_VALUE_6_CFG_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_VALUE_6_CFG_0_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_VALUE_6_CFG_0_READ_MASK (_MK_MASK_CONST(0x7ffff))
+#define PDP_D_POOLING_PADDING_VALUE_6_CFG_0_WRITE_MASK (_MK_MASK_CONST(0x7ffff))
+#define PDP_D_POOLING_PADDING_VALUE_6_CFG_0_PAD_VALUE_6X_SHIFT \
+	(_MK_SHIFT_CONST(0))
+#define PDP_D_POOLING_PADDING_VALUE_6_CFG_0_PAD_VALUE_6X_FIELD \
+	(_MK_FIELD_CONST(                                      \
+		0x7ffff,                                       \
+		PDP_D_POOLING_PADDING_VALUE_6_CFG_0_PAD_VALUE_6X_SHIFT))
+#define PDP_D_POOLING_PADDING_VALUE_6_CFG_0_PAD_VALUE_6X_RANGE (18 : 0)
+#define PDP_D_POOLING_PADDING_VALUE_6_CFG_0_PAD_VALUE_6X_WOFFSET (0x0)
+#define PDP_D_POOLING_PADDING_VALUE_6_CFG_0_PAD_VALUE_6X_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_VALUE_6_CFG_0_PAD_VALUE_6X_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffff))
+#define PDP_D_POOLING_PADDING_VALUE_6_CFG_0_PAD_VALUE_6X_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_VALUE_6_CFG_0_PAD_VALUE_6X_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_VALUE_6_CFG_0_PAD_VALUE_6X_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_VALUE_6_CFG_0_PAD_VALUE_6X_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register PDP_D_POOLING_PADDING_VALUE_7_CFG_0
+#define PDP_D_POOLING_PADDING_VALUE_7_CFG_0 (_MK_ADDR_CONST(0xd05c))
+#define PDP_D_POOLING_PADDING_VALUE_7_CFG_0_SECURE (0x0)
+#define PDP_D_POOLING_PADDING_VALUE_7_CFG_0_DUAL (0x0)
+#define PDP_D_POOLING_PADDING_VALUE_7_CFG_0_SCR (0)
+#define PDP_D_POOLING_PADDING_VALUE_7_CFG_0_WORD_COUNT (0x1)
+#define PDP_D_POOLING_PADDING_VALUE_7_CFG_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_VALUE_7_CFG_0_RESET_MASK (_MK_MASK_CONST(0x7ffff))
+#define PDP_D_POOLING_PADDING_VALUE_7_CFG_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_VALUE_7_CFG_0_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_VALUE_7_CFG_0_READ_MASK (_MK_MASK_CONST(0x7ffff))
+#define PDP_D_POOLING_PADDING_VALUE_7_CFG_0_WRITE_MASK (_MK_MASK_CONST(0x7ffff))
+#define PDP_D_POOLING_PADDING_VALUE_7_CFG_0_PAD_VALUE_7X_SHIFT \
+	(_MK_SHIFT_CONST(0))
+#define PDP_D_POOLING_PADDING_VALUE_7_CFG_0_PAD_VALUE_7X_FIELD \
+	(_MK_FIELD_CONST(                                      \
+		0x7ffff,                                       \
+		PDP_D_POOLING_PADDING_VALUE_7_CFG_0_PAD_VALUE_7X_SHIFT))
+#define PDP_D_POOLING_PADDING_VALUE_7_CFG_0_PAD_VALUE_7X_RANGE (18 : 0)
+#define PDP_D_POOLING_PADDING_VALUE_7_CFG_0_PAD_VALUE_7X_WOFFSET (0x0)
+#define PDP_D_POOLING_PADDING_VALUE_7_CFG_0_PAD_VALUE_7X_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_VALUE_7_CFG_0_PAD_VALUE_7X_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffff))
+#define PDP_D_POOLING_PADDING_VALUE_7_CFG_0_PAD_VALUE_7X_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_VALUE_7_CFG_0_PAD_VALUE_7X_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_VALUE_7_CFG_0_PAD_VALUE_7X_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_POOLING_PADDING_VALUE_7_CFG_0_PAD_VALUE_7X_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register PDP_D_SRC_BASE_ADDR_LOW_0
+#define PDP_D_SRC_BASE_ADDR_LOW_0 (_MK_ADDR_CONST(0xd060))
+#define PDP_D_SRC_BASE_ADDR_LOW_0_SECURE (0x0)
+#define PDP_D_SRC_BASE_ADDR_LOW_0_DUAL (0x0)
+#define PDP_D_SRC_BASE_ADDR_LOW_0_SCR (0)
+#define PDP_D_SRC_BASE_ADDR_LOW_0_WORD_COUNT (0x1)
+#define PDP_D_SRC_BASE_ADDR_LOW_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_SRC_BASE_ADDR_LOW_0_RESET_MASK (_MK_MASK_CONST(0xffffffe0))
+#define PDP_D_SRC_BASE_ADDR_LOW_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_SRC_BASE_ADDR_LOW_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_D_SRC_BASE_ADDR_LOW_0_READ_MASK (_MK_MASK_CONST(0xffffffe0))
+#define PDP_D_SRC_BASE_ADDR_LOW_0_WRITE_MASK (_MK_MASK_CONST(0xffffffe0))
+#define PDP_D_SRC_BASE_ADDR_LOW_0_SRC_BASE_ADDR_LOW_SHIFT (_MK_SHIFT_CONST(5))
+#define PDP_D_SRC_BASE_ADDR_LOW_0_SRC_BASE_ADDR_LOW_FIELD \
+	(_MK_FIELD_CONST(0x7ffffff,                       \
+			 PDP_D_SRC_BASE_ADDR_LOW_0_SRC_BASE_ADDR_LOW_SHIFT))
+#define PDP_D_SRC_BASE_ADDR_LOW_0_SRC_BASE_ADDR_LOW_RANGE (31 : 5)
+#define PDP_D_SRC_BASE_ADDR_LOW_0_SRC_BASE_ADDR_LOW_WOFFSET (0x0)
+#define PDP_D_SRC_BASE_ADDR_LOW_0_SRC_BASE_ADDR_LOW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_SRC_BASE_ADDR_LOW_0_SRC_BASE_ADDR_LOW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffffff))
+#define PDP_D_SRC_BASE_ADDR_LOW_0_SRC_BASE_ADDR_LOW_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_SRC_BASE_ADDR_LOW_0_SRC_BASE_ADDR_LOW_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_SRC_BASE_ADDR_LOW_0_SRC_BASE_ADDR_LOW_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_SRC_BASE_ADDR_LOW_0_SRC_BASE_ADDR_LOW_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register PDP_D_SRC_BASE_ADDR_HIGH_0
+#define PDP_D_SRC_BASE_ADDR_HIGH_0 (_MK_ADDR_CONST(0xd064))
+#define PDP_D_SRC_BASE_ADDR_HIGH_0_SECURE (0x0)
+#define PDP_D_SRC_BASE_ADDR_HIGH_0_DUAL (0x0)
+#define PDP_D_SRC_BASE_ADDR_HIGH_0_SCR (0)
+#define PDP_D_SRC_BASE_ADDR_HIGH_0_WORD_COUNT (0x1)
+#define PDP_D_SRC_BASE_ADDR_HIGH_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_SRC_BASE_ADDR_HIGH_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define PDP_D_SRC_BASE_ADDR_HIGH_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_SRC_BASE_ADDR_HIGH_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_D_SRC_BASE_ADDR_HIGH_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define PDP_D_SRC_BASE_ADDR_HIGH_0_WRITE_MASK (_MK_MASK_CONST(0xffffffff))
+#define PDP_D_SRC_BASE_ADDR_HIGH_0_SRC_BASE_ADDR_HIGH_SHIFT (_MK_SHIFT_CONST(0))
+#define PDP_D_SRC_BASE_ADDR_HIGH_0_SRC_BASE_ADDR_HIGH_FIELD \
+	(_MK_FIELD_CONST(0xffffffff,                        \
+			 PDP_D_SRC_BASE_ADDR_HIGH_0_SRC_BASE_ADDR_HIGH_SHIFT))
+#define PDP_D_SRC_BASE_ADDR_HIGH_0_SRC_BASE_ADDR_HIGH_RANGE (31 : 0)
+#define PDP_D_SRC_BASE_ADDR_HIGH_0_SRC_BASE_ADDR_HIGH_WOFFSET (0x0)
+#define PDP_D_SRC_BASE_ADDR_HIGH_0_SRC_BASE_ADDR_HIGH_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_SRC_BASE_ADDR_HIGH_0_SRC_BASE_ADDR_HIGH_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define PDP_D_SRC_BASE_ADDR_HIGH_0_SRC_BASE_ADDR_HIGH_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_SRC_BASE_ADDR_HIGH_0_SRC_BASE_ADDR_HIGH_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_SRC_BASE_ADDR_HIGH_0_SRC_BASE_ADDR_HIGH_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_SRC_BASE_ADDR_HIGH_0_SRC_BASE_ADDR_HIGH_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register PDP_D_SRC_LINE_STRIDE_0
+#define PDP_D_SRC_LINE_STRIDE_0 (_MK_ADDR_CONST(0xd068))
+#define PDP_D_SRC_LINE_STRIDE_0_SECURE (0x0)
+#define PDP_D_SRC_LINE_STRIDE_0_DUAL (0x0)
+#define PDP_D_SRC_LINE_STRIDE_0_SCR (0)
+#define PDP_D_SRC_LINE_STRIDE_0_WORD_COUNT (0x1)
+#define PDP_D_SRC_LINE_STRIDE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_SRC_LINE_STRIDE_0_RESET_MASK (_MK_MASK_CONST(0xffffffe0))
+#define PDP_D_SRC_LINE_STRIDE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_SRC_LINE_STRIDE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_D_SRC_LINE_STRIDE_0_READ_MASK (_MK_MASK_CONST(0xffffffe0))
+#define PDP_D_SRC_LINE_STRIDE_0_WRITE_MASK (_MK_MASK_CONST(0xffffffe0))
+#define PDP_D_SRC_LINE_STRIDE_0_SRC_LINE_STRIDE_SHIFT (_MK_SHIFT_CONST(5))
+#define PDP_D_SRC_LINE_STRIDE_0_SRC_LINE_STRIDE_FIELD \
+	(_MK_FIELD_CONST(0x7ffffff,                   \
+			 PDP_D_SRC_LINE_STRIDE_0_SRC_LINE_STRIDE_SHIFT))
+#define PDP_D_SRC_LINE_STRIDE_0_SRC_LINE_STRIDE_RANGE (31 : 5)
+#define PDP_D_SRC_LINE_STRIDE_0_SRC_LINE_STRIDE_WOFFSET (0x0)
+#define PDP_D_SRC_LINE_STRIDE_0_SRC_LINE_STRIDE_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_D_SRC_LINE_STRIDE_0_SRC_LINE_STRIDE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffffff))
+#define PDP_D_SRC_LINE_STRIDE_0_SRC_LINE_STRIDE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_D_SRC_LINE_STRIDE_0_SRC_LINE_STRIDE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_SRC_LINE_STRIDE_0_SRC_LINE_STRIDE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_SRC_LINE_STRIDE_0_SRC_LINE_STRIDE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register PDP_D_SRC_SURFACE_STRIDE_0
+#define PDP_D_SRC_SURFACE_STRIDE_0 (_MK_ADDR_CONST(0xd06c))
+#define PDP_D_SRC_SURFACE_STRIDE_0_SECURE (0x0)
+#define PDP_D_SRC_SURFACE_STRIDE_0_DUAL (0x0)
+#define PDP_D_SRC_SURFACE_STRIDE_0_SCR (0)
+#define PDP_D_SRC_SURFACE_STRIDE_0_WORD_COUNT (0x1)
+#define PDP_D_SRC_SURFACE_STRIDE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_SRC_SURFACE_STRIDE_0_RESET_MASK (_MK_MASK_CONST(0xffffffe0))
+#define PDP_D_SRC_SURFACE_STRIDE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_SRC_SURFACE_STRIDE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_D_SRC_SURFACE_STRIDE_0_READ_MASK (_MK_MASK_CONST(0xffffffe0))
+#define PDP_D_SRC_SURFACE_STRIDE_0_WRITE_MASK (_MK_MASK_CONST(0xffffffe0))
+#define PDP_D_SRC_SURFACE_STRIDE_0_SRC_SURFACE_STRIDE_SHIFT (_MK_SHIFT_CONST(5))
+#define PDP_D_SRC_SURFACE_STRIDE_0_SRC_SURFACE_STRIDE_FIELD \
+	(_MK_FIELD_CONST(0x7ffffff,                         \
+			 PDP_D_SRC_SURFACE_STRIDE_0_SRC_SURFACE_STRIDE_SHIFT))
+#define PDP_D_SRC_SURFACE_STRIDE_0_SRC_SURFACE_STRIDE_RANGE (31 : 5)
+#define PDP_D_SRC_SURFACE_STRIDE_0_SRC_SURFACE_STRIDE_WOFFSET (0x0)
+#define PDP_D_SRC_SURFACE_STRIDE_0_SRC_SURFACE_STRIDE_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_SRC_SURFACE_STRIDE_0_SRC_SURFACE_STRIDE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffffff))
+#define PDP_D_SRC_SURFACE_STRIDE_0_SRC_SURFACE_STRIDE_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_SRC_SURFACE_STRIDE_0_SRC_SURFACE_STRIDE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_SRC_SURFACE_STRIDE_0_SRC_SURFACE_STRIDE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_SRC_SURFACE_STRIDE_0_SRC_SURFACE_STRIDE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register PDP_D_DST_BASE_ADDR_LOW_0
+#define PDP_D_DST_BASE_ADDR_LOW_0 (_MK_ADDR_CONST(0xd070))
+#define PDP_D_DST_BASE_ADDR_LOW_0_SECURE (0x0)
+#define PDP_D_DST_BASE_ADDR_LOW_0_DUAL (0x0)
+#define PDP_D_DST_BASE_ADDR_LOW_0_SCR (0)
+#define PDP_D_DST_BASE_ADDR_LOW_0_WORD_COUNT (0x1)
+#define PDP_D_DST_BASE_ADDR_LOW_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_DST_BASE_ADDR_LOW_0_RESET_MASK (_MK_MASK_CONST(0xffffffe0))
+#define PDP_D_DST_BASE_ADDR_LOW_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_DST_BASE_ADDR_LOW_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_D_DST_BASE_ADDR_LOW_0_READ_MASK (_MK_MASK_CONST(0xffffffe0))
+#define PDP_D_DST_BASE_ADDR_LOW_0_WRITE_MASK (_MK_MASK_CONST(0xffffffe0))
+#define PDP_D_DST_BASE_ADDR_LOW_0_DST_BASE_ADDR_LOW_SHIFT (_MK_SHIFT_CONST(5))
+#define PDP_D_DST_BASE_ADDR_LOW_0_DST_BASE_ADDR_LOW_FIELD \
+	(_MK_FIELD_CONST(0x7ffffff,                       \
+			 PDP_D_DST_BASE_ADDR_LOW_0_DST_BASE_ADDR_LOW_SHIFT))
+#define PDP_D_DST_BASE_ADDR_LOW_0_DST_BASE_ADDR_LOW_RANGE (31 : 5)
+#define PDP_D_DST_BASE_ADDR_LOW_0_DST_BASE_ADDR_LOW_WOFFSET (0x0)
+#define PDP_D_DST_BASE_ADDR_LOW_0_DST_BASE_ADDR_LOW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_DST_BASE_ADDR_LOW_0_DST_BASE_ADDR_LOW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffffff))
+#define PDP_D_DST_BASE_ADDR_LOW_0_DST_BASE_ADDR_LOW_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_DST_BASE_ADDR_LOW_0_DST_BASE_ADDR_LOW_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_DST_BASE_ADDR_LOW_0_DST_BASE_ADDR_LOW_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_DST_BASE_ADDR_LOW_0_DST_BASE_ADDR_LOW_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register PDP_D_DST_BASE_ADDR_HIGH_0
+#define PDP_D_DST_BASE_ADDR_HIGH_0 (_MK_ADDR_CONST(0xd074))
+#define PDP_D_DST_BASE_ADDR_HIGH_0_SECURE (0x0)
+#define PDP_D_DST_BASE_ADDR_HIGH_0_DUAL (0x0)
+#define PDP_D_DST_BASE_ADDR_HIGH_0_SCR (0)
+#define PDP_D_DST_BASE_ADDR_HIGH_0_WORD_COUNT (0x1)
+#define PDP_D_DST_BASE_ADDR_HIGH_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_DST_BASE_ADDR_HIGH_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define PDP_D_DST_BASE_ADDR_HIGH_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_DST_BASE_ADDR_HIGH_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_D_DST_BASE_ADDR_HIGH_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define PDP_D_DST_BASE_ADDR_HIGH_0_WRITE_MASK (_MK_MASK_CONST(0xffffffff))
+#define PDP_D_DST_BASE_ADDR_HIGH_0_DST_BASE_ADDR_HIGH_SHIFT (_MK_SHIFT_CONST(0))
+#define PDP_D_DST_BASE_ADDR_HIGH_0_DST_BASE_ADDR_HIGH_FIELD \
+	(_MK_FIELD_CONST(0xffffffff,                        \
+			 PDP_D_DST_BASE_ADDR_HIGH_0_DST_BASE_ADDR_HIGH_SHIFT))
+#define PDP_D_DST_BASE_ADDR_HIGH_0_DST_BASE_ADDR_HIGH_RANGE (31 : 0)
+#define PDP_D_DST_BASE_ADDR_HIGH_0_DST_BASE_ADDR_HIGH_WOFFSET (0x0)
+#define PDP_D_DST_BASE_ADDR_HIGH_0_DST_BASE_ADDR_HIGH_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_DST_BASE_ADDR_HIGH_0_DST_BASE_ADDR_HIGH_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define PDP_D_DST_BASE_ADDR_HIGH_0_DST_BASE_ADDR_HIGH_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_DST_BASE_ADDR_HIGH_0_DST_BASE_ADDR_HIGH_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_DST_BASE_ADDR_HIGH_0_DST_BASE_ADDR_HIGH_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_DST_BASE_ADDR_HIGH_0_DST_BASE_ADDR_HIGH_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register PDP_D_DST_LINE_STRIDE_0
+#define PDP_D_DST_LINE_STRIDE_0 (_MK_ADDR_CONST(0xd078))
+#define PDP_D_DST_LINE_STRIDE_0_SECURE (0x0)
+#define PDP_D_DST_LINE_STRIDE_0_DUAL (0x0)
+#define PDP_D_DST_LINE_STRIDE_0_SCR (0)
+#define PDP_D_DST_LINE_STRIDE_0_WORD_COUNT (0x1)
+#define PDP_D_DST_LINE_STRIDE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_DST_LINE_STRIDE_0_RESET_MASK (_MK_MASK_CONST(0xffffffe0))
+#define PDP_D_DST_LINE_STRIDE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_DST_LINE_STRIDE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_D_DST_LINE_STRIDE_0_READ_MASK (_MK_MASK_CONST(0xffffffe0))
+#define PDP_D_DST_LINE_STRIDE_0_WRITE_MASK (_MK_MASK_CONST(0xffffffe0))
+#define PDP_D_DST_LINE_STRIDE_0_DST_LINE_STRIDE_SHIFT (_MK_SHIFT_CONST(5))
+#define PDP_D_DST_LINE_STRIDE_0_DST_LINE_STRIDE_FIELD \
+	(_MK_FIELD_CONST(0x7ffffff,                   \
+			 PDP_D_DST_LINE_STRIDE_0_DST_LINE_STRIDE_SHIFT))
+#define PDP_D_DST_LINE_STRIDE_0_DST_LINE_STRIDE_RANGE (31 : 5)
+#define PDP_D_DST_LINE_STRIDE_0_DST_LINE_STRIDE_WOFFSET (0x0)
+#define PDP_D_DST_LINE_STRIDE_0_DST_LINE_STRIDE_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_D_DST_LINE_STRIDE_0_DST_LINE_STRIDE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffffff))
+#define PDP_D_DST_LINE_STRIDE_0_DST_LINE_STRIDE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_D_DST_LINE_STRIDE_0_DST_LINE_STRIDE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_DST_LINE_STRIDE_0_DST_LINE_STRIDE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_DST_LINE_STRIDE_0_DST_LINE_STRIDE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register PDP_D_DST_SURFACE_STRIDE_0
+#define PDP_D_DST_SURFACE_STRIDE_0 (_MK_ADDR_CONST(0xd07c))
+#define PDP_D_DST_SURFACE_STRIDE_0_SECURE (0x0)
+#define PDP_D_DST_SURFACE_STRIDE_0_DUAL (0x0)
+#define PDP_D_DST_SURFACE_STRIDE_0_SCR (0)
+#define PDP_D_DST_SURFACE_STRIDE_0_WORD_COUNT (0x1)
+#define PDP_D_DST_SURFACE_STRIDE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_DST_SURFACE_STRIDE_0_RESET_MASK (_MK_MASK_CONST(0xffffffe0))
+#define PDP_D_DST_SURFACE_STRIDE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_DST_SURFACE_STRIDE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_D_DST_SURFACE_STRIDE_0_READ_MASK (_MK_MASK_CONST(0xffffffe0))
+#define PDP_D_DST_SURFACE_STRIDE_0_WRITE_MASK (_MK_MASK_CONST(0xffffffe0))
+#define PDP_D_DST_SURFACE_STRIDE_0_DST_SURFACE_STRIDE_SHIFT (_MK_SHIFT_CONST(5))
+#define PDP_D_DST_SURFACE_STRIDE_0_DST_SURFACE_STRIDE_FIELD \
+	(_MK_FIELD_CONST(0x7ffffff,                         \
+			 PDP_D_DST_SURFACE_STRIDE_0_DST_SURFACE_STRIDE_SHIFT))
+#define PDP_D_DST_SURFACE_STRIDE_0_DST_SURFACE_STRIDE_RANGE (31 : 5)
+#define PDP_D_DST_SURFACE_STRIDE_0_DST_SURFACE_STRIDE_WOFFSET (0x0)
+#define PDP_D_DST_SURFACE_STRIDE_0_DST_SURFACE_STRIDE_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_DST_SURFACE_STRIDE_0_DST_SURFACE_STRIDE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffffff))
+#define PDP_D_DST_SURFACE_STRIDE_0_DST_SURFACE_STRIDE_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_DST_SURFACE_STRIDE_0_DST_SURFACE_STRIDE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_DST_SURFACE_STRIDE_0_DST_SURFACE_STRIDE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_DST_SURFACE_STRIDE_0_DST_SURFACE_STRIDE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register PDP_D_DST_RAM_CFG_0
+#define PDP_D_DST_RAM_CFG_0 (_MK_ADDR_CONST(0xd080))
+#define PDP_D_DST_RAM_CFG_0_SECURE (0x0)
+#define PDP_D_DST_RAM_CFG_0_DUAL (0x0)
+#define PDP_D_DST_RAM_CFG_0_SCR (0)
+#define PDP_D_DST_RAM_CFG_0_WORD_COUNT (0x1)
+#define PDP_D_DST_RAM_CFG_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_DST_RAM_CFG_0_RESET_MASK (_MK_MASK_CONST(0x1))
+#define PDP_D_DST_RAM_CFG_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_DST_RAM_CFG_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_D_DST_RAM_CFG_0_READ_MASK (_MK_MASK_CONST(0x1))
+#define PDP_D_DST_RAM_CFG_0_WRITE_MASK (_MK_MASK_CONST(0x1))
+#define PDP_D_DST_RAM_CFG_0_DST_RAM_TYPE_SHIFT (_MK_SHIFT_CONST(0))
+#define PDP_D_DST_RAM_CFG_0_DST_RAM_TYPE_FIELD \
+	(_MK_FIELD_CONST(0x1, PDP_D_DST_RAM_CFG_0_DST_RAM_TYPE_SHIFT))
+#define PDP_D_DST_RAM_CFG_0_DST_RAM_TYPE_RANGE (0 : 0)
+#define PDP_D_DST_RAM_CFG_0_DST_RAM_TYPE_WOFFSET (0x0)
+#define PDP_D_DST_RAM_CFG_0_DST_RAM_TYPE_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_D_DST_RAM_CFG_0_DST_RAM_TYPE_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define PDP_D_DST_RAM_CFG_0_DST_RAM_TYPE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_D_DST_RAM_CFG_0_DST_RAM_TYPE_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_D_DST_RAM_CFG_0_DST_RAM_TYPE_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define PDP_D_DST_RAM_CFG_0_DST_RAM_TYPE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define PDP_D_DST_RAM_CFG_0_DST_RAM_TYPE_CV (_MK_ENUM_CONST(0))
+#define PDP_D_DST_RAM_CFG_0_DST_RAM_TYPE_MC (_MK_ENUM_CONST(1))
+
+// Register PDP_D_DATA_FORMAT_0
+#define PDP_D_DATA_FORMAT_0 (_MK_ADDR_CONST(0xd084))
+#define PDP_D_DATA_FORMAT_0_SECURE (0x0)
+#define PDP_D_DATA_FORMAT_0_DUAL (0x0)
+#define PDP_D_DATA_FORMAT_0_SCR (0)
+#define PDP_D_DATA_FORMAT_0_WORD_COUNT (0x1)
+#define PDP_D_DATA_FORMAT_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_DATA_FORMAT_0_RESET_MASK (_MK_MASK_CONST(0x3))
+#define PDP_D_DATA_FORMAT_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_DATA_FORMAT_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_D_DATA_FORMAT_0_READ_MASK (_MK_MASK_CONST(0x3))
+#define PDP_D_DATA_FORMAT_0_WRITE_MASK (_MK_MASK_CONST(0x3))
+#define PDP_D_DATA_FORMAT_0_INPUT_DATA_SHIFT (_MK_SHIFT_CONST(0))
+#define PDP_D_DATA_FORMAT_0_INPUT_DATA_FIELD \
+	(_MK_FIELD_CONST(0x3, PDP_D_DATA_FORMAT_0_INPUT_DATA_SHIFT))
+#define PDP_D_DATA_FORMAT_0_INPUT_DATA_RANGE (1 : 0)
+#define PDP_D_DATA_FORMAT_0_INPUT_DATA_WOFFSET (0x0)
+#define PDP_D_DATA_FORMAT_0_INPUT_DATA_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_D_DATA_FORMAT_0_INPUT_DATA_DEFAULT_MASK (_MK_MASK_CONST(0x3))
+#define PDP_D_DATA_FORMAT_0_INPUT_DATA_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_D_DATA_FORMAT_0_INPUT_DATA_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_D_DATA_FORMAT_0_INPUT_DATA_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define PDP_D_DATA_FORMAT_0_INPUT_DATA_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define PDP_D_DATA_FORMAT_0_INPUT_DATA_INT8 (_MK_ENUM_CONST(0))
+#define PDP_D_DATA_FORMAT_0_INPUT_DATA_INT16 (_MK_ENUM_CONST(1))
+#define PDP_D_DATA_FORMAT_0_INPUT_DATA_FP16 (_MK_ENUM_CONST(2))
+
+// Register PDP_D_INF_INPUT_NUM_0
+#define PDP_D_INF_INPUT_NUM_0 (_MK_ADDR_CONST(0xd088))
+#define PDP_D_INF_INPUT_NUM_0_SECURE (0x0)
+#define PDP_D_INF_INPUT_NUM_0_DUAL (0x0)
+#define PDP_D_INF_INPUT_NUM_0_SCR (0)
+#define PDP_D_INF_INPUT_NUM_0_WORD_COUNT (0x1)
+#define PDP_D_INF_INPUT_NUM_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_INF_INPUT_NUM_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define PDP_D_INF_INPUT_NUM_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_INF_INPUT_NUM_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_D_INF_INPUT_NUM_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define PDP_D_INF_INPUT_NUM_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define PDP_D_INF_INPUT_NUM_0_INF_INPUT_NUM_SHIFT (_MK_SHIFT_CONST(0))
+#define PDP_D_INF_INPUT_NUM_0_INF_INPUT_NUM_FIELD \
+	(_MK_FIELD_CONST(0xffffffff, PDP_D_INF_INPUT_NUM_0_INF_INPUT_NUM_SHIFT))
+#define PDP_D_INF_INPUT_NUM_0_INF_INPUT_NUM_RANGE (31 : 0)
+#define PDP_D_INF_INPUT_NUM_0_INF_INPUT_NUM_WOFFSET (0x0)
+#define PDP_D_INF_INPUT_NUM_0_INF_INPUT_NUM_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_D_INF_INPUT_NUM_0_INF_INPUT_NUM_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define PDP_D_INF_INPUT_NUM_0_INF_INPUT_NUM_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_D_INF_INPUT_NUM_0_INF_INPUT_NUM_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_INF_INPUT_NUM_0_INF_INPUT_NUM_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_INF_INPUT_NUM_0_INF_INPUT_NUM_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register PDP_D_NAN_INPUT_NUM_0
+#define PDP_D_NAN_INPUT_NUM_0 (_MK_ADDR_CONST(0xd08c))
+#define PDP_D_NAN_INPUT_NUM_0_SECURE (0x0)
+#define PDP_D_NAN_INPUT_NUM_0_DUAL (0x0)
+#define PDP_D_NAN_INPUT_NUM_0_SCR (0)
+#define PDP_D_NAN_INPUT_NUM_0_WORD_COUNT (0x1)
+#define PDP_D_NAN_INPUT_NUM_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_NAN_INPUT_NUM_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define PDP_D_NAN_INPUT_NUM_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_NAN_INPUT_NUM_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_D_NAN_INPUT_NUM_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define PDP_D_NAN_INPUT_NUM_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define PDP_D_NAN_INPUT_NUM_0_NAN_INPUT_NUM_SHIFT (_MK_SHIFT_CONST(0))
+#define PDP_D_NAN_INPUT_NUM_0_NAN_INPUT_NUM_FIELD \
+	(_MK_FIELD_CONST(0xffffffff, PDP_D_NAN_INPUT_NUM_0_NAN_INPUT_NUM_SHIFT))
+#define PDP_D_NAN_INPUT_NUM_0_NAN_INPUT_NUM_RANGE (31 : 0)
+#define PDP_D_NAN_INPUT_NUM_0_NAN_INPUT_NUM_WOFFSET (0x0)
+#define PDP_D_NAN_INPUT_NUM_0_NAN_INPUT_NUM_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_D_NAN_INPUT_NUM_0_NAN_INPUT_NUM_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define PDP_D_NAN_INPUT_NUM_0_NAN_INPUT_NUM_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_D_NAN_INPUT_NUM_0_NAN_INPUT_NUM_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_NAN_INPUT_NUM_0_NAN_INPUT_NUM_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_NAN_INPUT_NUM_0_NAN_INPUT_NUM_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register PDP_D_NAN_OUTPUT_NUM_0
+#define PDP_D_NAN_OUTPUT_NUM_0 (_MK_ADDR_CONST(0xd090))
+#define PDP_D_NAN_OUTPUT_NUM_0_SECURE (0x0)
+#define PDP_D_NAN_OUTPUT_NUM_0_DUAL (0x0)
+#define PDP_D_NAN_OUTPUT_NUM_0_SCR (0)
+#define PDP_D_NAN_OUTPUT_NUM_0_WORD_COUNT (0x1)
+#define PDP_D_NAN_OUTPUT_NUM_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_NAN_OUTPUT_NUM_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define PDP_D_NAN_OUTPUT_NUM_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_NAN_OUTPUT_NUM_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_D_NAN_OUTPUT_NUM_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define PDP_D_NAN_OUTPUT_NUM_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define PDP_D_NAN_OUTPUT_NUM_0_NAN_OUTPUT_NUM_SHIFT (_MK_SHIFT_CONST(0))
+#define PDP_D_NAN_OUTPUT_NUM_0_NAN_OUTPUT_NUM_FIELD \
+	(_MK_FIELD_CONST(0xffffffff,                \
+			 PDP_D_NAN_OUTPUT_NUM_0_NAN_OUTPUT_NUM_SHIFT))
+#define PDP_D_NAN_OUTPUT_NUM_0_NAN_OUTPUT_NUM_RANGE (31 : 0)
+#define PDP_D_NAN_OUTPUT_NUM_0_NAN_OUTPUT_NUM_WOFFSET (0x0)
+#define PDP_D_NAN_OUTPUT_NUM_0_NAN_OUTPUT_NUM_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_D_NAN_OUTPUT_NUM_0_NAN_OUTPUT_NUM_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define PDP_D_NAN_OUTPUT_NUM_0_NAN_OUTPUT_NUM_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_D_NAN_OUTPUT_NUM_0_NAN_OUTPUT_NUM_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_NAN_OUTPUT_NUM_0_NAN_OUTPUT_NUM_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_NAN_OUTPUT_NUM_0_NAN_OUTPUT_NUM_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register PDP_D_PERF_ENABLE_0
+#define PDP_D_PERF_ENABLE_0 (_MK_ADDR_CONST(0xd094))
+#define PDP_D_PERF_ENABLE_0_SECURE (0x0)
+#define PDP_D_PERF_ENABLE_0_DUAL (0x0)
+#define PDP_D_PERF_ENABLE_0_SCR (0)
+#define PDP_D_PERF_ENABLE_0_WORD_COUNT (0x1)
+#define PDP_D_PERF_ENABLE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_PERF_ENABLE_0_RESET_MASK (_MK_MASK_CONST(0x1))
+#define PDP_D_PERF_ENABLE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_PERF_ENABLE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_D_PERF_ENABLE_0_READ_MASK (_MK_MASK_CONST(0x1))
+#define PDP_D_PERF_ENABLE_0_WRITE_MASK (_MK_MASK_CONST(0x1))
+#define PDP_D_PERF_ENABLE_0_DMA_EN_SHIFT (_MK_SHIFT_CONST(0))
+#define PDP_D_PERF_ENABLE_0_DMA_EN_FIELD \
+	(_MK_FIELD_CONST(0x1, PDP_D_PERF_ENABLE_0_DMA_EN_SHIFT))
+#define PDP_D_PERF_ENABLE_0_DMA_EN_RANGE (0 : 0)
+#define PDP_D_PERF_ENABLE_0_DMA_EN_WOFFSET (0x0)
+#define PDP_D_PERF_ENABLE_0_DMA_EN_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_D_PERF_ENABLE_0_DMA_EN_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define PDP_D_PERF_ENABLE_0_DMA_EN_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_D_PERF_ENABLE_0_DMA_EN_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_D_PERF_ENABLE_0_DMA_EN_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define PDP_D_PERF_ENABLE_0_DMA_EN_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define PDP_D_PERF_ENABLE_0_DMA_EN_INIT_ENUM (DISABLE)
+#define PDP_D_PERF_ENABLE_0_DMA_EN_DISABLE (_MK_ENUM_CONST(0))
+#define PDP_D_PERF_ENABLE_0_DMA_EN_ENABLE (_MK_ENUM_CONST(1))
+
+// Register PDP_D_PERF_WRITE_STALL_0
+#define PDP_D_PERF_WRITE_STALL_0 (_MK_ADDR_CONST(0xd098))
+#define PDP_D_PERF_WRITE_STALL_0_SECURE (0x0)
+#define PDP_D_PERF_WRITE_STALL_0_DUAL (0x0)
+#define PDP_D_PERF_WRITE_STALL_0_SCR (0)
+#define PDP_D_PERF_WRITE_STALL_0_WORD_COUNT (0x1)
+#define PDP_D_PERF_WRITE_STALL_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_PERF_WRITE_STALL_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define PDP_D_PERF_WRITE_STALL_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_PERF_WRITE_STALL_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_D_PERF_WRITE_STALL_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define PDP_D_PERF_WRITE_STALL_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define PDP_D_PERF_WRITE_STALL_0_PERF_WRITE_STALL_SHIFT (_MK_SHIFT_CONST(0))
+#define PDP_D_PERF_WRITE_STALL_0_PERF_WRITE_STALL_FIELD \
+	(_MK_FIELD_CONST(0xffffffff,                    \
+			 PDP_D_PERF_WRITE_STALL_0_PERF_WRITE_STALL_SHIFT))
+#define PDP_D_PERF_WRITE_STALL_0_PERF_WRITE_STALL_RANGE (31 : 0)
+#define PDP_D_PERF_WRITE_STALL_0_PERF_WRITE_STALL_WOFFSET (0x0)
+#define PDP_D_PERF_WRITE_STALL_0_PERF_WRITE_STALL_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_D_PERF_WRITE_STALL_0_PERF_WRITE_STALL_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define PDP_D_PERF_WRITE_STALL_0_PERF_WRITE_STALL_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_PERF_WRITE_STALL_0_PERF_WRITE_STALL_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_PERF_WRITE_STALL_0_PERF_WRITE_STALL_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define PDP_D_PERF_WRITE_STALL_0_PERF_WRITE_STALL_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register PDP_D_CYA_0
+#define PDP_D_CYA_0 (_MK_ADDR_CONST(0xd09c))
+#define PDP_D_CYA_0_SECURE (0x0)
+#define PDP_D_CYA_0_DUAL (0x0)
+#define PDP_D_CYA_0_SCR (0)
+#define PDP_D_CYA_0_WORD_COUNT (0x1)
+#define PDP_D_CYA_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_CYA_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define PDP_D_CYA_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define PDP_D_CYA_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_D_CYA_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define PDP_D_CYA_0_WRITE_MASK (_MK_MASK_CONST(0xffffffff))
+#define PDP_D_CYA_0_CYA_SHIFT (_MK_SHIFT_CONST(0))
+#define PDP_D_CYA_0_CYA_FIELD \
+	(_MK_FIELD_CONST(0xffffffff, PDP_D_CYA_0_CYA_SHIFT))
+#define PDP_D_CYA_0_CYA_RANGE (31 : 0)
+#define PDP_D_CYA_0_CYA_WOFFSET (0x0)
+#define PDP_D_CYA_0_CYA_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_D_CYA_0_CYA_DEFAULT_MASK (_MK_MASK_CONST(0xffffffff))
+#define PDP_D_CYA_0_CYA_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define PDP_D_CYA_0_CYA_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define PDP_D_CYA_0_CYA_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define PDP_D_CYA_0_CYA_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+// Register CDP_RDMA_S_STATUS_0
+#define CDP_RDMA_S_STATUS_0 (_MK_ADDR_CONST(0xe000))
+#define CDP_RDMA_S_STATUS_0_SECURE (0x0)
+#define CDP_RDMA_S_STATUS_0_DUAL (0x0)
+#define CDP_RDMA_S_STATUS_0_SCR (0)
+#define CDP_RDMA_S_STATUS_0_WORD_COUNT (0x1)
+#define CDP_RDMA_S_STATUS_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_S_STATUS_0_RESET_MASK (_MK_MASK_CONST(0x30003))
+#define CDP_RDMA_S_STATUS_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_S_STATUS_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_S_STATUS_0_READ_MASK (_MK_MASK_CONST(0x30003))
+#define CDP_RDMA_S_STATUS_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_S_STATUS_0_STATUS_0_SHIFT (_MK_SHIFT_CONST(0))
+#define CDP_RDMA_S_STATUS_0_STATUS_0_FIELD \
+	(_MK_FIELD_CONST(0x3, CDP_RDMA_S_STATUS_0_STATUS_0_SHIFT))
+#define CDP_RDMA_S_STATUS_0_STATUS_0_RANGE (1 : 0)
+#define CDP_RDMA_S_STATUS_0_STATUS_0_WOFFSET (0x0)
+#define CDP_RDMA_S_STATUS_0_STATUS_0_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_S_STATUS_0_STATUS_0_DEFAULT_MASK (_MK_MASK_CONST(0x3))
+#define CDP_RDMA_S_STATUS_0_STATUS_0_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_S_STATUS_0_STATUS_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_S_STATUS_0_STATUS_0_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_S_STATUS_0_STATUS_0_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define CDP_RDMA_S_STATUS_0_STATUS_0_INIT_ENUM (IDLE)
+#define CDP_RDMA_S_STATUS_0_STATUS_0_IDLE (_MK_ENUM_CONST(0))
+#define CDP_RDMA_S_STATUS_0_STATUS_0_RUNNING (_MK_ENUM_CONST(1))
+#define CDP_RDMA_S_STATUS_0_STATUS_0_PENDING (_MK_ENUM_CONST(2))
+
+#define CDP_RDMA_S_STATUS_0_STATUS_1_SHIFT (_MK_SHIFT_CONST(16))
+#define CDP_RDMA_S_STATUS_0_STATUS_1_FIELD \
+	(_MK_FIELD_CONST(0x3, CDP_RDMA_S_STATUS_0_STATUS_1_SHIFT))
+#define CDP_RDMA_S_STATUS_0_STATUS_1_RANGE (17 : 16)
+#define CDP_RDMA_S_STATUS_0_STATUS_1_WOFFSET (0x0)
+#define CDP_RDMA_S_STATUS_0_STATUS_1_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_S_STATUS_0_STATUS_1_DEFAULT_MASK (_MK_MASK_CONST(0x3))
+#define CDP_RDMA_S_STATUS_0_STATUS_1_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_S_STATUS_0_STATUS_1_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_S_STATUS_0_STATUS_1_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_S_STATUS_0_STATUS_1_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define CDP_RDMA_S_STATUS_0_STATUS_1_INIT_ENUM (IDLE)
+#define CDP_RDMA_S_STATUS_0_STATUS_1_IDLE (_MK_ENUM_CONST(0))
+#define CDP_RDMA_S_STATUS_0_STATUS_1_RUNNING (_MK_ENUM_CONST(1))
+#define CDP_RDMA_S_STATUS_0_STATUS_1_PENDING (_MK_ENUM_CONST(2))
+
+// Register CDP_RDMA_S_POINTER_0
+#define CDP_RDMA_S_POINTER_0 (_MK_ADDR_CONST(0xe004))
+#define CDP_RDMA_S_POINTER_0_SECURE (0x0)
+#define CDP_RDMA_S_POINTER_0_DUAL (0x0)
+#define CDP_RDMA_S_POINTER_0_SCR (0)
+#define CDP_RDMA_S_POINTER_0_WORD_COUNT (0x1)
+#define CDP_RDMA_S_POINTER_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_S_POINTER_0_RESET_MASK (_MK_MASK_CONST(0x10001))
+#define CDP_RDMA_S_POINTER_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_S_POINTER_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_S_POINTER_0_READ_MASK (_MK_MASK_CONST(0x10001))
+#define CDP_RDMA_S_POINTER_0_WRITE_MASK (_MK_MASK_CONST(0x1))
+#define CDP_RDMA_S_POINTER_0_PRODUCER_SHIFT (_MK_SHIFT_CONST(0))
+#define CDP_RDMA_S_POINTER_0_PRODUCER_FIELD \
+	(_MK_FIELD_CONST(0x1, CDP_RDMA_S_POINTER_0_PRODUCER_SHIFT))
+#define CDP_RDMA_S_POINTER_0_PRODUCER_RANGE (0 : 0)
+#define CDP_RDMA_S_POINTER_0_PRODUCER_WOFFSET (0x0)
+#define CDP_RDMA_S_POINTER_0_PRODUCER_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_S_POINTER_0_PRODUCER_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CDP_RDMA_S_POINTER_0_PRODUCER_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_S_POINTER_0_PRODUCER_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_S_POINTER_0_PRODUCER_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_S_POINTER_0_PRODUCER_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define CDP_RDMA_S_POINTER_0_PRODUCER_INIT_ENUM (GROUP_0)
+#define CDP_RDMA_S_POINTER_0_PRODUCER_GROUP_0 (_MK_ENUM_CONST(0))
+#define CDP_RDMA_S_POINTER_0_PRODUCER_GROUP_1 (_MK_ENUM_CONST(1))
+
+#define CDP_RDMA_S_POINTER_0_CONSUMER_SHIFT (_MK_SHIFT_CONST(16))
+#define CDP_RDMA_S_POINTER_0_CONSUMER_FIELD \
+	(_MK_FIELD_CONST(0x1, CDP_RDMA_S_POINTER_0_CONSUMER_SHIFT))
+#define CDP_RDMA_S_POINTER_0_CONSUMER_RANGE (16 : 16)
+#define CDP_RDMA_S_POINTER_0_CONSUMER_WOFFSET (0x0)
+#define CDP_RDMA_S_POINTER_0_CONSUMER_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_S_POINTER_0_CONSUMER_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CDP_RDMA_S_POINTER_0_CONSUMER_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_S_POINTER_0_CONSUMER_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_S_POINTER_0_CONSUMER_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_S_POINTER_0_CONSUMER_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define CDP_RDMA_S_POINTER_0_CONSUMER_INIT_ENUM (GROUP_0)
+#define CDP_RDMA_S_POINTER_0_CONSUMER_GROUP_0 (_MK_ENUM_CONST(0))
+#define CDP_RDMA_S_POINTER_0_CONSUMER_GROUP_1 (_MK_ENUM_CONST(1))
+
+// Register CDP_RDMA_D_OP_ENABLE_0
+#define CDP_RDMA_D_OP_ENABLE_0 (_MK_ADDR_CONST(0xe008))
+#define CDP_RDMA_D_OP_ENABLE_0_SECURE (0x0)
+#define CDP_RDMA_D_OP_ENABLE_0_DUAL (0x0)
+#define CDP_RDMA_D_OP_ENABLE_0_SCR (0)
+#define CDP_RDMA_D_OP_ENABLE_0_WORD_COUNT (0x1)
+#define CDP_RDMA_D_OP_ENABLE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_OP_ENABLE_0_RESET_MASK (_MK_MASK_CONST(0x1))
+#define CDP_RDMA_D_OP_ENABLE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_OP_ENABLE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_OP_ENABLE_0_READ_MASK (_MK_MASK_CONST(0x1))
+#define CDP_RDMA_D_OP_ENABLE_0_WRITE_MASK (_MK_MASK_CONST(0x1))
+#define CDP_RDMA_D_OP_ENABLE_0_OP_EN_SHIFT (_MK_SHIFT_CONST(0))
+#define CDP_RDMA_D_OP_ENABLE_0_OP_EN_FIELD \
+	(_MK_FIELD_CONST(0x1, CDP_RDMA_D_OP_ENABLE_0_OP_EN_SHIFT))
+#define CDP_RDMA_D_OP_ENABLE_0_OP_EN_RANGE (0 : 0)
+#define CDP_RDMA_D_OP_ENABLE_0_OP_EN_WOFFSET (0x0)
+#define CDP_RDMA_D_OP_ENABLE_0_OP_EN_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_OP_ENABLE_0_OP_EN_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CDP_RDMA_D_OP_ENABLE_0_OP_EN_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_OP_ENABLE_0_OP_EN_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_OP_ENABLE_0_OP_EN_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_OP_ENABLE_0_OP_EN_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define CDP_RDMA_D_OP_ENABLE_0_OP_EN_INIT_ENUM (DISABLE)
+#define CDP_RDMA_D_OP_ENABLE_0_OP_EN_DISABLE (_MK_ENUM_CONST(0))
+#define CDP_RDMA_D_OP_ENABLE_0_OP_EN_ENABLE (_MK_ENUM_CONST(1))
+
+// Register CDP_RDMA_D_DATA_CUBE_WIDTH_0
+#define CDP_RDMA_D_DATA_CUBE_WIDTH_0 (_MK_ADDR_CONST(0xe00c))
+#define CDP_RDMA_D_DATA_CUBE_WIDTH_0_SECURE (0x0)
+#define CDP_RDMA_D_DATA_CUBE_WIDTH_0_DUAL (0x0)
+#define CDP_RDMA_D_DATA_CUBE_WIDTH_0_SCR (0)
+#define CDP_RDMA_D_DATA_CUBE_WIDTH_0_WORD_COUNT (0x1)
+#define CDP_RDMA_D_DATA_CUBE_WIDTH_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_DATA_CUBE_WIDTH_0_RESET_MASK (_MK_MASK_CONST(0x1fff))
+#define CDP_RDMA_D_DATA_CUBE_WIDTH_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_DATA_CUBE_WIDTH_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_DATA_CUBE_WIDTH_0_READ_MASK (_MK_MASK_CONST(0x1fff))
+#define CDP_RDMA_D_DATA_CUBE_WIDTH_0_WRITE_MASK (_MK_MASK_CONST(0x1fff))
+#define CDP_RDMA_D_DATA_CUBE_WIDTH_0_WIDTH_SHIFT (_MK_SHIFT_CONST(0))
+#define CDP_RDMA_D_DATA_CUBE_WIDTH_0_WIDTH_FIELD \
+	(_MK_FIELD_CONST(0x1fff, CDP_RDMA_D_DATA_CUBE_WIDTH_0_WIDTH_SHIFT))
+#define CDP_RDMA_D_DATA_CUBE_WIDTH_0_WIDTH_RANGE (12 : 0)
+#define CDP_RDMA_D_DATA_CUBE_WIDTH_0_WIDTH_WOFFSET (0x0)
+#define CDP_RDMA_D_DATA_CUBE_WIDTH_0_WIDTH_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_DATA_CUBE_WIDTH_0_WIDTH_DEFAULT_MASK (_MK_MASK_CONST(0x1fff))
+#define CDP_RDMA_D_DATA_CUBE_WIDTH_0_WIDTH_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_DATA_CUBE_WIDTH_0_WIDTH_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_DATA_CUBE_WIDTH_0_WIDTH_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_DATA_CUBE_WIDTH_0_WIDTH_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDP_RDMA_D_DATA_CUBE_HEIGHT_0
+#define CDP_RDMA_D_DATA_CUBE_HEIGHT_0 (_MK_ADDR_CONST(0xe010))
+#define CDP_RDMA_D_DATA_CUBE_HEIGHT_0_SECURE (0x0)
+#define CDP_RDMA_D_DATA_CUBE_HEIGHT_0_DUAL (0x0)
+#define CDP_RDMA_D_DATA_CUBE_HEIGHT_0_SCR (0)
+#define CDP_RDMA_D_DATA_CUBE_HEIGHT_0_WORD_COUNT (0x1)
+#define CDP_RDMA_D_DATA_CUBE_HEIGHT_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_DATA_CUBE_HEIGHT_0_RESET_MASK (_MK_MASK_CONST(0x1fff))
+#define CDP_RDMA_D_DATA_CUBE_HEIGHT_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_DATA_CUBE_HEIGHT_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_DATA_CUBE_HEIGHT_0_READ_MASK (_MK_MASK_CONST(0x1fff))
+#define CDP_RDMA_D_DATA_CUBE_HEIGHT_0_WRITE_MASK (_MK_MASK_CONST(0x1fff))
+#define CDP_RDMA_D_DATA_CUBE_HEIGHT_0_HEIGHT_SHIFT (_MK_SHIFT_CONST(0))
+#define CDP_RDMA_D_DATA_CUBE_HEIGHT_0_HEIGHT_FIELD \
+	(_MK_FIELD_CONST(0x1fff, CDP_RDMA_D_DATA_CUBE_HEIGHT_0_HEIGHT_SHIFT))
+#define CDP_RDMA_D_DATA_CUBE_HEIGHT_0_HEIGHT_RANGE (12 : 0)
+#define CDP_RDMA_D_DATA_CUBE_HEIGHT_0_HEIGHT_WOFFSET (0x0)
+#define CDP_RDMA_D_DATA_CUBE_HEIGHT_0_HEIGHT_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_DATA_CUBE_HEIGHT_0_HEIGHT_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1fff))
+#define CDP_RDMA_D_DATA_CUBE_HEIGHT_0_HEIGHT_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_DATA_CUBE_HEIGHT_0_HEIGHT_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_DATA_CUBE_HEIGHT_0_HEIGHT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_DATA_CUBE_HEIGHT_0_HEIGHT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDP_RDMA_D_DATA_CUBE_CHANNEL_0
+#define CDP_RDMA_D_DATA_CUBE_CHANNEL_0 (_MK_ADDR_CONST(0xe014))
+#define CDP_RDMA_D_DATA_CUBE_CHANNEL_0_SECURE (0x0)
+#define CDP_RDMA_D_DATA_CUBE_CHANNEL_0_DUAL (0x0)
+#define CDP_RDMA_D_DATA_CUBE_CHANNEL_0_SCR (0)
+#define CDP_RDMA_D_DATA_CUBE_CHANNEL_0_WORD_COUNT (0x1)
+#define CDP_RDMA_D_DATA_CUBE_CHANNEL_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_DATA_CUBE_CHANNEL_0_RESET_MASK (_MK_MASK_CONST(0x1fff))
+#define CDP_RDMA_D_DATA_CUBE_CHANNEL_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_DATA_CUBE_CHANNEL_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_DATA_CUBE_CHANNEL_0_READ_MASK (_MK_MASK_CONST(0x1fff))
+#define CDP_RDMA_D_DATA_CUBE_CHANNEL_0_WRITE_MASK (_MK_MASK_CONST(0x1fff))
+#define CDP_RDMA_D_DATA_CUBE_CHANNEL_0_CHANNEL_SHIFT (_MK_SHIFT_CONST(0))
+#define CDP_RDMA_D_DATA_CUBE_CHANNEL_0_CHANNEL_FIELD \
+	(_MK_FIELD_CONST(0x1fff, CDP_RDMA_D_DATA_CUBE_CHANNEL_0_CHANNEL_SHIFT))
+#define CDP_RDMA_D_DATA_CUBE_CHANNEL_0_CHANNEL_RANGE (12 : 0)
+#define CDP_RDMA_D_DATA_CUBE_CHANNEL_0_CHANNEL_WOFFSET (0x0)
+#define CDP_RDMA_D_DATA_CUBE_CHANNEL_0_CHANNEL_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_DATA_CUBE_CHANNEL_0_CHANNEL_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1fff))
+#define CDP_RDMA_D_DATA_CUBE_CHANNEL_0_CHANNEL_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_DATA_CUBE_CHANNEL_0_CHANNEL_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_DATA_CUBE_CHANNEL_0_CHANNEL_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_DATA_CUBE_CHANNEL_0_CHANNEL_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDP_RDMA_D_SRC_BASE_ADDR_LOW_0
+#define CDP_RDMA_D_SRC_BASE_ADDR_LOW_0 (_MK_ADDR_CONST(0xe018))
+#define CDP_RDMA_D_SRC_BASE_ADDR_LOW_0_SECURE (0x0)
+#define CDP_RDMA_D_SRC_BASE_ADDR_LOW_0_DUAL (0x0)
+#define CDP_RDMA_D_SRC_BASE_ADDR_LOW_0_SCR (0)
+#define CDP_RDMA_D_SRC_BASE_ADDR_LOW_0_WORD_COUNT (0x1)
+#define CDP_RDMA_D_SRC_BASE_ADDR_LOW_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_SRC_BASE_ADDR_LOW_0_RESET_MASK (_MK_MASK_CONST(0xffffffe0))
+#define CDP_RDMA_D_SRC_BASE_ADDR_LOW_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_SRC_BASE_ADDR_LOW_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_SRC_BASE_ADDR_LOW_0_READ_MASK (_MK_MASK_CONST(0xffffffe0))
+#define CDP_RDMA_D_SRC_BASE_ADDR_LOW_0_WRITE_MASK (_MK_MASK_CONST(0xffffffe0))
+#define CDP_RDMA_D_SRC_BASE_ADDR_LOW_0_SRC_BASE_ADDR_LOW_SHIFT \
+	(_MK_SHIFT_CONST(5))
+#define CDP_RDMA_D_SRC_BASE_ADDR_LOW_0_SRC_BASE_ADDR_LOW_FIELD \
+	(_MK_FIELD_CONST(                                      \
+		0x7ffffff,                                     \
+		CDP_RDMA_D_SRC_BASE_ADDR_LOW_0_SRC_BASE_ADDR_LOW_SHIFT))
+#define CDP_RDMA_D_SRC_BASE_ADDR_LOW_0_SRC_BASE_ADDR_LOW_RANGE (31 : 5)
+#define CDP_RDMA_D_SRC_BASE_ADDR_LOW_0_SRC_BASE_ADDR_LOW_WOFFSET (0x0)
+#define CDP_RDMA_D_SRC_BASE_ADDR_LOW_0_SRC_BASE_ADDR_LOW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_SRC_BASE_ADDR_LOW_0_SRC_BASE_ADDR_LOW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffffff))
+#define CDP_RDMA_D_SRC_BASE_ADDR_LOW_0_SRC_BASE_ADDR_LOW_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_SRC_BASE_ADDR_LOW_0_SRC_BASE_ADDR_LOW_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_SRC_BASE_ADDR_LOW_0_SRC_BASE_ADDR_LOW_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_SRC_BASE_ADDR_LOW_0_SRC_BASE_ADDR_LOW_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDP_RDMA_D_SRC_BASE_ADDR_HIGH_0
+#define CDP_RDMA_D_SRC_BASE_ADDR_HIGH_0 (_MK_ADDR_CONST(0xe01c))
+#define CDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_SECURE (0x0)
+#define CDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_DUAL (0x0)
+#define CDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_SCR (0)
+#define CDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_WORD_COUNT (0x1)
+#define CDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_WRITE_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_SRC_BASE_ADDR_HIGH_SHIFT \
+	(_MK_SHIFT_CONST(0))
+#define CDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_SRC_BASE_ADDR_HIGH_FIELD \
+	(_MK_FIELD_CONST(                                        \
+		0xffffffff,                                      \
+		CDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_SRC_BASE_ADDR_HIGH_SHIFT))
+#define CDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_SRC_BASE_ADDR_HIGH_RANGE (31 : 0)
+#define CDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_SRC_BASE_ADDR_HIGH_WOFFSET (0x0)
+#define CDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_SRC_BASE_ADDR_HIGH_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_SRC_BASE_ADDR_HIGH_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define CDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_SRC_BASE_ADDR_HIGH_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_SRC_BASE_ADDR_HIGH_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_SRC_BASE_ADDR_HIGH_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_SRC_BASE_ADDR_HIGH_0_SRC_BASE_ADDR_HIGH_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDP_RDMA_D_SRC_LINE_STRIDE_0
+#define CDP_RDMA_D_SRC_LINE_STRIDE_0 (_MK_ADDR_CONST(0xe020))
+#define CDP_RDMA_D_SRC_LINE_STRIDE_0_SECURE (0x0)
+#define CDP_RDMA_D_SRC_LINE_STRIDE_0_DUAL (0x0)
+#define CDP_RDMA_D_SRC_LINE_STRIDE_0_SCR (0)
+#define CDP_RDMA_D_SRC_LINE_STRIDE_0_WORD_COUNT (0x1)
+#define CDP_RDMA_D_SRC_LINE_STRIDE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_SRC_LINE_STRIDE_0_RESET_MASK (_MK_MASK_CONST(0xffffffe0))
+#define CDP_RDMA_D_SRC_LINE_STRIDE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_SRC_LINE_STRIDE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_SRC_LINE_STRIDE_0_READ_MASK (_MK_MASK_CONST(0xffffffe0))
+#define CDP_RDMA_D_SRC_LINE_STRIDE_0_WRITE_MASK (_MK_MASK_CONST(0xffffffe0))
+#define CDP_RDMA_D_SRC_LINE_STRIDE_0_SRC_LINE_STRIDE_SHIFT (_MK_SHIFT_CONST(5))
+#define CDP_RDMA_D_SRC_LINE_STRIDE_0_SRC_LINE_STRIDE_FIELD \
+	(_MK_FIELD_CONST(0x7ffffff,                        \
+			 CDP_RDMA_D_SRC_LINE_STRIDE_0_SRC_LINE_STRIDE_SHIFT))
+#define CDP_RDMA_D_SRC_LINE_STRIDE_0_SRC_LINE_STRIDE_RANGE (31 : 5)
+#define CDP_RDMA_D_SRC_LINE_STRIDE_0_SRC_LINE_STRIDE_WOFFSET (0x0)
+#define CDP_RDMA_D_SRC_LINE_STRIDE_0_SRC_LINE_STRIDE_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_SRC_LINE_STRIDE_0_SRC_LINE_STRIDE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffffff))
+#define CDP_RDMA_D_SRC_LINE_STRIDE_0_SRC_LINE_STRIDE_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_SRC_LINE_STRIDE_0_SRC_LINE_STRIDE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_SRC_LINE_STRIDE_0_SRC_LINE_STRIDE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_SRC_LINE_STRIDE_0_SRC_LINE_STRIDE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDP_RDMA_D_SRC_SURFACE_STRIDE_0
+#define CDP_RDMA_D_SRC_SURFACE_STRIDE_0 (_MK_ADDR_CONST(0xe024))
+#define CDP_RDMA_D_SRC_SURFACE_STRIDE_0_SECURE (0x0)
+#define CDP_RDMA_D_SRC_SURFACE_STRIDE_0_DUAL (0x0)
+#define CDP_RDMA_D_SRC_SURFACE_STRIDE_0_SCR (0)
+#define CDP_RDMA_D_SRC_SURFACE_STRIDE_0_WORD_COUNT (0x1)
+#define CDP_RDMA_D_SRC_SURFACE_STRIDE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_SRC_SURFACE_STRIDE_0_RESET_MASK (_MK_MASK_CONST(0xffffffe0))
+#define CDP_RDMA_D_SRC_SURFACE_STRIDE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_SRC_SURFACE_STRIDE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_SRC_SURFACE_STRIDE_0_READ_MASK (_MK_MASK_CONST(0xffffffe0))
+#define CDP_RDMA_D_SRC_SURFACE_STRIDE_0_WRITE_MASK (_MK_MASK_CONST(0xffffffe0))
+#define CDP_RDMA_D_SRC_SURFACE_STRIDE_0_SRC_SURFACE_STRIDE_SHIFT \
+	(_MK_SHIFT_CONST(5))
+#define CDP_RDMA_D_SRC_SURFACE_STRIDE_0_SRC_SURFACE_STRIDE_FIELD \
+	(_MK_FIELD_CONST(                                        \
+		0x7ffffff,                                       \
+		CDP_RDMA_D_SRC_SURFACE_STRIDE_0_SRC_SURFACE_STRIDE_SHIFT))
+#define CDP_RDMA_D_SRC_SURFACE_STRIDE_0_SRC_SURFACE_STRIDE_RANGE (31 : 5)
+#define CDP_RDMA_D_SRC_SURFACE_STRIDE_0_SRC_SURFACE_STRIDE_WOFFSET (0x0)
+#define CDP_RDMA_D_SRC_SURFACE_STRIDE_0_SRC_SURFACE_STRIDE_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_SRC_SURFACE_STRIDE_0_SRC_SURFACE_STRIDE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffffff))
+#define CDP_RDMA_D_SRC_SURFACE_STRIDE_0_SRC_SURFACE_STRIDE_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_SRC_SURFACE_STRIDE_0_SRC_SURFACE_STRIDE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_SRC_SURFACE_STRIDE_0_SRC_SURFACE_STRIDE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_SRC_SURFACE_STRIDE_0_SRC_SURFACE_STRIDE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDP_RDMA_D_SRC_DMA_CFG_0
+#define CDP_RDMA_D_SRC_DMA_CFG_0 (_MK_ADDR_CONST(0xe028))
+#define CDP_RDMA_D_SRC_DMA_CFG_0_SECURE (0x0)
+#define CDP_RDMA_D_SRC_DMA_CFG_0_DUAL (0x0)
+#define CDP_RDMA_D_SRC_DMA_CFG_0_SCR (0)
+#define CDP_RDMA_D_SRC_DMA_CFG_0_WORD_COUNT (0x1)
+#define CDP_RDMA_D_SRC_DMA_CFG_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_SRC_DMA_CFG_0_RESET_MASK (_MK_MASK_CONST(0x1))
+#define CDP_RDMA_D_SRC_DMA_CFG_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_SRC_DMA_CFG_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_SRC_DMA_CFG_0_READ_MASK (_MK_MASK_CONST(0x1))
+#define CDP_RDMA_D_SRC_DMA_CFG_0_WRITE_MASK (_MK_MASK_CONST(0x1))
+#define CDP_RDMA_D_SRC_DMA_CFG_0_SRC_RAM_TYPE_SHIFT (_MK_SHIFT_CONST(0))
+#define CDP_RDMA_D_SRC_DMA_CFG_0_SRC_RAM_TYPE_FIELD \
+	(_MK_FIELD_CONST(0x1, CDP_RDMA_D_SRC_DMA_CFG_0_SRC_RAM_TYPE_SHIFT))
+#define CDP_RDMA_D_SRC_DMA_CFG_0_SRC_RAM_TYPE_RANGE (0 : 0)
+#define CDP_RDMA_D_SRC_DMA_CFG_0_SRC_RAM_TYPE_WOFFSET (0x0)
+#define CDP_RDMA_D_SRC_DMA_CFG_0_SRC_RAM_TYPE_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_SRC_DMA_CFG_0_SRC_RAM_TYPE_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CDP_RDMA_D_SRC_DMA_CFG_0_SRC_RAM_TYPE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_SRC_DMA_CFG_0_SRC_RAM_TYPE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_SRC_DMA_CFG_0_SRC_RAM_TYPE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_SRC_DMA_CFG_0_SRC_RAM_TYPE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define CDP_RDMA_D_SRC_DMA_CFG_0_SRC_RAM_TYPE_CV (_MK_ENUM_CONST(0))
+#define CDP_RDMA_D_SRC_DMA_CFG_0_SRC_RAM_TYPE_MC (_MK_ENUM_CONST(1))
+
+// Register CDP_RDMA_D_SRC_COMPRESSION_EN_0
+#define CDP_RDMA_D_SRC_COMPRESSION_EN_0 (_MK_ADDR_CONST(0xe02c))
+#define CDP_RDMA_D_SRC_COMPRESSION_EN_0_SECURE (0x0)
+#define CDP_RDMA_D_SRC_COMPRESSION_EN_0_DUAL (0x0)
+#define CDP_RDMA_D_SRC_COMPRESSION_EN_0_SCR (0)
+#define CDP_RDMA_D_SRC_COMPRESSION_EN_0_WORD_COUNT (0x1)
+#define CDP_RDMA_D_SRC_COMPRESSION_EN_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_SRC_COMPRESSION_EN_0_RESET_MASK (_MK_MASK_CONST(0x1))
+#define CDP_RDMA_D_SRC_COMPRESSION_EN_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_SRC_COMPRESSION_EN_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_SRC_COMPRESSION_EN_0_READ_MASK (_MK_MASK_CONST(0x1))
+#define CDP_RDMA_D_SRC_COMPRESSION_EN_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_SRC_COMPRESSION_EN_0_SRC_COMPRESSION_EN_SHIFT \
+	(_MK_SHIFT_CONST(0))
+#define CDP_RDMA_D_SRC_COMPRESSION_EN_0_SRC_COMPRESSION_EN_FIELD \
+	(_MK_FIELD_CONST(                                        \
+		0x1,                                             \
+		CDP_RDMA_D_SRC_COMPRESSION_EN_0_SRC_COMPRESSION_EN_SHIFT))
+#define CDP_RDMA_D_SRC_COMPRESSION_EN_0_SRC_COMPRESSION_EN_RANGE (0 : 0)
+#define CDP_RDMA_D_SRC_COMPRESSION_EN_0_SRC_COMPRESSION_EN_WOFFSET (0x0)
+#define CDP_RDMA_D_SRC_COMPRESSION_EN_0_SRC_COMPRESSION_EN_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_SRC_COMPRESSION_EN_0_SRC_COMPRESSION_EN_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1))
+#define CDP_RDMA_D_SRC_COMPRESSION_EN_0_SRC_COMPRESSION_EN_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_SRC_COMPRESSION_EN_0_SRC_COMPRESSION_EN_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_SRC_COMPRESSION_EN_0_SRC_COMPRESSION_EN_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_SRC_COMPRESSION_EN_0_SRC_COMPRESSION_EN_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define CDP_RDMA_D_SRC_COMPRESSION_EN_0_SRC_COMPRESSION_EN_DISABLE \
+	(_MK_ENUM_CONST(0))
+#define CDP_RDMA_D_SRC_COMPRESSION_EN_0_SRC_COMPRESSION_EN_ENABLE \
+	(_MK_ENUM_CONST(1))
+
+// Register CDP_RDMA_D_OPERATION_MODE_0
+#define CDP_RDMA_D_OPERATION_MODE_0 (_MK_ADDR_CONST(0xe030))
+#define CDP_RDMA_D_OPERATION_MODE_0_SECURE (0x0)
+#define CDP_RDMA_D_OPERATION_MODE_0_DUAL (0x0)
+#define CDP_RDMA_D_OPERATION_MODE_0_SCR (0)
+#define CDP_RDMA_D_OPERATION_MODE_0_WORD_COUNT (0x1)
+#define CDP_RDMA_D_OPERATION_MODE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_OPERATION_MODE_0_RESET_MASK (_MK_MASK_CONST(0x3))
+#define CDP_RDMA_D_OPERATION_MODE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_OPERATION_MODE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_OPERATION_MODE_0_READ_MASK (_MK_MASK_CONST(0x3))
+#define CDP_RDMA_D_OPERATION_MODE_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_OPERATION_MODE_0_OPERATION_MODE_SHIFT (_MK_SHIFT_CONST(0))
+#define CDP_RDMA_D_OPERATION_MODE_0_OPERATION_MODE_FIELD \
+	(_MK_FIELD_CONST(0x3, CDP_RDMA_D_OPERATION_MODE_0_OPERATION_MODE_SHIFT))
+#define CDP_RDMA_D_OPERATION_MODE_0_OPERATION_MODE_RANGE (1 : 0)
+#define CDP_RDMA_D_OPERATION_MODE_0_OPERATION_MODE_WOFFSET (0x0)
+#define CDP_RDMA_D_OPERATION_MODE_0_OPERATION_MODE_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_OPERATION_MODE_0_OPERATION_MODE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x3))
+#define CDP_RDMA_D_OPERATION_MODE_0_OPERATION_MODE_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_OPERATION_MODE_0_OPERATION_MODE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_OPERATION_MODE_0_OPERATION_MODE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_OPERATION_MODE_0_OPERATION_MODE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define CDP_RDMA_D_OPERATION_MODE_0_OPERATION_MODE_READPHILE (_MK_ENUM_CONST(0))
+#define CDP_RDMA_D_OPERATION_MODE_0_OPERATION_MODE_WRITEPHILE \
+	(_MK_ENUM_CONST(1))
+#define CDP_RDMA_D_OPERATION_MODE_0_OPERATION_MODE_ORDINARY (_MK_ENUM_CONST(2))
+
+// Register CDP_RDMA_D_DATA_FORMAT_0
+#define CDP_RDMA_D_DATA_FORMAT_0 (_MK_ADDR_CONST(0xe034))
+#define CDP_RDMA_D_DATA_FORMAT_0_SECURE (0x0)
+#define CDP_RDMA_D_DATA_FORMAT_0_DUAL (0x0)
+#define CDP_RDMA_D_DATA_FORMAT_0_SCR (0)
+#define CDP_RDMA_D_DATA_FORMAT_0_WORD_COUNT (0x1)
+#define CDP_RDMA_D_DATA_FORMAT_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_DATA_FORMAT_0_RESET_MASK (_MK_MASK_CONST(0x3))
+#define CDP_RDMA_D_DATA_FORMAT_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_DATA_FORMAT_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_DATA_FORMAT_0_READ_MASK (_MK_MASK_CONST(0x3))
+#define CDP_RDMA_D_DATA_FORMAT_0_WRITE_MASK (_MK_MASK_CONST(0x3))
+#define CDP_RDMA_D_DATA_FORMAT_0_INPUT_DATA_SHIFT (_MK_SHIFT_CONST(0))
+#define CDP_RDMA_D_DATA_FORMAT_0_INPUT_DATA_FIELD \
+	(_MK_FIELD_CONST(0x3, CDP_RDMA_D_DATA_FORMAT_0_INPUT_DATA_SHIFT))
+#define CDP_RDMA_D_DATA_FORMAT_0_INPUT_DATA_RANGE (1 : 0)
+#define CDP_RDMA_D_DATA_FORMAT_0_INPUT_DATA_WOFFSET (0x0)
+#define CDP_RDMA_D_DATA_FORMAT_0_INPUT_DATA_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_DATA_FORMAT_0_INPUT_DATA_DEFAULT_MASK (_MK_MASK_CONST(0x3))
+#define CDP_RDMA_D_DATA_FORMAT_0_INPUT_DATA_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_DATA_FORMAT_0_INPUT_DATA_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_DATA_FORMAT_0_INPUT_DATA_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_DATA_FORMAT_0_INPUT_DATA_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define CDP_RDMA_D_DATA_FORMAT_0_INPUT_DATA_INT8 (_MK_ENUM_CONST(0))
+#define CDP_RDMA_D_DATA_FORMAT_0_INPUT_DATA_INT16 (_MK_ENUM_CONST(1))
+#define CDP_RDMA_D_DATA_FORMAT_0_INPUT_DATA_FP16 (_MK_ENUM_CONST(2))
+
+// Register CDP_RDMA_D_PERF_ENABLE_0
+#define CDP_RDMA_D_PERF_ENABLE_0 (_MK_ADDR_CONST(0xe038))
+#define CDP_RDMA_D_PERF_ENABLE_0_SECURE (0x0)
+#define CDP_RDMA_D_PERF_ENABLE_0_DUAL (0x0)
+#define CDP_RDMA_D_PERF_ENABLE_0_SCR (0)
+#define CDP_RDMA_D_PERF_ENABLE_0_WORD_COUNT (0x1)
+#define CDP_RDMA_D_PERF_ENABLE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_PERF_ENABLE_0_RESET_MASK (_MK_MASK_CONST(0x1))
+#define CDP_RDMA_D_PERF_ENABLE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_PERF_ENABLE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_PERF_ENABLE_0_READ_MASK (_MK_MASK_CONST(0x1))
+#define CDP_RDMA_D_PERF_ENABLE_0_WRITE_MASK (_MK_MASK_CONST(0x1))
+#define CDP_RDMA_D_PERF_ENABLE_0_DMA_EN_SHIFT (_MK_SHIFT_CONST(0))
+#define CDP_RDMA_D_PERF_ENABLE_0_DMA_EN_FIELD \
+	(_MK_FIELD_CONST(0x1, CDP_RDMA_D_PERF_ENABLE_0_DMA_EN_SHIFT))
+#define CDP_RDMA_D_PERF_ENABLE_0_DMA_EN_RANGE (0 : 0)
+#define CDP_RDMA_D_PERF_ENABLE_0_DMA_EN_WOFFSET (0x0)
+#define CDP_RDMA_D_PERF_ENABLE_0_DMA_EN_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_PERF_ENABLE_0_DMA_EN_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CDP_RDMA_D_PERF_ENABLE_0_DMA_EN_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_PERF_ENABLE_0_DMA_EN_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_PERF_ENABLE_0_DMA_EN_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_PERF_ENABLE_0_DMA_EN_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define CDP_RDMA_D_PERF_ENABLE_0_DMA_EN_INIT_ENUM (DISABLE)
+#define CDP_RDMA_D_PERF_ENABLE_0_DMA_EN_DISABLE (_MK_ENUM_CONST(0))
+#define CDP_RDMA_D_PERF_ENABLE_0_DMA_EN_ENABLE (_MK_ENUM_CONST(1))
+
+// Register CDP_RDMA_D_PERF_READ_STALL_0
+#define CDP_RDMA_D_PERF_READ_STALL_0 (_MK_ADDR_CONST(0xe03c))
+#define CDP_RDMA_D_PERF_READ_STALL_0_SECURE (0x0)
+#define CDP_RDMA_D_PERF_READ_STALL_0_DUAL (0x0)
+#define CDP_RDMA_D_PERF_READ_STALL_0_SCR (0)
+#define CDP_RDMA_D_PERF_READ_STALL_0_WORD_COUNT (0x1)
+#define CDP_RDMA_D_PERF_READ_STALL_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_PERF_READ_STALL_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDP_RDMA_D_PERF_READ_STALL_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_PERF_READ_STALL_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_PERF_READ_STALL_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDP_RDMA_D_PERF_READ_STALL_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_PERF_READ_STALL_0_PERF_READ_STALL_SHIFT (_MK_SHIFT_CONST(0))
+#define CDP_RDMA_D_PERF_READ_STALL_0_PERF_READ_STALL_FIELD \
+	(_MK_FIELD_CONST(0xffffffff,                       \
+			 CDP_RDMA_D_PERF_READ_STALL_0_PERF_READ_STALL_SHIFT))
+#define CDP_RDMA_D_PERF_READ_STALL_0_PERF_READ_STALL_RANGE (31 : 0)
+#define CDP_RDMA_D_PERF_READ_STALL_0_PERF_READ_STALL_WOFFSET (0x0)
+#define CDP_RDMA_D_PERF_READ_STALL_0_PERF_READ_STALL_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_PERF_READ_STALL_0_PERF_READ_STALL_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define CDP_RDMA_D_PERF_READ_STALL_0_PERF_READ_STALL_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_PERF_READ_STALL_0_PERF_READ_STALL_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_PERF_READ_STALL_0_PERF_READ_STALL_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_PERF_READ_STALL_0_PERF_READ_STALL_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDP_RDMA_D_CYA_0
+#define CDP_RDMA_D_CYA_0 (_MK_ADDR_CONST(0xe040))
+#define CDP_RDMA_D_CYA_0_SECURE (0x0)
+#define CDP_RDMA_D_CYA_0_DUAL (0x0)
+#define CDP_RDMA_D_CYA_0_SCR (0)
+#define CDP_RDMA_D_CYA_0_WORD_COUNT (0x1)
+#define CDP_RDMA_D_CYA_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_CYA_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDP_RDMA_D_CYA_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_CYA_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_CYA_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDP_RDMA_D_CYA_0_WRITE_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDP_RDMA_D_CYA_0_CYA_SHIFT (_MK_SHIFT_CONST(0))
+#define CDP_RDMA_D_CYA_0_CYA_FIELD \
+	(_MK_FIELD_CONST(0xffffffff, CDP_RDMA_D_CYA_0_CYA_SHIFT))
+#define CDP_RDMA_D_CYA_0_CYA_RANGE (31 : 0)
+#define CDP_RDMA_D_CYA_0_CYA_WOFFSET (0x0)
+#define CDP_RDMA_D_CYA_0_CYA_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_CYA_0_CYA_DEFAULT_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDP_RDMA_D_CYA_0_CYA_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_CYA_0_CYA_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_CYA_0_CYA_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDP_RDMA_D_CYA_0_CYA_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+// Register CDP_S_STATUS_0
+#define CDP_S_STATUS_0 (_MK_ADDR_CONST(0xf000))
+#define CDP_S_STATUS_0_SECURE (0x0)
+#define CDP_S_STATUS_0_DUAL (0x0)
+#define CDP_S_STATUS_0_SCR (0)
+#define CDP_S_STATUS_0_WORD_COUNT (0x1)
+#define CDP_S_STATUS_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_S_STATUS_0_RESET_MASK (_MK_MASK_CONST(0x30003))
+#define CDP_S_STATUS_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_S_STATUS_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_S_STATUS_0_READ_MASK (_MK_MASK_CONST(0x30003))
+#define CDP_S_STATUS_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define CDP_S_STATUS_0_STATUS_0_SHIFT (_MK_SHIFT_CONST(0))
+#define CDP_S_STATUS_0_STATUS_0_FIELD \
+	(_MK_FIELD_CONST(0x3, CDP_S_STATUS_0_STATUS_0_SHIFT))
+#define CDP_S_STATUS_0_STATUS_0_RANGE (1 : 0)
+#define CDP_S_STATUS_0_STATUS_0_WOFFSET (0x0)
+#define CDP_S_STATUS_0_STATUS_0_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_S_STATUS_0_STATUS_0_DEFAULT_MASK (_MK_MASK_CONST(0x3))
+#define CDP_S_STATUS_0_STATUS_0_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_S_STATUS_0_STATUS_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_S_STATUS_0_STATUS_0_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDP_S_STATUS_0_STATUS_0_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define CDP_S_STATUS_0_STATUS_0_INIT_ENUM (IDLE)
+#define CDP_S_STATUS_0_STATUS_0_IDLE (_MK_ENUM_CONST(0))
+#define CDP_S_STATUS_0_STATUS_0_RUNNING (_MK_ENUM_CONST(1))
+#define CDP_S_STATUS_0_STATUS_0_PENDING (_MK_ENUM_CONST(2))
+
+#define CDP_S_STATUS_0_STATUS_1_SHIFT (_MK_SHIFT_CONST(16))
+#define CDP_S_STATUS_0_STATUS_1_FIELD \
+	(_MK_FIELD_CONST(0x3, CDP_S_STATUS_0_STATUS_1_SHIFT))
+#define CDP_S_STATUS_0_STATUS_1_RANGE (17 : 16)
+#define CDP_S_STATUS_0_STATUS_1_WOFFSET (0x0)
+#define CDP_S_STATUS_0_STATUS_1_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_S_STATUS_0_STATUS_1_DEFAULT_MASK (_MK_MASK_CONST(0x3))
+#define CDP_S_STATUS_0_STATUS_1_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_S_STATUS_0_STATUS_1_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_S_STATUS_0_STATUS_1_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDP_S_STATUS_0_STATUS_1_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define CDP_S_STATUS_0_STATUS_1_INIT_ENUM (IDLE)
+#define CDP_S_STATUS_0_STATUS_1_IDLE (_MK_ENUM_CONST(0))
+#define CDP_S_STATUS_0_STATUS_1_RUNNING (_MK_ENUM_CONST(1))
+#define CDP_S_STATUS_0_STATUS_1_PENDING (_MK_ENUM_CONST(2))
+
+// Register CDP_S_POINTER_0
+#define CDP_S_POINTER_0 (_MK_ADDR_CONST(0xf004))
+#define CDP_S_POINTER_0_SECURE (0x0)
+#define CDP_S_POINTER_0_DUAL (0x0)
+#define CDP_S_POINTER_0_SCR (0)
+#define CDP_S_POINTER_0_WORD_COUNT (0x1)
+#define CDP_S_POINTER_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_S_POINTER_0_RESET_MASK (_MK_MASK_CONST(0x10001))
+#define CDP_S_POINTER_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_S_POINTER_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_S_POINTER_0_READ_MASK (_MK_MASK_CONST(0x10001))
+#define CDP_S_POINTER_0_WRITE_MASK (_MK_MASK_CONST(0x1))
+#define CDP_S_POINTER_0_PRODUCER_SHIFT (_MK_SHIFT_CONST(0))
+#define CDP_S_POINTER_0_PRODUCER_FIELD \
+	(_MK_FIELD_CONST(0x1, CDP_S_POINTER_0_PRODUCER_SHIFT))
+#define CDP_S_POINTER_0_PRODUCER_RANGE (0 : 0)
+#define CDP_S_POINTER_0_PRODUCER_WOFFSET (0x0)
+#define CDP_S_POINTER_0_PRODUCER_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_S_POINTER_0_PRODUCER_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CDP_S_POINTER_0_PRODUCER_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_S_POINTER_0_PRODUCER_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_S_POINTER_0_PRODUCER_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDP_S_POINTER_0_PRODUCER_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define CDP_S_POINTER_0_PRODUCER_INIT_ENUM (GROUP_0)
+#define CDP_S_POINTER_0_PRODUCER_GROUP_0 (_MK_ENUM_CONST(0))
+#define CDP_S_POINTER_0_PRODUCER_GROUP_1 (_MK_ENUM_CONST(1))
+
+#define CDP_S_POINTER_0_CONSUMER_SHIFT (_MK_SHIFT_CONST(16))
+#define CDP_S_POINTER_0_CONSUMER_FIELD \
+	(_MK_FIELD_CONST(0x1, CDP_S_POINTER_0_CONSUMER_SHIFT))
+#define CDP_S_POINTER_0_CONSUMER_RANGE (16 : 16)
+#define CDP_S_POINTER_0_CONSUMER_WOFFSET (0x0)
+#define CDP_S_POINTER_0_CONSUMER_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_S_POINTER_0_CONSUMER_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CDP_S_POINTER_0_CONSUMER_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_S_POINTER_0_CONSUMER_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_S_POINTER_0_CONSUMER_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDP_S_POINTER_0_CONSUMER_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define CDP_S_POINTER_0_CONSUMER_INIT_ENUM (GROUP_0)
+#define CDP_S_POINTER_0_CONSUMER_GROUP_0 (_MK_ENUM_CONST(0))
+#define CDP_S_POINTER_0_CONSUMER_GROUP_1 (_MK_ENUM_CONST(1))
+
+// Register CDP_S_LUT_ACCESS_CFG_0
+#define CDP_S_LUT_ACCESS_CFG_0 (_MK_ADDR_CONST(0xf008))
+#define CDP_S_LUT_ACCESS_CFG_0_SECURE (0x0)
+#define CDP_S_LUT_ACCESS_CFG_0_DUAL (0x0)
+#define CDP_S_LUT_ACCESS_CFG_0_SCR (0)
+#define CDP_S_LUT_ACCESS_CFG_0_WORD_COUNT (0x1)
+#define CDP_S_LUT_ACCESS_CFG_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_ACCESS_CFG_0_RESET_MASK (_MK_MASK_CONST(0x303ff))
+#define CDP_S_LUT_ACCESS_CFG_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_ACCESS_CFG_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_ACCESS_CFG_0_READ_MASK (_MK_MASK_CONST(0x303ff))
+#define CDP_S_LUT_ACCESS_CFG_0_WRITE_MASK (_MK_MASK_CONST(0x303ff))
+#define CDP_S_LUT_ACCESS_CFG_0_LUT_ADDR_SHIFT (_MK_SHIFT_CONST(0))
+#define CDP_S_LUT_ACCESS_CFG_0_LUT_ADDR_FIELD \
+	(_MK_FIELD_CONST(0x3ff, CDP_S_LUT_ACCESS_CFG_0_LUT_ADDR_SHIFT))
+#define CDP_S_LUT_ACCESS_CFG_0_LUT_ADDR_RANGE (9 : 0)
+#define CDP_S_LUT_ACCESS_CFG_0_LUT_ADDR_WOFFSET (0x0)
+#define CDP_S_LUT_ACCESS_CFG_0_LUT_ADDR_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_ACCESS_CFG_0_LUT_ADDR_DEFAULT_MASK (_MK_MASK_CONST(0x3ff))
+#define CDP_S_LUT_ACCESS_CFG_0_LUT_ADDR_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_ACCESS_CFG_0_LUT_ADDR_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_ACCESS_CFG_0_LUT_ADDR_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_ACCESS_CFG_0_LUT_ADDR_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+#define CDP_S_LUT_ACCESS_CFG_0_LUT_TABLE_ID_SHIFT (_MK_SHIFT_CONST(16))
+#define CDP_S_LUT_ACCESS_CFG_0_LUT_TABLE_ID_FIELD \
+	(_MK_FIELD_CONST(0x1, CDP_S_LUT_ACCESS_CFG_0_LUT_TABLE_ID_SHIFT))
+#define CDP_S_LUT_ACCESS_CFG_0_LUT_TABLE_ID_RANGE (16 : 16)
+#define CDP_S_LUT_ACCESS_CFG_0_LUT_TABLE_ID_WOFFSET (0x0)
+#define CDP_S_LUT_ACCESS_CFG_0_LUT_TABLE_ID_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_ACCESS_CFG_0_LUT_TABLE_ID_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CDP_S_LUT_ACCESS_CFG_0_LUT_TABLE_ID_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_ACCESS_CFG_0_LUT_TABLE_ID_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_ACCESS_CFG_0_LUT_TABLE_ID_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_ACCESS_CFG_0_LUT_TABLE_ID_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define CDP_S_LUT_ACCESS_CFG_0_LUT_TABLE_ID_LE (_MK_ENUM_CONST(0))
+#define CDP_S_LUT_ACCESS_CFG_0_LUT_TABLE_ID_LO (_MK_ENUM_CONST(1))
+
+#define CDP_S_LUT_ACCESS_CFG_0_LUT_ACCESS_TYPE_SHIFT (_MK_SHIFT_CONST(17))
+#define CDP_S_LUT_ACCESS_CFG_0_LUT_ACCESS_TYPE_FIELD \
+	(_MK_FIELD_CONST(0x1, CDP_S_LUT_ACCESS_CFG_0_LUT_ACCESS_TYPE_SHIFT))
+#define CDP_S_LUT_ACCESS_CFG_0_LUT_ACCESS_TYPE_RANGE (17 : 17)
+#define CDP_S_LUT_ACCESS_CFG_0_LUT_ACCESS_TYPE_WOFFSET (0x0)
+#define CDP_S_LUT_ACCESS_CFG_0_LUT_ACCESS_TYPE_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_ACCESS_CFG_0_LUT_ACCESS_TYPE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1))
+#define CDP_S_LUT_ACCESS_CFG_0_LUT_ACCESS_TYPE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_ACCESS_CFG_0_LUT_ACCESS_TYPE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_ACCESS_CFG_0_LUT_ACCESS_TYPE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_ACCESS_CFG_0_LUT_ACCESS_TYPE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define CDP_S_LUT_ACCESS_CFG_0_LUT_ACCESS_TYPE_READ (_MK_ENUM_CONST(0))
+#define CDP_S_LUT_ACCESS_CFG_0_LUT_ACCESS_TYPE_WRITE (_MK_ENUM_CONST(1))
+
+// Register CDP_S_LUT_ACCESS_DATA_0
+#define CDP_S_LUT_ACCESS_DATA_0 (_MK_ADDR_CONST(0xf00c))
+#define CDP_S_LUT_ACCESS_DATA_0_SECURE (0x0)
+#define CDP_S_LUT_ACCESS_DATA_0_DUAL (0x0)
+#define CDP_S_LUT_ACCESS_DATA_0_SCR (0)
+#define CDP_S_LUT_ACCESS_DATA_0_WORD_COUNT (0x1)
+#define CDP_S_LUT_ACCESS_DATA_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_ACCESS_DATA_0_RESET_MASK (_MK_MASK_CONST(0xffff))
+#define CDP_S_LUT_ACCESS_DATA_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_ACCESS_DATA_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_ACCESS_DATA_0_READ_MASK (_MK_MASK_CONST(0xffff))
+#define CDP_S_LUT_ACCESS_DATA_0_WRITE_MASK (_MK_MASK_CONST(0xffff))
+#define CDP_S_LUT_ACCESS_DATA_0_LUT_DATA_SHIFT (_MK_SHIFT_CONST(0))
+#define CDP_S_LUT_ACCESS_DATA_0_LUT_DATA_FIELD \
+	(_MK_FIELD_CONST(0xffff, CDP_S_LUT_ACCESS_DATA_0_LUT_DATA_SHIFT))
+#define CDP_S_LUT_ACCESS_DATA_0_LUT_DATA_RANGE (15 : 0)
+#define CDP_S_LUT_ACCESS_DATA_0_LUT_DATA_WOFFSET (0x0)
+#define CDP_S_LUT_ACCESS_DATA_0_LUT_DATA_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_ACCESS_DATA_0_LUT_DATA_DEFAULT_MASK (_MK_MASK_CONST(0xffff))
+#define CDP_S_LUT_ACCESS_DATA_0_LUT_DATA_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_ACCESS_DATA_0_LUT_DATA_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_ACCESS_DATA_0_LUT_DATA_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_ACCESS_DATA_0_LUT_DATA_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDP_S_LUT_CFG_0
+#define CDP_S_LUT_CFG_0 (_MK_ADDR_CONST(0xf010))
+#define CDP_S_LUT_CFG_0_SECURE (0x0)
+#define CDP_S_LUT_CFG_0_DUAL (0x0)
+#define CDP_S_LUT_CFG_0_SCR (0)
+#define CDP_S_LUT_CFG_0_WORD_COUNT (0x1)
+#define CDP_S_LUT_CFG_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_CFG_0_RESET_MASK (_MK_MASK_CONST(0x71))
+#define CDP_S_LUT_CFG_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_CFG_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_CFG_0_READ_MASK (_MK_MASK_CONST(0x71))
+#define CDP_S_LUT_CFG_0_WRITE_MASK (_MK_MASK_CONST(0x71))
+#define CDP_S_LUT_CFG_0_LUT_LE_FUNCTION_SHIFT (_MK_SHIFT_CONST(0))
+#define CDP_S_LUT_CFG_0_LUT_LE_FUNCTION_FIELD \
+	(_MK_FIELD_CONST(0x1, CDP_S_LUT_CFG_0_LUT_LE_FUNCTION_SHIFT))
+#define CDP_S_LUT_CFG_0_LUT_LE_FUNCTION_RANGE (0 : 0)
+#define CDP_S_LUT_CFG_0_LUT_LE_FUNCTION_WOFFSET (0x0)
+#define CDP_S_LUT_CFG_0_LUT_LE_FUNCTION_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_CFG_0_LUT_LE_FUNCTION_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CDP_S_LUT_CFG_0_LUT_LE_FUNCTION_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_CFG_0_LUT_LE_FUNCTION_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_CFG_0_LUT_LE_FUNCTION_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_CFG_0_LUT_LE_FUNCTION_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define CDP_S_LUT_CFG_0_LUT_LE_FUNCTION_EXPONENT (_MK_ENUM_CONST(0))
+#define CDP_S_LUT_CFG_0_LUT_LE_FUNCTION_LINEAR (_MK_ENUM_CONST(1))
+
+#define CDP_S_LUT_CFG_0_LUT_UFLOW_PRIORITY_SHIFT (_MK_SHIFT_CONST(4))
+#define CDP_S_LUT_CFG_0_LUT_UFLOW_PRIORITY_FIELD \
+	(_MK_FIELD_CONST(0x1, CDP_S_LUT_CFG_0_LUT_UFLOW_PRIORITY_SHIFT))
+#define CDP_S_LUT_CFG_0_LUT_UFLOW_PRIORITY_RANGE (4 : 4)
+#define CDP_S_LUT_CFG_0_LUT_UFLOW_PRIORITY_WOFFSET (0x0)
+#define CDP_S_LUT_CFG_0_LUT_UFLOW_PRIORITY_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_CFG_0_LUT_UFLOW_PRIORITY_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CDP_S_LUT_CFG_0_LUT_UFLOW_PRIORITY_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_CFG_0_LUT_UFLOW_PRIORITY_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_CFG_0_LUT_UFLOW_PRIORITY_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_CFG_0_LUT_UFLOW_PRIORITY_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define CDP_S_LUT_CFG_0_LUT_UFLOW_PRIORITY_LE (_MK_ENUM_CONST(0))
+#define CDP_S_LUT_CFG_0_LUT_UFLOW_PRIORITY_LO (_MK_ENUM_CONST(1))
+
+#define CDP_S_LUT_CFG_0_LUT_OFLOW_PRIORITY_SHIFT (_MK_SHIFT_CONST(5))
+#define CDP_S_LUT_CFG_0_LUT_OFLOW_PRIORITY_FIELD \
+	(_MK_FIELD_CONST(0x1, CDP_S_LUT_CFG_0_LUT_OFLOW_PRIORITY_SHIFT))
+#define CDP_S_LUT_CFG_0_LUT_OFLOW_PRIORITY_RANGE (5 : 5)
+#define CDP_S_LUT_CFG_0_LUT_OFLOW_PRIORITY_WOFFSET (0x0)
+#define CDP_S_LUT_CFG_0_LUT_OFLOW_PRIORITY_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_CFG_0_LUT_OFLOW_PRIORITY_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CDP_S_LUT_CFG_0_LUT_OFLOW_PRIORITY_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_CFG_0_LUT_OFLOW_PRIORITY_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_CFG_0_LUT_OFLOW_PRIORITY_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_CFG_0_LUT_OFLOW_PRIORITY_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define CDP_S_LUT_CFG_0_LUT_OFLOW_PRIORITY_LE (_MK_ENUM_CONST(0))
+#define CDP_S_LUT_CFG_0_LUT_OFLOW_PRIORITY_LO (_MK_ENUM_CONST(1))
+
+#define CDP_S_LUT_CFG_0_LUT_HYBRID_PRIORITY_SHIFT (_MK_SHIFT_CONST(6))
+#define CDP_S_LUT_CFG_0_LUT_HYBRID_PRIORITY_FIELD \
+	(_MK_FIELD_CONST(0x1, CDP_S_LUT_CFG_0_LUT_HYBRID_PRIORITY_SHIFT))
+#define CDP_S_LUT_CFG_0_LUT_HYBRID_PRIORITY_RANGE (6 : 6)
+#define CDP_S_LUT_CFG_0_LUT_HYBRID_PRIORITY_WOFFSET (0x0)
+#define CDP_S_LUT_CFG_0_LUT_HYBRID_PRIORITY_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_CFG_0_LUT_HYBRID_PRIORITY_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CDP_S_LUT_CFG_0_LUT_HYBRID_PRIORITY_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_CFG_0_LUT_HYBRID_PRIORITY_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_CFG_0_LUT_HYBRID_PRIORITY_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_CFG_0_LUT_HYBRID_PRIORITY_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define CDP_S_LUT_CFG_0_LUT_HYBRID_PRIORITY_LE (_MK_ENUM_CONST(0))
+#define CDP_S_LUT_CFG_0_LUT_HYBRID_PRIORITY_LO (_MK_ENUM_CONST(1))
+
+// Register CDP_S_LUT_INFO_0
+#define CDP_S_LUT_INFO_0 (_MK_ADDR_CONST(0xf014))
+#define CDP_S_LUT_INFO_0_SECURE (0x0)
+#define CDP_S_LUT_INFO_0_DUAL (0x0)
+#define CDP_S_LUT_INFO_0_SCR (0)
+#define CDP_S_LUT_INFO_0_WORD_COUNT (0x1)
+#define CDP_S_LUT_INFO_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_INFO_0_RESET_MASK (_MK_MASK_CONST(0xffffff))
+#define CDP_S_LUT_INFO_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_INFO_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_INFO_0_READ_MASK (_MK_MASK_CONST(0xffffff))
+#define CDP_S_LUT_INFO_0_WRITE_MASK (_MK_MASK_CONST(0xffffff))
+#define CDP_S_LUT_INFO_0_LUT_LE_INDEX_OFFSET_SHIFT (_MK_SHIFT_CONST(0))
+#define CDP_S_LUT_INFO_0_LUT_LE_INDEX_OFFSET_FIELD \
+	(_MK_FIELD_CONST(0xff, CDP_S_LUT_INFO_0_LUT_LE_INDEX_OFFSET_SHIFT))
+#define CDP_S_LUT_INFO_0_LUT_LE_INDEX_OFFSET_RANGE (7 : 0)
+#define CDP_S_LUT_INFO_0_LUT_LE_INDEX_OFFSET_WOFFSET (0x0)
+#define CDP_S_LUT_INFO_0_LUT_LE_INDEX_OFFSET_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_INFO_0_LUT_LE_INDEX_OFFSET_DEFAULT_MASK (_MK_MASK_CONST(0xff))
+#define CDP_S_LUT_INFO_0_LUT_LE_INDEX_OFFSET_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_INFO_0_LUT_LE_INDEX_OFFSET_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_INFO_0_LUT_LE_INDEX_OFFSET_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_INFO_0_LUT_LE_INDEX_OFFSET_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define CDP_S_LUT_INFO_0_LUT_LE_INDEX_SELECT_SHIFT (_MK_SHIFT_CONST(8))
+#define CDP_S_LUT_INFO_0_LUT_LE_INDEX_SELECT_FIELD \
+	(_MK_FIELD_CONST(0xff, CDP_S_LUT_INFO_0_LUT_LE_INDEX_SELECT_SHIFT))
+#define CDP_S_LUT_INFO_0_LUT_LE_INDEX_SELECT_RANGE (15 : 8)
+#define CDP_S_LUT_INFO_0_LUT_LE_INDEX_SELECT_WOFFSET (0x0)
+#define CDP_S_LUT_INFO_0_LUT_LE_INDEX_SELECT_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_INFO_0_LUT_LE_INDEX_SELECT_DEFAULT_MASK (_MK_MASK_CONST(0xff))
+#define CDP_S_LUT_INFO_0_LUT_LE_INDEX_SELECT_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_INFO_0_LUT_LE_INDEX_SELECT_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_INFO_0_LUT_LE_INDEX_SELECT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_INFO_0_LUT_LE_INDEX_SELECT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define CDP_S_LUT_INFO_0_LUT_LO_INDEX_SELECT_SHIFT (_MK_SHIFT_CONST(16))
+#define CDP_S_LUT_INFO_0_LUT_LO_INDEX_SELECT_FIELD \
+	(_MK_FIELD_CONST(0xff, CDP_S_LUT_INFO_0_LUT_LO_INDEX_SELECT_SHIFT))
+#define CDP_S_LUT_INFO_0_LUT_LO_INDEX_SELECT_RANGE (23 : 16)
+#define CDP_S_LUT_INFO_0_LUT_LO_INDEX_SELECT_WOFFSET (0x0)
+#define CDP_S_LUT_INFO_0_LUT_LO_INDEX_SELECT_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_INFO_0_LUT_LO_INDEX_SELECT_DEFAULT_MASK (_MK_MASK_CONST(0xff))
+#define CDP_S_LUT_INFO_0_LUT_LO_INDEX_SELECT_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_INFO_0_LUT_LO_INDEX_SELECT_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_INFO_0_LUT_LO_INDEX_SELECT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_INFO_0_LUT_LO_INDEX_SELECT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDP_S_LUT_LE_START_LOW_0
+#define CDP_S_LUT_LE_START_LOW_0 (_MK_ADDR_CONST(0xf018))
+#define CDP_S_LUT_LE_START_LOW_0_SECURE (0x0)
+#define CDP_S_LUT_LE_START_LOW_0_DUAL (0x0)
+#define CDP_S_LUT_LE_START_LOW_0_SCR (0)
+#define CDP_S_LUT_LE_START_LOW_0_WORD_COUNT (0x1)
+#define CDP_S_LUT_LE_START_LOW_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LE_START_LOW_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDP_S_LUT_LE_START_LOW_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LE_START_LOW_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LE_START_LOW_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDP_S_LUT_LE_START_LOW_0_WRITE_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDP_S_LUT_LE_START_LOW_0_LUT_LE_START_LOW_SHIFT (_MK_SHIFT_CONST(0))
+#define CDP_S_LUT_LE_START_LOW_0_LUT_LE_START_LOW_FIELD \
+	(_MK_FIELD_CONST(0xffffffff,                    \
+			 CDP_S_LUT_LE_START_LOW_0_LUT_LE_START_LOW_SHIFT))
+#define CDP_S_LUT_LE_START_LOW_0_LUT_LE_START_LOW_RANGE (31 : 0)
+#define CDP_S_LUT_LE_START_LOW_0_LUT_LE_START_LOW_WOFFSET (0x0)
+#define CDP_S_LUT_LE_START_LOW_0_LUT_LE_START_LOW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LE_START_LOW_0_LUT_LE_START_LOW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define CDP_S_LUT_LE_START_LOW_0_LUT_LE_START_LOW_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LE_START_LOW_0_LUT_LE_START_LOW_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LE_START_LOW_0_LUT_LE_START_LOW_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LE_START_LOW_0_LUT_LE_START_LOW_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDP_S_LUT_LE_START_HIGH_0
+#define CDP_S_LUT_LE_START_HIGH_0 (_MK_ADDR_CONST(0xf01c))
+#define CDP_S_LUT_LE_START_HIGH_0_SECURE (0x0)
+#define CDP_S_LUT_LE_START_HIGH_0_DUAL (0x0)
+#define CDP_S_LUT_LE_START_HIGH_0_SCR (0)
+#define CDP_S_LUT_LE_START_HIGH_0_WORD_COUNT (0x1)
+#define CDP_S_LUT_LE_START_HIGH_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LE_START_HIGH_0_RESET_MASK (_MK_MASK_CONST(0x3f))
+#define CDP_S_LUT_LE_START_HIGH_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LE_START_HIGH_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LE_START_HIGH_0_READ_MASK (_MK_MASK_CONST(0x3f))
+#define CDP_S_LUT_LE_START_HIGH_0_WRITE_MASK (_MK_MASK_CONST(0x3f))
+#define CDP_S_LUT_LE_START_HIGH_0_LUT_LE_START_HIGH_SHIFT (_MK_SHIFT_CONST(0))
+#define CDP_S_LUT_LE_START_HIGH_0_LUT_LE_START_HIGH_FIELD \
+	(_MK_FIELD_CONST(0x3f,                            \
+			 CDP_S_LUT_LE_START_HIGH_0_LUT_LE_START_HIGH_SHIFT))
+#define CDP_S_LUT_LE_START_HIGH_0_LUT_LE_START_HIGH_RANGE (5 : 0)
+#define CDP_S_LUT_LE_START_HIGH_0_LUT_LE_START_HIGH_WOFFSET (0x0)
+#define CDP_S_LUT_LE_START_HIGH_0_LUT_LE_START_HIGH_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LE_START_HIGH_0_LUT_LE_START_HIGH_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x3f))
+#define CDP_S_LUT_LE_START_HIGH_0_LUT_LE_START_HIGH_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LE_START_HIGH_0_LUT_LE_START_HIGH_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LE_START_HIGH_0_LUT_LE_START_HIGH_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LE_START_HIGH_0_LUT_LE_START_HIGH_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDP_S_LUT_LE_END_LOW_0
+#define CDP_S_LUT_LE_END_LOW_0 (_MK_ADDR_CONST(0xf020))
+#define CDP_S_LUT_LE_END_LOW_0_SECURE (0x0)
+#define CDP_S_LUT_LE_END_LOW_0_DUAL (0x0)
+#define CDP_S_LUT_LE_END_LOW_0_SCR (0)
+#define CDP_S_LUT_LE_END_LOW_0_WORD_COUNT (0x1)
+#define CDP_S_LUT_LE_END_LOW_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LE_END_LOW_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDP_S_LUT_LE_END_LOW_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LE_END_LOW_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LE_END_LOW_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDP_S_LUT_LE_END_LOW_0_WRITE_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDP_S_LUT_LE_END_LOW_0_LUT_LE_END_LOW_SHIFT (_MK_SHIFT_CONST(0))
+#define CDP_S_LUT_LE_END_LOW_0_LUT_LE_END_LOW_FIELD \
+	(_MK_FIELD_CONST(0xffffffff,                \
+			 CDP_S_LUT_LE_END_LOW_0_LUT_LE_END_LOW_SHIFT))
+#define CDP_S_LUT_LE_END_LOW_0_LUT_LE_END_LOW_RANGE (31 : 0)
+#define CDP_S_LUT_LE_END_LOW_0_LUT_LE_END_LOW_WOFFSET (0x0)
+#define CDP_S_LUT_LE_END_LOW_0_LUT_LE_END_LOW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LE_END_LOW_0_LUT_LE_END_LOW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define CDP_S_LUT_LE_END_LOW_0_LUT_LE_END_LOW_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LE_END_LOW_0_LUT_LE_END_LOW_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LE_END_LOW_0_LUT_LE_END_LOW_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LE_END_LOW_0_LUT_LE_END_LOW_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDP_S_LUT_LE_END_HIGH_0
+#define CDP_S_LUT_LE_END_HIGH_0 (_MK_ADDR_CONST(0xf024))
+#define CDP_S_LUT_LE_END_HIGH_0_SECURE (0x0)
+#define CDP_S_LUT_LE_END_HIGH_0_DUAL (0x0)
+#define CDP_S_LUT_LE_END_HIGH_0_SCR (0)
+#define CDP_S_LUT_LE_END_HIGH_0_WORD_COUNT (0x1)
+#define CDP_S_LUT_LE_END_HIGH_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LE_END_HIGH_0_RESET_MASK (_MK_MASK_CONST(0x3f))
+#define CDP_S_LUT_LE_END_HIGH_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LE_END_HIGH_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LE_END_HIGH_0_READ_MASK (_MK_MASK_CONST(0x3f))
+#define CDP_S_LUT_LE_END_HIGH_0_WRITE_MASK (_MK_MASK_CONST(0x3f))
+#define CDP_S_LUT_LE_END_HIGH_0_LUT_LE_END_HIGH_SHIFT (_MK_SHIFT_CONST(0))
+#define CDP_S_LUT_LE_END_HIGH_0_LUT_LE_END_HIGH_FIELD \
+	(_MK_FIELD_CONST(0x3f, CDP_S_LUT_LE_END_HIGH_0_LUT_LE_END_HIGH_SHIFT))
+#define CDP_S_LUT_LE_END_HIGH_0_LUT_LE_END_HIGH_RANGE (5 : 0)
+#define CDP_S_LUT_LE_END_HIGH_0_LUT_LE_END_HIGH_WOFFSET (0x0)
+#define CDP_S_LUT_LE_END_HIGH_0_LUT_LE_END_HIGH_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LE_END_HIGH_0_LUT_LE_END_HIGH_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x3f))
+#define CDP_S_LUT_LE_END_HIGH_0_LUT_LE_END_HIGH_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LE_END_HIGH_0_LUT_LE_END_HIGH_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LE_END_HIGH_0_LUT_LE_END_HIGH_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LE_END_HIGH_0_LUT_LE_END_HIGH_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDP_S_LUT_LO_START_LOW_0
+#define CDP_S_LUT_LO_START_LOW_0 (_MK_ADDR_CONST(0xf028))
+#define CDP_S_LUT_LO_START_LOW_0_SECURE (0x0)
+#define CDP_S_LUT_LO_START_LOW_0_DUAL (0x0)
+#define CDP_S_LUT_LO_START_LOW_0_SCR (0)
+#define CDP_S_LUT_LO_START_LOW_0_WORD_COUNT (0x1)
+#define CDP_S_LUT_LO_START_LOW_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LO_START_LOW_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDP_S_LUT_LO_START_LOW_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LO_START_LOW_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LO_START_LOW_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDP_S_LUT_LO_START_LOW_0_WRITE_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDP_S_LUT_LO_START_LOW_0_LUT_LO_START_LOW_SHIFT (_MK_SHIFT_CONST(0))
+#define CDP_S_LUT_LO_START_LOW_0_LUT_LO_START_LOW_FIELD \
+	(_MK_FIELD_CONST(0xffffffff,                    \
+			 CDP_S_LUT_LO_START_LOW_0_LUT_LO_START_LOW_SHIFT))
+#define CDP_S_LUT_LO_START_LOW_0_LUT_LO_START_LOW_RANGE (31 : 0)
+#define CDP_S_LUT_LO_START_LOW_0_LUT_LO_START_LOW_WOFFSET (0x0)
+#define CDP_S_LUT_LO_START_LOW_0_LUT_LO_START_LOW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LO_START_LOW_0_LUT_LO_START_LOW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define CDP_S_LUT_LO_START_LOW_0_LUT_LO_START_LOW_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LO_START_LOW_0_LUT_LO_START_LOW_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LO_START_LOW_0_LUT_LO_START_LOW_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LO_START_LOW_0_LUT_LO_START_LOW_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDP_S_LUT_LO_START_HIGH_0
+#define CDP_S_LUT_LO_START_HIGH_0 (_MK_ADDR_CONST(0xf02c))
+#define CDP_S_LUT_LO_START_HIGH_0_SECURE (0x0)
+#define CDP_S_LUT_LO_START_HIGH_0_DUAL (0x0)
+#define CDP_S_LUT_LO_START_HIGH_0_SCR (0)
+#define CDP_S_LUT_LO_START_HIGH_0_WORD_COUNT (0x1)
+#define CDP_S_LUT_LO_START_HIGH_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LO_START_HIGH_0_RESET_MASK (_MK_MASK_CONST(0x3f))
+#define CDP_S_LUT_LO_START_HIGH_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LO_START_HIGH_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LO_START_HIGH_0_READ_MASK (_MK_MASK_CONST(0x3f))
+#define CDP_S_LUT_LO_START_HIGH_0_WRITE_MASK (_MK_MASK_CONST(0x3f))
+#define CDP_S_LUT_LO_START_HIGH_0_LUT_LO_START_HIGH_SHIFT (_MK_SHIFT_CONST(0))
+#define CDP_S_LUT_LO_START_HIGH_0_LUT_LO_START_HIGH_FIELD \
+	(_MK_FIELD_CONST(0x3f,                            \
+			 CDP_S_LUT_LO_START_HIGH_0_LUT_LO_START_HIGH_SHIFT))
+#define CDP_S_LUT_LO_START_HIGH_0_LUT_LO_START_HIGH_RANGE (5 : 0)
+#define CDP_S_LUT_LO_START_HIGH_0_LUT_LO_START_HIGH_WOFFSET (0x0)
+#define CDP_S_LUT_LO_START_HIGH_0_LUT_LO_START_HIGH_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LO_START_HIGH_0_LUT_LO_START_HIGH_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x3f))
+#define CDP_S_LUT_LO_START_HIGH_0_LUT_LO_START_HIGH_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LO_START_HIGH_0_LUT_LO_START_HIGH_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LO_START_HIGH_0_LUT_LO_START_HIGH_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LO_START_HIGH_0_LUT_LO_START_HIGH_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDP_S_LUT_LO_END_LOW_0
+#define CDP_S_LUT_LO_END_LOW_0 (_MK_ADDR_CONST(0xf030))
+#define CDP_S_LUT_LO_END_LOW_0_SECURE (0x0)
+#define CDP_S_LUT_LO_END_LOW_0_DUAL (0x0)
+#define CDP_S_LUT_LO_END_LOW_0_SCR (0)
+#define CDP_S_LUT_LO_END_LOW_0_WORD_COUNT (0x1)
+#define CDP_S_LUT_LO_END_LOW_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LO_END_LOW_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDP_S_LUT_LO_END_LOW_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LO_END_LOW_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LO_END_LOW_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDP_S_LUT_LO_END_LOW_0_WRITE_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDP_S_LUT_LO_END_LOW_0_LUT_LO_END_LOW_SHIFT (_MK_SHIFT_CONST(0))
+#define CDP_S_LUT_LO_END_LOW_0_LUT_LO_END_LOW_FIELD \
+	(_MK_FIELD_CONST(0xffffffff,                \
+			 CDP_S_LUT_LO_END_LOW_0_LUT_LO_END_LOW_SHIFT))
+#define CDP_S_LUT_LO_END_LOW_0_LUT_LO_END_LOW_RANGE (31 : 0)
+#define CDP_S_LUT_LO_END_LOW_0_LUT_LO_END_LOW_WOFFSET (0x0)
+#define CDP_S_LUT_LO_END_LOW_0_LUT_LO_END_LOW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LO_END_LOW_0_LUT_LO_END_LOW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define CDP_S_LUT_LO_END_LOW_0_LUT_LO_END_LOW_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LO_END_LOW_0_LUT_LO_END_LOW_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LO_END_LOW_0_LUT_LO_END_LOW_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LO_END_LOW_0_LUT_LO_END_LOW_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDP_S_LUT_LO_END_HIGH_0
+#define CDP_S_LUT_LO_END_HIGH_0 (_MK_ADDR_CONST(0xf034))
+#define CDP_S_LUT_LO_END_HIGH_0_SECURE (0x0)
+#define CDP_S_LUT_LO_END_HIGH_0_DUAL (0x0)
+#define CDP_S_LUT_LO_END_HIGH_0_SCR (0)
+#define CDP_S_LUT_LO_END_HIGH_0_WORD_COUNT (0x1)
+#define CDP_S_LUT_LO_END_HIGH_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LO_END_HIGH_0_RESET_MASK (_MK_MASK_CONST(0x3f))
+#define CDP_S_LUT_LO_END_HIGH_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LO_END_HIGH_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LO_END_HIGH_0_READ_MASK (_MK_MASK_CONST(0x3f))
+#define CDP_S_LUT_LO_END_HIGH_0_WRITE_MASK (_MK_MASK_CONST(0x3f))
+#define CDP_S_LUT_LO_END_HIGH_0_LUT_LO_END_HIGH_SHIFT (_MK_SHIFT_CONST(0))
+#define CDP_S_LUT_LO_END_HIGH_0_LUT_LO_END_HIGH_FIELD \
+	(_MK_FIELD_CONST(0x3f, CDP_S_LUT_LO_END_HIGH_0_LUT_LO_END_HIGH_SHIFT))
+#define CDP_S_LUT_LO_END_HIGH_0_LUT_LO_END_HIGH_RANGE (5 : 0)
+#define CDP_S_LUT_LO_END_HIGH_0_LUT_LO_END_HIGH_WOFFSET (0x0)
+#define CDP_S_LUT_LO_END_HIGH_0_LUT_LO_END_HIGH_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LO_END_HIGH_0_LUT_LO_END_HIGH_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x3f))
+#define CDP_S_LUT_LO_END_HIGH_0_LUT_LO_END_HIGH_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LO_END_HIGH_0_LUT_LO_END_HIGH_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LO_END_HIGH_0_LUT_LO_END_HIGH_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LO_END_HIGH_0_LUT_LO_END_HIGH_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDP_S_LUT_LE_SLOPE_SCALE_0
+#define CDP_S_LUT_LE_SLOPE_SCALE_0 (_MK_ADDR_CONST(0xf038))
+#define CDP_S_LUT_LE_SLOPE_SCALE_0_SECURE (0x0)
+#define CDP_S_LUT_LE_SLOPE_SCALE_0_DUAL (0x0)
+#define CDP_S_LUT_LE_SLOPE_SCALE_0_SCR (0)
+#define CDP_S_LUT_LE_SLOPE_SCALE_0_WORD_COUNT (0x1)
+#define CDP_S_LUT_LE_SLOPE_SCALE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LE_SLOPE_SCALE_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDP_S_LUT_LE_SLOPE_SCALE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LE_SLOPE_SCALE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LE_SLOPE_SCALE_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDP_S_LUT_LE_SLOPE_SCALE_0_WRITE_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDP_S_LUT_LE_SLOPE_SCALE_0_LUT_LE_SLOPE_UFLOW_SCALE_SHIFT \
+	(_MK_SHIFT_CONST(0))
+#define CDP_S_LUT_LE_SLOPE_SCALE_0_LUT_LE_SLOPE_UFLOW_SCALE_FIELD \
+	(_MK_FIELD_CONST(                                         \
+		0xffff,                                           \
+		CDP_S_LUT_LE_SLOPE_SCALE_0_LUT_LE_SLOPE_UFLOW_SCALE_SHIFT))
+#define CDP_S_LUT_LE_SLOPE_SCALE_0_LUT_LE_SLOPE_UFLOW_SCALE_RANGE (15 : 0)
+#define CDP_S_LUT_LE_SLOPE_SCALE_0_LUT_LE_SLOPE_UFLOW_SCALE_WOFFSET (0x0)
+#define CDP_S_LUT_LE_SLOPE_SCALE_0_LUT_LE_SLOPE_UFLOW_SCALE_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LE_SLOPE_SCALE_0_LUT_LE_SLOPE_UFLOW_SCALE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffff))
+#define CDP_S_LUT_LE_SLOPE_SCALE_0_LUT_LE_SLOPE_UFLOW_SCALE_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LE_SLOPE_SCALE_0_LUT_LE_SLOPE_UFLOW_SCALE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LE_SLOPE_SCALE_0_LUT_LE_SLOPE_UFLOW_SCALE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LE_SLOPE_SCALE_0_LUT_LE_SLOPE_UFLOW_SCALE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define CDP_S_LUT_LE_SLOPE_SCALE_0_LUT_LE_SLOPE_OFLOW_SCALE_SHIFT \
+	(_MK_SHIFT_CONST(16))
+#define CDP_S_LUT_LE_SLOPE_SCALE_0_LUT_LE_SLOPE_OFLOW_SCALE_FIELD \
+	(_MK_FIELD_CONST(                                         \
+		0xffff,                                           \
+		CDP_S_LUT_LE_SLOPE_SCALE_0_LUT_LE_SLOPE_OFLOW_SCALE_SHIFT))
+#define CDP_S_LUT_LE_SLOPE_SCALE_0_LUT_LE_SLOPE_OFLOW_SCALE_RANGE (31 : 16)
+#define CDP_S_LUT_LE_SLOPE_SCALE_0_LUT_LE_SLOPE_OFLOW_SCALE_WOFFSET (0x0)
+#define CDP_S_LUT_LE_SLOPE_SCALE_0_LUT_LE_SLOPE_OFLOW_SCALE_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LE_SLOPE_SCALE_0_LUT_LE_SLOPE_OFLOW_SCALE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffff))
+#define CDP_S_LUT_LE_SLOPE_SCALE_0_LUT_LE_SLOPE_OFLOW_SCALE_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LE_SLOPE_SCALE_0_LUT_LE_SLOPE_OFLOW_SCALE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LE_SLOPE_SCALE_0_LUT_LE_SLOPE_OFLOW_SCALE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LE_SLOPE_SCALE_0_LUT_LE_SLOPE_OFLOW_SCALE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDP_S_LUT_LE_SLOPE_SHIFT_0
+#define CDP_S_LUT_LE_SLOPE_SHIFT_0 (_MK_ADDR_CONST(0xf03c))
+#define CDP_S_LUT_LE_SLOPE_SHIFT_0_SECURE (0x0)
+#define CDP_S_LUT_LE_SLOPE_SHIFT_0_DUAL (0x0)
+#define CDP_S_LUT_LE_SLOPE_SHIFT_0_SCR (0)
+#define CDP_S_LUT_LE_SLOPE_SHIFT_0_WORD_COUNT (0x1)
+#define CDP_S_LUT_LE_SLOPE_SHIFT_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LE_SLOPE_SHIFT_0_RESET_MASK (_MK_MASK_CONST(0x3ff))
+#define CDP_S_LUT_LE_SLOPE_SHIFT_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LE_SLOPE_SHIFT_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LE_SLOPE_SHIFT_0_READ_MASK (_MK_MASK_CONST(0x3ff))
+#define CDP_S_LUT_LE_SLOPE_SHIFT_0_WRITE_MASK (_MK_MASK_CONST(0x3ff))
+#define CDP_S_LUT_LE_SLOPE_SHIFT_0_LUT_LE_SLOPE_UFLOW_SHIFT_SHIFT \
+	(_MK_SHIFT_CONST(0))
+#define CDP_S_LUT_LE_SLOPE_SHIFT_0_LUT_LE_SLOPE_UFLOW_SHIFT_FIELD \
+	(_MK_FIELD_CONST(                                         \
+		0x1f,                                             \
+		CDP_S_LUT_LE_SLOPE_SHIFT_0_LUT_LE_SLOPE_UFLOW_SHIFT_SHIFT))
+#define CDP_S_LUT_LE_SLOPE_SHIFT_0_LUT_LE_SLOPE_UFLOW_SHIFT_RANGE (4 : 0)
+#define CDP_S_LUT_LE_SLOPE_SHIFT_0_LUT_LE_SLOPE_UFLOW_SHIFT_WOFFSET (0x0)
+#define CDP_S_LUT_LE_SLOPE_SHIFT_0_LUT_LE_SLOPE_UFLOW_SHIFT_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LE_SLOPE_SHIFT_0_LUT_LE_SLOPE_UFLOW_SHIFT_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1f))
+#define CDP_S_LUT_LE_SLOPE_SHIFT_0_LUT_LE_SLOPE_UFLOW_SHIFT_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LE_SLOPE_SHIFT_0_LUT_LE_SLOPE_UFLOW_SHIFT_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LE_SLOPE_SHIFT_0_LUT_LE_SLOPE_UFLOW_SHIFT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LE_SLOPE_SHIFT_0_LUT_LE_SLOPE_UFLOW_SHIFT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define CDP_S_LUT_LE_SLOPE_SHIFT_0_LUT_LE_SLOPE_OFLOW_SHIFT_SHIFT \
+	(_MK_SHIFT_CONST(5))
+#define CDP_S_LUT_LE_SLOPE_SHIFT_0_LUT_LE_SLOPE_OFLOW_SHIFT_FIELD \
+	(_MK_FIELD_CONST(                                         \
+		0x1f,                                             \
+		CDP_S_LUT_LE_SLOPE_SHIFT_0_LUT_LE_SLOPE_OFLOW_SHIFT_SHIFT))
+#define CDP_S_LUT_LE_SLOPE_SHIFT_0_LUT_LE_SLOPE_OFLOW_SHIFT_RANGE (9 : 5)
+#define CDP_S_LUT_LE_SLOPE_SHIFT_0_LUT_LE_SLOPE_OFLOW_SHIFT_WOFFSET (0x0)
+#define CDP_S_LUT_LE_SLOPE_SHIFT_0_LUT_LE_SLOPE_OFLOW_SHIFT_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LE_SLOPE_SHIFT_0_LUT_LE_SLOPE_OFLOW_SHIFT_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1f))
+#define CDP_S_LUT_LE_SLOPE_SHIFT_0_LUT_LE_SLOPE_OFLOW_SHIFT_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LE_SLOPE_SHIFT_0_LUT_LE_SLOPE_OFLOW_SHIFT_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LE_SLOPE_SHIFT_0_LUT_LE_SLOPE_OFLOW_SHIFT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LE_SLOPE_SHIFT_0_LUT_LE_SLOPE_OFLOW_SHIFT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDP_S_LUT_LO_SLOPE_SCALE_0
+#define CDP_S_LUT_LO_SLOPE_SCALE_0 (_MK_ADDR_CONST(0xf040))
+#define CDP_S_LUT_LO_SLOPE_SCALE_0_SECURE (0x0)
+#define CDP_S_LUT_LO_SLOPE_SCALE_0_DUAL (0x0)
+#define CDP_S_LUT_LO_SLOPE_SCALE_0_SCR (0)
+#define CDP_S_LUT_LO_SLOPE_SCALE_0_WORD_COUNT (0x1)
+#define CDP_S_LUT_LO_SLOPE_SCALE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LO_SLOPE_SCALE_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDP_S_LUT_LO_SLOPE_SCALE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LO_SLOPE_SCALE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LO_SLOPE_SCALE_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDP_S_LUT_LO_SLOPE_SCALE_0_WRITE_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDP_S_LUT_LO_SLOPE_SCALE_0_LUT_LO_SLOPE_UFLOW_SCALE_SHIFT \
+	(_MK_SHIFT_CONST(0))
+#define CDP_S_LUT_LO_SLOPE_SCALE_0_LUT_LO_SLOPE_UFLOW_SCALE_FIELD \
+	(_MK_FIELD_CONST(                                         \
+		0xffff,                                           \
+		CDP_S_LUT_LO_SLOPE_SCALE_0_LUT_LO_SLOPE_UFLOW_SCALE_SHIFT))
+#define CDP_S_LUT_LO_SLOPE_SCALE_0_LUT_LO_SLOPE_UFLOW_SCALE_RANGE (15 : 0)
+#define CDP_S_LUT_LO_SLOPE_SCALE_0_LUT_LO_SLOPE_UFLOW_SCALE_WOFFSET (0x0)
+#define CDP_S_LUT_LO_SLOPE_SCALE_0_LUT_LO_SLOPE_UFLOW_SCALE_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LO_SLOPE_SCALE_0_LUT_LO_SLOPE_UFLOW_SCALE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffff))
+#define CDP_S_LUT_LO_SLOPE_SCALE_0_LUT_LO_SLOPE_UFLOW_SCALE_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LO_SLOPE_SCALE_0_LUT_LO_SLOPE_UFLOW_SCALE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LO_SLOPE_SCALE_0_LUT_LO_SLOPE_UFLOW_SCALE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LO_SLOPE_SCALE_0_LUT_LO_SLOPE_UFLOW_SCALE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define CDP_S_LUT_LO_SLOPE_SCALE_0_LUT_LO_SLOPE_OFLOW_SCALE_SHIFT \
+	(_MK_SHIFT_CONST(16))
+#define CDP_S_LUT_LO_SLOPE_SCALE_0_LUT_LO_SLOPE_OFLOW_SCALE_FIELD \
+	(_MK_FIELD_CONST(                                         \
+		0xffff,                                           \
+		CDP_S_LUT_LO_SLOPE_SCALE_0_LUT_LO_SLOPE_OFLOW_SCALE_SHIFT))
+#define CDP_S_LUT_LO_SLOPE_SCALE_0_LUT_LO_SLOPE_OFLOW_SCALE_RANGE (31 : 16)
+#define CDP_S_LUT_LO_SLOPE_SCALE_0_LUT_LO_SLOPE_OFLOW_SCALE_WOFFSET (0x0)
+#define CDP_S_LUT_LO_SLOPE_SCALE_0_LUT_LO_SLOPE_OFLOW_SCALE_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LO_SLOPE_SCALE_0_LUT_LO_SLOPE_OFLOW_SCALE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffff))
+#define CDP_S_LUT_LO_SLOPE_SCALE_0_LUT_LO_SLOPE_OFLOW_SCALE_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LO_SLOPE_SCALE_0_LUT_LO_SLOPE_OFLOW_SCALE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LO_SLOPE_SCALE_0_LUT_LO_SLOPE_OFLOW_SCALE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LO_SLOPE_SCALE_0_LUT_LO_SLOPE_OFLOW_SCALE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDP_S_LUT_LO_SLOPE_SHIFT_0
+#define CDP_S_LUT_LO_SLOPE_SHIFT_0 (_MK_ADDR_CONST(0xf044))
+#define CDP_S_LUT_LO_SLOPE_SHIFT_0_SECURE (0x0)
+#define CDP_S_LUT_LO_SLOPE_SHIFT_0_DUAL (0x0)
+#define CDP_S_LUT_LO_SLOPE_SHIFT_0_SCR (0)
+#define CDP_S_LUT_LO_SLOPE_SHIFT_0_WORD_COUNT (0x1)
+#define CDP_S_LUT_LO_SLOPE_SHIFT_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LO_SLOPE_SHIFT_0_RESET_MASK (_MK_MASK_CONST(0x3ff))
+#define CDP_S_LUT_LO_SLOPE_SHIFT_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LO_SLOPE_SHIFT_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LO_SLOPE_SHIFT_0_READ_MASK (_MK_MASK_CONST(0x3ff))
+#define CDP_S_LUT_LO_SLOPE_SHIFT_0_WRITE_MASK (_MK_MASK_CONST(0x3ff))
+#define CDP_S_LUT_LO_SLOPE_SHIFT_0_LUT_LO_SLOPE_UFLOW_SHIFT_SHIFT \
+	(_MK_SHIFT_CONST(0))
+#define CDP_S_LUT_LO_SLOPE_SHIFT_0_LUT_LO_SLOPE_UFLOW_SHIFT_FIELD \
+	(_MK_FIELD_CONST(                                         \
+		0x1f,                                             \
+		CDP_S_LUT_LO_SLOPE_SHIFT_0_LUT_LO_SLOPE_UFLOW_SHIFT_SHIFT))
+#define CDP_S_LUT_LO_SLOPE_SHIFT_0_LUT_LO_SLOPE_UFLOW_SHIFT_RANGE (4 : 0)
+#define CDP_S_LUT_LO_SLOPE_SHIFT_0_LUT_LO_SLOPE_UFLOW_SHIFT_WOFFSET (0x0)
+#define CDP_S_LUT_LO_SLOPE_SHIFT_0_LUT_LO_SLOPE_UFLOW_SHIFT_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LO_SLOPE_SHIFT_0_LUT_LO_SLOPE_UFLOW_SHIFT_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1f))
+#define CDP_S_LUT_LO_SLOPE_SHIFT_0_LUT_LO_SLOPE_UFLOW_SHIFT_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LO_SLOPE_SHIFT_0_LUT_LO_SLOPE_UFLOW_SHIFT_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LO_SLOPE_SHIFT_0_LUT_LO_SLOPE_UFLOW_SHIFT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LO_SLOPE_SHIFT_0_LUT_LO_SLOPE_UFLOW_SHIFT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define CDP_S_LUT_LO_SLOPE_SHIFT_0_LUT_LO_SLOPE_OFLOW_SHIFT_SHIFT \
+	(_MK_SHIFT_CONST(5))
+#define CDP_S_LUT_LO_SLOPE_SHIFT_0_LUT_LO_SLOPE_OFLOW_SHIFT_FIELD \
+	(_MK_FIELD_CONST(                                         \
+		0x1f,                                             \
+		CDP_S_LUT_LO_SLOPE_SHIFT_0_LUT_LO_SLOPE_OFLOW_SHIFT_SHIFT))
+#define CDP_S_LUT_LO_SLOPE_SHIFT_0_LUT_LO_SLOPE_OFLOW_SHIFT_RANGE (9 : 5)
+#define CDP_S_LUT_LO_SLOPE_SHIFT_0_LUT_LO_SLOPE_OFLOW_SHIFT_WOFFSET (0x0)
+#define CDP_S_LUT_LO_SLOPE_SHIFT_0_LUT_LO_SLOPE_OFLOW_SHIFT_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LO_SLOPE_SHIFT_0_LUT_LO_SLOPE_OFLOW_SHIFT_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1f))
+#define CDP_S_LUT_LO_SLOPE_SHIFT_0_LUT_LO_SLOPE_OFLOW_SHIFT_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LO_SLOPE_SHIFT_0_LUT_LO_SLOPE_OFLOW_SHIFT_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LO_SLOPE_SHIFT_0_LUT_LO_SLOPE_OFLOW_SHIFT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDP_S_LUT_LO_SLOPE_SHIFT_0_LUT_LO_SLOPE_OFLOW_SHIFT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDP_D_OP_ENABLE_0
+#define CDP_D_OP_ENABLE_0 (_MK_ADDR_CONST(0xf048))
+#define CDP_D_OP_ENABLE_0_SECURE (0x0)
+#define CDP_D_OP_ENABLE_0_DUAL (0x0)
+#define CDP_D_OP_ENABLE_0_SCR (0)
+#define CDP_D_OP_ENABLE_0_WORD_COUNT (0x1)
+#define CDP_D_OP_ENABLE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_D_OP_ENABLE_0_RESET_MASK (_MK_MASK_CONST(0x1))
+#define CDP_D_OP_ENABLE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_D_OP_ENABLE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_D_OP_ENABLE_0_READ_MASK (_MK_MASK_CONST(0x1))
+#define CDP_D_OP_ENABLE_0_WRITE_MASK (_MK_MASK_CONST(0x1))
+#define CDP_D_OP_ENABLE_0_OP_EN_SHIFT (_MK_SHIFT_CONST(0))
+#define CDP_D_OP_ENABLE_0_OP_EN_FIELD \
+	(_MK_FIELD_CONST(0x1, CDP_D_OP_ENABLE_0_OP_EN_SHIFT))
+#define CDP_D_OP_ENABLE_0_OP_EN_RANGE (0 : 0)
+#define CDP_D_OP_ENABLE_0_OP_EN_WOFFSET (0x0)
+#define CDP_D_OP_ENABLE_0_OP_EN_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_D_OP_ENABLE_0_OP_EN_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CDP_D_OP_ENABLE_0_OP_EN_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_D_OP_ENABLE_0_OP_EN_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_D_OP_ENABLE_0_OP_EN_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDP_D_OP_ENABLE_0_OP_EN_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define CDP_D_OP_ENABLE_0_OP_EN_INIT_ENUM (DISABLE)
+#define CDP_D_OP_ENABLE_0_OP_EN_DISABLE (_MK_ENUM_CONST(0))
+#define CDP_D_OP_ENABLE_0_OP_EN_ENABLE (_MK_ENUM_CONST(1))
+
+// Register CDP_D_FUNC_BYPASS_0
+#define CDP_D_FUNC_BYPASS_0 (_MK_ADDR_CONST(0xf04c))
+#define CDP_D_FUNC_BYPASS_0_SECURE (0x0)
+#define CDP_D_FUNC_BYPASS_0_DUAL (0x0)
+#define CDP_D_FUNC_BYPASS_0_SCR (0)
+#define CDP_D_FUNC_BYPASS_0_WORD_COUNT (0x1)
+#define CDP_D_FUNC_BYPASS_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_D_FUNC_BYPASS_0_RESET_MASK (_MK_MASK_CONST(0x3))
+#define CDP_D_FUNC_BYPASS_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_D_FUNC_BYPASS_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_D_FUNC_BYPASS_0_READ_MASK (_MK_MASK_CONST(0x3))
+#define CDP_D_FUNC_BYPASS_0_WRITE_MASK (_MK_MASK_CONST(0x3))
+#define CDP_D_FUNC_BYPASS_0_SQSUM_BYPASS_SHIFT (_MK_SHIFT_CONST(0))
+#define CDP_D_FUNC_BYPASS_0_SQSUM_BYPASS_FIELD \
+	(_MK_FIELD_CONST(0x1, CDP_D_FUNC_BYPASS_0_SQSUM_BYPASS_SHIFT))
+#define CDP_D_FUNC_BYPASS_0_SQSUM_BYPASS_RANGE (0 : 0)
+#define CDP_D_FUNC_BYPASS_0_SQSUM_BYPASS_WOFFSET (0x0)
+#define CDP_D_FUNC_BYPASS_0_SQSUM_BYPASS_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_D_FUNC_BYPASS_0_SQSUM_BYPASS_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CDP_D_FUNC_BYPASS_0_SQSUM_BYPASS_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_D_FUNC_BYPASS_0_SQSUM_BYPASS_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_D_FUNC_BYPASS_0_SQSUM_BYPASS_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDP_D_FUNC_BYPASS_0_SQSUM_BYPASS_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define CDP_D_FUNC_BYPASS_0_SQSUM_BYPASS_INIT_ENUM (DISABLE)
+#define CDP_D_FUNC_BYPASS_0_SQSUM_BYPASS_DISABLE (_MK_ENUM_CONST(0))
+#define CDP_D_FUNC_BYPASS_0_SQSUM_BYPASS_ENABLE (_MK_ENUM_CONST(1))
+
+#define CDP_D_FUNC_BYPASS_0_MUL_BYPASS_SHIFT (_MK_SHIFT_CONST(1))
+#define CDP_D_FUNC_BYPASS_0_MUL_BYPASS_FIELD \
+	(_MK_FIELD_CONST(0x1, CDP_D_FUNC_BYPASS_0_MUL_BYPASS_SHIFT))
+#define CDP_D_FUNC_BYPASS_0_MUL_BYPASS_RANGE (1 : 1)
+#define CDP_D_FUNC_BYPASS_0_MUL_BYPASS_WOFFSET (0x0)
+#define CDP_D_FUNC_BYPASS_0_MUL_BYPASS_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_D_FUNC_BYPASS_0_MUL_BYPASS_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CDP_D_FUNC_BYPASS_0_MUL_BYPASS_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_D_FUNC_BYPASS_0_MUL_BYPASS_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_D_FUNC_BYPASS_0_MUL_BYPASS_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDP_D_FUNC_BYPASS_0_MUL_BYPASS_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define CDP_D_FUNC_BYPASS_0_MUL_BYPASS_INIT_ENUM (DISABLE)
+#define CDP_D_FUNC_BYPASS_0_MUL_BYPASS_DISABLE (_MK_ENUM_CONST(0))
+#define CDP_D_FUNC_BYPASS_0_MUL_BYPASS_ENABLE (_MK_ENUM_CONST(1))
+
+// Register CDP_D_DST_BASE_ADDR_LOW_0
+#define CDP_D_DST_BASE_ADDR_LOW_0 (_MK_ADDR_CONST(0xf050))
+#define CDP_D_DST_BASE_ADDR_LOW_0_SECURE (0x0)
+#define CDP_D_DST_BASE_ADDR_LOW_0_DUAL (0x0)
+#define CDP_D_DST_BASE_ADDR_LOW_0_SCR (0)
+#define CDP_D_DST_BASE_ADDR_LOW_0_WORD_COUNT (0x1)
+#define CDP_D_DST_BASE_ADDR_LOW_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_D_DST_BASE_ADDR_LOW_0_RESET_MASK (_MK_MASK_CONST(0xffffffe0))
+#define CDP_D_DST_BASE_ADDR_LOW_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_D_DST_BASE_ADDR_LOW_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_D_DST_BASE_ADDR_LOW_0_READ_MASK (_MK_MASK_CONST(0xffffffe0))
+#define CDP_D_DST_BASE_ADDR_LOW_0_WRITE_MASK (_MK_MASK_CONST(0xffffffe0))
+#define CDP_D_DST_BASE_ADDR_LOW_0_DST_BASE_ADDR_LOW_SHIFT (_MK_SHIFT_CONST(5))
+#define CDP_D_DST_BASE_ADDR_LOW_0_DST_BASE_ADDR_LOW_FIELD \
+	(_MK_FIELD_CONST(0x7ffffff,                       \
+			 CDP_D_DST_BASE_ADDR_LOW_0_DST_BASE_ADDR_LOW_SHIFT))
+#define CDP_D_DST_BASE_ADDR_LOW_0_DST_BASE_ADDR_LOW_RANGE (31 : 5)
+#define CDP_D_DST_BASE_ADDR_LOW_0_DST_BASE_ADDR_LOW_WOFFSET (0x0)
+#define CDP_D_DST_BASE_ADDR_LOW_0_DST_BASE_ADDR_LOW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDP_D_DST_BASE_ADDR_LOW_0_DST_BASE_ADDR_LOW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffffff))
+#define CDP_D_DST_BASE_ADDR_LOW_0_DST_BASE_ADDR_LOW_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDP_D_DST_BASE_ADDR_LOW_0_DST_BASE_ADDR_LOW_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDP_D_DST_BASE_ADDR_LOW_0_DST_BASE_ADDR_LOW_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDP_D_DST_BASE_ADDR_LOW_0_DST_BASE_ADDR_LOW_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDP_D_DST_BASE_ADDR_HIGH_0
+#define CDP_D_DST_BASE_ADDR_HIGH_0 (_MK_ADDR_CONST(0xf054))
+#define CDP_D_DST_BASE_ADDR_HIGH_0_SECURE (0x0)
+#define CDP_D_DST_BASE_ADDR_HIGH_0_DUAL (0x0)
+#define CDP_D_DST_BASE_ADDR_HIGH_0_SCR (0)
+#define CDP_D_DST_BASE_ADDR_HIGH_0_WORD_COUNT (0x1)
+#define CDP_D_DST_BASE_ADDR_HIGH_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_D_DST_BASE_ADDR_HIGH_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDP_D_DST_BASE_ADDR_HIGH_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_D_DST_BASE_ADDR_HIGH_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_D_DST_BASE_ADDR_HIGH_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDP_D_DST_BASE_ADDR_HIGH_0_WRITE_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDP_D_DST_BASE_ADDR_HIGH_0_DST_BASE_ADDR_HIGH_SHIFT (_MK_SHIFT_CONST(0))
+#define CDP_D_DST_BASE_ADDR_HIGH_0_DST_BASE_ADDR_HIGH_FIELD \
+	(_MK_FIELD_CONST(0xffffffff,                        \
+			 CDP_D_DST_BASE_ADDR_HIGH_0_DST_BASE_ADDR_HIGH_SHIFT))
+#define CDP_D_DST_BASE_ADDR_HIGH_0_DST_BASE_ADDR_HIGH_RANGE (31 : 0)
+#define CDP_D_DST_BASE_ADDR_HIGH_0_DST_BASE_ADDR_HIGH_WOFFSET (0x0)
+#define CDP_D_DST_BASE_ADDR_HIGH_0_DST_BASE_ADDR_HIGH_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDP_D_DST_BASE_ADDR_HIGH_0_DST_BASE_ADDR_HIGH_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define CDP_D_DST_BASE_ADDR_HIGH_0_DST_BASE_ADDR_HIGH_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDP_D_DST_BASE_ADDR_HIGH_0_DST_BASE_ADDR_HIGH_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDP_D_DST_BASE_ADDR_HIGH_0_DST_BASE_ADDR_HIGH_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDP_D_DST_BASE_ADDR_HIGH_0_DST_BASE_ADDR_HIGH_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDP_D_DST_LINE_STRIDE_0
+#define CDP_D_DST_LINE_STRIDE_0 (_MK_ADDR_CONST(0xf058))
+#define CDP_D_DST_LINE_STRIDE_0_SECURE (0x0)
+#define CDP_D_DST_LINE_STRIDE_0_DUAL (0x0)
+#define CDP_D_DST_LINE_STRIDE_0_SCR (0)
+#define CDP_D_DST_LINE_STRIDE_0_WORD_COUNT (0x1)
+#define CDP_D_DST_LINE_STRIDE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_D_DST_LINE_STRIDE_0_RESET_MASK (_MK_MASK_CONST(0xffffffe0))
+#define CDP_D_DST_LINE_STRIDE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_D_DST_LINE_STRIDE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_D_DST_LINE_STRIDE_0_READ_MASK (_MK_MASK_CONST(0xffffffe0))
+#define CDP_D_DST_LINE_STRIDE_0_WRITE_MASK (_MK_MASK_CONST(0xffffffe0))
+#define CDP_D_DST_LINE_STRIDE_0_DST_LINE_STRIDE_SHIFT (_MK_SHIFT_CONST(5))
+#define CDP_D_DST_LINE_STRIDE_0_DST_LINE_STRIDE_FIELD \
+	(_MK_FIELD_CONST(0x7ffffff,                   \
+			 CDP_D_DST_LINE_STRIDE_0_DST_LINE_STRIDE_SHIFT))
+#define CDP_D_DST_LINE_STRIDE_0_DST_LINE_STRIDE_RANGE (31 : 5)
+#define CDP_D_DST_LINE_STRIDE_0_DST_LINE_STRIDE_WOFFSET (0x0)
+#define CDP_D_DST_LINE_STRIDE_0_DST_LINE_STRIDE_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_D_DST_LINE_STRIDE_0_DST_LINE_STRIDE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffffff))
+#define CDP_D_DST_LINE_STRIDE_0_DST_LINE_STRIDE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_D_DST_LINE_STRIDE_0_DST_LINE_STRIDE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDP_D_DST_LINE_STRIDE_0_DST_LINE_STRIDE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDP_D_DST_LINE_STRIDE_0_DST_LINE_STRIDE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDP_D_DST_SURFACE_STRIDE_0
+#define CDP_D_DST_SURFACE_STRIDE_0 (_MK_ADDR_CONST(0xf05c))
+#define CDP_D_DST_SURFACE_STRIDE_0_SECURE (0x0)
+#define CDP_D_DST_SURFACE_STRIDE_0_DUAL (0x0)
+#define CDP_D_DST_SURFACE_STRIDE_0_SCR (0)
+#define CDP_D_DST_SURFACE_STRIDE_0_WORD_COUNT (0x1)
+#define CDP_D_DST_SURFACE_STRIDE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_D_DST_SURFACE_STRIDE_0_RESET_MASK (_MK_MASK_CONST(0xffffffe0))
+#define CDP_D_DST_SURFACE_STRIDE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_D_DST_SURFACE_STRIDE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_D_DST_SURFACE_STRIDE_0_READ_MASK (_MK_MASK_CONST(0xffffffe0))
+#define CDP_D_DST_SURFACE_STRIDE_0_WRITE_MASK (_MK_MASK_CONST(0xffffffe0))
+#define CDP_D_DST_SURFACE_STRIDE_0_DST_SURFACE_STRIDE_SHIFT (_MK_SHIFT_CONST(5))
+#define CDP_D_DST_SURFACE_STRIDE_0_DST_SURFACE_STRIDE_FIELD \
+	(_MK_FIELD_CONST(0x7ffffff,                         \
+			 CDP_D_DST_SURFACE_STRIDE_0_DST_SURFACE_STRIDE_SHIFT))
+#define CDP_D_DST_SURFACE_STRIDE_0_DST_SURFACE_STRIDE_RANGE (31 : 5)
+#define CDP_D_DST_SURFACE_STRIDE_0_DST_SURFACE_STRIDE_WOFFSET (0x0)
+#define CDP_D_DST_SURFACE_STRIDE_0_DST_SURFACE_STRIDE_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDP_D_DST_SURFACE_STRIDE_0_DST_SURFACE_STRIDE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffffff))
+#define CDP_D_DST_SURFACE_STRIDE_0_DST_SURFACE_STRIDE_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDP_D_DST_SURFACE_STRIDE_0_DST_SURFACE_STRIDE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDP_D_DST_SURFACE_STRIDE_0_DST_SURFACE_STRIDE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDP_D_DST_SURFACE_STRIDE_0_DST_SURFACE_STRIDE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDP_D_DST_DMA_CFG_0
+#define CDP_D_DST_DMA_CFG_0 (_MK_ADDR_CONST(0xf060))
+#define CDP_D_DST_DMA_CFG_0_SECURE (0x0)
+#define CDP_D_DST_DMA_CFG_0_DUAL (0x0)
+#define CDP_D_DST_DMA_CFG_0_SCR (0)
+#define CDP_D_DST_DMA_CFG_0_WORD_COUNT (0x1)
+#define CDP_D_DST_DMA_CFG_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_D_DST_DMA_CFG_0_RESET_MASK (_MK_MASK_CONST(0x1))
+#define CDP_D_DST_DMA_CFG_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_D_DST_DMA_CFG_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_D_DST_DMA_CFG_0_READ_MASK (_MK_MASK_CONST(0x1))
+#define CDP_D_DST_DMA_CFG_0_WRITE_MASK (_MK_MASK_CONST(0x1))
+#define CDP_D_DST_DMA_CFG_0_DST_RAM_TYPE_SHIFT (_MK_SHIFT_CONST(0))
+#define CDP_D_DST_DMA_CFG_0_DST_RAM_TYPE_FIELD \
+	(_MK_FIELD_CONST(0x1, CDP_D_DST_DMA_CFG_0_DST_RAM_TYPE_SHIFT))
+#define CDP_D_DST_DMA_CFG_0_DST_RAM_TYPE_RANGE (0 : 0)
+#define CDP_D_DST_DMA_CFG_0_DST_RAM_TYPE_WOFFSET (0x0)
+#define CDP_D_DST_DMA_CFG_0_DST_RAM_TYPE_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_D_DST_DMA_CFG_0_DST_RAM_TYPE_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CDP_D_DST_DMA_CFG_0_DST_RAM_TYPE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_D_DST_DMA_CFG_0_DST_RAM_TYPE_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_D_DST_DMA_CFG_0_DST_RAM_TYPE_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDP_D_DST_DMA_CFG_0_DST_RAM_TYPE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define CDP_D_DST_DMA_CFG_0_DST_RAM_TYPE_CV (_MK_ENUM_CONST(0))
+#define CDP_D_DST_DMA_CFG_0_DST_RAM_TYPE_MC (_MK_ENUM_CONST(1))
+
+// Register CDP_D_DST_COMPRESSION_EN_0
+#define CDP_D_DST_COMPRESSION_EN_0 (_MK_ADDR_CONST(0xf064))
+#define CDP_D_DST_COMPRESSION_EN_0_SECURE (0x0)
+#define CDP_D_DST_COMPRESSION_EN_0_DUAL (0x0)
+#define CDP_D_DST_COMPRESSION_EN_0_SCR (0)
+#define CDP_D_DST_COMPRESSION_EN_0_WORD_COUNT (0x1)
+#define CDP_D_DST_COMPRESSION_EN_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_D_DST_COMPRESSION_EN_0_RESET_MASK (_MK_MASK_CONST(0x1))
+#define CDP_D_DST_COMPRESSION_EN_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_D_DST_COMPRESSION_EN_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_D_DST_COMPRESSION_EN_0_READ_MASK (_MK_MASK_CONST(0x1))
+#define CDP_D_DST_COMPRESSION_EN_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define CDP_D_DST_COMPRESSION_EN_0_DST_COMPRESSION_EN_SHIFT (_MK_SHIFT_CONST(0))
+#define CDP_D_DST_COMPRESSION_EN_0_DST_COMPRESSION_EN_FIELD \
+	(_MK_FIELD_CONST(0x1,                               \
+			 CDP_D_DST_COMPRESSION_EN_0_DST_COMPRESSION_EN_SHIFT))
+#define CDP_D_DST_COMPRESSION_EN_0_DST_COMPRESSION_EN_RANGE (0 : 0)
+#define CDP_D_DST_COMPRESSION_EN_0_DST_COMPRESSION_EN_WOFFSET (0x0)
+#define CDP_D_DST_COMPRESSION_EN_0_DST_COMPRESSION_EN_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDP_D_DST_COMPRESSION_EN_0_DST_COMPRESSION_EN_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1))
+#define CDP_D_DST_COMPRESSION_EN_0_DST_COMPRESSION_EN_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDP_D_DST_COMPRESSION_EN_0_DST_COMPRESSION_EN_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDP_D_DST_COMPRESSION_EN_0_DST_COMPRESSION_EN_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDP_D_DST_COMPRESSION_EN_0_DST_COMPRESSION_EN_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define CDP_D_DST_COMPRESSION_EN_0_DST_COMPRESSION_EN_DISABLE \
+	(_MK_ENUM_CONST(0))
+#define CDP_D_DST_COMPRESSION_EN_0_DST_COMPRESSION_EN_ENABLE (_MK_ENUM_CONST(1))
+
+// Register CDP_D_DATA_FORMAT_0
+#define CDP_D_DATA_FORMAT_0 (_MK_ADDR_CONST(0xf068))
+#define CDP_D_DATA_FORMAT_0_SECURE (0x0)
+#define CDP_D_DATA_FORMAT_0_DUAL (0x0)
+#define CDP_D_DATA_FORMAT_0_SCR (0)
+#define CDP_D_DATA_FORMAT_0_WORD_COUNT (0x1)
+#define CDP_D_DATA_FORMAT_0_RESET_VAL (_MK_MASK_CONST(0x1))
+#define CDP_D_DATA_FORMAT_0_RESET_MASK (_MK_MASK_CONST(0x3))
+#define CDP_D_DATA_FORMAT_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_D_DATA_FORMAT_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_D_DATA_FORMAT_0_READ_MASK (_MK_MASK_CONST(0x3))
+#define CDP_D_DATA_FORMAT_0_WRITE_MASK (_MK_MASK_CONST(0x3))
+#define CDP_D_DATA_FORMAT_0_INPUT_DATA_TYPE_SHIFT (_MK_SHIFT_CONST(0))
+#define CDP_D_DATA_FORMAT_0_INPUT_DATA_TYPE_FIELD \
+	(_MK_FIELD_CONST(0x3, CDP_D_DATA_FORMAT_0_INPUT_DATA_TYPE_SHIFT))
+#define CDP_D_DATA_FORMAT_0_INPUT_DATA_TYPE_RANGE (1 : 0)
+#define CDP_D_DATA_FORMAT_0_INPUT_DATA_TYPE_WOFFSET (0x0)
+#define CDP_D_DATA_FORMAT_0_INPUT_DATA_TYPE_DEFAULT (_MK_MASK_CONST(0x1))
+#define CDP_D_DATA_FORMAT_0_INPUT_DATA_TYPE_DEFAULT_MASK (_MK_MASK_CONST(0x3))
+#define CDP_D_DATA_FORMAT_0_INPUT_DATA_TYPE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_D_DATA_FORMAT_0_INPUT_DATA_TYPE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDP_D_DATA_FORMAT_0_INPUT_DATA_TYPE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDP_D_DATA_FORMAT_0_INPUT_DATA_TYPE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define CDP_D_DATA_FORMAT_0_INPUT_DATA_TYPE_INT8 (_MK_ENUM_CONST(0))
+#define CDP_D_DATA_FORMAT_0_INPUT_DATA_TYPE_INT16 (_MK_ENUM_CONST(1))
+#define CDP_D_DATA_FORMAT_0_INPUT_DATA_TYPE_FP16 (_MK_ENUM_CONST(2))
+
+// Register CDP_D_NAN_FLUSH_TO_ZERO_0
+#define CDP_D_NAN_FLUSH_TO_ZERO_0 (_MK_ADDR_CONST(0xf06c))
+#define CDP_D_NAN_FLUSH_TO_ZERO_0_SECURE (0x0)
+#define CDP_D_NAN_FLUSH_TO_ZERO_0_DUAL (0x0)
+#define CDP_D_NAN_FLUSH_TO_ZERO_0_SCR (0)
+#define CDP_D_NAN_FLUSH_TO_ZERO_0_WORD_COUNT (0x1)
+#define CDP_D_NAN_FLUSH_TO_ZERO_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_D_NAN_FLUSH_TO_ZERO_0_RESET_MASK (_MK_MASK_CONST(0x1))
+#define CDP_D_NAN_FLUSH_TO_ZERO_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_D_NAN_FLUSH_TO_ZERO_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_D_NAN_FLUSH_TO_ZERO_0_READ_MASK (_MK_MASK_CONST(0x1))
+#define CDP_D_NAN_FLUSH_TO_ZERO_0_WRITE_MASK (_MK_MASK_CONST(0x1))
+#define CDP_D_NAN_FLUSH_TO_ZERO_0_NAN_TO_ZERO_SHIFT (_MK_SHIFT_CONST(0))
+#define CDP_D_NAN_FLUSH_TO_ZERO_0_NAN_TO_ZERO_FIELD \
+	(_MK_FIELD_CONST(0x1, CDP_D_NAN_FLUSH_TO_ZERO_0_NAN_TO_ZERO_SHIFT))
+#define CDP_D_NAN_FLUSH_TO_ZERO_0_NAN_TO_ZERO_RANGE (0 : 0)
+#define CDP_D_NAN_FLUSH_TO_ZERO_0_NAN_TO_ZERO_WOFFSET (0x0)
+#define CDP_D_NAN_FLUSH_TO_ZERO_0_NAN_TO_ZERO_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_D_NAN_FLUSH_TO_ZERO_0_NAN_TO_ZERO_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CDP_D_NAN_FLUSH_TO_ZERO_0_NAN_TO_ZERO_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_D_NAN_FLUSH_TO_ZERO_0_NAN_TO_ZERO_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDP_D_NAN_FLUSH_TO_ZERO_0_NAN_TO_ZERO_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDP_D_NAN_FLUSH_TO_ZERO_0_NAN_TO_ZERO_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define CDP_D_NAN_FLUSH_TO_ZERO_0_NAN_TO_ZERO_INIT_ENUM (DISABLE)
+#define CDP_D_NAN_FLUSH_TO_ZERO_0_NAN_TO_ZERO_DISABLE (_MK_ENUM_CONST(0))
+#define CDP_D_NAN_FLUSH_TO_ZERO_0_NAN_TO_ZERO_ENABLE (_MK_ENUM_CONST(1))
+
+// Register CDP_D_LRN_CFG_0
+#define CDP_D_LRN_CFG_0 (_MK_ADDR_CONST(0xf070))
+#define CDP_D_LRN_CFG_0_SECURE (0x0)
+#define CDP_D_LRN_CFG_0_DUAL (0x0)
+#define CDP_D_LRN_CFG_0_SCR (0)
+#define CDP_D_LRN_CFG_0_WORD_COUNT (0x1)
+#define CDP_D_LRN_CFG_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_D_LRN_CFG_0_RESET_MASK (_MK_MASK_CONST(0x3))
+#define CDP_D_LRN_CFG_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_D_LRN_CFG_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_D_LRN_CFG_0_READ_MASK (_MK_MASK_CONST(0x3))
+#define CDP_D_LRN_CFG_0_WRITE_MASK (_MK_MASK_CONST(0x3))
+#define CDP_D_LRN_CFG_0_NORMALZ_LEN_SHIFT (_MK_SHIFT_CONST(0))
+#define CDP_D_LRN_CFG_0_NORMALZ_LEN_FIELD \
+	(_MK_FIELD_CONST(0x3, CDP_D_LRN_CFG_0_NORMALZ_LEN_SHIFT))
+#define CDP_D_LRN_CFG_0_NORMALZ_LEN_RANGE (1 : 0)
+#define CDP_D_LRN_CFG_0_NORMALZ_LEN_WOFFSET (0x0)
+#define CDP_D_LRN_CFG_0_NORMALZ_LEN_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_D_LRN_CFG_0_NORMALZ_LEN_DEFAULT_MASK (_MK_MASK_CONST(0x3))
+#define CDP_D_LRN_CFG_0_NORMALZ_LEN_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_D_LRN_CFG_0_NORMALZ_LEN_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_D_LRN_CFG_0_NORMALZ_LEN_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDP_D_LRN_CFG_0_NORMALZ_LEN_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define CDP_D_LRN_CFG_0_NORMALZ_LEN_LEN3 (_MK_ENUM_CONST(0))
+#define CDP_D_LRN_CFG_0_NORMALZ_LEN_LEN5 (_MK_ENUM_CONST(1))
+#define CDP_D_LRN_CFG_0_NORMALZ_LEN_LEN7 (_MK_ENUM_CONST(2))
+#define CDP_D_LRN_CFG_0_NORMALZ_LEN_LEN9 (_MK_ENUM_CONST(3))
+
+// Register CDP_D_DATIN_OFFSET_0
+#define CDP_D_DATIN_OFFSET_0 (_MK_ADDR_CONST(0xf074))
+#define CDP_D_DATIN_OFFSET_0_SECURE (0x0)
+#define CDP_D_DATIN_OFFSET_0_DUAL (0x0)
+#define CDP_D_DATIN_OFFSET_0_SCR (0)
+#define CDP_D_DATIN_OFFSET_0_WORD_COUNT (0x1)
+#define CDP_D_DATIN_OFFSET_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_D_DATIN_OFFSET_0_RESET_MASK (_MK_MASK_CONST(0xffff))
+#define CDP_D_DATIN_OFFSET_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_D_DATIN_OFFSET_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_D_DATIN_OFFSET_0_READ_MASK (_MK_MASK_CONST(0xffff))
+#define CDP_D_DATIN_OFFSET_0_WRITE_MASK (_MK_MASK_CONST(0xffff))
+#define CDP_D_DATIN_OFFSET_0_DATIN_OFFSET_SHIFT (_MK_SHIFT_CONST(0))
+#define CDP_D_DATIN_OFFSET_0_DATIN_OFFSET_FIELD \
+	(_MK_FIELD_CONST(0xffff, CDP_D_DATIN_OFFSET_0_DATIN_OFFSET_SHIFT))
+#define CDP_D_DATIN_OFFSET_0_DATIN_OFFSET_RANGE (15 : 0)
+#define CDP_D_DATIN_OFFSET_0_DATIN_OFFSET_WOFFSET (0x0)
+#define CDP_D_DATIN_OFFSET_0_DATIN_OFFSET_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_D_DATIN_OFFSET_0_DATIN_OFFSET_DEFAULT_MASK (_MK_MASK_CONST(0xffff))
+#define CDP_D_DATIN_OFFSET_0_DATIN_OFFSET_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_D_DATIN_OFFSET_0_DATIN_OFFSET_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_D_DATIN_OFFSET_0_DATIN_OFFSET_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDP_D_DATIN_OFFSET_0_DATIN_OFFSET_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDP_D_DATIN_SCALE_0
+#define CDP_D_DATIN_SCALE_0 (_MK_ADDR_CONST(0xf078))
+#define CDP_D_DATIN_SCALE_0_SECURE (0x0)
+#define CDP_D_DATIN_SCALE_0_DUAL (0x0)
+#define CDP_D_DATIN_SCALE_0_SCR (0)
+#define CDP_D_DATIN_SCALE_0_WORD_COUNT (0x1)
+#define CDP_D_DATIN_SCALE_0_RESET_VAL (_MK_MASK_CONST(0x1))
+#define CDP_D_DATIN_SCALE_0_RESET_MASK (_MK_MASK_CONST(0xffff))
+#define CDP_D_DATIN_SCALE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_D_DATIN_SCALE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_D_DATIN_SCALE_0_READ_MASK (_MK_MASK_CONST(0xffff))
+#define CDP_D_DATIN_SCALE_0_WRITE_MASK (_MK_MASK_CONST(0xffff))
+#define CDP_D_DATIN_SCALE_0_DATIN_SCALE_SHIFT (_MK_SHIFT_CONST(0))
+#define CDP_D_DATIN_SCALE_0_DATIN_SCALE_FIELD \
+	(_MK_FIELD_CONST(0xffff, CDP_D_DATIN_SCALE_0_DATIN_SCALE_SHIFT))
+#define CDP_D_DATIN_SCALE_0_DATIN_SCALE_RANGE (15 : 0)
+#define CDP_D_DATIN_SCALE_0_DATIN_SCALE_WOFFSET (0x0)
+#define CDP_D_DATIN_SCALE_0_DATIN_SCALE_DEFAULT (_MK_MASK_CONST(0x1))
+#define CDP_D_DATIN_SCALE_0_DATIN_SCALE_DEFAULT_MASK (_MK_MASK_CONST(0xffff))
+#define CDP_D_DATIN_SCALE_0_DATIN_SCALE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_D_DATIN_SCALE_0_DATIN_SCALE_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_D_DATIN_SCALE_0_DATIN_SCALE_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDP_D_DATIN_SCALE_0_DATIN_SCALE_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+// Register CDP_D_DATIN_SHIFTER_0
+#define CDP_D_DATIN_SHIFTER_0 (_MK_ADDR_CONST(0xf07c))
+#define CDP_D_DATIN_SHIFTER_0_SECURE (0x0)
+#define CDP_D_DATIN_SHIFTER_0_DUAL (0x0)
+#define CDP_D_DATIN_SHIFTER_0_SCR (0)
+#define CDP_D_DATIN_SHIFTER_0_WORD_COUNT (0x1)
+#define CDP_D_DATIN_SHIFTER_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_D_DATIN_SHIFTER_0_RESET_MASK (_MK_MASK_CONST(0x1f))
+#define CDP_D_DATIN_SHIFTER_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_D_DATIN_SHIFTER_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_D_DATIN_SHIFTER_0_READ_MASK (_MK_MASK_CONST(0x1f))
+#define CDP_D_DATIN_SHIFTER_0_WRITE_MASK (_MK_MASK_CONST(0x1f))
+#define CDP_D_DATIN_SHIFTER_0_DATIN_SHIFTER_SHIFT (_MK_SHIFT_CONST(0))
+#define CDP_D_DATIN_SHIFTER_0_DATIN_SHIFTER_FIELD \
+	(_MK_FIELD_CONST(0x1f, CDP_D_DATIN_SHIFTER_0_DATIN_SHIFTER_SHIFT))
+#define CDP_D_DATIN_SHIFTER_0_DATIN_SHIFTER_RANGE (4 : 0)
+#define CDP_D_DATIN_SHIFTER_0_DATIN_SHIFTER_WOFFSET (0x0)
+#define CDP_D_DATIN_SHIFTER_0_DATIN_SHIFTER_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_D_DATIN_SHIFTER_0_DATIN_SHIFTER_DEFAULT_MASK (_MK_MASK_CONST(0x1f))
+#define CDP_D_DATIN_SHIFTER_0_DATIN_SHIFTER_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_D_DATIN_SHIFTER_0_DATIN_SHIFTER_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDP_D_DATIN_SHIFTER_0_DATIN_SHIFTER_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDP_D_DATIN_SHIFTER_0_DATIN_SHIFTER_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDP_D_DATOUT_OFFSET_0
+#define CDP_D_DATOUT_OFFSET_0 (_MK_ADDR_CONST(0xf080))
+#define CDP_D_DATOUT_OFFSET_0_SECURE (0x0)
+#define CDP_D_DATOUT_OFFSET_0_DUAL (0x0)
+#define CDP_D_DATOUT_OFFSET_0_SCR (0)
+#define CDP_D_DATOUT_OFFSET_0_WORD_COUNT (0x1)
+#define CDP_D_DATOUT_OFFSET_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_D_DATOUT_OFFSET_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDP_D_DATOUT_OFFSET_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_D_DATOUT_OFFSET_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_D_DATOUT_OFFSET_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDP_D_DATOUT_OFFSET_0_WRITE_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDP_D_DATOUT_OFFSET_0_DATOUT_OFFSET_SHIFT (_MK_SHIFT_CONST(0))
+#define CDP_D_DATOUT_OFFSET_0_DATOUT_OFFSET_FIELD \
+	(_MK_FIELD_CONST(0xffffffff, CDP_D_DATOUT_OFFSET_0_DATOUT_OFFSET_SHIFT))
+#define CDP_D_DATOUT_OFFSET_0_DATOUT_OFFSET_RANGE (31 : 0)
+#define CDP_D_DATOUT_OFFSET_0_DATOUT_OFFSET_WOFFSET (0x0)
+#define CDP_D_DATOUT_OFFSET_0_DATOUT_OFFSET_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_D_DATOUT_OFFSET_0_DATOUT_OFFSET_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define CDP_D_DATOUT_OFFSET_0_DATOUT_OFFSET_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_D_DATOUT_OFFSET_0_DATOUT_OFFSET_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDP_D_DATOUT_OFFSET_0_DATOUT_OFFSET_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDP_D_DATOUT_OFFSET_0_DATOUT_OFFSET_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDP_D_DATOUT_SCALE_0
+#define CDP_D_DATOUT_SCALE_0 (_MK_ADDR_CONST(0xf084))
+#define CDP_D_DATOUT_SCALE_0_SECURE (0x0)
+#define CDP_D_DATOUT_SCALE_0_DUAL (0x0)
+#define CDP_D_DATOUT_SCALE_0_SCR (0)
+#define CDP_D_DATOUT_SCALE_0_WORD_COUNT (0x1)
+#define CDP_D_DATOUT_SCALE_0_RESET_VAL (_MK_MASK_CONST(0x1))
+#define CDP_D_DATOUT_SCALE_0_RESET_MASK (_MK_MASK_CONST(0xffff))
+#define CDP_D_DATOUT_SCALE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_D_DATOUT_SCALE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_D_DATOUT_SCALE_0_READ_MASK (_MK_MASK_CONST(0xffff))
+#define CDP_D_DATOUT_SCALE_0_WRITE_MASK (_MK_MASK_CONST(0xffff))
+#define CDP_D_DATOUT_SCALE_0_DATOUT_SCALE_SHIFT (_MK_SHIFT_CONST(0))
+#define CDP_D_DATOUT_SCALE_0_DATOUT_SCALE_FIELD \
+	(_MK_FIELD_CONST(0xffff, CDP_D_DATOUT_SCALE_0_DATOUT_SCALE_SHIFT))
+#define CDP_D_DATOUT_SCALE_0_DATOUT_SCALE_RANGE (15 : 0)
+#define CDP_D_DATOUT_SCALE_0_DATOUT_SCALE_WOFFSET (0x0)
+#define CDP_D_DATOUT_SCALE_0_DATOUT_SCALE_DEFAULT (_MK_MASK_CONST(0x1))
+#define CDP_D_DATOUT_SCALE_0_DATOUT_SCALE_DEFAULT_MASK (_MK_MASK_CONST(0xffff))
+#define CDP_D_DATOUT_SCALE_0_DATOUT_SCALE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_D_DATOUT_SCALE_0_DATOUT_SCALE_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_D_DATOUT_SCALE_0_DATOUT_SCALE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDP_D_DATOUT_SCALE_0_DATOUT_SCALE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDP_D_DATOUT_SHIFTER_0
+#define CDP_D_DATOUT_SHIFTER_0 (_MK_ADDR_CONST(0xf088))
+#define CDP_D_DATOUT_SHIFTER_0_SECURE (0x0)
+#define CDP_D_DATOUT_SHIFTER_0_DUAL (0x0)
+#define CDP_D_DATOUT_SHIFTER_0_SCR (0)
+#define CDP_D_DATOUT_SHIFTER_0_WORD_COUNT (0x1)
+#define CDP_D_DATOUT_SHIFTER_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_D_DATOUT_SHIFTER_0_RESET_MASK (_MK_MASK_CONST(0x3f))
+#define CDP_D_DATOUT_SHIFTER_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_D_DATOUT_SHIFTER_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_D_DATOUT_SHIFTER_0_READ_MASK (_MK_MASK_CONST(0x3f))
+#define CDP_D_DATOUT_SHIFTER_0_WRITE_MASK (_MK_MASK_CONST(0x3f))
+#define CDP_D_DATOUT_SHIFTER_0_DATOUT_SHIFTER_SHIFT (_MK_SHIFT_CONST(0))
+#define CDP_D_DATOUT_SHIFTER_0_DATOUT_SHIFTER_FIELD \
+	(_MK_FIELD_CONST(0x3f, CDP_D_DATOUT_SHIFTER_0_DATOUT_SHIFTER_SHIFT))
+#define CDP_D_DATOUT_SHIFTER_0_DATOUT_SHIFTER_RANGE (5 : 0)
+#define CDP_D_DATOUT_SHIFTER_0_DATOUT_SHIFTER_WOFFSET (0x0)
+#define CDP_D_DATOUT_SHIFTER_0_DATOUT_SHIFTER_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_D_DATOUT_SHIFTER_0_DATOUT_SHIFTER_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x3f))
+#define CDP_D_DATOUT_SHIFTER_0_DATOUT_SHIFTER_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_D_DATOUT_SHIFTER_0_DATOUT_SHIFTER_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDP_D_DATOUT_SHIFTER_0_DATOUT_SHIFTER_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDP_D_DATOUT_SHIFTER_0_DATOUT_SHIFTER_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDP_D_NAN_INPUT_NUM_0
+#define CDP_D_NAN_INPUT_NUM_0 (_MK_ADDR_CONST(0xf08c))
+#define CDP_D_NAN_INPUT_NUM_0_SECURE (0x0)
+#define CDP_D_NAN_INPUT_NUM_0_DUAL (0x0)
+#define CDP_D_NAN_INPUT_NUM_0_SCR (0)
+#define CDP_D_NAN_INPUT_NUM_0_WORD_COUNT (0x1)
+#define CDP_D_NAN_INPUT_NUM_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_D_NAN_INPUT_NUM_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDP_D_NAN_INPUT_NUM_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_D_NAN_INPUT_NUM_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_D_NAN_INPUT_NUM_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDP_D_NAN_INPUT_NUM_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define CDP_D_NAN_INPUT_NUM_0_NAN_INPUT_NUM_SHIFT (_MK_SHIFT_CONST(0))
+#define CDP_D_NAN_INPUT_NUM_0_NAN_INPUT_NUM_FIELD \
+	(_MK_FIELD_CONST(0xffffffff, CDP_D_NAN_INPUT_NUM_0_NAN_INPUT_NUM_SHIFT))
+#define CDP_D_NAN_INPUT_NUM_0_NAN_INPUT_NUM_RANGE (31 : 0)
+#define CDP_D_NAN_INPUT_NUM_0_NAN_INPUT_NUM_WOFFSET (0x0)
+#define CDP_D_NAN_INPUT_NUM_0_NAN_INPUT_NUM_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_D_NAN_INPUT_NUM_0_NAN_INPUT_NUM_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define CDP_D_NAN_INPUT_NUM_0_NAN_INPUT_NUM_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_D_NAN_INPUT_NUM_0_NAN_INPUT_NUM_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDP_D_NAN_INPUT_NUM_0_NAN_INPUT_NUM_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDP_D_NAN_INPUT_NUM_0_NAN_INPUT_NUM_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDP_D_INF_INPUT_NUM_0
+#define CDP_D_INF_INPUT_NUM_0 (_MK_ADDR_CONST(0xf090))
+#define CDP_D_INF_INPUT_NUM_0_SECURE (0x0)
+#define CDP_D_INF_INPUT_NUM_0_DUAL (0x0)
+#define CDP_D_INF_INPUT_NUM_0_SCR (0)
+#define CDP_D_INF_INPUT_NUM_0_WORD_COUNT (0x1)
+#define CDP_D_INF_INPUT_NUM_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_D_INF_INPUT_NUM_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDP_D_INF_INPUT_NUM_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_D_INF_INPUT_NUM_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_D_INF_INPUT_NUM_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDP_D_INF_INPUT_NUM_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define CDP_D_INF_INPUT_NUM_0_INF_INPUT_NUM_SHIFT (_MK_SHIFT_CONST(0))
+#define CDP_D_INF_INPUT_NUM_0_INF_INPUT_NUM_FIELD \
+	(_MK_FIELD_CONST(0xffffffff, CDP_D_INF_INPUT_NUM_0_INF_INPUT_NUM_SHIFT))
+#define CDP_D_INF_INPUT_NUM_0_INF_INPUT_NUM_RANGE (31 : 0)
+#define CDP_D_INF_INPUT_NUM_0_INF_INPUT_NUM_WOFFSET (0x0)
+#define CDP_D_INF_INPUT_NUM_0_INF_INPUT_NUM_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_D_INF_INPUT_NUM_0_INF_INPUT_NUM_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define CDP_D_INF_INPUT_NUM_0_INF_INPUT_NUM_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_D_INF_INPUT_NUM_0_INF_INPUT_NUM_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDP_D_INF_INPUT_NUM_0_INF_INPUT_NUM_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDP_D_INF_INPUT_NUM_0_INF_INPUT_NUM_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDP_D_NAN_OUTPUT_NUM_0
+#define CDP_D_NAN_OUTPUT_NUM_0 (_MK_ADDR_CONST(0xf094))
+#define CDP_D_NAN_OUTPUT_NUM_0_SECURE (0x0)
+#define CDP_D_NAN_OUTPUT_NUM_0_DUAL (0x0)
+#define CDP_D_NAN_OUTPUT_NUM_0_SCR (0)
+#define CDP_D_NAN_OUTPUT_NUM_0_WORD_COUNT (0x1)
+#define CDP_D_NAN_OUTPUT_NUM_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_D_NAN_OUTPUT_NUM_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDP_D_NAN_OUTPUT_NUM_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_D_NAN_OUTPUT_NUM_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_D_NAN_OUTPUT_NUM_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDP_D_NAN_OUTPUT_NUM_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define CDP_D_NAN_OUTPUT_NUM_0_NAN_OUTPUT_NUM_SHIFT (_MK_SHIFT_CONST(0))
+#define CDP_D_NAN_OUTPUT_NUM_0_NAN_OUTPUT_NUM_FIELD \
+	(_MK_FIELD_CONST(0xffffffff,                \
+			 CDP_D_NAN_OUTPUT_NUM_0_NAN_OUTPUT_NUM_SHIFT))
+#define CDP_D_NAN_OUTPUT_NUM_0_NAN_OUTPUT_NUM_RANGE (31 : 0)
+#define CDP_D_NAN_OUTPUT_NUM_0_NAN_OUTPUT_NUM_WOFFSET (0x0)
+#define CDP_D_NAN_OUTPUT_NUM_0_NAN_OUTPUT_NUM_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_D_NAN_OUTPUT_NUM_0_NAN_OUTPUT_NUM_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define CDP_D_NAN_OUTPUT_NUM_0_NAN_OUTPUT_NUM_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_D_NAN_OUTPUT_NUM_0_NAN_OUTPUT_NUM_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDP_D_NAN_OUTPUT_NUM_0_NAN_OUTPUT_NUM_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDP_D_NAN_OUTPUT_NUM_0_NAN_OUTPUT_NUM_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDP_D_OUT_SATURATION_0
+#define CDP_D_OUT_SATURATION_0 (_MK_ADDR_CONST(0xf098))
+#define CDP_D_OUT_SATURATION_0_SECURE (0x0)
+#define CDP_D_OUT_SATURATION_0_DUAL (0x0)
+#define CDP_D_OUT_SATURATION_0_SCR (0)
+#define CDP_D_OUT_SATURATION_0_WORD_COUNT (0x1)
+#define CDP_D_OUT_SATURATION_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_D_OUT_SATURATION_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDP_D_OUT_SATURATION_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_D_OUT_SATURATION_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_D_OUT_SATURATION_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDP_D_OUT_SATURATION_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define CDP_D_OUT_SATURATION_0_OUT_SATURATION_SHIFT (_MK_SHIFT_CONST(0))
+#define CDP_D_OUT_SATURATION_0_OUT_SATURATION_FIELD \
+	(_MK_FIELD_CONST(0xffffffff,                \
+			 CDP_D_OUT_SATURATION_0_OUT_SATURATION_SHIFT))
+#define CDP_D_OUT_SATURATION_0_OUT_SATURATION_RANGE (31 : 0)
+#define CDP_D_OUT_SATURATION_0_OUT_SATURATION_WOFFSET (0x0)
+#define CDP_D_OUT_SATURATION_0_OUT_SATURATION_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_D_OUT_SATURATION_0_OUT_SATURATION_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define CDP_D_OUT_SATURATION_0_OUT_SATURATION_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_D_OUT_SATURATION_0_OUT_SATURATION_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDP_D_OUT_SATURATION_0_OUT_SATURATION_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDP_D_OUT_SATURATION_0_OUT_SATURATION_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDP_D_PERF_ENABLE_0
+#define CDP_D_PERF_ENABLE_0 (_MK_ADDR_CONST(0xf09c))
+#define CDP_D_PERF_ENABLE_0_SECURE (0x0)
+#define CDP_D_PERF_ENABLE_0_DUAL (0x0)
+#define CDP_D_PERF_ENABLE_0_SCR (0)
+#define CDP_D_PERF_ENABLE_0_WORD_COUNT (0x1)
+#define CDP_D_PERF_ENABLE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_D_PERF_ENABLE_0_RESET_MASK (_MK_MASK_CONST(0x3))
+#define CDP_D_PERF_ENABLE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_D_PERF_ENABLE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_D_PERF_ENABLE_0_READ_MASK (_MK_MASK_CONST(0x3))
+#define CDP_D_PERF_ENABLE_0_WRITE_MASK (_MK_MASK_CONST(0x3))
+#define CDP_D_PERF_ENABLE_0_DMA_EN_SHIFT (_MK_SHIFT_CONST(0))
+#define CDP_D_PERF_ENABLE_0_DMA_EN_FIELD \
+	(_MK_FIELD_CONST(0x1, CDP_D_PERF_ENABLE_0_DMA_EN_SHIFT))
+#define CDP_D_PERF_ENABLE_0_DMA_EN_RANGE (0 : 0)
+#define CDP_D_PERF_ENABLE_0_DMA_EN_WOFFSET (0x0)
+#define CDP_D_PERF_ENABLE_0_DMA_EN_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_D_PERF_ENABLE_0_DMA_EN_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CDP_D_PERF_ENABLE_0_DMA_EN_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_D_PERF_ENABLE_0_DMA_EN_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_D_PERF_ENABLE_0_DMA_EN_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDP_D_PERF_ENABLE_0_DMA_EN_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define CDP_D_PERF_ENABLE_0_DMA_EN_INIT_ENUM (DISABLE)
+#define CDP_D_PERF_ENABLE_0_DMA_EN_DISABLE (_MK_ENUM_CONST(0))
+#define CDP_D_PERF_ENABLE_0_DMA_EN_ENABLE (_MK_ENUM_CONST(1))
+
+#define CDP_D_PERF_ENABLE_0_LUT_EN_SHIFT (_MK_SHIFT_CONST(1))
+#define CDP_D_PERF_ENABLE_0_LUT_EN_FIELD \
+	(_MK_FIELD_CONST(0x1, CDP_D_PERF_ENABLE_0_LUT_EN_SHIFT))
+#define CDP_D_PERF_ENABLE_0_LUT_EN_RANGE (1 : 1)
+#define CDP_D_PERF_ENABLE_0_LUT_EN_WOFFSET (0x0)
+#define CDP_D_PERF_ENABLE_0_LUT_EN_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_D_PERF_ENABLE_0_LUT_EN_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define CDP_D_PERF_ENABLE_0_LUT_EN_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_D_PERF_ENABLE_0_LUT_EN_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_D_PERF_ENABLE_0_LUT_EN_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDP_D_PERF_ENABLE_0_LUT_EN_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define CDP_D_PERF_ENABLE_0_LUT_EN_INIT_ENUM (DISABLE)
+#define CDP_D_PERF_ENABLE_0_LUT_EN_DISABLE (_MK_ENUM_CONST(0))
+#define CDP_D_PERF_ENABLE_0_LUT_EN_ENABLE (_MK_ENUM_CONST(1))
+
+// Register CDP_D_PERF_WRITE_STALL_0
+#define CDP_D_PERF_WRITE_STALL_0 (_MK_ADDR_CONST(0xf0a0))
+#define CDP_D_PERF_WRITE_STALL_0_SECURE (0x0)
+#define CDP_D_PERF_WRITE_STALL_0_DUAL (0x0)
+#define CDP_D_PERF_WRITE_STALL_0_SCR (0)
+#define CDP_D_PERF_WRITE_STALL_0_WORD_COUNT (0x1)
+#define CDP_D_PERF_WRITE_STALL_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_D_PERF_WRITE_STALL_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDP_D_PERF_WRITE_STALL_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_D_PERF_WRITE_STALL_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_D_PERF_WRITE_STALL_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDP_D_PERF_WRITE_STALL_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define CDP_D_PERF_WRITE_STALL_0_PERF_WRITE_STALL_SHIFT (_MK_SHIFT_CONST(0))
+#define CDP_D_PERF_WRITE_STALL_0_PERF_WRITE_STALL_FIELD \
+	(_MK_FIELD_CONST(0xffffffff,                    \
+			 CDP_D_PERF_WRITE_STALL_0_PERF_WRITE_STALL_SHIFT))
+#define CDP_D_PERF_WRITE_STALL_0_PERF_WRITE_STALL_RANGE (31 : 0)
+#define CDP_D_PERF_WRITE_STALL_0_PERF_WRITE_STALL_WOFFSET (0x0)
+#define CDP_D_PERF_WRITE_STALL_0_PERF_WRITE_STALL_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_D_PERF_WRITE_STALL_0_PERF_WRITE_STALL_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define CDP_D_PERF_WRITE_STALL_0_PERF_WRITE_STALL_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define CDP_D_PERF_WRITE_STALL_0_PERF_WRITE_STALL_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDP_D_PERF_WRITE_STALL_0_PERF_WRITE_STALL_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDP_D_PERF_WRITE_STALL_0_PERF_WRITE_STALL_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDP_D_PERF_LUT_UFLOW_0
+#define CDP_D_PERF_LUT_UFLOW_0 (_MK_ADDR_CONST(0xf0a4))
+#define CDP_D_PERF_LUT_UFLOW_0_SECURE (0x0)
+#define CDP_D_PERF_LUT_UFLOW_0_DUAL (0x0)
+#define CDP_D_PERF_LUT_UFLOW_0_SCR (0)
+#define CDP_D_PERF_LUT_UFLOW_0_WORD_COUNT (0x1)
+#define CDP_D_PERF_LUT_UFLOW_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_D_PERF_LUT_UFLOW_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDP_D_PERF_LUT_UFLOW_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_D_PERF_LUT_UFLOW_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_D_PERF_LUT_UFLOW_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDP_D_PERF_LUT_UFLOW_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define CDP_D_PERF_LUT_UFLOW_0_PERF_LUT_UFLOW_SHIFT (_MK_SHIFT_CONST(0))
+#define CDP_D_PERF_LUT_UFLOW_0_PERF_LUT_UFLOW_FIELD \
+	(_MK_FIELD_CONST(0xffffffff,                \
+			 CDP_D_PERF_LUT_UFLOW_0_PERF_LUT_UFLOW_SHIFT))
+#define CDP_D_PERF_LUT_UFLOW_0_PERF_LUT_UFLOW_RANGE (31 : 0)
+#define CDP_D_PERF_LUT_UFLOW_0_PERF_LUT_UFLOW_WOFFSET (0x0)
+#define CDP_D_PERF_LUT_UFLOW_0_PERF_LUT_UFLOW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_D_PERF_LUT_UFLOW_0_PERF_LUT_UFLOW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define CDP_D_PERF_LUT_UFLOW_0_PERF_LUT_UFLOW_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_D_PERF_LUT_UFLOW_0_PERF_LUT_UFLOW_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDP_D_PERF_LUT_UFLOW_0_PERF_LUT_UFLOW_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDP_D_PERF_LUT_UFLOW_0_PERF_LUT_UFLOW_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDP_D_PERF_LUT_OFLOW_0
+#define CDP_D_PERF_LUT_OFLOW_0 (_MK_ADDR_CONST(0xf0a8))
+#define CDP_D_PERF_LUT_OFLOW_0_SECURE (0x0)
+#define CDP_D_PERF_LUT_OFLOW_0_DUAL (0x0)
+#define CDP_D_PERF_LUT_OFLOW_0_SCR (0)
+#define CDP_D_PERF_LUT_OFLOW_0_WORD_COUNT (0x1)
+#define CDP_D_PERF_LUT_OFLOW_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_D_PERF_LUT_OFLOW_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDP_D_PERF_LUT_OFLOW_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_D_PERF_LUT_OFLOW_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_D_PERF_LUT_OFLOW_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDP_D_PERF_LUT_OFLOW_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define CDP_D_PERF_LUT_OFLOW_0_PERF_LUT_OFLOW_SHIFT (_MK_SHIFT_CONST(0))
+#define CDP_D_PERF_LUT_OFLOW_0_PERF_LUT_OFLOW_FIELD \
+	(_MK_FIELD_CONST(0xffffffff,                \
+			 CDP_D_PERF_LUT_OFLOW_0_PERF_LUT_OFLOW_SHIFT))
+#define CDP_D_PERF_LUT_OFLOW_0_PERF_LUT_OFLOW_RANGE (31 : 0)
+#define CDP_D_PERF_LUT_OFLOW_0_PERF_LUT_OFLOW_WOFFSET (0x0)
+#define CDP_D_PERF_LUT_OFLOW_0_PERF_LUT_OFLOW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_D_PERF_LUT_OFLOW_0_PERF_LUT_OFLOW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define CDP_D_PERF_LUT_OFLOW_0_PERF_LUT_OFLOW_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_D_PERF_LUT_OFLOW_0_PERF_LUT_OFLOW_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDP_D_PERF_LUT_OFLOW_0_PERF_LUT_OFLOW_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDP_D_PERF_LUT_OFLOW_0_PERF_LUT_OFLOW_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDP_D_PERF_LUT_HYBRID_0
+#define CDP_D_PERF_LUT_HYBRID_0 (_MK_ADDR_CONST(0xf0ac))
+#define CDP_D_PERF_LUT_HYBRID_0_SECURE (0x0)
+#define CDP_D_PERF_LUT_HYBRID_0_DUAL (0x0)
+#define CDP_D_PERF_LUT_HYBRID_0_SCR (0)
+#define CDP_D_PERF_LUT_HYBRID_0_WORD_COUNT (0x1)
+#define CDP_D_PERF_LUT_HYBRID_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_D_PERF_LUT_HYBRID_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDP_D_PERF_LUT_HYBRID_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_D_PERF_LUT_HYBRID_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_D_PERF_LUT_HYBRID_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDP_D_PERF_LUT_HYBRID_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define CDP_D_PERF_LUT_HYBRID_0_PERF_LUT_HYBRID_SHIFT (_MK_SHIFT_CONST(0))
+#define CDP_D_PERF_LUT_HYBRID_0_PERF_LUT_HYBRID_FIELD \
+	(_MK_FIELD_CONST(0xffffffff,                  \
+			 CDP_D_PERF_LUT_HYBRID_0_PERF_LUT_HYBRID_SHIFT))
+#define CDP_D_PERF_LUT_HYBRID_0_PERF_LUT_HYBRID_RANGE (31 : 0)
+#define CDP_D_PERF_LUT_HYBRID_0_PERF_LUT_HYBRID_WOFFSET (0x0)
+#define CDP_D_PERF_LUT_HYBRID_0_PERF_LUT_HYBRID_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_D_PERF_LUT_HYBRID_0_PERF_LUT_HYBRID_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define CDP_D_PERF_LUT_HYBRID_0_PERF_LUT_HYBRID_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_D_PERF_LUT_HYBRID_0_PERF_LUT_HYBRID_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDP_D_PERF_LUT_HYBRID_0_PERF_LUT_HYBRID_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDP_D_PERF_LUT_HYBRID_0_PERF_LUT_HYBRID_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDP_D_PERF_LUT_LE_HIT_0
+#define CDP_D_PERF_LUT_LE_HIT_0 (_MK_ADDR_CONST(0xf0b0))
+#define CDP_D_PERF_LUT_LE_HIT_0_SECURE (0x0)
+#define CDP_D_PERF_LUT_LE_HIT_0_DUAL (0x0)
+#define CDP_D_PERF_LUT_LE_HIT_0_SCR (0)
+#define CDP_D_PERF_LUT_LE_HIT_0_WORD_COUNT (0x1)
+#define CDP_D_PERF_LUT_LE_HIT_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_D_PERF_LUT_LE_HIT_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDP_D_PERF_LUT_LE_HIT_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_D_PERF_LUT_LE_HIT_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_D_PERF_LUT_LE_HIT_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDP_D_PERF_LUT_LE_HIT_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define CDP_D_PERF_LUT_LE_HIT_0_PERF_LUT_LE_HIT_SHIFT (_MK_SHIFT_CONST(0))
+#define CDP_D_PERF_LUT_LE_HIT_0_PERF_LUT_LE_HIT_FIELD \
+	(_MK_FIELD_CONST(0xffffffff,                  \
+			 CDP_D_PERF_LUT_LE_HIT_0_PERF_LUT_LE_HIT_SHIFT))
+#define CDP_D_PERF_LUT_LE_HIT_0_PERF_LUT_LE_HIT_RANGE (31 : 0)
+#define CDP_D_PERF_LUT_LE_HIT_0_PERF_LUT_LE_HIT_WOFFSET (0x0)
+#define CDP_D_PERF_LUT_LE_HIT_0_PERF_LUT_LE_HIT_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_D_PERF_LUT_LE_HIT_0_PERF_LUT_LE_HIT_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define CDP_D_PERF_LUT_LE_HIT_0_PERF_LUT_LE_HIT_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_D_PERF_LUT_LE_HIT_0_PERF_LUT_LE_HIT_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDP_D_PERF_LUT_LE_HIT_0_PERF_LUT_LE_HIT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDP_D_PERF_LUT_LE_HIT_0_PERF_LUT_LE_HIT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDP_D_PERF_LUT_LO_HIT_0
+#define CDP_D_PERF_LUT_LO_HIT_0 (_MK_ADDR_CONST(0xf0b4))
+#define CDP_D_PERF_LUT_LO_HIT_0_SECURE (0x0)
+#define CDP_D_PERF_LUT_LO_HIT_0_DUAL (0x0)
+#define CDP_D_PERF_LUT_LO_HIT_0_SCR (0)
+#define CDP_D_PERF_LUT_LO_HIT_0_WORD_COUNT (0x1)
+#define CDP_D_PERF_LUT_LO_HIT_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_D_PERF_LUT_LO_HIT_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDP_D_PERF_LUT_LO_HIT_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_D_PERF_LUT_LO_HIT_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_D_PERF_LUT_LO_HIT_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDP_D_PERF_LUT_LO_HIT_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define CDP_D_PERF_LUT_LO_HIT_0_PERF_LUT_LO_HIT_SHIFT (_MK_SHIFT_CONST(0))
+#define CDP_D_PERF_LUT_LO_HIT_0_PERF_LUT_LO_HIT_FIELD \
+	(_MK_FIELD_CONST(0xffffffff,                  \
+			 CDP_D_PERF_LUT_LO_HIT_0_PERF_LUT_LO_HIT_SHIFT))
+#define CDP_D_PERF_LUT_LO_HIT_0_PERF_LUT_LO_HIT_RANGE (31 : 0)
+#define CDP_D_PERF_LUT_LO_HIT_0_PERF_LUT_LO_HIT_WOFFSET (0x0)
+#define CDP_D_PERF_LUT_LO_HIT_0_PERF_LUT_LO_HIT_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_D_PERF_LUT_LO_HIT_0_PERF_LUT_LO_HIT_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define CDP_D_PERF_LUT_LO_HIT_0_PERF_LUT_LO_HIT_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_D_PERF_LUT_LO_HIT_0_PERF_LUT_LO_HIT_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define CDP_D_PERF_LUT_LO_HIT_0_PERF_LUT_LO_HIT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define CDP_D_PERF_LUT_LO_HIT_0_PERF_LUT_LO_HIT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register CDP_D_CYA_0
+#define CDP_D_CYA_0 (_MK_ADDR_CONST(0xf0b8))
+#define CDP_D_CYA_0_SECURE (0x0)
+#define CDP_D_CYA_0_DUAL (0x0)
+#define CDP_D_CYA_0_SCR (0)
+#define CDP_D_CYA_0_WORD_COUNT (0x1)
+#define CDP_D_CYA_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define CDP_D_CYA_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDP_D_CYA_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define CDP_D_CYA_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_D_CYA_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDP_D_CYA_0_WRITE_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDP_D_CYA_0_CYA_SHIFT (_MK_SHIFT_CONST(0))
+#define CDP_D_CYA_0_CYA_FIELD \
+	(_MK_FIELD_CONST(0xffffffff, CDP_D_CYA_0_CYA_SHIFT))
+#define CDP_D_CYA_0_CYA_RANGE (31 : 0)
+#define CDP_D_CYA_0_CYA_WOFFSET (0x0)
+#define CDP_D_CYA_0_CYA_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_D_CYA_0_CYA_DEFAULT_MASK (_MK_MASK_CONST(0xffffffff))
+#define CDP_D_CYA_0_CYA_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define CDP_D_CYA_0_CYA_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define CDP_D_CYA_0_CYA_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define CDP_D_CYA_0_CYA_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+// Register RBK_S_STATUS_0
+#define RBK_S_STATUS_0 (_MK_ADDR_CONST(0x10000))
+#define RBK_S_STATUS_0_SECURE (0x0)
+#define RBK_S_STATUS_0_DUAL (0x0)
+#define RBK_S_STATUS_0_SCR (0)
+#define RBK_S_STATUS_0_WORD_COUNT (0x1)
+#define RBK_S_STATUS_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define RBK_S_STATUS_0_RESET_MASK (_MK_MASK_CONST(0x30003))
+#define RBK_S_STATUS_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define RBK_S_STATUS_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define RBK_S_STATUS_0_READ_MASK (_MK_MASK_CONST(0x30003))
+#define RBK_S_STATUS_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define RBK_S_STATUS_0_STATUS_0_SHIFT (_MK_SHIFT_CONST(0))
+#define RBK_S_STATUS_0_STATUS_0_FIELD \
+	(_MK_FIELD_CONST(0x3, RBK_S_STATUS_0_STATUS_0_SHIFT))
+#define RBK_S_STATUS_0_STATUS_0_RANGE (1 : 0)
+#define RBK_S_STATUS_0_STATUS_0_WOFFSET (0x0)
+#define RBK_S_STATUS_0_STATUS_0_DEFAULT (_MK_MASK_CONST(0x0))
+#define RBK_S_STATUS_0_STATUS_0_DEFAULT_MASK (_MK_MASK_CONST(0x3))
+#define RBK_S_STATUS_0_STATUS_0_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define RBK_S_STATUS_0_STATUS_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define RBK_S_STATUS_0_STATUS_0_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define RBK_S_STATUS_0_STATUS_0_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define RBK_S_STATUS_0_STATUS_0_INIT_ENUM (IDLE)
+#define RBK_S_STATUS_0_STATUS_0_IDLE (_MK_ENUM_CONST(0))
+#define RBK_S_STATUS_0_STATUS_0_RUNNING (_MK_ENUM_CONST(1))
+#define RBK_S_STATUS_0_STATUS_0_PENDING (_MK_ENUM_CONST(2))
+
+#define RBK_S_STATUS_0_STATUS_1_SHIFT (_MK_SHIFT_CONST(16))
+#define RBK_S_STATUS_0_STATUS_1_FIELD \
+	(_MK_FIELD_CONST(0x3, RBK_S_STATUS_0_STATUS_1_SHIFT))
+#define RBK_S_STATUS_0_STATUS_1_RANGE (17 : 16)
+#define RBK_S_STATUS_0_STATUS_1_WOFFSET (0x0)
+#define RBK_S_STATUS_0_STATUS_1_DEFAULT (_MK_MASK_CONST(0x0))
+#define RBK_S_STATUS_0_STATUS_1_DEFAULT_MASK (_MK_MASK_CONST(0x3))
+#define RBK_S_STATUS_0_STATUS_1_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define RBK_S_STATUS_0_STATUS_1_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define RBK_S_STATUS_0_STATUS_1_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define RBK_S_STATUS_0_STATUS_1_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define RBK_S_STATUS_0_STATUS_1_INIT_ENUM (IDLE)
+#define RBK_S_STATUS_0_STATUS_1_IDLE (_MK_ENUM_CONST(0))
+#define RBK_S_STATUS_0_STATUS_1_RUNNING (_MK_ENUM_CONST(1))
+#define RBK_S_STATUS_0_STATUS_1_PENDING (_MK_ENUM_CONST(2))
+
+// Register RBK_S_POINTER_0
+#define RBK_S_POINTER_0 (_MK_ADDR_CONST(0x10004))
+#define RBK_S_POINTER_0_SECURE (0x0)
+#define RBK_S_POINTER_0_DUAL (0x0)
+#define RBK_S_POINTER_0_SCR (0)
+#define RBK_S_POINTER_0_WORD_COUNT (0x1)
+#define RBK_S_POINTER_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define RBK_S_POINTER_0_RESET_MASK (_MK_MASK_CONST(0x10001))
+#define RBK_S_POINTER_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define RBK_S_POINTER_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define RBK_S_POINTER_0_READ_MASK (_MK_MASK_CONST(0x10001))
+#define RBK_S_POINTER_0_WRITE_MASK (_MK_MASK_CONST(0x1))
+#define RBK_S_POINTER_0_PRODUCER_SHIFT (_MK_SHIFT_CONST(0))
+#define RBK_S_POINTER_0_PRODUCER_FIELD \
+	(_MK_FIELD_CONST(0x1, RBK_S_POINTER_0_PRODUCER_SHIFT))
+#define RBK_S_POINTER_0_PRODUCER_RANGE (0 : 0)
+#define RBK_S_POINTER_0_PRODUCER_WOFFSET (0x0)
+#define RBK_S_POINTER_0_PRODUCER_DEFAULT (_MK_MASK_CONST(0x0))
+#define RBK_S_POINTER_0_PRODUCER_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define RBK_S_POINTER_0_PRODUCER_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define RBK_S_POINTER_0_PRODUCER_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define RBK_S_POINTER_0_PRODUCER_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define RBK_S_POINTER_0_PRODUCER_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define RBK_S_POINTER_0_PRODUCER_INIT_ENUM (GROUP_0)
+#define RBK_S_POINTER_0_PRODUCER_GROUP_0 (_MK_ENUM_CONST(0))
+#define RBK_S_POINTER_0_PRODUCER_GROUP_1 (_MK_ENUM_CONST(1))
+
+#define RBK_S_POINTER_0_CONSUMER_SHIFT (_MK_SHIFT_CONST(16))
+#define RBK_S_POINTER_0_CONSUMER_FIELD \
+	(_MK_FIELD_CONST(0x1, RBK_S_POINTER_0_CONSUMER_SHIFT))
+#define RBK_S_POINTER_0_CONSUMER_RANGE (16 : 16)
+#define RBK_S_POINTER_0_CONSUMER_WOFFSET (0x0)
+#define RBK_S_POINTER_0_CONSUMER_DEFAULT (_MK_MASK_CONST(0x0))
+#define RBK_S_POINTER_0_CONSUMER_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define RBK_S_POINTER_0_CONSUMER_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define RBK_S_POINTER_0_CONSUMER_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define RBK_S_POINTER_0_CONSUMER_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define RBK_S_POINTER_0_CONSUMER_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define RBK_S_POINTER_0_CONSUMER_INIT_ENUM (GROUP_0)
+#define RBK_S_POINTER_0_CONSUMER_GROUP_0 (_MK_ENUM_CONST(0))
+#define RBK_S_POINTER_0_CONSUMER_GROUP_1 (_MK_ENUM_CONST(1))
+
+// Register RBK_D_OP_ENABLE_0
+#define RBK_D_OP_ENABLE_0 (_MK_ADDR_CONST(0x10008))
+#define RBK_D_OP_ENABLE_0_SECURE (0x0)
+#define RBK_D_OP_ENABLE_0_DUAL (0x0)
+#define RBK_D_OP_ENABLE_0_SCR (0)
+#define RBK_D_OP_ENABLE_0_WORD_COUNT (0x1)
+#define RBK_D_OP_ENABLE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define RBK_D_OP_ENABLE_0_RESET_MASK (_MK_MASK_CONST(0x1))
+#define RBK_D_OP_ENABLE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define RBK_D_OP_ENABLE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define RBK_D_OP_ENABLE_0_READ_MASK (_MK_MASK_CONST(0x1))
+#define RBK_D_OP_ENABLE_0_WRITE_MASK (_MK_MASK_CONST(0x1))
+#define RBK_D_OP_ENABLE_0_OP_EN_SHIFT (_MK_SHIFT_CONST(0))
+#define RBK_D_OP_ENABLE_0_OP_EN_FIELD \
+	(_MK_FIELD_CONST(0x1, RBK_D_OP_ENABLE_0_OP_EN_SHIFT))
+#define RBK_D_OP_ENABLE_0_OP_EN_RANGE (0 : 0)
+#define RBK_D_OP_ENABLE_0_OP_EN_WOFFSET (0x0)
+#define RBK_D_OP_ENABLE_0_OP_EN_DEFAULT (_MK_MASK_CONST(0x0))
+#define RBK_D_OP_ENABLE_0_OP_EN_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define RBK_D_OP_ENABLE_0_OP_EN_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define RBK_D_OP_ENABLE_0_OP_EN_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define RBK_D_OP_ENABLE_0_OP_EN_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define RBK_D_OP_ENABLE_0_OP_EN_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define RBK_D_OP_ENABLE_0_OP_EN_INIT_ENUM (DISABLE)
+#define RBK_D_OP_ENABLE_0_OP_EN_DISABLE (_MK_ENUM_CONST(0))
+#define RBK_D_OP_ENABLE_0_OP_EN_ENABLE (_MK_ENUM_CONST(1))
+
+// Register RBK_D_MISC_CFG_0
+#define RBK_D_MISC_CFG_0 (_MK_ADDR_CONST(0x1000c))
+#define RBK_D_MISC_CFG_0_SECURE (0x0)
+#define RBK_D_MISC_CFG_0_DUAL (0x0)
+#define RBK_D_MISC_CFG_0_SCR (0)
+#define RBK_D_MISC_CFG_0_WORD_COUNT (0x1)
+#define RBK_D_MISC_CFG_0_RESET_VAL (_MK_MASK_CONST(0x100))
+#define RBK_D_MISC_CFG_0_RESET_MASK (_MK_MASK_CONST(0x303))
+#define RBK_D_MISC_CFG_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define RBK_D_MISC_CFG_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define RBK_D_MISC_CFG_0_READ_MASK (_MK_MASK_CONST(0x303))
+#define RBK_D_MISC_CFG_0_WRITE_MASK (_MK_MASK_CONST(0x303))
+#define RBK_D_MISC_CFG_0_RUBIK_MODE_SHIFT (_MK_SHIFT_CONST(0))
+#define RBK_D_MISC_CFG_0_RUBIK_MODE_FIELD \
+	(_MK_FIELD_CONST(0x3, RBK_D_MISC_CFG_0_RUBIK_MODE_SHIFT))
+#define RBK_D_MISC_CFG_0_RUBIK_MODE_RANGE (1 : 0)
+#define RBK_D_MISC_CFG_0_RUBIK_MODE_WOFFSET (0x0)
+#define RBK_D_MISC_CFG_0_RUBIK_MODE_DEFAULT (_MK_MASK_CONST(0x0))
+#define RBK_D_MISC_CFG_0_RUBIK_MODE_DEFAULT_MASK (_MK_MASK_CONST(0x3))
+#define RBK_D_MISC_CFG_0_RUBIK_MODE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define RBK_D_MISC_CFG_0_RUBIK_MODE_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define RBK_D_MISC_CFG_0_RUBIK_MODE_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define RBK_D_MISC_CFG_0_RUBIK_MODE_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define RBK_D_MISC_CFG_0_RUBIK_MODE_INIT_ENUM (CONTRACT)
+#define RBK_D_MISC_CFG_0_RUBIK_MODE_CONTRACT (_MK_ENUM_CONST(0))
+#define RBK_D_MISC_CFG_0_RUBIK_MODE_SPLIT (_MK_ENUM_CONST(1))
+#define RBK_D_MISC_CFG_0_RUBIK_MODE_MERGE (_MK_ENUM_CONST(2))
+
+#define RBK_D_MISC_CFG_0_IN_PRECISION_SHIFT (_MK_SHIFT_CONST(8))
+#define RBK_D_MISC_CFG_0_IN_PRECISION_FIELD \
+	(_MK_FIELD_CONST(0x3, RBK_D_MISC_CFG_0_IN_PRECISION_SHIFT))
+#define RBK_D_MISC_CFG_0_IN_PRECISION_RANGE (9 : 8)
+#define RBK_D_MISC_CFG_0_IN_PRECISION_WOFFSET (0x0)
+#define RBK_D_MISC_CFG_0_IN_PRECISION_DEFAULT (_MK_MASK_CONST(0x1))
+#define RBK_D_MISC_CFG_0_IN_PRECISION_DEFAULT_MASK (_MK_MASK_CONST(0x3))
+#define RBK_D_MISC_CFG_0_IN_PRECISION_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define RBK_D_MISC_CFG_0_IN_PRECISION_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define RBK_D_MISC_CFG_0_IN_PRECISION_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define RBK_D_MISC_CFG_0_IN_PRECISION_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+#define RBK_D_MISC_CFG_0_IN_PRECISION_INIT_ENUM (INT16)
+#define RBK_D_MISC_CFG_0_IN_PRECISION_INT8 (_MK_ENUM_CONST(0))
+#define RBK_D_MISC_CFG_0_IN_PRECISION_INT16 (_MK_ENUM_CONST(1))
+#define RBK_D_MISC_CFG_0_IN_PRECISION_FP16 (_MK_ENUM_CONST(2))
+
+// Register RBK_D_DAIN_RAM_TYPE_0
+#define RBK_D_DAIN_RAM_TYPE_0 (_MK_ADDR_CONST(0x10010))
+#define RBK_D_DAIN_RAM_TYPE_0_SECURE (0x0)
+#define RBK_D_DAIN_RAM_TYPE_0_DUAL (0x0)
+#define RBK_D_DAIN_RAM_TYPE_0_SCR (0)
+#define RBK_D_DAIN_RAM_TYPE_0_WORD_COUNT (0x1)
+#define RBK_D_DAIN_RAM_TYPE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define RBK_D_DAIN_RAM_TYPE_0_RESET_MASK (_MK_MASK_CONST(0x1))
+#define RBK_D_DAIN_RAM_TYPE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define RBK_D_DAIN_RAM_TYPE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define RBK_D_DAIN_RAM_TYPE_0_READ_MASK (_MK_MASK_CONST(0x1))
+#define RBK_D_DAIN_RAM_TYPE_0_WRITE_MASK (_MK_MASK_CONST(0x1))
+#define RBK_D_DAIN_RAM_TYPE_0_DATAIN_RAM_TYPE_SHIFT (_MK_SHIFT_CONST(0))
+#define RBK_D_DAIN_RAM_TYPE_0_DATAIN_RAM_TYPE_FIELD \
+	(_MK_FIELD_CONST(0x1, RBK_D_DAIN_RAM_TYPE_0_DATAIN_RAM_TYPE_SHIFT))
+#define RBK_D_DAIN_RAM_TYPE_0_DATAIN_RAM_TYPE_RANGE (0 : 0)
+#define RBK_D_DAIN_RAM_TYPE_0_DATAIN_RAM_TYPE_WOFFSET (0x0)
+#define RBK_D_DAIN_RAM_TYPE_0_DATAIN_RAM_TYPE_DEFAULT (_MK_MASK_CONST(0x0))
+#define RBK_D_DAIN_RAM_TYPE_0_DATAIN_RAM_TYPE_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define RBK_D_DAIN_RAM_TYPE_0_DATAIN_RAM_TYPE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define RBK_D_DAIN_RAM_TYPE_0_DATAIN_RAM_TYPE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define RBK_D_DAIN_RAM_TYPE_0_DATAIN_RAM_TYPE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define RBK_D_DAIN_RAM_TYPE_0_DATAIN_RAM_TYPE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define RBK_D_DAIN_RAM_TYPE_0_DATAIN_RAM_TYPE_INIT_ENUM (CVIF)
+#define RBK_D_DAIN_RAM_TYPE_0_DATAIN_RAM_TYPE_CVIF (_MK_ENUM_CONST(0))
+#define RBK_D_DAIN_RAM_TYPE_0_DATAIN_RAM_TYPE_MCIF (_MK_ENUM_CONST(1))
+
+// Register RBK_D_DATAIN_SIZE_0_0
+#define RBK_D_DATAIN_SIZE_0_0 (_MK_ADDR_CONST(0x10014))
+#define RBK_D_DATAIN_SIZE_0_0_SECURE (0x0)
+#define RBK_D_DATAIN_SIZE_0_0_DUAL (0x0)
+#define RBK_D_DATAIN_SIZE_0_0_SCR (0)
+#define RBK_D_DATAIN_SIZE_0_0_WORD_COUNT (0x1)
+#define RBK_D_DATAIN_SIZE_0_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define RBK_D_DATAIN_SIZE_0_0_RESET_MASK (_MK_MASK_CONST(0x1fff1fff))
+#define RBK_D_DATAIN_SIZE_0_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define RBK_D_DATAIN_SIZE_0_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define RBK_D_DATAIN_SIZE_0_0_READ_MASK (_MK_MASK_CONST(0x1fff1fff))
+#define RBK_D_DATAIN_SIZE_0_0_WRITE_MASK (_MK_MASK_CONST(0x1fff1fff))
+#define RBK_D_DATAIN_SIZE_0_0_DATAIN_WIDTH_SHIFT (_MK_SHIFT_CONST(0))
+#define RBK_D_DATAIN_SIZE_0_0_DATAIN_WIDTH_FIELD \
+	(_MK_FIELD_CONST(0x1fff, RBK_D_DATAIN_SIZE_0_0_DATAIN_WIDTH_SHIFT))
+#define RBK_D_DATAIN_SIZE_0_0_DATAIN_WIDTH_RANGE (12 : 0)
+#define RBK_D_DATAIN_SIZE_0_0_DATAIN_WIDTH_WOFFSET (0x0)
+#define RBK_D_DATAIN_SIZE_0_0_DATAIN_WIDTH_DEFAULT (_MK_MASK_CONST(0x0))
+#define RBK_D_DATAIN_SIZE_0_0_DATAIN_WIDTH_DEFAULT_MASK (_MK_MASK_CONST(0x1fff))
+#define RBK_D_DATAIN_SIZE_0_0_DATAIN_WIDTH_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define RBK_D_DATAIN_SIZE_0_0_DATAIN_WIDTH_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define RBK_D_DATAIN_SIZE_0_0_DATAIN_WIDTH_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define RBK_D_DATAIN_SIZE_0_0_DATAIN_WIDTH_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define RBK_D_DATAIN_SIZE_0_0_DATAIN_HEIGHT_SHIFT (_MK_SHIFT_CONST(16))
+#define RBK_D_DATAIN_SIZE_0_0_DATAIN_HEIGHT_FIELD \
+	(_MK_FIELD_CONST(0x1fff, RBK_D_DATAIN_SIZE_0_0_DATAIN_HEIGHT_SHIFT))
+#define RBK_D_DATAIN_SIZE_0_0_DATAIN_HEIGHT_RANGE (28 : 16)
+#define RBK_D_DATAIN_SIZE_0_0_DATAIN_HEIGHT_WOFFSET (0x0)
+#define RBK_D_DATAIN_SIZE_0_0_DATAIN_HEIGHT_DEFAULT (_MK_MASK_CONST(0x0))
+#define RBK_D_DATAIN_SIZE_0_0_DATAIN_HEIGHT_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1fff))
+#define RBK_D_DATAIN_SIZE_0_0_DATAIN_HEIGHT_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define RBK_D_DATAIN_SIZE_0_0_DATAIN_HEIGHT_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define RBK_D_DATAIN_SIZE_0_0_DATAIN_HEIGHT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define RBK_D_DATAIN_SIZE_0_0_DATAIN_HEIGHT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register RBK_D_DATAIN_SIZE_1_0
+#define RBK_D_DATAIN_SIZE_1_0 (_MK_ADDR_CONST(0x10018))
+#define RBK_D_DATAIN_SIZE_1_0_SECURE (0x0)
+#define RBK_D_DATAIN_SIZE_1_0_DUAL (0x0)
+#define RBK_D_DATAIN_SIZE_1_0_SCR (0)
+#define RBK_D_DATAIN_SIZE_1_0_WORD_COUNT (0x1)
+#define RBK_D_DATAIN_SIZE_1_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define RBK_D_DATAIN_SIZE_1_0_RESET_MASK (_MK_MASK_CONST(0x1fff))
+#define RBK_D_DATAIN_SIZE_1_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define RBK_D_DATAIN_SIZE_1_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define RBK_D_DATAIN_SIZE_1_0_READ_MASK (_MK_MASK_CONST(0x1fff))
+#define RBK_D_DATAIN_SIZE_1_0_WRITE_MASK (_MK_MASK_CONST(0x1fff))
+#define RBK_D_DATAIN_SIZE_1_0_DATAIN_CHANNEL_SHIFT (_MK_SHIFT_CONST(0))
+#define RBK_D_DATAIN_SIZE_1_0_DATAIN_CHANNEL_FIELD \
+	(_MK_FIELD_CONST(0x1fff, RBK_D_DATAIN_SIZE_1_0_DATAIN_CHANNEL_SHIFT))
+#define RBK_D_DATAIN_SIZE_1_0_DATAIN_CHANNEL_RANGE (12 : 0)
+#define RBK_D_DATAIN_SIZE_1_0_DATAIN_CHANNEL_WOFFSET (0x0)
+#define RBK_D_DATAIN_SIZE_1_0_DATAIN_CHANNEL_DEFAULT (_MK_MASK_CONST(0x0))
+#define RBK_D_DATAIN_SIZE_1_0_DATAIN_CHANNEL_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1fff))
+#define RBK_D_DATAIN_SIZE_1_0_DATAIN_CHANNEL_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define RBK_D_DATAIN_SIZE_1_0_DATAIN_CHANNEL_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define RBK_D_DATAIN_SIZE_1_0_DATAIN_CHANNEL_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define RBK_D_DATAIN_SIZE_1_0_DATAIN_CHANNEL_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register RBK_D_DAIN_ADDR_HIGH_0
+#define RBK_D_DAIN_ADDR_HIGH_0 (_MK_ADDR_CONST(0x1001c))
+#define RBK_D_DAIN_ADDR_HIGH_0_SECURE (0x0)
+#define RBK_D_DAIN_ADDR_HIGH_0_DUAL (0x0)
+#define RBK_D_DAIN_ADDR_HIGH_0_SCR (0)
+#define RBK_D_DAIN_ADDR_HIGH_0_WORD_COUNT (0x1)
+#define RBK_D_DAIN_ADDR_HIGH_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define RBK_D_DAIN_ADDR_HIGH_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define RBK_D_DAIN_ADDR_HIGH_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define RBK_D_DAIN_ADDR_HIGH_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define RBK_D_DAIN_ADDR_HIGH_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define RBK_D_DAIN_ADDR_HIGH_0_WRITE_MASK (_MK_MASK_CONST(0xffffffff))
+#define RBK_D_DAIN_ADDR_HIGH_0_DAIN_ADDR_HIGH_SHIFT (_MK_SHIFT_CONST(0))
+#define RBK_D_DAIN_ADDR_HIGH_0_DAIN_ADDR_HIGH_FIELD \
+	(_MK_FIELD_CONST(0xffffffff,                \
+			 RBK_D_DAIN_ADDR_HIGH_0_DAIN_ADDR_HIGH_SHIFT))
+#define RBK_D_DAIN_ADDR_HIGH_0_DAIN_ADDR_HIGH_RANGE (31 : 0)
+#define RBK_D_DAIN_ADDR_HIGH_0_DAIN_ADDR_HIGH_WOFFSET (0x0)
+#define RBK_D_DAIN_ADDR_HIGH_0_DAIN_ADDR_HIGH_DEFAULT (_MK_MASK_CONST(0x0))
+#define RBK_D_DAIN_ADDR_HIGH_0_DAIN_ADDR_HIGH_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define RBK_D_DAIN_ADDR_HIGH_0_DAIN_ADDR_HIGH_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define RBK_D_DAIN_ADDR_HIGH_0_DAIN_ADDR_HIGH_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define RBK_D_DAIN_ADDR_HIGH_0_DAIN_ADDR_HIGH_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define RBK_D_DAIN_ADDR_HIGH_0_DAIN_ADDR_HIGH_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register RBK_D_DAIN_ADDR_LOW_0
+#define RBK_D_DAIN_ADDR_LOW_0 (_MK_ADDR_CONST(0x10020))
+#define RBK_D_DAIN_ADDR_LOW_0_SECURE (0x0)
+#define RBK_D_DAIN_ADDR_LOW_0_DUAL (0x0)
+#define RBK_D_DAIN_ADDR_LOW_0_SCR (0)
+#define RBK_D_DAIN_ADDR_LOW_0_WORD_COUNT (0x1)
+#define RBK_D_DAIN_ADDR_LOW_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define RBK_D_DAIN_ADDR_LOW_0_RESET_MASK (_MK_MASK_CONST(0xffffffe0))
+#define RBK_D_DAIN_ADDR_LOW_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define RBK_D_DAIN_ADDR_LOW_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define RBK_D_DAIN_ADDR_LOW_0_READ_MASK (_MK_MASK_CONST(0xffffffe0))
+#define RBK_D_DAIN_ADDR_LOW_0_WRITE_MASK (_MK_MASK_CONST(0xffffffe0))
+#define RBK_D_DAIN_ADDR_LOW_0_DAIN_ADDR_LOW_SHIFT (_MK_SHIFT_CONST(5))
+#define RBK_D_DAIN_ADDR_LOW_0_DAIN_ADDR_LOW_FIELD \
+	(_MK_FIELD_CONST(0x7ffffff, RBK_D_DAIN_ADDR_LOW_0_DAIN_ADDR_LOW_SHIFT))
+#define RBK_D_DAIN_ADDR_LOW_0_DAIN_ADDR_LOW_RANGE (31 : 5)
+#define RBK_D_DAIN_ADDR_LOW_0_DAIN_ADDR_LOW_WOFFSET (0x0)
+#define RBK_D_DAIN_ADDR_LOW_0_DAIN_ADDR_LOW_DEFAULT (_MK_MASK_CONST(0x0))
+#define RBK_D_DAIN_ADDR_LOW_0_DAIN_ADDR_LOW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffffff))
+#define RBK_D_DAIN_ADDR_LOW_0_DAIN_ADDR_LOW_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define RBK_D_DAIN_ADDR_LOW_0_DAIN_ADDR_LOW_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define RBK_D_DAIN_ADDR_LOW_0_DAIN_ADDR_LOW_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define RBK_D_DAIN_ADDR_LOW_0_DAIN_ADDR_LOW_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register RBK_D_DAIN_LINE_STRIDE_0
+#define RBK_D_DAIN_LINE_STRIDE_0 (_MK_ADDR_CONST(0x10024))
+#define RBK_D_DAIN_LINE_STRIDE_0_SECURE (0x0)
+#define RBK_D_DAIN_LINE_STRIDE_0_DUAL (0x0)
+#define RBK_D_DAIN_LINE_STRIDE_0_SCR (0)
+#define RBK_D_DAIN_LINE_STRIDE_0_WORD_COUNT (0x1)
+#define RBK_D_DAIN_LINE_STRIDE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define RBK_D_DAIN_LINE_STRIDE_0_RESET_MASK (_MK_MASK_CONST(0xffffffe0))
+#define RBK_D_DAIN_LINE_STRIDE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define RBK_D_DAIN_LINE_STRIDE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define RBK_D_DAIN_LINE_STRIDE_0_READ_MASK (_MK_MASK_CONST(0xffffffe0))
+#define RBK_D_DAIN_LINE_STRIDE_0_WRITE_MASK (_MK_MASK_CONST(0xffffffe0))
+#define RBK_D_DAIN_LINE_STRIDE_0_DAIN_LINE_STRIDE_SHIFT (_MK_SHIFT_CONST(5))
+#define RBK_D_DAIN_LINE_STRIDE_0_DAIN_LINE_STRIDE_FIELD \
+	(_MK_FIELD_CONST(0x7ffffff,                     \
+			 RBK_D_DAIN_LINE_STRIDE_0_DAIN_LINE_STRIDE_SHIFT))
+#define RBK_D_DAIN_LINE_STRIDE_0_DAIN_LINE_STRIDE_RANGE (31 : 5)
+#define RBK_D_DAIN_LINE_STRIDE_0_DAIN_LINE_STRIDE_WOFFSET (0x0)
+#define RBK_D_DAIN_LINE_STRIDE_0_DAIN_LINE_STRIDE_DEFAULT (_MK_MASK_CONST(0x0))
+#define RBK_D_DAIN_LINE_STRIDE_0_DAIN_LINE_STRIDE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffffff))
+#define RBK_D_DAIN_LINE_STRIDE_0_DAIN_LINE_STRIDE_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define RBK_D_DAIN_LINE_STRIDE_0_DAIN_LINE_STRIDE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define RBK_D_DAIN_LINE_STRIDE_0_DAIN_LINE_STRIDE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define RBK_D_DAIN_LINE_STRIDE_0_DAIN_LINE_STRIDE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register RBK_D_DAIN_SURF_STRIDE_0
+#define RBK_D_DAIN_SURF_STRIDE_0 (_MK_ADDR_CONST(0x10028))
+#define RBK_D_DAIN_SURF_STRIDE_0_SECURE (0x0)
+#define RBK_D_DAIN_SURF_STRIDE_0_DUAL (0x0)
+#define RBK_D_DAIN_SURF_STRIDE_0_SCR (0)
+#define RBK_D_DAIN_SURF_STRIDE_0_WORD_COUNT (0x1)
+#define RBK_D_DAIN_SURF_STRIDE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define RBK_D_DAIN_SURF_STRIDE_0_RESET_MASK (_MK_MASK_CONST(0xffffffe0))
+#define RBK_D_DAIN_SURF_STRIDE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define RBK_D_DAIN_SURF_STRIDE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define RBK_D_DAIN_SURF_STRIDE_0_READ_MASK (_MK_MASK_CONST(0xffffffe0))
+#define RBK_D_DAIN_SURF_STRIDE_0_WRITE_MASK (_MK_MASK_CONST(0xffffffe0))
+#define RBK_D_DAIN_SURF_STRIDE_0_DAIN_SURF_STRIDE_SHIFT (_MK_SHIFT_CONST(5))
+#define RBK_D_DAIN_SURF_STRIDE_0_DAIN_SURF_STRIDE_FIELD \
+	(_MK_FIELD_CONST(0x7ffffff,                     \
+			 RBK_D_DAIN_SURF_STRIDE_0_DAIN_SURF_STRIDE_SHIFT))
+#define RBK_D_DAIN_SURF_STRIDE_0_DAIN_SURF_STRIDE_RANGE (31 : 5)
+#define RBK_D_DAIN_SURF_STRIDE_0_DAIN_SURF_STRIDE_WOFFSET (0x0)
+#define RBK_D_DAIN_SURF_STRIDE_0_DAIN_SURF_STRIDE_DEFAULT (_MK_MASK_CONST(0x0))
+#define RBK_D_DAIN_SURF_STRIDE_0_DAIN_SURF_STRIDE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffffff))
+#define RBK_D_DAIN_SURF_STRIDE_0_DAIN_SURF_STRIDE_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define RBK_D_DAIN_SURF_STRIDE_0_DAIN_SURF_STRIDE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define RBK_D_DAIN_SURF_STRIDE_0_DAIN_SURF_STRIDE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define RBK_D_DAIN_SURF_STRIDE_0_DAIN_SURF_STRIDE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register RBK_D_DAIN_PLANAR_STRIDE_0
+#define RBK_D_DAIN_PLANAR_STRIDE_0 (_MK_ADDR_CONST(0x1002c))
+#define RBK_D_DAIN_PLANAR_STRIDE_0_SECURE (0x0)
+#define RBK_D_DAIN_PLANAR_STRIDE_0_DUAL (0x0)
+#define RBK_D_DAIN_PLANAR_STRIDE_0_SCR (0)
+#define RBK_D_DAIN_PLANAR_STRIDE_0_WORD_COUNT (0x1)
+#define RBK_D_DAIN_PLANAR_STRIDE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define RBK_D_DAIN_PLANAR_STRIDE_0_RESET_MASK (_MK_MASK_CONST(0xffffffe0))
+#define RBK_D_DAIN_PLANAR_STRIDE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define RBK_D_DAIN_PLANAR_STRIDE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define RBK_D_DAIN_PLANAR_STRIDE_0_READ_MASK (_MK_MASK_CONST(0xffffffe0))
+#define RBK_D_DAIN_PLANAR_STRIDE_0_WRITE_MASK (_MK_MASK_CONST(0xffffffe0))
+#define RBK_D_DAIN_PLANAR_STRIDE_0_DAIN_PLANAR_STRIDE_SHIFT (_MK_SHIFT_CONST(5))
+#define RBK_D_DAIN_PLANAR_STRIDE_0_DAIN_PLANAR_STRIDE_FIELD \
+	(_MK_FIELD_CONST(0x7ffffff,                         \
+			 RBK_D_DAIN_PLANAR_STRIDE_0_DAIN_PLANAR_STRIDE_SHIFT))
+#define RBK_D_DAIN_PLANAR_STRIDE_0_DAIN_PLANAR_STRIDE_RANGE (31 : 5)
+#define RBK_D_DAIN_PLANAR_STRIDE_0_DAIN_PLANAR_STRIDE_WOFFSET (0x0)
+#define RBK_D_DAIN_PLANAR_STRIDE_0_DAIN_PLANAR_STRIDE_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define RBK_D_DAIN_PLANAR_STRIDE_0_DAIN_PLANAR_STRIDE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffffff))
+#define RBK_D_DAIN_PLANAR_STRIDE_0_DAIN_PLANAR_STRIDE_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define RBK_D_DAIN_PLANAR_STRIDE_0_DAIN_PLANAR_STRIDE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define RBK_D_DAIN_PLANAR_STRIDE_0_DAIN_PLANAR_STRIDE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define RBK_D_DAIN_PLANAR_STRIDE_0_DAIN_PLANAR_STRIDE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register RBK_D_DAOUT_RAM_TYPE_0
+#define RBK_D_DAOUT_RAM_TYPE_0 (_MK_ADDR_CONST(0x10030))
+#define RBK_D_DAOUT_RAM_TYPE_0_SECURE (0x0)
+#define RBK_D_DAOUT_RAM_TYPE_0_DUAL (0x0)
+#define RBK_D_DAOUT_RAM_TYPE_0_SCR (0)
+#define RBK_D_DAOUT_RAM_TYPE_0_WORD_COUNT (0x1)
+#define RBK_D_DAOUT_RAM_TYPE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define RBK_D_DAOUT_RAM_TYPE_0_RESET_MASK (_MK_MASK_CONST(0x1))
+#define RBK_D_DAOUT_RAM_TYPE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define RBK_D_DAOUT_RAM_TYPE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define RBK_D_DAOUT_RAM_TYPE_0_READ_MASK (_MK_MASK_CONST(0x1))
+#define RBK_D_DAOUT_RAM_TYPE_0_WRITE_MASK (_MK_MASK_CONST(0x1))
+#define RBK_D_DAOUT_RAM_TYPE_0_DATAOUT_RAM_TYPE_SHIFT (_MK_SHIFT_CONST(0))
+#define RBK_D_DAOUT_RAM_TYPE_0_DATAOUT_RAM_TYPE_FIELD \
+	(_MK_FIELD_CONST(0x1, RBK_D_DAOUT_RAM_TYPE_0_DATAOUT_RAM_TYPE_SHIFT))
+#define RBK_D_DAOUT_RAM_TYPE_0_DATAOUT_RAM_TYPE_RANGE (0 : 0)
+#define RBK_D_DAOUT_RAM_TYPE_0_DATAOUT_RAM_TYPE_WOFFSET (0x0)
+#define RBK_D_DAOUT_RAM_TYPE_0_DATAOUT_RAM_TYPE_DEFAULT (_MK_MASK_CONST(0x0))
+#define RBK_D_DAOUT_RAM_TYPE_0_DATAOUT_RAM_TYPE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1))
+#define RBK_D_DAOUT_RAM_TYPE_0_DATAOUT_RAM_TYPE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define RBK_D_DAOUT_RAM_TYPE_0_DATAOUT_RAM_TYPE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define RBK_D_DAOUT_RAM_TYPE_0_DATAOUT_RAM_TYPE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define RBK_D_DAOUT_RAM_TYPE_0_DATAOUT_RAM_TYPE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+#define RBK_D_DAOUT_RAM_TYPE_0_DATAOUT_RAM_TYPE_INIT_ENUM (CVIF)
+#define RBK_D_DAOUT_RAM_TYPE_0_DATAOUT_RAM_TYPE_CVIF (_MK_ENUM_CONST(0))
+#define RBK_D_DAOUT_RAM_TYPE_0_DATAOUT_RAM_TYPE_MCIF (_MK_ENUM_CONST(1))
+
+// Register RBK_D_DATAOUT_SIZE_1_0
+#define RBK_D_DATAOUT_SIZE_1_0 (_MK_ADDR_CONST(0x10034))
+#define RBK_D_DATAOUT_SIZE_1_0_SECURE (0x0)
+#define RBK_D_DATAOUT_SIZE_1_0_DUAL (0x0)
+#define RBK_D_DATAOUT_SIZE_1_0_SCR (0)
+#define RBK_D_DATAOUT_SIZE_1_0_WORD_COUNT (0x1)
+#define RBK_D_DATAOUT_SIZE_1_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define RBK_D_DATAOUT_SIZE_1_0_RESET_MASK (_MK_MASK_CONST(0x1fff))
+#define RBK_D_DATAOUT_SIZE_1_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define RBK_D_DATAOUT_SIZE_1_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define RBK_D_DATAOUT_SIZE_1_0_READ_MASK (_MK_MASK_CONST(0x1fff))
+#define RBK_D_DATAOUT_SIZE_1_0_WRITE_MASK (_MK_MASK_CONST(0x1fff))
+#define RBK_D_DATAOUT_SIZE_1_0_DATAOUT_CHANNEL_SHIFT (_MK_SHIFT_CONST(0))
+#define RBK_D_DATAOUT_SIZE_1_0_DATAOUT_CHANNEL_FIELD \
+	(_MK_FIELD_CONST(0x1fff, RBK_D_DATAOUT_SIZE_1_0_DATAOUT_CHANNEL_SHIFT))
+#define RBK_D_DATAOUT_SIZE_1_0_DATAOUT_CHANNEL_RANGE (12 : 0)
+#define RBK_D_DATAOUT_SIZE_1_0_DATAOUT_CHANNEL_WOFFSET (0x0)
+#define RBK_D_DATAOUT_SIZE_1_0_DATAOUT_CHANNEL_DEFAULT (_MK_MASK_CONST(0x0))
+#define RBK_D_DATAOUT_SIZE_1_0_DATAOUT_CHANNEL_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1fff))
+#define RBK_D_DATAOUT_SIZE_1_0_DATAOUT_CHANNEL_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define RBK_D_DATAOUT_SIZE_1_0_DATAOUT_CHANNEL_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define RBK_D_DATAOUT_SIZE_1_0_DATAOUT_CHANNEL_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define RBK_D_DATAOUT_SIZE_1_0_DATAOUT_CHANNEL_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register RBK_D_DAOUT_ADDR_HIGH_0
+#define RBK_D_DAOUT_ADDR_HIGH_0 (_MK_ADDR_CONST(0x10038))
+#define RBK_D_DAOUT_ADDR_HIGH_0_SECURE (0x0)
+#define RBK_D_DAOUT_ADDR_HIGH_0_DUAL (0x0)
+#define RBK_D_DAOUT_ADDR_HIGH_0_SCR (0)
+#define RBK_D_DAOUT_ADDR_HIGH_0_WORD_COUNT (0x1)
+#define RBK_D_DAOUT_ADDR_HIGH_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define RBK_D_DAOUT_ADDR_HIGH_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define RBK_D_DAOUT_ADDR_HIGH_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define RBK_D_DAOUT_ADDR_HIGH_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define RBK_D_DAOUT_ADDR_HIGH_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define RBK_D_DAOUT_ADDR_HIGH_0_WRITE_MASK (_MK_MASK_CONST(0xffffffff))
+#define RBK_D_DAOUT_ADDR_HIGH_0_DAOUT_ADDR_HIGH_SHIFT (_MK_SHIFT_CONST(0))
+#define RBK_D_DAOUT_ADDR_HIGH_0_DAOUT_ADDR_HIGH_FIELD \
+	(_MK_FIELD_CONST(0xffffffff,                  \
+			 RBK_D_DAOUT_ADDR_HIGH_0_DAOUT_ADDR_HIGH_SHIFT))
+#define RBK_D_DAOUT_ADDR_HIGH_0_DAOUT_ADDR_HIGH_RANGE (31 : 0)
+#define RBK_D_DAOUT_ADDR_HIGH_0_DAOUT_ADDR_HIGH_WOFFSET (0x0)
+#define RBK_D_DAOUT_ADDR_HIGH_0_DAOUT_ADDR_HIGH_DEFAULT (_MK_MASK_CONST(0x0))
+#define RBK_D_DAOUT_ADDR_HIGH_0_DAOUT_ADDR_HIGH_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define RBK_D_DAOUT_ADDR_HIGH_0_DAOUT_ADDR_HIGH_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define RBK_D_DAOUT_ADDR_HIGH_0_DAOUT_ADDR_HIGH_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define RBK_D_DAOUT_ADDR_HIGH_0_DAOUT_ADDR_HIGH_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define RBK_D_DAOUT_ADDR_HIGH_0_DAOUT_ADDR_HIGH_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register RBK_D_DAOUT_ADDR_LOW_0
+#define RBK_D_DAOUT_ADDR_LOW_0 (_MK_ADDR_CONST(0x1003c))
+#define RBK_D_DAOUT_ADDR_LOW_0_SECURE (0x0)
+#define RBK_D_DAOUT_ADDR_LOW_0_DUAL (0x0)
+#define RBK_D_DAOUT_ADDR_LOW_0_SCR (0)
+#define RBK_D_DAOUT_ADDR_LOW_0_WORD_COUNT (0x1)
+#define RBK_D_DAOUT_ADDR_LOW_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define RBK_D_DAOUT_ADDR_LOW_0_RESET_MASK (_MK_MASK_CONST(0xffffffe0))
+#define RBK_D_DAOUT_ADDR_LOW_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define RBK_D_DAOUT_ADDR_LOW_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define RBK_D_DAOUT_ADDR_LOW_0_READ_MASK (_MK_MASK_CONST(0xffffffe0))
+#define RBK_D_DAOUT_ADDR_LOW_0_WRITE_MASK (_MK_MASK_CONST(0xffffffe0))
+#define RBK_D_DAOUT_ADDR_LOW_0_DAOUT_ADDR_LOW_SHIFT (_MK_SHIFT_CONST(5))
+#define RBK_D_DAOUT_ADDR_LOW_0_DAOUT_ADDR_LOW_FIELD \
+	(_MK_FIELD_CONST(0x7ffffff,                 \
+			 RBK_D_DAOUT_ADDR_LOW_0_DAOUT_ADDR_LOW_SHIFT))
+#define RBK_D_DAOUT_ADDR_LOW_0_DAOUT_ADDR_LOW_RANGE (31 : 5)
+#define RBK_D_DAOUT_ADDR_LOW_0_DAOUT_ADDR_LOW_WOFFSET (0x0)
+#define RBK_D_DAOUT_ADDR_LOW_0_DAOUT_ADDR_LOW_DEFAULT (_MK_MASK_CONST(0x0))
+#define RBK_D_DAOUT_ADDR_LOW_0_DAOUT_ADDR_LOW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffffff))
+#define RBK_D_DAOUT_ADDR_LOW_0_DAOUT_ADDR_LOW_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define RBK_D_DAOUT_ADDR_LOW_0_DAOUT_ADDR_LOW_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define RBK_D_DAOUT_ADDR_LOW_0_DAOUT_ADDR_LOW_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define RBK_D_DAOUT_ADDR_LOW_0_DAOUT_ADDR_LOW_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register RBK_D_DAOUT_LINE_STRIDE_0
+#define RBK_D_DAOUT_LINE_STRIDE_0 (_MK_ADDR_CONST(0x10040))
+#define RBK_D_DAOUT_LINE_STRIDE_0_SECURE (0x0)
+#define RBK_D_DAOUT_LINE_STRIDE_0_DUAL (0x0)
+#define RBK_D_DAOUT_LINE_STRIDE_0_SCR (0)
+#define RBK_D_DAOUT_LINE_STRIDE_0_WORD_COUNT (0x1)
+#define RBK_D_DAOUT_LINE_STRIDE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define RBK_D_DAOUT_LINE_STRIDE_0_RESET_MASK (_MK_MASK_CONST(0xffffffe0))
+#define RBK_D_DAOUT_LINE_STRIDE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define RBK_D_DAOUT_LINE_STRIDE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define RBK_D_DAOUT_LINE_STRIDE_0_READ_MASK (_MK_MASK_CONST(0xffffffe0))
+#define RBK_D_DAOUT_LINE_STRIDE_0_WRITE_MASK (_MK_MASK_CONST(0xffffffe0))
+#define RBK_D_DAOUT_LINE_STRIDE_0_DAOUT_LINE_STRIDE_SHIFT (_MK_SHIFT_CONST(5))
+#define RBK_D_DAOUT_LINE_STRIDE_0_DAOUT_LINE_STRIDE_FIELD \
+	(_MK_FIELD_CONST(0x7ffffff,                       \
+			 RBK_D_DAOUT_LINE_STRIDE_0_DAOUT_LINE_STRIDE_SHIFT))
+#define RBK_D_DAOUT_LINE_STRIDE_0_DAOUT_LINE_STRIDE_RANGE (31 : 5)
+#define RBK_D_DAOUT_LINE_STRIDE_0_DAOUT_LINE_STRIDE_WOFFSET (0x0)
+#define RBK_D_DAOUT_LINE_STRIDE_0_DAOUT_LINE_STRIDE_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define RBK_D_DAOUT_LINE_STRIDE_0_DAOUT_LINE_STRIDE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffffff))
+#define RBK_D_DAOUT_LINE_STRIDE_0_DAOUT_LINE_STRIDE_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define RBK_D_DAOUT_LINE_STRIDE_0_DAOUT_LINE_STRIDE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define RBK_D_DAOUT_LINE_STRIDE_0_DAOUT_LINE_STRIDE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define RBK_D_DAOUT_LINE_STRIDE_0_DAOUT_LINE_STRIDE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register RBK_D_CONTRACT_STRIDE_0_0
+#define RBK_D_CONTRACT_STRIDE_0_0 (_MK_ADDR_CONST(0x10044))
+#define RBK_D_CONTRACT_STRIDE_0_0_SECURE (0x0)
+#define RBK_D_CONTRACT_STRIDE_0_0_DUAL (0x0)
+#define RBK_D_CONTRACT_STRIDE_0_0_SCR (0)
+#define RBK_D_CONTRACT_STRIDE_0_0_WORD_COUNT (0x1)
+#define RBK_D_CONTRACT_STRIDE_0_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define RBK_D_CONTRACT_STRIDE_0_0_RESET_MASK (_MK_MASK_CONST(0xffffffe0))
+#define RBK_D_CONTRACT_STRIDE_0_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define RBK_D_CONTRACT_STRIDE_0_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define RBK_D_CONTRACT_STRIDE_0_0_READ_MASK (_MK_MASK_CONST(0xffffffe0))
+#define RBK_D_CONTRACT_STRIDE_0_0_WRITE_MASK (_MK_MASK_CONST(0xffffffe0))
+#define RBK_D_CONTRACT_STRIDE_0_0_CONTRACT_STRIDE_0_SHIFT (_MK_SHIFT_CONST(5))
+#define RBK_D_CONTRACT_STRIDE_0_0_CONTRACT_STRIDE_0_FIELD \
+	(_MK_FIELD_CONST(0x7ffffff,                       \
+			 RBK_D_CONTRACT_STRIDE_0_0_CONTRACT_STRIDE_0_SHIFT))
+#define RBK_D_CONTRACT_STRIDE_0_0_CONTRACT_STRIDE_0_RANGE (31 : 5)
+#define RBK_D_CONTRACT_STRIDE_0_0_CONTRACT_STRIDE_0_WOFFSET (0x0)
+#define RBK_D_CONTRACT_STRIDE_0_0_CONTRACT_STRIDE_0_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define RBK_D_CONTRACT_STRIDE_0_0_CONTRACT_STRIDE_0_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffffff))
+#define RBK_D_CONTRACT_STRIDE_0_0_CONTRACT_STRIDE_0_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define RBK_D_CONTRACT_STRIDE_0_0_CONTRACT_STRIDE_0_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define RBK_D_CONTRACT_STRIDE_0_0_CONTRACT_STRIDE_0_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define RBK_D_CONTRACT_STRIDE_0_0_CONTRACT_STRIDE_0_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register RBK_D_CONTRACT_STRIDE_1_0
+#define RBK_D_CONTRACT_STRIDE_1_0 (_MK_ADDR_CONST(0x10048))
+#define RBK_D_CONTRACT_STRIDE_1_0_SECURE (0x0)
+#define RBK_D_CONTRACT_STRIDE_1_0_DUAL (0x0)
+#define RBK_D_CONTRACT_STRIDE_1_0_SCR (0)
+#define RBK_D_CONTRACT_STRIDE_1_0_WORD_COUNT (0x1)
+#define RBK_D_CONTRACT_STRIDE_1_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define RBK_D_CONTRACT_STRIDE_1_0_RESET_MASK (_MK_MASK_CONST(0xffffffe0))
+#define RBK_D_CONTRACT_STRIDE_1_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define RBK_D_CONTRACT_STRIDE_1_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define RBK_D_CONTRACT_STRIDE_1_0_READ_MASK (_MK_MASK_CONST(0xffffffe0))
+#define RBK_D_CONTRACT_STRIDE_1_0_WRITE_MASK (_MK_MASK_CONST(0xffffffe0))
+#define RBK_D_CONTRACT_STRIDE_1_0_CONTRACT_STRIDE_1_SHIFT (_MK_SHIFT_CONST(5))
+#define RBK_D_CONTRACT_STRIDE_1_0_CONTRACT_STRIDE_1_FIELD \
+	(_MK_FIELD_CONST(0x7ffffff,                       \
+			 RBK_D_CONTRACT_STRIDE_1_0_CONTRACT_STRIDE_1_SHIFT))
+#define RBK_D_CONTRACT_STRIDE_1_0_CONTRACT_STRIDE_1_RANGE (31 : 5)
+#define RBK_D_CONTRACT_STRIDE_1_0_CONTRACT_STRIDE_1_WOFFSET (0x0)
+#define RBK_D_CONTRACT_STRIDE_1_0_CONTRACT_STRIDE_1_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define RBK_D_CONTRACT_STRIDE_1_0_CONTRACT_STRIDE_1_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffffff))
+#define RBK_D_CONTRACT_STRIDE_1_0_CONTRACT_STRIDE_1_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define RBK_D_CONTRACT_STRIDE_1_0_CONTRACT_STRIDE_1_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define RBK_D_CONTRACT_STRIDE_1_0_CONTRACT_STRIDE_1_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define RBK_D_CONTRACT_STRIDE_1_0_CONTRACT_STRIDE_1_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register RBK_D_DAOUT_SURF_STRIDE_0
+#define RBK_D_DAOUT_SURF_STRIDE_0 (_MK_ADDR_CONST(0x1004c))
+#define RBK_D_DAOUT_SURF_STRIDE_0_SECURE (0x0)
+#define RBK_D_DAOUT_SURF_STRIDE_0_DUAL (0x0)
+#define RBK_D_DAOUT_SURF_STRIDE_0_SCR (0)
+#define RBK_D_DAOUT_SURF_STRIDE_0_WORD_COUNT (0x1)
+#define RBK_D_DAOUT_SURF_STRIDE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define RBK_D_DAOUT_SURF_STRIDE_0_RESET_MASK (_MK_MASK_CONST(0xffffffe0))
+#define RBK_D_DAOUT_SURF_STRIDE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define RBK_D_DAOUT_SURF_STRIDE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define RBK_D_DAOUT_SURF_STRIDE_0_READ_MASK (_MK_MASK_CONST(0xffffffe0))
+#define RBK_D_DAOUT_SURF_STRIDE_0_WRITE_MASK (_MK_MASK_CONST(0xffffffe0))
+#define RBK_D_DAOUT_SURF_STRIDE_0_DAOUT_SURF_STRIDE_SHIFT (_MK_SHIFT_CONST(5))
+#define RBK_D_DAOUT_SURF_STRIDE_0_DAOUT_SURF_STRIDE_FIELD \
+	(_MK_FIELD_CONST(0x7ffffff,                       \
+			 RBK_D_DAOUT_SURF_STRIDE_0_DAOUT_SURF_STRIDE_SHIFT))
+#define RBK_D_DAOUT_SURF_STRIDE_0_DAOUT_SURF_STRIDE_RANGE (31 : 5)
+#define RBK_D_DAOUT_SURF_STRIDE_0_DAOUT_SURF_STRIDE_WOFFSET (0x0)
+#define RBK_D_DAOUT_SURF_STRIDE_0_DAOUT_SURF_STRIDE_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define RBK_D_DAOUT_SURF_STRIDE_0_DAOUT_SURF_STRIDE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffffff))
+#define RBK_D_DAOUT_SURF_STRIDE_0_DAOUT_SURF_STRIDE_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define RBK_D_DAOUT_SURF_STRIDE_0_DAOUT_SURF_STRIDE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define RBK_D_DAOUT_SURF_STRIDE_0_DAOUT_SURF_STRIDE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define RBK_D_DAOUT_SURF_STRIDE_0_DAOUT_SURF_STRIDE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register RBK_D_DAOUT_PLANAR_STRIDE_0
+#define RBK_D_DAOUT_PLANAR_STRIDE_0 (_MK_ADDR_CONST(0x10050))
+#define RBK_D_DAOUT_PLANAR_STRIDE_0_SECURE (0x0)
+#define RBK_D_DAOUT_PLANAR_STRIDE_0_DUAL (0x0)
+#define RBK_D_DAOUT_PLANAR_STRIDE_0_SCR (0)
+#define RBK_D_DAOUT_PLANAR_STRIDE_0_WORD_COUNT (0x1)
+#define RBK_D_DAOUT_PLANAR_STRIDE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define RBK_D_DAOUT_PLANAR_STRIDE_0_RESET_MASK (_MK_MASK_CONST(0xffffffe0))
+#define RBK_D_DAOUT_PLANAR_STRIDE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define RBK_D_DAOUT_PLANAR_STRIDE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define RBK_D_DAOUT_PLANAR_STRIDE_0_READ_MASK (_MK_MASK_CONST(0xffffffe0))
+#define RBK_D_DAOUT_PLANAR_STRIDE_0_WRITE_MASK (_MK_MASK_CONST(0xffffffe0))
+#define RBK_D_DAOUT_PLANAR_STRIDE_0_DAOUT_PLANAR_STRIDE_SHIFT \
+	(_MK_SHIFT_CONST(5))
+#define RBK_D_DAOUT_PLANAR_STRIDE_0_DAOUT_PLANAR_STRIDE_FIELD \
+	(_MK_FIELD_CONST(                                     \
+		0x7ffffff,                                    \
+		RBK_D_DAOUT_PLANAR_STRIDE_0_DAOUT_PLANAR_STRIDE_SHIFT))
+#define RBK_D_DAOUT_PLANAR_STRIDE_0_DAOUT_PLANAR_STRIDE_RANGE (31 : 5)
+#define RBK_D_DAOUT_PLANAR_STRIDE_0_DAOUT_PLANAR_STRIDE_WOFFSET (0x0)
+#define RBK_D_DAOUT_PLANAR_STRIDE_0_DAOUT_PLANAR_STRIDE_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define RBK_D_DAOUT_PLANAR_STRIDE_0_DAOUT_PLANAR_STRIDE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x7ffffff))
+#define RBK_D_DAOUT_PLANAR_STRIDE_0_DAOUT_PLANAR_STRIDE_SW_DEFAULT \
+	(_MK_MASK_CONST(0x0))
+#define RBK_D_DAOUT_PLANAR_STRIDE_0_DAOUT_PLANAR_STRIDE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define RBK_D_DAOUT_PLANAR_STRIDE_0_DAOUT_PLANAR_STRIDE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define RBK_D_DAOUT_PLANAR_STRIDE_0_DAOUT_PLANAR_STRIDE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register RBK_D_DECONV_STRIDE_0
+#define RBK_D_DECONV_STRIDE_0 (_MK_ADDR_CONST(0x10054))
+#define RBK_D_DECONV_STRIDE_0_SECURE (0x0)
+#define RBK_D_DECONV_STRIDE_0_DUAL (0x0)
+#define RBK_D_DECONV_STRIDE_0_SCR (0)
+#define RBK_D_DECONV_STRIDE_0_WORD_COUNT (0x1)
+#define RBK_D_DECONV_STRIDE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define RBK_D_DECONV_STRIDE_0_RESET_MASK (_MK_MASK_CONST(0x1f001f))
+#define RBK_D_DECONV_STRIDE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define RBK_D_DECONV_STRIDE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define RBK_D_DECONV_STRIDE_0_READ_MASK (_MK_MASK_CONST(0x1f001f))
+#define RBK_D_DECONV_STRIDE_0_WRITE_MASK (_MK_MASK_CONST(0x1f001f))
+#define RBK_D_DECONV_STRIDE_0_DECONV_X_STRIDE_SHIFT (_MK_SHIFT_CONST(0))
+#define RBK_D_DECONV_STRIDE_0_DECONV_X_STRIDE_FIELD \
+	(_MK_FIELD_CONST(0x1f, RBK_D_DECONV_STRIDE_0_DECONV_X_STRIDE_SHIFT))
+#define RBK_D_DECONV_STRIDE_0_DECONV_X_STRIDE_RANGE (4 : 0)
+#define RBK_D_DECONV_STRIDE_0_DECONV_X_STRIDE_WOFFSET (0x0)
+#define RBK_D_DECONV_STRIDE_0_DECONV_X_STRIDE_DEFAULT (_MK_MASK_CONST(0x0))
+#define RBK_D_DECONV_STRIDE_0_DECONV_X_STRIDE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1f))
+#define RBK_D_DECONV_STRIDE_0_DECONV_X_STRIDE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define RBK_D_DECONV_STRIDE_0_DECONV_X_STRIDE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define RBK_D_DECONV_STRIDE_0_DECONV_X_STRIDE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define RBK_D_DECONV_STRIDE_0_DECONV_X_STRIDE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+#define RBK_D_DECONV_STRIDE_0_DECONV_Y_STRIDE_SHIFT (_MK_SHIFT_CONST(16))
+#define RBK_D_DECONV_STRIDE_0_DECONV_Y_STRIDE_FIELD \
+	(_MK_FIELD_CONST(0x1f, RBK_D_DECONV_STRIDE_0_DECONV_Y_STRIDE_SHIFT))
+#define RBK_D_DECONV_STRIDE_0_DECONV_Y_STRIDE_RANGE (20 : 16)
+#define RBK_D_DECONV_STRIDE_0_DECONV_Y_STRIDE_WOFFSET (0x0)
+#define RBK_D_DECONV_STRIDE_0_DECONV_Y_STRIDE_DEFAULT (_MK_MASK_CONST(0x0))
+#define RBK_D_DECONV_STRIDE_0_DECONV_Y_STRIDE_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x1f))
+#define RBK_D_DECONV_STRIDE_0_DECONV_Y_STRIDE_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define RBK_D_DECONV_STRIDE_0_DECONV_Y_STRIDE_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define RBK_D_DECONV_STRIDE_0_DECONV_Y_STRIDE_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define RBK_D_DECONV_STRIDE_0_DECONV_Y_STRIDE_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register RBK_D_PERF_ENABLE_0
+#define RBK_D_PERF_ENABLE_0 (_MK_ADDR_CONST(0x10058))
+#define RBK_D_PERF_ENABLE_0_SECURE (0x0)
+#define RBK_D_PERF_ENABLE_0_DUAL (0x0)
+#define RBK_D_PERF_ENABLE_0_SCR (0)
+#define RBK_D_PERF_ENABLE_0_WORD_COUNT (0x1)
+#define RBK_D_PERF_ENABLE_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define RBK_D_PERF_ENABLE_0_RESET_MASK (_MK_MASK_CONST(0x1))
+#define RBK_D_PERF_ENABLE_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define RBK_D_PERF_ENABLE_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define RBK_D_PERF_ENABLE_0_READ_MASK (_MK_MASK_CONST(0x1))
+#define RBK_D_PERF_ENABLE_0_WRITE_MASK (_MK_MASK_CONST(0x1))
+#define RBK_D_PERF_ENABLE_0_PERF_EN_SHIFT (_MK_SHIFT_CONST(0))
+#define RBK_D_PERF_ENABLE_0_PERF_EN_FIELD \
+	(_MK_FIELD_CONST(0x1, RBK_D_PERF_ENABLE_0_PERF_EN_SHIFT))
+#define RBK_D_PERF_ENABLE_0_PERF_EN_RANGE (0 : 0)
+#define RBK_D_PERF_ENABLE_0_PERF_EN_WOFFSET (0x0)
+#define RBK_D_PERF_ENABLE_0_PERF_EN_DEFAULT (_MK_MASK_CONST(0x0))
+#define RBK_D_PERF_ENABLE_0_PERF_EN_DEFAULT_MASK (_MK_MASK_CONST(0x1))
+#define RBK_D_PERF_ENABLE_0_PERF_EN_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define RBK_D_PERF_ENABLE_0_PERF_EN_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define RBK_D_PERF_ENABLE_0_PERF_EN_PARITY_PROTECTION (_MK_MASK_CONST(0x0))
+#define RBK_D_PERF_ENABLE_0_PERF_EN_PLATFORM_DEPENDENT (_MK_MASK_CONST(0x1))
+
+// Register RBK_D_PERF_READ_STALL_0
+#define RBK_D_PERF_READ_STALL_0 (_MK_ADDR_CONST(0x1005c))
+#define RBK_D_PERF_READ_STALL_0_SECURE (0x0)
+#define RBK_D_PERF_READ_STALL_0_DUAL (0x0)
+#define RBK_D_PERF_READ_STALL_0_SCR (0)
+#define RBK_D_PERF_READ_STALL_0_WORD_COUNT (0x1)
+#define RBK_D_PERF_READ_STALL_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define RBK_D_PERF_READ_STALL_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define RBK_D_PERF_READ_STALL_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define RBK_D_PERF_READ_STALL_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define RBK_D_PERF_READ_STALL_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define RBK_D_PERF_READ_STALL_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define RBK_D_PERF_READ_STALL_0_RD_STALL_CNT_SHIFT (_MK_SHIFT_CONST(0))
+#define RBK_D_PERF_READ_STALL_0_RD_STALL_CNT_FIELD \
+	(_MK_FIELD_CONST(0xffffffff,               \
+			 RBK_D_PERF_READ_STALL_0_RD_STALL_CNT_SHIFT))
+#define RBK_D_PERF_READ_STALL_0_RD_STALL_CNT_RANGE (31 : 0)
+#define RBK_D_PERF_READ_STALL_0_RD_STALL_CNT_WOFFSET (0x0)
+#define RBK_D_PERF_READ_STALL_0_RD_STALL_CNT_DEFAULT (_MK_MASK_CONST(0x0))
+#define RBK_D_PERF_READ_STALL_0_RD_STALL_CNT_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define RBK_D_PERF_READ_STALL_0_RD_STALL_CNT_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define RBK_D_PERF_READ_STALL_0_RD_STALL_CNT_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define RBK_D_PERF_READ_STALL_0_RD_STALL_CNT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define RBK_D_PERF_READ_STALL_0_RD_STALL_CNT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+// Register RBK_D_PERF_WRITE_STALL_0
+#define RBK_D_PERF_WRITE_STALL_0 (_MK_ADDR_CONST(0x10060))
+#define RBK_D_PERF_WRITE_STALL_0_SECURE (0x0)
+#define RBK_D_PERF_WRITE_STALL_0_DUAL (0x0)
+#define RBK_D_PERF_WRITE_STALL_0_SCR (0)
+#define RBK_D_PERF_WRITE_STALL_0_WORD_COUNT (0x1)
+#define RBK_D_PERF_WRITE_STALL_0_RESET_VAL (_MK_MASK_CONST(0x0))
+#define RBK_D_PERF_WRITE_STALL_0_RESET_MASK (_MK_MASK_CONST(0xffffffff))
+#define RBK_D_PERF_WRITE_STALL_0_SW_DEFAULT_VAL (_MK_MASK_CONST(0x0))
+#define RBK_D_PERF_WRITE_STALL_0_SW_DEFAULT_MASK (_MK_MASK_CONST(0x0))
+#define RBK_D_PERF_WRITE_STALL_0_READ_MASK (_MK_MASK_CONST(0xffffffff))
+#define RBK_D_PERF_WRITE_STALL_0_WRITE_MASK (_MK_MASK_CONST(0x0))
+#define RBK_D_PERF_WRITE_STALL_0_WR_STALL_CNT_SHIFT (_MK_SHIFT_CONST(0))
+#define RBK_D_PERF_WRITE_STALL_0_WR_STALL_CNT_FIELD \
+	(_MK_FIELD_CONST(0xffffffff,                \
+			 RBK_D_PERF_WRITE_STALL_0_WR_STALL_CNT_SHIFT))
+#define RBK_D_PERF_WRITE_STALL_0_WR_STALL_CNT_RANGE (31 : 0)
+#define RBK_D_PERF_WRITE_STALL_0_WR_STALL_CNT_WOFFSET (0x0)
+#define RBK_D_PERF_WRITE_STALL_0_WR_STALL_CNT_DEFAULT (_MK_MASK_CONST(0x0))
+#define RBK_D_PERF_WRITE_STALL_0_WR_STALL_CNT_DEFAULT_MASK \
+	(_MK_MASK_CONST(0xffffffff))
+#define RBK_D_PERF_WRITE_STALL_0_WR_STALL_CNT_SW_DEFAULT (_MK_MASK_CONST(0x0))
+#define RBK_D_PERF_WRITE_STALL_0_WR_STALL_CNT_SW_DEFAULT_MASK \
+	(_MK_MASK_CONST(0x0))
+#define RBK_D_PERF_WRITE_STALL_0_WR_STALL_CNT_PARITY_PROTECTION \
+	(_MK_MASK_CONST(0x0))
+#define RBK_D_PERF_WRITE_STALL_0_WR_STALL_CNT_PLATFORM_DEPENDENT \
+	(_MK_MASK_CONST(0x1))
+
+//
+// REGISTER LIST
+//
+#define LIST_ARREGS(_op_)                                                                                                                                                                                                                                                                                                                                                                                                                                                               \
+	(_op_(GLB_S_NVDLA_HW_VERSION_0) _op_(GLB_S_INTR_MASK_0) _op_(GLB_S_INTR_SET_0) _op_(GLB_S_INTR_STATUS_0) _op_(MCIF_CFG_RD_WEIGHT_0_0) _op_(MCIF_CFG_RD_WEIGHT_1_0) _op_(MCIF_CFG_RD_WEIGHT_2_0) _op_(MCIF_CFG_WR_WEIGHT_0_0) _op_(MCIF_CFG_WR_WEIGHT_1_0) _op_(MCIF_CFG_OUTSTANDING_CNT_0) _op_(MCIF_STATUS_0) _op_(CVIF_CFG_RD_WEIGHT_0_0) _op_(                                                                                                                               \
+		CVIF_CFG_RD_WEIGHT_1_0) _op_(CVIF_CFG_RD_WEIGHT_2_0) _op_(CVIF_CFG_WR_WEIGHT_0_0) _op_(CVIF_CFG_WR_WEIGHT_1_0) _op_(CVIF_CFG_OUTSTANDING_CNT_0) _op_(CVIF_STATUS_0) _op_(BDMA_CFG_SRC_ADDR_LOW_0) _op_(BDMA_CFG_SRC_ADDR_HIGH_0) _op_(BDMA_CFG_DST_ADDR_LOW_0) _op_(BDMA_CFG_DST_ADDR_HIGH_0) _op_(BDMA_CFG_LINE_0)                                                                                                                                                     \
+		 _op_(BDMA_CFG_CMD_0) _op_(BDMA_CFG_LINE_REPEAT_0) _op_(BDMA_CFG_SRC_LINE_0) _op_(BDMA_CFG_DST_LINE_0) _op_(BDMA_CFG_SURF_REPEAT_0) _op_(BDMA_CFG_SRC_SURF_0) _op_(BDMA_CFG_DST_SURF_0) _op_(                                                                                                                                                                                                                                                                           \
+			 BDMA_CFG_OP_0) _op_(BDMA_CFG_LAUNCH0_0) _op_(BDMA_CFG_LAUNCH1_0) _op_(BDMA_CFG_STATUS_0) _op_(BDMA_STATUS_0) _op_(BDMA_STATUS_GRP0_READ_STALL_0) _op_(BDMA_STATUS_GRP0_WRITE_STALL_0) _op_(BDMA_STATUS_GRP1_READ_STALL_0) _op_(BDMA_STATUS_GRP1_WRITE_STALL_0)                                                                                                                                                                                                 \
+			 _op_(CDMA_S_STATUS_0) _op_(CDMA_S_POINTER_0) _op_(CDMA_S_ARBITER_0) _op_(CDMA_S_CBUF_FLUSH_STATUS_0) _op_(CDMA_D_OP_ENABLE_0) _op_(CDMA_D_MISC_CFG_0) _op_(CDMA_D_DATAIN_FORMAT_0) _op_(CDMA_D_DATAIN_SIZE_0_0) _op_(CDMA_D_DATAIN_SIZE_1_0) _op_(CDMA_D_DATAIN_SIZE_EXT_0_0) _op_(CDMA_D_PIXEL_OFFSET_0) _op_(                                                                                                                                                \
+				 CDMA_D_DAIN_RAM_TYPE_0) _op_(CDMA_D_DAIN_ADDR_HIGH_0_0) _op_(CDMA_D_DAIN_ADDR_LOW_0_0) _op_(CDMA_D_DAIN_ADDR_HIGH_1_0) _op_(CDMA_D_DAIN_ADDR_LOW_1_0) _op_(CDMA_D_LINE_STRIDE_0) _op_(CDMA_D_LINE_UV_STRIDE_0) _op_(CDMA_D_SURF_STRIDE_0) _op_(CDMA_D_DAIN_MAP_0) _op_(CDMA_D_RESERVED_X_CFG_0) _op_(CDMA_D_RESERVED_Y_CFG_0) _op_(CDMA_D_BATCH_NUMBER_0)                                                                                              \
+				 _op_(CDMA_D_BATCH_STRIDE_0) _op_(CDMA_D_ENTRY_PER_SLICE_0) _op_(CDMA_D_FETCH_GRAIN_0) _op_(CDMA_D_WEIGHT_FORMAT_0) _op_(                                                                                                                                                                                                                                                                                                                               \
+					 CDMA_D_WEIGHT_SIZE_0_0) _op_(CDMA_D_WEIGHT_SIZE_1_0) _op_(CDMA_D_WEIGHT_RAM_TYPE_0) _op_(CDMA_D_WEIGHT_ADDR_HIGH_0) _op_(CDMA_D_WEIGHT_ADDR_LOW_0) _op_(CDMA_D_WEIGHT_BYTES_0)                                                                                                                                                                                                                                                                 \
+					 _op_(CDMA_D_WGS_ADDR_HIGH_0) _op_(CDMA_D_WGS_ADDR_LOW_0) _op_(CDMA_D_WMB_ADDR_HIGH_0) _op_(CDMA_D_WMB_ADDR_LOW_0) _op_(CDMA_D_WMB_BYTES_0) _op_(CDMA_D_MEAN_FORMAT_0) _op_(CDMA_D_MEAN_GLOBAL_0_0) _op_(CDMA_D_MEAN_GLOBAL_1_0) _op_(CDMA_D_CVT_CFG_0) _op_(CDMA_D_CVT_OFFSET_0) _op_(CDMA_D_CVT_SCALE_0) _op_(CDMA_D_CONV_STRIDE_0) _op_(                                                                                                     \
+						 CDMA_D_ZERO_PADDING_0) _op_(CDMA_D_ZERO_PADDING_VALUE_0) _op_(CDMA_D_BANK_0) _op_(CDMA_D_NAN_FLUSH_TO_ZERO_0) _op_(CDMA_D_NAN_INPUT_DATA_NUM_0) _op_(CDMA_D_NAN_INPUT_WEIGHT_NUM_0)                                                                                                                                                                                                                                                    \
+						 _op_(CDMA_D_INF_INPUT_DATA_NUM_0) _op_(CDMA_D_INF_INPUT_WEIGHT_NUM_0) _op_(CDMA_D_PERF_ENABLE_0) _op_(CDMA_D_PERF_DAT_READ_STALL_0) _op_(CDMA_D_PERF_WT_READ_STALL_0) _op_(CDMA_D_PERF_DAT_READ_LATENCY_0) _op_(CDMA_D_PERF_WT_READ_LATENCY_0) _op_(CDMA_D_CYA_0) _op_(                                                                                                                                                                \
+							 CSC_S_STATUS_0) _op_(CSC_S_POINTER_0) _op_(CSC_D_OP_ENABLE_0) _op_(CSC_D_MISC_CFG_0) _op_(CSC_D_DATAIN_FORMAT_0) _op_(CSC_D_DATAIN_SIZE_EXT_0_0) _op_(CSC_D_DATAIN_SIZE_EXT_1_0) _op_(CSC_D_BATCH_NUMBER_0) _op_(CSC_D_POST_Y_EXTENSION_0)                                                                                                                                                                                     \
+							 _op_(CSC_D_ENTRY_PER_SLICE_0) _op_(CSC_D_WEIGHT_FORMAT_0) _op_(CSC_D_WEIGHT_SIZE_EXT_0_0) _op_(CSC_D_WEIGHT_SIZE_EXT_1_0) _op_(CSC_D_WEIGHT_BYTES_0) _op_(CSC_D_WMB_BYTES_0) _op_(CSC_D_DATAOUT_SIZE_0_0) _op_(CSC_D_DATAOUT_SIZE_1_0) _op_(                                                                                                                                                                                   \
+								 CSC_D_ATOMICS_0) _op_(CSC_D_RELEASE_0) _op_(CSC_D_CONV_STRIDE_EXT_0) _op_(CSC_D_DILATION_EXT_0) _op_(CSC_D_ZERO_PADDING_0) _op_(CSC_D_ZERO_PADDING_VALUE_0)                                                                                                                                                                                                                                                            \
+								 _op_(CSC_D_BANK_0) _op_(CSC_D_PRA_CFG_0) _op_(CSC_D_CYA_0) _op_(CMAC_A_S_STATUS_0) _op_(CMAC_A_S_POINTER_0) _op_(                                                                                                                                                                                                                                                                                                      \
+									 CMAC_A_D_OP_ENABLE_0) _op_(CMAC_A_D_MISC_CFG_0) _op_(CMAC_B_S_STATUS_0) _op_(CMAC_B_S_POINTER_0) _op_(CMAC_B_D_OP_ENABLE_0) _op_(CMAC_B_D_MISC_CFG_0)                                                                                                                                                                                                                                                          \
+									 _op_(CACC_S_STATUS_0) _op_(CACC_S_POINTER_0) _op_(CACC_D_OP_ENABLE_0) _op_(CACC_D_MISC_CFG_0) _op_(CACC_D_DATAOUT_SIZE_0_0) _op_(CACC_D_DATAOUT_SIZE_1_0) _op_(CACC_D_DATAOUT_ADDR_0) _op_(CACC_D_BATCH_NUMBER_0) _op_(CACC_D_LINE_STRIDE_0) _op_(CACC_D_SURF_STRIDE_0) _op_(                                                                                                                                  \
+										 CACC_D_DATAOUT_MAP_0) _op_(CACC_D_CLIP_CFG_0) _op_(CACC_D_OUT_SATURATION_0) _op_(CACC_D_CYA_0) _op_(SDP_RDMA_S_STATUS_0) _op_(SDP_RDMA_S_POINTER_0) _op_(SDP_RDMA_D_OP_ENABLE_0) _op_(SDP_RDMA_D_DATA_CUBE_WIDTH_0) _op_(SDP_RDMA_D_DATA_CUBE_HEIGHT_0) _op_(SDP_RDMA_D_DATA_CUBE_CHANNEL_0)                                                                                                           \
+										 _op_(SDP_RDMA_D_SRC_BASE_ADDR_LOW_0) _op_(SDP_RDMA_D_SRC_BASE_ADDR_HIGH_0) _op_(SDP_RDMA_D_SRC_LINE_STRIDE_0) _op_(SDP_RDMA_D_SRC_SURFACE_STRIDE_0) _op_(SDP_RDMA_D_BRDMA_CFG_0) _op_(SDP_RDMA_D_BS_BASE_ADDR_LOW_0) _op_(SDP_RDMA_D_BS_BASE_ADDR_HIGH_0) _op_(SDP_RDMA_D_BS_LINE_STRIDE_0) _op_(SDP_RDMA_D_BS_SURFACE_STRIDE_0) _op_(SDP_RDMA_D_BS_BATCH_STRIDE_0) _op_(SDP_RDMA_D_NRDMA_CFG_0) _op_( \
+											 SDP_RDMA_D_BN_BASE_ADDR_LOW_0) _op_(SDP_RDMA_D_BN_BASE_ADDR_HIGH_0) _op_(SDP_RDMA_D_BN_LINE_STRIDE_0) _op_(SDP_RDMA_D_BN_SURFACE_STRIDE_0) _op_(SDP_RDMA_D_BN_BATCH_STRIDE_0)                                                                                                                                                                                                                  \
+											 _op_(SDP_RDMA_D_ERDMA_CFG_0) _op_(SDP_RDMA_D_EW_BASE_ADDR_LOW_0) _op_(SDP_RDMA_D_EW_BASE_ADDR_HIGH_0) _op_(                                                                                                                                                                                                                                                                                    \
+												 SDP_RDMA_D_EW_LINE_STRIDE_0) _op_(SDP_RDMA_D_EW_SURFACE_STRIDE_0) _op_(SDP_RDMA_D_EW_BATCH_STRIDE_0)                                                                                                                                                                                                                                                                                   \
+												 _op_(SDP_RDMA_D_FEATURE_MODE_CFG_0) _op_(SDP_RDMA_D_SRC_DMA_CFG_0) _op_(SDP_RDMA_D_STATUS_NAN_INPUT_NUM_0) _op_(SDP_RDMA_D_STATUS_INF_INPUT_NUM_0) _op_(SDP_RDMA_D_PERF_ENABLE_0) _op_(                                                                                                                                                                                                \
+													 SDP_RDMA_D_PERF_MRDMA_READ_STALL_0) _op_(SDP_RDMA_D_PERF_BRDMA_READ_STALL_0) _op_(SDP_RDMA_D_PERF_NRDMA_READ_STALL_0)                                                                                                                                                                                                                                                          \
+													 _op_(SDP_RDMA_D_PERF_ERDMA_READ_STALL_0) _op_(SDP_S_STATUS_0) _op_(SDP_S_POINTER_0) _op_(SDP_S_LUT_ACCESS_CFG_0) _op_(                                                                                                                                                                                                                                                         \
+														 SDP_S_LUT_ACCESS_DATA_0) _op_(SDP_S_LUT_CFG_0) _op_(SDP_S_LUT_INFO_0) _op_(SDP_S_LUT_LE_START_0) _op_(SDP_S_LUT_LE_END_0) _op_(SDP_S_LUT_LO_START_0)                                                                                                                                                                                                                   \
+														 _op_(SDP_S_LUT_LO_END_0) _op_(SDP_S_LUT_LE_SLOPE_SCALE_0) _op_(SDP_S_LUT_LE_SLOPE_SHIFT_0) _op_(SDP_S_LUT_LO_SLOPE_SCALE_0) _op_(SDP_S_LUT_LO_SLOPE_SHIFT_0) _op_(SDP_D_OP_ENABLE_0) _op_(                                                                                                                                                                             \
+															 SDP_D_DATA_CUBE_WIDTH_0) _op_(SDP_D_DATA_CUBE_HEIGHT_0) _op_(SDP_D_DATA_CUBE_CHANNEL_0) _op_(SDP_D_DST_BASE_ADDR_LOW_0) _op_(SDP_D_DST_BASE_ADDR_HIGH_0) _op_(SDP_D_DST_LINE_STRIDE_0) _op_(SDP_D_DST_SURFACE_STRIDE_0) _op_(SDP_D_DP_BS_CFG_0)                                                                                                                \
+															 _op_(SDP_D_DP_BS_ALU_CFG_0) _op_(SDP_D_DP_BS_ALU_SRC_VALUE_0) _op_(SDP_D_DP_BS_MUL_CFG_0) _op_(SDP_D_DP_BS_MUL_SRC_VALUE_0) _op_(SDP_D_DP_BN_CFG_0) _op_(                                                                                                                                                                                                      \
+																 SDP_D_DP_BN_ALU_CFG_0) _op_(SDP_D_DP_BN_ALU_SRC_VALUE_0) _op_(SDP_D_DP_BN_MUL_CFG_0) _op_(SDP_D_DP_BN_MUL_SRC_VALUE_0) _op_(SDP_D_DP_EW_CFG_0) _op_(SDP_D_DP_EW_ALU_CFG_0)                                                                                                                                                                             \
+																 _op_(SDP_D_DP_EW_ALU_SRC_VALUE_0) _op_(SDP_D_DP_EW_ALU_CVT_OFFSET_VALUE_0) _op_(SDP_D_DP_EW_ALU_CVT_SCALE_VALUE_0) _op_(SDP_D_DP_EW_ALU_CVT_TRUNCATE_VALUE_0) _op_(SDP_D_DP_EW_MUL_CFG_0) _op_(                                                                                                                                                        \
+																	 SDP_D_DP_EW_MUL_SRC_VALUE_0) _op_(SDP_D_DP_EW_MUL_CVT_OFFSET_VALUE_0) _op_(SDP_D_DP_EW_MUL_CVT_SCALE_VALUE_0) _op_(SDP_D_DP_EW_MUL_CVT_TRUNCATE_VALUE_0) _op_(SDP_D_DP_EW_TRUNCATE_VALUE_0) _op_(SDP_D_FEATURE_MODE_CFG_0)                                                                                                                     \
+																	 _op_(SDP_D_DST_DMA_CFG_0) _op_(SDP_D_DST_BATCH_STRIDE_0) _op_(SDP_D_DATA_FORMAT_0) _op_(SDP_D_CVT_OFFSET_0) _op_(SDP_D_CVT_SCALE_0) _op_(SDP_D_CVT_SHIFT_0) _op_(SDP_D_STATUS_0) _op_(                                                                                                                                                         \
+																		 SDP_D_STATUS_NAN_INPUT_NUM_0) _op_(SDP_D_STATUS_INF_INPUT_NUM_0) _op_(SDP_D_STATUS_NAN_OUTPUT_NUM_0) _op_(SDP_D_PERF_ENABLE_0) _op_(SDP_D_PERF_WDMA_WRITE_STALL_0)                                                                                                                                                                     \
+																		 _op_(SDP_D_PERF_LUT_UFLOW_0) _op_(SDP_D_PERF_LUT_OFLOW_0) _op_(SDP_D_PERF_OUT_SATURATION_0) _op_(SDP_D_PERF_LUT_HYBRID_0) _op_(                                                                                                                                                                                                        \
+																			 SDP_D_PERF_LUT_LE_HIT_0) _op_(SDP_D_PERF_LUT_LO_HIT_0) _op_(PDP_RDMA_S_STATUS_0) _op_(PDP_RDMA_S_POINTER_0) _op_(PDP_RDMA_D_OP_ENABLE_0)                                                                                                                                                                                       \
+																			 _op_(PDP_RDMA_D_DATA_CUBE_IN_WIDTH_0) _op_(PDP_RDMA_D_DATA_CUBE_IN_HEIGHT_0) _op_(PDP_RDMA_D_DATA_CUBE_IN_CHANNEL_0) _op_(PDP_RDMA_D_FLYING_MODE_0) _op_(                                                                                                                                                                      \
+																				 PDP_RDMA_D_SRC_BASE_ADDR_LOW_0) _op_(PDP_RDMA_D_SRC_BASE_ADDR_HIGH_0) _op_(PDP_RDMA_D_SRC_LINE_STRIDE_0) _op_(PDP_RDMA_D_SRC_SURFACE_STRIDE_0)                                                                                                                                                                         \
+																				 _op_(PDP_RDMA_D_SRC_RAM_CFG_0) _op_(PDP_RDMA_D_DATA_FORMAT_0) _op_(PDP_RDMA_D_OPERATION_MODE_CFG_0) _op_(PDP_RDMA_D_POOLING_KERNEL_CFG_0) _op_(PDP_RDMA_D_POOLING_PADDING_CFG_0) _op_(                                                                                                                                 \
+																					 PDP_RDMA_D_PARTIAL_WIDTH_IN_0) _op_(PDP_RDMA_D_PERF_ENABLE_0) _op_(PDP_RDMA_D_PERF_READ_STALL_0) _op_(PDP_RDMA_D_CYA_0)                                                                                                                                                                                        \
+																					 _op_(PDP_S_STATUS_0) _op_(PDP_S_POINTER_0) _op_(PDP_D_OP_ENABLE_0) _op_(PDP_D_DATA_CUBE_IN_WIDTH_0) _op_(PDP_D_DATA_CUBE_IN_HEIGHT_0) _op_(PDP_D_DATA_CUBE_IN_CHANNEL_0) _op_(                                                                                                                                 \
+																						 PDP_D_DATA_CUBE_OUT_WIDTH_0) _op_(PDP_D_DATA_CUBE_OUT_HEIGHT_0) _op_(PDP_D_DATA_CUBE_OUT_CHANNEL_0) _op_(PDP_D_OPERATION_MODE_CFG_0) _op_(PDP_D_NAN_FLUSH_TO_ZERO_0) _op_(PDP_D_PARTIAL_WIDTH_IN_0) _op_(PDP_D_PARTIAL_WIDTH_OUT_0)                                                                    \
+																						 _op_(PDP_D_POOLING_KERNEL_CFG_0) _op_(PDP_D_RECIP_KERNEL_WIDTH_0) _op_(PDP_D_RECIP_KERNEL_HEIGHT_0) _op_(PDP_D_POOLING_PADDING_CFG_0) _op_(                                                                                                                                                            \
+																							 PDP_D_POOLING_PADDING_VALUE_1_CFG_0) _op_(PDP_D_POOLING_PADDING_VALUE_2_CFG_0) _op_(PDP_D_POOLING_PADDING_VALUE_3_CFG_0) _op_(PDP_D_POOLING_PADDING_VALUE_4_CFG_0) _op_(PDP_D_POOLING_PADDING_VALUE_5_CFG_0)                                                                                   \
+																							 _op_(PDP_D_POOLING_PADDING_VALUE_6_CFG_0) _op_(PDP_D_POOLING_PADDING_VALUE_7_CFG_0) _op_(PDP_D_SRC_BASE_ADDR_LOW_0) _op_(PDP_D_SRC_BASE_ADDR_HIGH_0) _op_(                                                                                                                                     \
+																								 PDP_D_SRC_LINE_STRIDE_0) _op_(PDP_D_SRC_SURFACE_STRIDE_0) _op_(PDP_D_DST_BASE_ADDR_LOW_0) _op_(PDP_D_DST_BASE_ADDR_HIGH_0)                                                                                                                                                             \
+																								 _op_(PDP_D_DST_LINE_STRIDE_0) _op_(PDP_D_DST_SURFACE_STRIDE_0) _op_(PDP_D_DST_RAM_CFG_0) _op_(PDP_D_DATA_FORMAT_0) _op_(PDP_D_INF_INPUT_NUM_0) _op_(                                                                                                                                   \
+																									 PDP_D_NAN_INPUT_NUM_0) _op_(PDP_D_NAN_OUTPUT_NUM_0) _op_(PDP_D_PERF_ENABLE_0) _op_(PDP_D_PERF_WRITE_STALL_0)                                                                                                                                                                   \
+																									 _op_(PDP_D_CYA_0) _op_(CDP_RDMA_S_STATUS_0) _op_(CDP_RDMA_S_POINTER_0) _op_(CDP_RDMA_D_OP_ENABLE_0) _op_(CDP_RDMA_D_DATA_CUBE_WIDTH_0) _op_(                                                                                                                                   \
+																										 CDP_RDMA_D_DATA_CUBE_HEIGHT_0) _op_(CDP_RDMA_D_DATA_CUBE_CHANNEL_0) _op_(CDP_RDMA_D_SRC_BASE_ADDR_LOW_0) _op_(CDP_RDMA_D_SRC_BASE_ADDR_HIGH_0) _op_(CDP_RDMA_D_SRC_LINE_STRIDE_0)                                                                                      \
+																										 _op_(CDP_RDMA_D_SRC_SURFACE_STRIDE_0) _op_(CDP_RDMA_D_SRC_DMA_CFG_0) _op_(CDP_RDMA_D_SRC_COMPRESSION_EN_0) _op_(                                                                                                                                                       \
+																											 CDP_RDMA_D_OPERATION_MODE_0) _op_(CDP_RDMA_D_DATA_FORMAT_0) _op_(CDP_RDMA_D_PERF_ENABLE_0) _op_(CDP_RDMA_D_PERF_READ_STALL_0)                                                                                                                                  \
+																											 _op_(CDP_RDMA_D_CYA_0) _op_(CDP_S_STATUS_0) _op_(CDP_S_POINTER_0) _op_(CDP_S_LUT_ACCESS_CFG_0) _op_(CDP_S_LUT_ACCESS_DATA_0) _op_(                                                                                                                             \
+																												 CDP_S_LUT_CFG_0) _op_(CDP_S_LUT_INFO_0) _op_(CDP_S_LUT_LE_START_LOW_0) _op_(CDP_S_LUT_LE_START_HIGH_0) _op_(CDP_S_LUT_LE_END_LOW_0)                                                                                                                    \
+																												 _op_(CDP_S_LUT_LE_END_HIGH_0) _op_(CDP_S_LUT_LO_START_LOW_0) _op_(CDP_S_LUT_LO_START_HIGH_0) _op_(CDP_S_LUT_LO_END_LOW_0) _op_(                                                                                                                        \
+																													 CDP_S_LUT_LO_END_HIGH_0) _op_(CDP_S_LUT_LE_SLOPE_SCALE_0) _op_(CDP_S_LUT_LE_SLOPE_SHIFT_0) _op_(CDP_S_LUT_LO_SLOPE_SCALE_0)                                                                                                                    \
+																													 _op_(CDP_S_LUT_LO_SLOPE_SHIFT_0) _op_(CDP_D_OP_ENABLE_0) _op_(CDP_D_FUNC_BYPASS_0) _op_(CDP_D_DST_BASE_ADDR_LOW_0) _op_(                                                                                                                       \
+																														 CDP_D_DST_BASE_ADDR_HIGH_0) _op_(CDP_D_DST_LINE_STRIDE_0) _op_(CDP_D_DST_SURFACE_STRIDE_0)                                                                                                                                             \
+																														 _op_(CDP_D_DST_DMA_CFG_0) _op_(CDP_D_DST_COMPRESSION_EN_0) _op_(CDP_D_DATA_FORMAT_0) _op_(CDP_D_NAN_FLUSH_TO_ZERO_0) _op_(                                                                                                             \
+																															 CDP_D_LRN_CFG_0) _op_(CDP_D_DATIN_OFFSET_0) _op_(CDP_D_DATIN_SCALE_0) _op_(CDP_D_DATIN_SHIFTER_0)                                                                                                                              \
+																															 _op_(CDP_D_DATOUT_OFFSET_0) _op_(CDP_D_DATOUT_SCALE_0) _op_(CDP_D_DATOUT_SHIFTER_0) _op_(                                                                                                                                      \
+																																 CDP_D_NAN_INPUT_NUM_0) _op_(CDP_D_INF_INPUT_NUM_0) _op_(CDP_D_NAN_OUTPUT_NUM_0)                                                                                                                                        \
+																																 _op_(CDP_D_OUT_SATURATION_0) _op_(CDP_D_PERF_ENABLE_0) _op_(CDP_D_PERF_WRITE_STALL_0) _op_(                                                                                                                            \
+																																	 CDP_D_PERF_LUT_UFLOW_0) _op_(CDP_D_PERF_LUT_OFLOW_0) _op_(CDP_D_PERF_LUT_HYBRID_0)                                                                                                                             \
+																																	 _op_(CDP_D_PERF_LUT_LE_HIT_0) _op_(CDP_D_PERF_LUT_LO_HIT_0) _op_(                                                                                                                                              \
+																																		 CDP_D_CYA_0) _op_(RBK_S_STATUS_0) _op_(RBK_S_POINTER_0) _op_(RBK_D_OP_ENABLE_0)                                                                                                                        \
+																																		 _op_(RBK_D_MISC_CFG_0) _op_(RBK_D_DAIN_RAM_TYPE_0) _op_(                                                                                                                                               \
+																																			 RBK_D_DATAIN_SIZE_0_0) _op_(RBK_D_DATAIN_SIZE_1_0) _op_(RBK_D_DAIN_ADDR_HIGH_0)                                                                                                                \
+																																			 _op_(RBK_D_DAIN_ADDR_LOW_0) _op_(RBK_D_DAIN_LINE_STRIDE_0) _op_(                                                                                                                               \
+																																				 RBK_D_DAIN_SURF_STRIDE_0) _op_(RBK_D_DAIN_PLANAR_STRIDE_0)                                                                                                                             \
+																																				 _op_(RBK_D_DAOUT_RAM_TYPE_0) _op_(                                                                                                                                                     \
+																																					 RBK_D_DATAOUT_SIZE_1_0) _op_(RBK_D_DAOUT_ADDR_HIGH_0)                                                                                                                          \
+																																					 _op_(RBK_D_DAOUT_ADDR_LOW_0) _op_(                                                                                                                                             \
+																																						 RBK_D_DAOUT_LINE_STRIDE_0) _op_(RBK_D_CONTRACT_STRIDE_0_0)                                                                                                             \
+																																						 _op_(                                                                                                                                                                  \
+																																							 RBK_D_CONTRACT_STRIDE_1_0) _op_(RBK_D_DAOUT_SURF_STRIDE_0)                                                                                                     \
+																																							 _op_(RBK_D_DAOUT_PLANAR_STRIDE_0) _op_(                                                                                                                        \
+																																								 RBK_D_DECONV_STRIDE_0)                                                                                                                                 \
+																																								 _op_(RBK_D_PERF_ENABLE_0) _op_(                                                                                                                        \
+																																									 RBK_D_PERF_READ_STALL_0)                                                                                                                       \
+																																									 _op_(RBK_D_PERF_WRITE_STALL_0))
+
+//
+// ADDRESS SPACES
+//
+#if 0
+#define BASE_ADDRESS_NVDLA_GLB (0x00000000)
+#define BASE_ADDRESS_NVDLA_MCIF (0x00002000)
+#define BASE_ADDRESS_NVDLA_CVIF (0x00003000)
+#define BASE_ADDRESS_NVDLA_BDMA (0x00004000)
+#define BASE_ADDRESS_NVDLA_CDMA (0x00005000)
+#define BASE_ADDRESS_NVDLA_CSC (0x00006000)
+#define BASE_ADDRESS_NVDLA_CMAC_A (0x00007000)
+#define BASE_ADDRESS_NVDLA_CMAC_B (0x00008000)
+#define BASE_ADDRESS_NVDLA_CACC (0x00009000)
+#define BASE_ADDRESS_NVDLA_SDP_RDMA (0x0000a000)
+#define BASE_ADDRESS_NVDLA_SDP (0x0000b000)
+#define BASE_ADDRESS_NVDLA_PDP_RDMA (0x0000c000)
+#define BASE_ADDRESS_NVDLA_PDP (0x0000d000)
+#define BASE_ADDRESS_NVDLA_CDP_RDMA (0x0000e000)
+#define BASE_ADDRESS_NVDLA_CDP (0x0000f000)
+#define BASE_ADDRESS_NVDLA_RBK (0x00010000)
+
+//
+// ARNVDLA REGISTER BANKS
+//
+
+#define GLB0_FIRST_REG (0x0000)
+#define GLB0_LAST_REG (0x000c)
+#define MCIF0_FIRST_REG (0x2000)
+#define MCIF0_LAST_REG (0x2018)
+#define CVIF0_FIRST_REG (0x3000)
+#define CVIF0_LAST_REG (0x3018)
+#define BDMA0_FIRST_REG (0x4000)
+#define BDMA0_LAST_REG (0x4050)
+#define CDMA0_FIRST_REG (0x5000)
+#define CDMA0_LAST_REG (0x50e8)
+#define CSC0_FIRST_REG (0x6000)
+#define CSC0_LAST_REG (0x6064)
+#define CMAC_A0_FIRST_REG (0x7000)
+#define CMAC_A0_LAST_REG (0x700c)
+#define CMAC_B0_FIRST_REG (0x8000)
+#define CMAC_B0_LAST_REG (0x800c)
+#define CACC0_FIRST_REG (0x9000)
+#define CACC0_LAST_REG (0x9034)
+#define SDP_RDMA0_FIRST_REG (0xa000)
+#define SDP_RDMA0_LAST_REG (0xa090)
+#define SDP0_FIRST_REG (0xb000)
+#define SDP0_LAST_REG (0xb0f8)
+#define PDP_RDMA0_FIRST_REG (0xc000)
+#define PDP_RDMA0_LAST_REG (0xc04c)
+#define PDP0_FIRST_REG (0xd000)
+#define PDP0_LAST_REG (0xd09c)
+#define CDP_RDMA0_FIRST_REG (0xe000)
+#define CDP_RDMA0_LAST_REG (0xe040)
+#define CDP0_FIRST_REG (0xf000)
+#define CDP0_LAST_REG (0xf0b8)
+#define RBK0_FIRST_REG (0x10000)
+#define RBK0_LAST_REG (0x10060)
+
+#else
+
+#define BASE_ADDRESS_NVDLA_GLB (OFFSET_ADDRESS_NPU_NVDLA + 0x00000000)
+#define BASE_ADDRESS_NVDLA_MCIF (OFFSET_ADDRESS_NPU_NVDLA + 0x00002000)
+#define BASE_ADDRESS_NVDLA_CVIF (OFFSET_ADDRESS_NPU_NVDLA + 0x00003000)
+#define BASE_ADDRESS_NVDLA_BDMA (OFFSET_ADDRESS_NPU_NVDLA + 0x00004000)
+#define BASE_ADDRESS_NVDLA_CDMA (OFFSET_ADDRESS_NPU_NVDLA + 0x00005000)
+#define BASE_ADDRESS_NVDLA_CSC (OFFSET_ADDRESS_NPU_NVDLA + 0x00006000)
+#define BASE_ADDRESS_NVDLA_CMAC_A (OFFSET_ADDRESS_NPU_NVDLA + 0x00007000)
+#define BASE_ADDRESS_NVDLA_CMAC_B (OFFSET_ADDRESS_NPU_NVDLA + 0x00008000)
+#define BASE_ADDRESS_NVDLA_CACC (OFFSET_ADDRESS_NPU_NVDLA + 0x00009000)
+#define BASE_ADDRESS_NVDLA_SDP_RDMA (OFFSET_ADDRESS_NPU_NVDLA + 0x0000a000)
+#define BASE_ADDRESS_NVDLA_SDP (OFFSET_ADDRESS_NPU_NVDLA + 0x0000b000)
+#define BASE_ADDRESS_NVDLA_PDP_RDMA (OFFSET_ADDRESS_NPU_NVDLA + 0x0000c000)
+#define BASE_ADDRESS_NVDLA_PDP (OFFSET_ADDRESS_NPU_NVDLA + 0x0000d000)
+#define BASE_ADDRESS_NVDLA_CDP_RDMA (OFFSET_ADDRESS_NPU_NVDLA + 0x0000e000)
+#define BASE_ADDRESS_NVDLA_CDP (OFFSET_ADDRESS_NPU_NVDLA + 0x0000f000)
+#define BASE_ADDRESS_NVDLA_RBK (OFFSET_ADDRESS_NPU_NVDLA + 0x00010000)
+
+#define GLB0_FIRST_REG (OFFSET_ADDRESS_NPU_NVDLA + 0x0000)
+#define GLB0_LAST_REG (OFFSET_ADDRESS_NPU_NVDLA + 0x000c)
+#define MCIF0_FIRST_REG (OFFSET_ADDRESS_NPU_NVDLA + 0x2000)
+#define MCIF0_LAST_REG (OFFSET_ADDRESS_NPU_NVDLA + 0x2018)
+#define CVIF0_FIRST_REG (OFFSET_ADDRESS_NPU_NVDLA + 0x3000)
+#define CVIF0_LAST_REG (OFFSET_ADDRESS_NPU_NVDLA + 0x3018)
+#define BDMA0_FIRST_REG (OFFSET_ADDRESS_NPU_NVDLA + 0x4000)
+#define BDMA0_LAST_REG (OFFSET_ADDRESS_NPU_NVDLA + 0x4050)
+#define CDMA0_FIRST_REG (OFFSET_ADDRESS_NPU_NVDLA + 0x5000)
+#define CDMA0_LAST_REG (OFFSET_ADDRESS_NPU_NVDLA + 0x50e8)
+#define CSC0_FIRST_REG (OFFSET_ADDRESS_NPU_NVDLA + 0x6000)
+#define CSC0_LAST_REG (OFFSET_ADDRESS_NPU_NVDLA + 0x6064)
+#define CMAC_A0_FIRST_REG (OFFSET_ADDRESS_NPU_NVDLA + 0x7000)
+#define CMAC_A0_LAST_REG (OFFSET_ADDRESS_NPU_NVDLA + 0x700c)
+#define CMAC_B0_FIRST_REG (OFFSET_ADDRESS_NPU_NVDLA + 0x8000)
+#define CMAC_B0_LAST_REG (OFFSET_ADDRESS_NPU_NVDLA + 0x800c)
+#define CACC0_FIRST_REG (OFFSET_ADDRESS_NPU_NVDLA + 0x9000)
+#define CACC0_LAST_REG (OFFSET_ADDRESS_NPU_NVDLA + 0x9034)
+#define SDP_RDMA0_FIRST_REG (OFFSET_ADDRESS_NPU_NVDLA + 0xa000)
+#define SDP_RDMA0_LAST_REG (OFFSET_ADDRESS_NPU_NVDLA + 0xa090)
+#define SDP0_FIRST_REG (OFFSET_ADDRESS_NPU_NVDLA + 0xb000)
+#define SDP0_LAST_REG (OFFSET_ADDRESS_NPU_NVDLA + 0xb0f8)
+#define PDP_RDMA0_FIRST_REG (OFFSET_ADDRESS_NPU_NVDLA + 0xc000)
+#define PDP_RDMA0_LAST_REG (OFFSET_ADDRESS_NPU_NVDLA + 0xc04c)
+#define PDP0_FIRST_REG (OFFSET_ADDRESS_NPU_NVDLA + 0xd000)
+#define PDP0_LAST_REG (OFFSET_ADDRESS_NPU_NVDLA + 0xd09c)
+#define CDP_RDMA0_FIRST_REG (OFFSET_ADDRESS_NPU_NVDLA + 0xe000)
+#define CDP_RDMA0_LAST_REG (OFFSET_ADDRESS_NPU_NVDLA + 0xe040)
+#define CDP0_FIRST_REG (OFFSET_ADDRESS_NPU_NVDLA + 0xf000)
+#define CDP0_LAST_REG (OFFSET_ADDRESS_NPU_NVDLA + 0xf0b8)
+#define RBK0_FIRST_REG (OFFSET_ADDRESS_NPU_NVDLA + 0x10000)
+#define RBK0_LAST_REG (OFFSET_ADDRESS_NPU_NVDLA + 0x10060)
+
+#endif
+
+// To satisfy various compilers and platforms,
+// we let users control the types and syntax of certain constants, using macros.
+#ifndef _MK_SHIFT_CONST
+#define _MK_SHIFT_CONST(_constant_) (_constant_)
+#endif
+#ifndef _MK_MASK_CONST
+#define _MK_MASK_CONST(_constant_) (_constant_)
+#endif
+#ifndef _MK_ENUM_CONST
+#define _MK_ENUM_CONST(_constant_) ((_constant_##UL))
+#endif
+#ifndef _MK_ADDR_CONST
+#define _MK_ADDR_CONST(_constant_) (OFFSET_ADDRESS_NPU_NVDLA + _constant_)
+#endif
+#ifndef _MK_FIELD_CONST
+#define _MK_FIELD_CONST(_mask_, _shift_) \
+	((_MK_MASK_CONST(_mask_) << _MK_SHIFT_CONST(_shift_)))
+#endif
+
+#endif	// ifndef ___ARH_INC_
diff --git a/drivers/soc/eswin/ai_driver/npu/internal_interface.h b/drivers/soc/eswin/ai_driver/npu/internal_interface.h
new file mode 100644
index 000000000000..f5a4dfba861b
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/npu/internal_interface.h
@@ -0,0 +1,567 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#ifndef __INTERNAL_INTERFACE__
+#define __INTERNAL_INTERFACE__
+#include <linux/version.h>
+#include <linux/dma-buf.h>
+#include <linux/dma-mapping.h>
+#include <linux/irqreturn.h>
+#include <nvdla_linux.h>
+#include "eswin-khandle.h"
+#include <linux/timer.h>
+#include "hetero_ioctl.h"
+#include "dla_engine.h"
+#include "dla_log.h"
+#include "edma.h"
+#include "conv.h"
+#include "hetero_common.h"
+#include "hetero_ipc.h"
+#include "dla_buffer.h"
+#include <linux/workqueue.h>
+
+struct host_frame_desc;
+
+/**************** hardware_context.c (nvdla_core_callback.c) ****************/
+void *npu_get_win_engine(void *nvdla_dev);
+int npu_spram_get(struct nvdla_device *nvdla_dev);
+int npu_spram_release(struct nvdla_device *nvdla_dev);
+int32_t dla_data_get_fd(void *driver_context, void *task_data, void *handle,
+			uint16_t index);
+
+static inline void reset_uart_mutex(struct nvdla_device *nvdla_dev)
+{
+	if (nvdla_dev->uart_mutex_base) {
+		io_write(nvdla_dev->uart_mutex_base + UART_MUTEX_UNIT_OFFSET,
+			 0);
+	} else {
+		dev_err(&nvdla_dev->pdev->dev, "uart mutex addr is NULL\n");
+	}
+}
+
+/**************** hardware_context.c (nvdla_core_callback.c) ****************/
+
+/**************** user_context.c ****************/
+#define MAX_EVENT_SINK_SAVE_NUM 64
+
+#define NPU_RT_MUTX_IDLE 0x0
+#define NPU_RT_MUTX_LOCKED 0x1
+#define NPU_RT_MUTX_FRAME_DONE 0x2
+
+typedef struct _event_desc {
+	spinlock_t spinlock;
+	u16 produce_idx;
+	u16 consumer_idx;
+	u16 len;
+	s16 event_sinks[MAX_EVENT_SINK_SAVE_NUM];
+} event_desc_t;
+
+struct user_context {
+	struct khandle handle;
+	bool uctx_is_alive;
+	spinlock_t model_lock;
+	atomic_t lock_status;
+	struct mutex dma_lock;
+	struct xarray buf_xrray;
+	event_desc_t event_desc;
+	struct nvdla_device *ndev;
+};
+
+struct user_model {
+	struct khandle handle;
+	struct user_context *uctx;
+	struct nvdla_task mem_handles;
+	struct dla_task task;
+	struct dla_network_desc *network;
+	void *executor;
+	void *engine;  //win_engine.
+	void *nvdla_dev;
+	struct dma_buf *dma_buf_address_list;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 6, 0)
+	struct iosys_map dma_buf_map_address_list;
+#else
+	struct dma_buf_map dma_buf_map_address_list;
+#endif
+	hetero_ipc_frame_t e31_frame_info;
+	/* frame counter: Only commit == done could release model */
+	s64 frame_commit_cnt;
+	s64 frame_done_cnt;
+
+	struct dla_buffer_object *model_bobj;
+	modelShmDesc_t *model_shm;
+};
+struct win_engine;
+
+int create_npu_dev(int node_id, struct nvdla_device *nvdla_dev);
+void destory_npu_dev(int node_id);
+int npu_hetero_cmd(struct nvdla_device *nvdla_dev, struct win_ioctl_args *args);
+void hetero_send_frame_to_npu(u8 tiktok, struct host_frame_desc *f);
+struct nvdla_device *get_nvdla_dev(int i);
+void hetero_send_event_source_req(u8 tiktok, u16 op_index);
+
+int send_mbx_msg_to_e31(struct win_engine *engine, msg_payload_t);
+/**************** user_context.c ****************/
+
+/**************** dfx.c ****************/
+
+/**************** engine_context.c ****************/
+struct processors_interface {
+	/* Processors status */
+	const char *name;
+	uint8_t op_type;
+	/**
+	 * TODO: need ops: valid-model->validate operation
+	 */
+	int (*tensor_unfold)(struct win_executor *executor, int op_idx,
+			     union dla_operation_container *operation_desc,
+			     union dla_surface_container *surface_desc,
+			     void *tensor, int idx);
+	int (*prepare_prog_data)(struct win_executor *executor, int rdma,
+				 int tensor_idx, u16 op_idx,
+				 union dla_operation_container *op_desc,
+				 union dla_surface_container *surface_desc);
+	int (*rdma_check)(struct dla_processor_group *group,
+			  union dla_operation_container *op,
+			  union dla_surface_container *surface);
+};
+
+struct dump_file_work_t {
+	int tiktok;
+	struct host_frame_desc *f;
+	struct work_struct work;
+};
+
+struct dump_op_work_t {
+	int tiktok;
+	u16 op_index;
+	struct host_frame_desc *f;
+	struct work_struct work;
+};
+
+enum {
+	NPU_UCTX_KHANDLE_MAGIC = 1,
+	NPU_MODEL_KHANDLE_MAGIC,
+	NPU_FRAME_KHANDLE_MAGIC,
+	NPU_DMABUF_HANDLE_MAGIC,
+};
+
+struct win_engine {
+	struct processors_interface *processors[HW_OP_NUM];
+	struct semaphore runtime_sem;
+	void *master_shm;
+	void *master_mem;
+	void *aux_shm;
+	void *aux_mem;
+	void *major_shm[NUM_MAJOR_CORES];
+	void *major_mem[NUM_MAJOR_CORES];
+	void *nvdla_dev;
+	struct mutex reset_mutex;
+	/* Current executor */
+	void *cur[NUM_TIKTOK];
+	/* Next executor to use, Protected by executor_lock */
+	spinlock_t executor_lock;
+	bool perf_switch;
+	void *perf_data_buf;
+	struct timer_list timer[NUM_TIKTOK];
+	atomic_t is_sending;
+
+	struct list_head sched_frame_list;
+	struct host_frame_desc *tiktok_frame[NUM_TIKTOK];
+	u32 tiktok;
+	u32 frame_seq;
+
+	bool engine_is_alive;
+	struct workqueue_struct *work_queue;
+	struct dump_file_work_t dump_file_work[NUM_TIKTOK];
+
+	struct workqueue_struct *dump_op_work_queue;
+	struct dump_op_work_t dump_op_work[NUM_OP_TYPE];
+
+	struct host_frame_desc *frame_done;
+	struct work_struct frame_done_work;
+	u8 *is_event_source_done[NUM_TIKTOK];
+
+	struct work_struct complete_work;
+	spinlock_t complete_lock;
+	struct list_head frame_complete_list;
+
+	host_node_t *host_node;
+	dma_addr_t host_node_iova;
+	struct device *dsp_dev[DSP_MAX_CORE_NUM];
+};
+
+enum frame_state_list {
+	frame_state_done = 0xd,
+	frame_state_working = 0xe,
+	frame_state_queued = -1,
+	frame_state_orphan = 0xfe,
+};
+
+#define ES_TASK_MAX_FD_CNT 10
+
+struct host_frame_desc {
+	struct khandle handle;
+	struct list_head sched_node;
+	u16 input_num;
+	u16 output_num;
+	addrDesc_t *io_tensor_list;
+	u64 *io_tensors_addr_list;
+	npu_io_tensor_t io_tensor;
+	//for e31
+	u32 tiktok;
+	bool dump_dtim;
+	struct list_head complete_entry;
+
+	struct win_executor *executor;
+	void *model;
+
+	s32 state;
+	s32 frame_idx;
+	wait_queue_head_t frame_done;
+	struct host_frame_desc *next;
+	u8 *is_event_source_done;
+	struct dsp_dma_buf *dsp_io_dmabuf[DSP_MAX_CORE_NUM]
+					 [DSP_KERNEL_MAX_INOUT_TENSOR_NUM];
+
+	struct dla_buffer_object *input_bobj[ES_TASK_MAX_FD_CNT];
+	struct dla_buffer_object *output_bobj[ES_TASK_MAX_FD_CNT];
+} __attribute__((aligned(sizeof(u32))));
+
+void npu_frame_done_process(struct host_frame_desc *f);
+
+static inline void npu_set_u16_bit(int nr, u16 *addr)
+{
+	addr[nr / 16] |= (1UL << (nr % 16));
+}
+
+static inline void npu_set_u64_bit(int nr, u64 *addr)
+{
+	addr[nr / 64] |= (1ULL << (nr % 64));
+}
+
+typedef struct _edma_tensor_t {
+	u32 src_is_io_tensor;
+	u32 dst_is_io_tensor;
+	struct hw_desc hw;
+	struct hw_desc_src src;
+	struct hw_desc_dst dst;
+} edma_tensor_t;
+
+typedef struct _conv_tensor_t {
+	//struct conv_host2dev_t h2m_msg;
+	u32 ifmap_is_io_tensor;
+	u32 ofmap_is_io_tensor;
+	u64 ifmap_base_addr;
+	u64 ofmap_base_addr;
+} __attribute__((aligned(64))) conv_tensor_t;
+
+typedef struct _dsp_tensor_t {
+	u32 have_unfold;
+
+	u32 src_is_io_tensor[DSP_KERNEL_MAX_INOUT_TENSOR_NUM];
+	u32 dst_is_io_tensor[DSP_KERNEL_MAX_INOUT_TENSOR_NUM];
+	u64 src_base_addr[DSP_KERNEL_MAX_INOUT_TENSOR_NUM];
+	u64 dst_base_addr[DSP_KERNEL_MAX_INOUT_TENSOR_NUM];
+	u64 handle;
+	u32 flat1_size;
+	u32 flat1_addr_offset;
+	u32 flat1_dma_addr;
+	void *flat1_vaddr;
+	u32 data_dma_addr;
+} __attribute__((aligned(64))) dsp_tensor_t;
+
+typedef struct _sdp_tensor_t {
+	u32 src_is_io_tensor;
+	u32 dst_is_io_tensor;
+	u32 x1_is_io_tensor;
+	u32 x2_is_io_tensor;
+	u32 y_is_io_tensor;
+	u64 no_fly_src_addr;
+	u64 out_dma_dst_addr;
+	u64 x1_addr;
+	u64 x2_addr;
+	u64 y_addr;
+
+	u8 fly;
+	u8 out_dma_ena;
+	u8 x1_rdma_ena;
+	u8 x2_rdma_ena;
+	u8 y_rdma_ena;
+} sdp_tensor_t;
+
+typedef struct _pdp_tensor_t {
+	u32 input_is_io_tensor;
+	u32 output_is_io_tensor;
+	u64 input_address;
+	u64 output_address;
+} pdp_tensor_t;
+
+typedef struct _rubik_tensor_t {
+	u32 input_is_io_tensor;
+	u32 output_is_io_tensor;
+	u64 input_address;
+	u64 output_address;
+} rubik_tensor_t;
+
+typedef struct _event_sink_tensor_t {
+	u32 input_is_io_tensor;
+} event_sink_tensor_t;
+
+typedef struct _event_source_tensor_t {
+	u32 input_is_io_tensor;
+} event_source_tensor_t;
+
+enum executor_state_list {
+	executor_state_live = 0xaa,
+	executor_state_dead = 0xfe,
+};
+
+struct io_mem_info {
+	int io_cnt;
+	u32 *offset;
+	u64 *virt;
+};
+
+struct win_executor {
+	uint8_t *dependency_count;
+	uint16_t num_proc_hwl;
+	int32_t status;
+	void *model;
+	s32 state;
+	struct dla_task *task;
+	struct dla_network_desc *network;
+	struct nvdla_task *mem_handles;
+	struct win_engine *engine;
+	void *driver_context;
+	void *tensor_set[NUM_OP_TYPE];
+	//for e31
+	void *prog_data_buf_bobj[NUM_OP_TYPE];
+	dma_addr_t dma_addr[NUM_OP_TYPE];
+	u32 prog_data_size[NUM_OP_TYPE];
+	// this code is very ugly, need to remove, but now need it
+	struct dla_buffer_object *tmp_for_simu[NUM_OP_TYPE];
+
+	dma_addr_t recent_lut_iova;
+	dma_addr_t lut_base_iova;
+
+	int dsp_op_num;
+	void *dsp_flat1_set_vaddr[DSP_MAX_CORE_NUM];
+	dma_addr_t dsp_flat1_set_dma[DSP_MAX_CORE_NUM];
+	u32 dsp_flat1_set_size[DSP_MAX_CORE_NUM];
+	struct dsp_dma_buf *model_dsp_dmabuf[DSP_MAX_CORE_NUM];
+	struct xarray dsp_ddr_xrray[DSP_MAX_CORE_NUM];
+	struct mutex xrray_lock[DSP_MAX_CORE_NUM];
+
+	struct io_mem_info dsp_io[DSP_MAX_CORE_NUM]
+				 [DSP_KERNEL_MAX_INOUT_TENSOR_NUM];
+
+	int dsp_iobuf_cnt[DSP_MAX_CORE_NUM];
+	void *dsp_iobuf_virt[DSP_MAX_CORE_NUM];
+	void *dsp_iobuf_offset[DSP_MAX_CORE_NUM];
+	int dsp_all_inout[DSP_MAX_CORE_NUM][DSP_KERNEL_MAX_INOUT_TENSOR_NUM];
+
+	u16 input_num;
+	u16 output_num;
+	u32 frame_size;
+	u32 io_mem_handle_size;
+	s16 head_op_idx[NUM_OP_TYPE];
+
+#define INVALID_OP_IDX (-32768)
+	s16 *cfg_seq[NUM_OP_TYPE];
+	u16 total_op_num;
+	u16 op_num[NUM_OP_TYPE];
+
+	op_current_t op_prog_addrs;
+
+	/*event map*/
+	s16 *event_sink_map;
+	s16 *event_source_map;
+	u16 total_event_sink_num;
+	u16 total_event_source_num;
+	s32 dsp_fd[DSP_MAX_CORE_NUM];
+	struct file *dsp_file[DSP_MAX_CORE_NUM];
+	kmd_dump_info_t dump_info;
+};
+
+void *npu_alloc_dma_addr(struct win_executor *executor, size_t size,
+			 dma_addr_t *dma_handle, int i, gfp_t gfp);
+void npu_free_dma_addr(struct win_executor *executor, int i);
+int npu_init_ipc(struct nvdla_device *ndev);
+int npu_uninit_ipc(struct nvdla_device *ndev);
+
+void npu_frame_schedule(struct win_engine *engine);
+void npu_drop_all_frame(struct nvdla_device *ndev, bool dump_dtim);
+
+int prepare_frame_io_tensor(struct win_engine *engine, struct win_executor *exe,
+			    struct host_frame_desc *f);
+int prepare_e31_frame_info(struct win_executor *executor,
+			   struct user_model *model);
+
+bool send_new_frame(struct win_engine *engine, struct win_executor *executor,
+		    struct host_frame_desc *f);
+
+int start_inference(void *arg_executor);
+
+int set_current(struct win_engine *engine, struct win_executor *executor,
+		u32 tiktok);
+int unset_current(struct win_engine *engine, struct win_executor *executor,
+		  u32 tiktok);
+int create_executor(struct dla_task *task, struct dla_network_desc *network,
+		    void **m_executor, struct nvdla_task *mem_handles,
+		    void *engine, void *dev, struct user_model *model);
+void destroy_executor(void *arg_executor);
+int win_engine_init(struct nvdla_device *nvdla_dev, void **arg_engine);
+void win_engine_destroy(struct nvdla_device *nvdla_dev);
+
+int io_tensor_record(struct win_executor *executor, addrDesc_t *handle,
+		     u32 *is_io_tensor);
+int read_input_address(struct win_executor *executor,
+		       struct dla_data_cube *data, uint64_t *address,
+		       u32 *is_io_tensor);
+int io_tensor_to_io_addr(struct win_executor *executor,
+			 struct host_frame_desc *f);
+int create_new_frame(struct win_executor *executor, struct host_frame_desc **f,
+		     void *model);
+void destroy_frame(struct host_frame_desc *f);
+void executor_clearup(void *arg_executor);
+
+extern const u8 processor_idx_convert[NUM_OP_TYPE];
+extern const u8 processor_dla_convert[HW_OP_NUM];
+char *pcer2str(u8 pcer);
+void dump_frame_op_statistic(struct win_executor *executor);
+/**************** engine_context.c ****************/
+
+/**************** dep_graph_parser.c ****************/
+int generate_small_program(struct win_executor *executor);
+int generate_event_map(struct win_executor *executor);
+int set_pause_op_done(struct win_executor *executor,
+		      kmd_dump_info_t *dump_info);
+int reset_pause_op_done(struct win_executor *executor);
+
+void mbx_irq_frame_done(struct win_engine *engine, u32 tiktok, u32 stat);
+void mbx_irq_op_done(struct win_engine *engine, u32 tiktok, u16 op_index);
+void mbx_irq_event_sink_done(struct win_engine *engine, u32 tiktok,
+			     u16 op_index);
+int send_frame_to_npu(struct host_frame_desc *f, int tiktok);
+/**************** frame_scheduler.c ****************/
+int edma_tensor_unfold(struct win_executor *executor, int op_idx,
+		       union dla_operation_container *operation_desc,
+		       union dla_surface_container *surface_desc, void *tensor,
+		       int idx);
+int edma_prepare_prog_data(struct win_executor *executor, int rdma,
+			   int tensor_idx, u16 op_idx,
+			   union dla_operation_container *operation_desc,
+			   union dla_surface_container *surface_desc);
+
+int conv_set_program_data(struct win_executor *executor, int idx, int op_idx,
+			  void *tensor,
+			  union dla_operation_container *operation_desc);
+
+int conv_tensor_unfold(struct win_executor *executor, int op_idx,
+		       union dla_operation_container *operation_desc,
+		       union dla_surface_container *surface_desc, void *tensor,
+		       int idx);
+
+int dla_conv_prepare_prog_data(struct win_executor *executor, int rdma,
+			       int tensor_idx, u16 op_idx,
+			       union dla_operation_container *operation_desc,
+			       union dla_surface_container *surface_desc);
+
+int sdp_tensor_unfold(struct win_executor *executor, int op_idx,
+		      union dla_operation_container *operation_desc,
+		      union dla_surface_container *surface_desc, void *tensor,
+		      int idx);
+int dla_sdp_prepare_prog_data(struct win_executor *executor, int rdma,
+			      int tensor_idx, u16 op_idx,
+			      union dla_operation_container *operation_desc,
+			      union dla_surface_container *surface_desc);
+
+int pdp_tensor_unfold(struct win_executor *executor, int op_idx,
+		      union dla_operation_container *operation_desc,
+		      union dla_surface_container *surface_desc, void *tensor,
+		      int idx);
+int dla_pdp_prepare_prog_data(struct win_executor *executor, int rdma,
+			      int tensor_idx, u16 op_idx,
+			      union dla_operation_container *operation_desc,
+			      union dla_surface_container *surface_desc);
+
+int rubik_tensor_unfold(struct win_executor *executor, int op_idx,
+			union dla_operation_container *operation_desc,
+			union dla_surface_container *surface_desc, void *tensor,
+			int idx);
+int dla_rubik_prepare_prog_data(struct win_executor *executor, int rdma,
+				int tensor_idx, u16 op_idx,
+				union dla_operation_container *operation_desc,
+				union dla_surface_container *surface_desc);
+
+int dla_event_sink_rdma_check(struct dla_processor_group *group,
+			      union dla_operation_container *op,
+			      union dla_surface_container *surface);
+
+int event_sink_tensor_unfold(struct win_executor *executor, int op_idx,
+			     union dla_operation_container *operation_desc,
+			     union dla_surface_container *surface_desc,
+			     void *tensor, int idx);
+
+void dla_event_sink_dump_config(struct dla_processor_group *group);
+
+int dla_event_sink_prepare_prog_data(
+	struct win_executor *executor, int rdma, int tensor_idx, u16 op_idx,
+	union dla_operation_container *operation_desc,
+	union dla_surface_container *surface_desc);
+
+int dla_event_source_rdma_check(struct dla_processor_group *group,
+				union dla_operation_container *op,
+				union dla_surface_container *surface);
+
+int event_source_tensor_unfold(struct win_executor *executor, int op_idx,
+			       union dla_operation_container *operation_desc,
+			       union dla_surface_container *surface_desc,
+			       void *tensor, int idx);
+
+void dla_event_source_dump_config(struct dla_processor_group *group);
+
+int dla_event_source_prepare_prog_data(
+	struct win_executor *executor, int rdma, int tensor_idx, u16 op_idx,
+	union dla_operation_container *operation_desc,
+	union dla_surface_container *surface_desc);
+
+/* dsp operation*/
+
+int dsp0_tensor_unfold(struct win_executor *executor, int op_idx,
+		       union dla_operation_container *operation_desc,
+		       union dla_surface_container *surface_desc, void *tensor,
+		       int idx);
+
+int dsp1_tensor_unfold(struct win_executor *executor, int op_idx,
+		       union dla_operation_container *operation_desc,
+		       union dla_surface_container *surface_desc, void *tensor,
+		       int idx);
+
+int dsp2_tensor_unfold(struct win_executor *executor, int op_idx,
+		       union dla_operation_container *operation_desc,
+		       union dla_surface_container *surface_desc, void *tensor,
+		       int idx);
+
+int dsp3_tensor_unfold(struct win_executor *executor, int op_idx,
+		       union dla_operation_container *operation_desc,
+		       union dla_surface_container *surface_desc, void *tensor,
+		       int idx);
+
+int dsp0_prepare_prog_data(struct win_executor *executor, int rdma, int idx,
+			   u16 op_idx, union dla_operation_container *op_desc,
+			   union dla_surface_container *surf_desc);
+int dsp1_prepare_prog_data(struct win_executor *executor, int rdma, int idx,
+			   u16 op_idx, union dla_operation_container *op_desc,
+			   union dla_surface_container *surf_desc);
+int dsp2_prepare_prog_data(struct win_executor *executor, int rdma, int idx,
+			   u16 op_idx, union dla_operation_container *op_desc,
+			   union dla_surface_container *surf_desc);
+int dsp3_prepare_prog_data(struct win_executor *executor, int rdma, int idx,
+			   u16 op_idx, union dla_operation_container *op_desc,
+			   union dla_surface_container *surf_desc);
+#endif
diff --git a/drivers/soc/eswin/ai_driver/npu/npu_e31.c b/drivers/soc/eswin/ai_driver/npu/npu_e31.c
new file mode 100644
index 000000000000..3494f170fc68
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/npu/npu_e31.c
@@ -0,0 +1,170 @@
+// Copyright © 2024 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#include <linux/platform_device.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/uaccess.h>
+#include <linux/firmware.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/elf.h>
+#include <linux/of_platform.h>
+#include <linux/dma-heap.h>
+#include <dt-bindings/memory/eswin-win2030-sid.h>
+#include <linux/bitfield.h>
+#include <linux/clk.h>
+#include <linux/reset.h>
+#include <linux/iommu.h>
+#include <linux/es_iommu_rsv.h>
+#include <asm/io.h>
+#include "dla_log.h"
+#include "hetero_host.h"
+#include "dla_driver.h"
+
+#ifdef DUMP_NIM
+static void dump_data(const void *buf, const u32 len)
+{
+	int i = 0;
+	dla_debug("=======================\n");
+	for (i = 0; i < len; i++) {
+		if (i % 16 == 0) {
+			dla_debug("\n0x%04x: ", i);
+		}
+		dla_debug("%02x ", ((char *)buf)[i]);
+	}
+	dla_debug("\n");
+}
+#endif
+
+#define AMMUSSID GENMASK(27, 8)	 // The ssid of write and read operation
+#define AMMUSID GENMASK(7, 0)  // The sid of write and read operation
+
+#define E31_MMU_RID_REG_OFFSET 0x3c
+#define E31_MMU_WID_REG_OFFSET 0x40
+#define E31_STREAMID_CFG_OFFSET 0x108
+
+static inline void npu_e31_sid_cfg(void __iomem *npu_subsys_base, u32 sid)
+{
+	u32 rdwr_sid_ssid = 0;
+	u32 rsidval = 0;
+	u32 wsidval = 0;
+	/* make the reading sid the same as writing sid, and ssid is fixed to zero */
+	rdwr_sid_ssid |= FIELD_PREP(AMMUSID, sid);
+	rdwr_sid_ssid |= FIELD_PREP(AMMUSSID, 0);
+	writel(rdwr_sid_ssid,
+	       npu_subsys_base + NPU_TOP_CSR_OFFSET + E31_MMU_RID_REG_OFFSET);
+	writel(rdwr_sid_ssid,
+	       npu_subsys_base + NPU_TOP_CSR_OFFSET + E31_MMU_WID_REG_OFFSET);
+
+	rsidval = readl(npu_subsys_base + NPU_TOP_CSR_OFFSET +
+			E31_MMU_RID_REG_OFFSET);
+	wsidval = readl(npu_subsys_base + NPU_TOP_CSR_OFFSET +
+			E31_MMU_WID_REG_OFFSET);
+
+	dla_debug(
+		"%s, NPU_TOP_CSR_OFFSET=0x%x, npu_e31: rsid=0x%x, wsid=0x%x\n",
+		__func__, NPU_TOP_CSR_OFFSET, rsidval, wsidval);
+}
+
+#if NPU_DEV_SIM == NPU_REAL_ENV
+static void npu_check_mcu_active(struct nvdla_device *nvdla_dev)
+{
+	int i;
+	for (i = 0; i < NUM_NPU_CORES; i++) {
+		/* initialize the node id for all e31 */
+		io_write((u8 *)nvdla_dev->e31_mmio_base + NPU_CPU_OFFSET +
+				 NPU_CPU_SIZE * i + NPU_DTIM_OFFSET +
+				 ADDR_OFFSET(cpu_node_t, node_id),
+			 i);
+		activate_system(nvdla_dev->e31_mmio_base, i);
+		if (i == 0) {
+			msleep(3);
+		}
+	}
+
+	check_system_activated(nvdla_dev->e31_mmio_base);
+}
+
+#endif
+
+#define NPU_E31_FW_RSV_IOVA 0x80000000
+
+int npu_e31_load_fw(struct platform_device *pdev, void __iomem *e31_mmio_base)
+{
+	int retval = 0;
+	int err = 0;
+	const struct firmware *e31_fw;
+	dma_addr_t nim_iova;
+	char *fw_virt_base;
+	u32 boot_len = 0;
+	u8 *e31_boot_virt_base;
+	u32 offset;
+	u32 boot_dma_addr;
+	u32 streamid_cfg;
+	struct nvdla_device *nvdla_dev = dev_get_drvdata(&pdev->dev);
+
+	/* config streamid of npu-e31 */
+	streamid_cfg = readl(e31_mmio_base + NPU_CTRL_OFFSET +
+			     E31_STREAMID_CFG_OFFSET);
+	streamid_cfg &= ~(1 << 3);
+	writel(streamid_cfg,
+	       e31_mmio_base + NPU_CTRL_OFFSET + E31_STREAMID_CFG_OFFSET);
+	npu_e31_sid_cfg(e31_mmio_base, WIN2030_SID_NPU_DMA);
+
+	err = request_firmware(&e31_fw, "eic7700_e31_fw", &pdev->dev);
+	if (err < 0) {
+		dla_error("Eswin e31 request fw error.\n");
+		return -EINVAL;
+	}
+
+	nim_iova = NPU_E31_FW_RSV_IOVA;
+	fw_virt_base = iommu_map_rsv_iova(&pdev->dev, nim_iova, e31_fw->size,
+					  GFP_KERNEL, IOMMU_MMIO);
+	if (!fw_virt_base) {
+		dla_error("iommu map rsv iova for e31 fw error.\n");
+		retval = -ENOMEM;
+		goto err_map_iova;
+	}
+
+	dla_debug("%s, fw_base=0x%px, iova=0x%llx, size=0x%lx.\n", __func__,
+		  fw_virt_base, nim_iova, e31_fw->size);
+	//copy fw from user context to kernel space
+	memcpy((char *)fw_virt_base, (char *)e31_fw->data, e31_fw->size);
+
+	e31_boot_virt_base = find_boot_firmware(fw_virt_base, &boot_len);
+	offset = e31_boot_virt_base - (u8 *)fw_virt_base;
+	boot_dma_addr = (u32)((size_t)nim_iova + offset);
+	dla_debug("fw_virt_base=0x%px, boot_fw=0x%px, boot_dma=%0x, offset=%u.",
+		  fw_virt_base, e31_boot_virt_base, boot_dma_addr, offset);
+
+	dma_sync_single_for_device(&pdev->dev, nim_iova, e31_fw->size,
+				   DMA_BIDIRECTIONAL);
+
+	load_firmware_to_conv_cpus(fw_virt_base, boot_dma_addr, e31_mmio_base);
+
+	nvdla_dev->e31_fw_virt_base = fw_virt_base;
+	nvdla_dev->e31_nim_iova = nim_iova;
+	nvdla_dev->e31_fw_size = e31_fw->size;
+	retval = 0;
+#if NPU_DEV_SIM == NPU_REAL_ENV
+	npu_check_mcu_active(nvdla_dev);
+#endif
+
+	if (nvdla_dev->e31_fw_virt_base) {
+		iommu_unmap_rsv_iova(&pdev->dev, nvdla_dev->e31_fw_virt_base,
+				     nvdla_dev->e31_nim_iova,
+				     nvdla_dev->e31_fw_size);
+		nvdla_dev->e31_fw_virt_base = NULL;
+	}
+
+	dla_debug("npu e31 load firmware done.\n");
+err_map_iova:
+	release_firmware(e31_fw);
+	return retval;
+}
diff --git a/drivers/soc/eswin/ai_driver/npu/npu_frame.c b/drivers/soc/eswin/ai_driver/npu/npu_frame.c
new file mode 100644
index 000000000000..b5434913324c
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/npu/npu_frame.c
@@ -0,0 +1,409 @@
+// Copyright © 2024 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/workqueue.h>
+#include "dla_log.h"
+#include "dla_driver.h"
+#include "dla_engine.h"
+#include "hetero_ioctl.h"
+#include "internal_interface.h"
+#include "npu_spram.h"
+#include "conv.h"
+#include "hetero_host.h"
+#include "dla_buffer.h"
+#include "debug.h"
+#include "nvdla_proc.h"
+#include "dsp.h"
+
+static inline void set_dep_cnt(u8 *dep, u16 op, u8 value)
+{
+	u16 slot = op / NUM_CNT_PER_BYTE;
+	u8 shift = (op % NUM_CNT_PER_BYTE) * BIT_PER_DEPCNT;
+
+	dep[slot] |= (value & DEP_CNT_MASK) << shift;
+}
+
+int prepare_e31_frame_info(struct win_executor *executor,
+			   struct user_model *model)
+{
+	hetero_ipc_frame_t *frame_info =
+		(hetero_ipc_frame_t *)&model->e31_frame_info;
+	int i;
+	u16 op;
+
+	for (i = IDX_START; i < NUM_OP_TYPE; i++) {
+		if (executor->op_num[i] <= 0) {
+			frame_info->op_current.program_addr[i] = 0;
+			frame_info->op_current.num_remain_ops[i] = 0;
+			continue;
+		}
+
+		if (i == IDX_CONV) {
+			dla_debug("conv_op#=%u, %s, %d.\n", executor->op_num[i],
+				  __func__, __LINE__);
+			memcpy(&frame_info->op_current.next_conv_hdr,
+			       &executor->op_prog_addrs.next_conv_hdr,
+			       sizeof(conv_dev_hdr_t));
+		}
+		dla_debug("%s, %d, i = %d, bobj addr=0x%px.\n", __func__,
+			  __LINE__, i, executor->prog_data_buf_bobj[i]);
+		frame_info->op_current.program_addr[i] = executor->dma_addr[i];
+
+		frame_info->op_current.num_remain_ops[i] = executor->op_num[i];
+	}
+	for (op = 0; op < executor->total_op_num && op < MAX_DTIM_DEPCNT;
+	     op++) {
+		set_dep_cnt(frame_info->op_dependency.ref_count, op,
+			    executor->dependency_count[op]);
+	}
+
+	frame_info->op_dependency.num_op = executor->total_op_num;
+
+	dla_debug("%s, %d. total_op_num:%d\n", __func__, __LINE__,
+		  executor->total_op_num);
+	return 0;
+}
+
+int io_tensor_to_io_addr(struct win_executor *executor,
+			 struct host_frame_desc *f)
+{
+	u16 i = 0, input_num = 0, output_num = 0;
+	addrDesc_t *address = f->io_tensor_list;
+	u64 *addr_list = f->io_tensors_addr_list;
+	int fd = 0;
+	struct khandle *handle;
+	struct npu_dma_buf_ex *entry;
+	int ret;
+	struct user_model *model = (struct user_model *)executor->model;
+	struct user_context *uctx = model->uctx;
+	struct nvdla_device *nvdla_dev =
+		(struct nvdla_device *)executor->driver_context;
+
+	f->input_num = executor->input_num;
+	f->output_num = executor->output_num;
+
+	ret = npu_set_dsp_iobuf(executor, f);
+	if (ret < 0) {
+		dla_error("%s, %d, set dsp iobuf error.\n", __func__, __LINE__);
+		return -EINVAL;
+	}
+
+	for (i = 0; input_num < executor->input_num ||
+		    output_num < executor->output_num;
+	     i++) {
+		dla_detail("i=%d fd=%lld address[i].flag=0x%x\n", i,
+			   address[i].devBuf.memFd, address[i].flag);
+		if (address[i].flag == mem_flag_input) {
+			if (address[i].bindId > executor->input_num) {
+				dla_error("%s %d invalid bind_id %d\n",
+					  __func__, __LINE__,
+					  address[i].bindId);
+				goto map_err;
+			}
+
+			fd = address[i].devBuf.memFd;
+			mutex_lock(&uctx->dma_lock);
+			entry = xa_load(&uctx->buf_xrray, (int)fd);
+			if (entry) {
+				dla_debug(
+					"%s, %d, input entry->buf_info.memFd = %d.\n",
+					__func__, __LINE__,
+					(int)entry->buf_info.memFd);
+				handle = find_kernel_handle(
+					&uctx->handle, entry->handle.fd,
+					NPU_DMABUF_HANDLE_MAGIC);
+			}
+			mutex_unlock(&uctx->dma_lock);
+			if (!entry || !handle) {
+				f->input_bobj[i] = dla_import_fd_to_device(
+					fd, &nvdla_dev->pdev->dev);
+				if (IS_ERR(f->input_bobj[i])) {
+					dla_error(
+						"err:import input dmabuf error!i=%d\n",
+						i);
+					goto map_err;
+				}
+				f->input_bobj[i]->fd = -1;
+			} else {
+				f->input_bobj[i] = &entry->obj;
+			}
+
+			addr_list[address[i].bindId] =
+				f->input_bobj[i]->dma_addr +
+				address[i].devBuf.offset;
+			dla_detail("i=%d addr_list[address[i].bind_id=%lld\n",
+				   i, addr_list[address[i].bindId]);
+
+			input_num++;
+		}
+		if (address[i].flag == mem_flag_output) {
+			if (address[i].bindId > executor->output_num) {
+				dla_error("%s %d invalid bind_id %d\n",
+					  __func__, __LINE__,
+					  address[i].bindId);
+				goto map_err;
+			}
+
+			fd = address[i].devBuf.memFd;
+			mutex_lock(&uctx->dma_lock);
+			entry = xa_load(&uctx->buf_xrray, (int)fd);
+			if (entry) {
+				dla_debug(
+					"%s, %d, output entry->buf_info.memFd = %d.\n",
+					__func__, __LINE__,
+					(int)entry->buf_info.memFd);
+				handle = find_kernel_handle(
+					&uctx->handle, entry->handle.fd,
+					NPU_DMABUF_HANDLE_MAGIC);
+			}
+			mutex_unlock(&uctx->dma_lock);
+			if (!entry || !handle) {
+				f->output_bobj[i] = dla_import_fd_to_device(
+					fd, &nvdla_dev->pdev->dev);
+				if (!f->output_bobj[i]) {
+					dla_error(
+						"%s, %d, import output fd = %d err.r\n",
+						__func__, __LINE__, fd);
+					goto map_err;
+				}
+				f->output_bobj[i]->fd = -1;
+			} else {
+				f->output_bobj[i] = &entry->obj;
+			}
+
+			addr_list[address[i].bindId + executor->input_num] =
+				f->output_bobj[i]->dma_addr +
+				address[i].devBuf.offset;
+			dla_detail("i=%d addr_list[address[i].bind_id=%lld\n",
+				   i, addr_list[address[i].bindId]);
+
+			output_num++;
+		}
+	}
+
+	return 0;
+
+map_err:
+	return -1;
+}
+
+void destroy_frame(struct host_frame_desc *f)
+{
+	int i = 0;
+	struct npu_dma_buf_ex *entry;
+
+	if (f == NULL) {
+		return;
+	}
+	for (i = 0; i < ES_TASK_MAX_FD_CNT; i++) {
+		if (f->input_bobj[i] != NULL) {
+			dla_detail("release input bobj\n");
+			if (f->input_bobj[i]->fd == -1) {
+				dla_release_bobj(f->input_bobj[i]);
+				f->input_bobj[i] = NULL;
+			} else {
+				entry = container_of(f->input_bobj[i],
+						     struct npu_dma_buf_ex,
+						     obj);
+				kernel_handle_decref(&entry->handle);
+			}
+		}
+		if (f->output_bobj[i] != NULL) {
+			dla_detail("release output bobj\n");
+			if (f->output_bobj[i]->fd == -1) {
+				dla_release_bobj(f->output_bobj[i]);
+				f->output_bobj[i] = NULL;
+			} else {
+				entry = container_of(f->output_bobj[i],
+						     struct npu_dma_buf_ex,
+						     obj);
+				kernel_handle_decref(&entry->handle);
+			}
+		}
+	}
+	destroy_frame_dsp_info(f->executor, f);
+	kfree(f);
+	dla_debug("%s, %d. ok.\n", __func__, __LINE__);
+}
+
+static void npu_release_frame(struct khandle *h)
+{
+	struct host_frame_desc *f =
+		container_of(h, struct host_frame_desc, handle);
+	struct user_model *model;
+
+	model = f->model;
+	destroy_frame(f);
+	kernel_handle_decref(&model->handle);
+	dla_debug("npu_free_frame ok.\n");
+}
+
+void npu_frame_done_process(struct host_frame_desc *f)
+{
+	struct win_executor *executor = f->executor;
+	struct win_engine *engine = executor->engine;
+	unsigned long flags;
+
+	spin_lock_irqsave(&engine->complete_lock, flags);
+	list_add_tail(&f->complete_entry, &engine->frame_complete_list);
+	spin_unlock_irqrestore(&engine->complete_lock, flags);
+
+	if (!work_pending(&engine->complete_work)) {
+		queue_work(system_highpri_wq, &engine->complete_work);
+	}
+	npu_frame_schedule(engine);
+}
+
+static void npu_dump_dtim(struct win_engine *engine, struct host_frame_desc *f)
+{
+#if (NPU_DEV_SIM == NPU_REAL_ENV)
+	int i;
+
+	f->dump_dtim = true;
+	if (engine->master_mem) {
+		memcpy(engine->master_mem, engine->master_shm,
+		       E31_EMISSION_DTIM_SIZE);
+	}
+
+	if (engine->aux_mem) {
+		memcpy(engine->aux_mem, engine->aux_shm, E31_PROGRAM_DTIM_SIZE);
+	}
+	for (i = 0; i < NUM_MAJOR_CORES; i++) {
+		if (engine->major_mem[i]) {
+			memcpy(engine->major_mem[i], engine->major_shm[i],
+			       E31_MAJOR_DTIM_SIZE);
+		}
+	}
+#endif
+}
+
+void npu_drop_all_frame(struct nvdla_device *ndev, bool dump)
+{
+	struct host_frame_desc *f;
+	unsigned long flags;
+	struct win_executor *executor;
+	struct win_engine *engine;
+	int ret = 1;
+	int i;
+
+	engine = npu_get_win_engine(ndev);
+	if (engine == NULL) {
+		return;
+	}
+
+	spin_lock_irqsave(&engine->executor_lock, flags);
+	engine->engine_is_alive = false;
+
+	for (i = 0; i < NUM_TIKTOK; i++) {
+		f = engine->tiktok_frame[i];
+		if (f == NULL) {
+			continue;
+		}
+		ret = del_timer(&engine->timer[i]);
+		if (!ret) {
+			dla_debug("%s, %d, task is now processing in timer.\n",
+				  __func__, __LINE__);
+			continue;
+		}
+		executor = f->executor;
+		engine->tiktok_frame[i] = NULL;
+		unset_current(engine, executor, f->tiktok);
+		ret = 1;
+		spin_unlock_irqrestore(&engine->executor_lock, flags);
+		if (dump) {
+			npu_dump_dtim(engine, f);
+		}
+		npu_frame_done_process(f);
+		spin_lock_irqsave(&engine->executor_lock, flags);
+	}
+	spin_unlock_irqrestore(&engine->executor_lock, flags);
+}
+
+static void npu_process_timeout(struct win_engine *engine, u32 tiktok)
+{
+	struct host_frame_desc *f;
+	struct user_model *model;
+	unsigned long flags;
+	struct win_executor *executor;
+	unsigned long last_state;
+
+	spin_lock_irqsave(&engine->executor_lock, flags);
+	engine->engine_is_alive = false;
+	f = engine->tiktok_frame[tiktok];
+	executor = f->executor;
+	engine->tiktok_frame[tiktok] = NULL;
+	unset_current(engine, executor, f->tiktok);
+	spin_unlock_irqrestore(&engine->executor_lock, flags);
+
+	npu_dump_dtim(engine, f);
+
+	npu_frame_done_process(f);
+	model = f->model;
+	last_state = atomic_fetch_and(~NPU_RT_MUTX_FRAME_DONE,
+				      &model->uctx->lock_status);
+	if (last_state == NPU_RT_MUTX_FRAME_DONE) {
+		dla_debug("%s, %d unlocked, last_state:0x%lx\n", __func__,
+			  __LINE__, last_state);
+		up(&engine->runtime_sem);
+	}
+
+	dla_debug("%s, %d, timeout frame free done.\n", __func__, __LINE__);
+}
+
+void npu_frame_timeout_tok(struct timer_list *t)
+{
+	struct win_engine *engine =
+		container_of(t, struct win_engine, timer[1]);
+	dla_error("%s, npu frame timeout.\n", __func__);
+	npu_process_timeout(engine, 1);
+}
+
+void npu_frame_timeout_tik(struct timer_list *t)
+{
+	struct win_engine *engine =
+		container_of(t, struct win_engine, timer[0]);
+	dla_error("%s, npu frame timeout.\n", __func__);
+	npu_process_timeout(engine, 0);
+}
+
+int create_new_frame(struct win_executor *executor, struct host_frame_desc **f,
+		     void *model)
+{
+	int ret = 0;
+	struct user_model *m = (struct user_model *)model;
+	struct user_context *uctx = m->uctx;
+
+	*f = kzalloc(executor->frame_size, GFP_KERNEL);
+	if (unlikely(*f == NULL)) {
+		dla_error("%s %d no mem\n", __func__, __LINE__);
+		return -ENOMEM;
+	}
+	(*f)->io_tensor_list =
+		(addrDesc_t *)((u8 *)*f + sizeof(struct host_frame_desc));
+	(*f)->io_tensors_addr_list =
+		(u64 *)((u8 *)*f + sizeof(struct host_frame_desc) +
+			executor->io_mem_handle_size);
+	(*f)->model = model;
+
+	ret = init_kernel_handle(&(*f)->handle, npu_release_frame,
+				 NPU_FRAME_KHANDLE_MAGIC, &uctx->handle);
+	if (ret) {
+		dla_error("create khandle for frame error.\n");
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	INIT_LIST_HEAD(&(*f)->complete_entry);
+	return executor->io_mem_handle_size;
+err:
+	kfree(*f);
+	*f = NULL;
+	return ret;
+}
diff --git a/drivers/soc/eswin/ai_driver/npu/npu_main.c b/drivers/soc/eswin/ai_driver/npu/npu_main.c
new file mode 100644
index 000000000000..e83f7c9c85f3
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/npu/npu_main.c
@@ -0,0 +1,724 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/dma-buf.h>
+#include <linux/dma-mapping.h>
+#include <linux/elf.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/irqdomain.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include <linux/ctype.h>
+#include <linux/mailbox_client.h>
+#include <linux/mailbox/eswin-mailbox.h>
+#include <linux/delay.h>
+#include <linux/bitfield.h>
+#include <linux/pm_runtime.h>
+#include <nvdla_interface.h>
+#include <nvdla_linux.h>
+#include "hetero_ioctl.h"
+#include <opendla.h>
+#include <linux/reset.h>
+#include <linux/clk.h>
+#include <dt-bindings/memory/eswin-win2030-sid.h>
+#include <dt-bindings/interconnect/eswin,win2030.h>
+#include <linux/eswin-win2030-sid-cfg.h>
+#include <linux/win2030_noc.h>
+#include <linux/iommu.h>
+#include <linux/es_iommu_rsv.h>
+#include "dla_log.h"
+#include "dla_engine.h"
+#include "dla_engine_internal.h"
+#include "dla_interface.h"
+#include "npu_spram.h"
+#include "dla_driver.h"
+#include "npu_top_csr.h"
+#include "dla_log.h"
+#include "edma.h"
+#include <dt-bindings/memory/eswin-win2030-sid.h>
+#include "debug.h"
+#include "internal_interface.h"
+#include "nvdla_lowlevel.h"
+#include "npu_base_regs.h"
+#include "conv_regs.h"
+#include "hetero_host.h"
+#include "hetero_ipc.h"
+#include "nvdla_linux.h"
+#include "dla_buffer.h"
+#include "mailbox_regs.h"
+#include "nvdla_proc.h"
+
+MODULE_IMPORT_NS(DMA_BUF);
+#define DRIVER_NAME "eswin_npu"
+
+int64_t dla_get_time_us(void)
+{
+	return 0;
+}
+
+int32_t dla_data_read(void *driver_context, void *task_data, void *handle,
+		      uint16_t index, void *dst, uint32_t size, uint64_t offset)
+{
+	int32_t ret;
+	void *ptr = NULL;
+	struct dma_buf *buf;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 6, 0)
+	struct iosys_map map;
+#else
+	struct dma_buf_map map;
+#endif
+	int32_t fd;
+	struct nvdla_task *task = (struct nvdla_task *)task_data;
+	addrDesc_t *h;
+
+	if (handle != NULL) {
+		h = handle;
+	} else {
+		h = &task->addrlist->addrDesc[index];
+	}
+
+	fd = h->devBuf.memFd;
+
+	buf = dma_buf_get(fd);
+	if (IS_ERR(buf)) {
+		pr_err("Failed get dma_buf for handle=%d\n", fd);
+		return -EFAULT;
+	}
+
+	ret = dma_buf_begin_cpu_access(buf, DMA_BIDIRECTIONAL);
+	if (ret) {
+		dla_error("dma_buf_begin_cpu_access error\n");
+		goto put_dma_buf;
+	}
+	ret = dma_buf_vmap(buf, &map);
+	ptr = ret ? NULL : map.vaddr;
+	if (!ptr) {
+		pr_err("Failed to vmap dma_buf for fd=%d\n", fd);
+		ret = -ENOMEM;
+		goto end_cpu_access;
+	}
+
+	if ((buf->size < offset) || (buf->size - offset < size)) {
+		dla_error(
+			"error:dma buf wrong!fd:%d offset=%lld dma_buf size:%ld size:%d\n",
+			fd, offset, buf->size, size);
+		ret = -EFAULT;
+	} else {
+		memcpy(dst, (void *)(((uint8_t *)ptr) + offset), size);
+	}
+	dma_buf_vunmap(buf, &map);
+
+end_cpu_access:
+	dma_buf_end_cpu_access(buf, DMA_BIDIRECTIONAL);
+put_dma_buf:
+	dma_buf_put(buf);
+	return ret;
+}
+
+int32_t dla_data_get_fd(void *driver_context, void *task_data, void *handle,
+			uint16_t index)
+{
+	int32_t fd;
+	struct nvdla_task *task = (struct nvdla_task *)task_data;
+	addrDesc_t *h;
+
+	if (handle != NULL) {
+		h = handle;
+	} else {
+		h = &task->addrlist->addrDesc[index];
+	}
+
+	fd = h->devBuf.memFd;
+
+	return fd;
+}
+
+int32_t dla_data_get_vaddr(void *task_data, uint16_t index, void **vaddr)
+{
+	struct nvdla_task *task = (struct nvdla_task *)task_data;
+
+	if (index >= task->addrlist->numAddress) {
+		pr_err("index(%d) is large than task->addrlist_desc->numAddress(%d)\n",
+		       index, task->addrlist->numAddress);
+		return -EFAULT;
+	}
+	if (task->bobjs[index].vaddr == NULL) {
+		pr_err("bobj of index(%d) not vmap!\n", index);
+		return -EFAULT;
+	}
+
+	*vaddr = (uint8_t *)task->bobjs[index].vaddr +
+		 task->addrlist->addrDesc[index].devBuf.offset;
+	dla_detail("index:%d offset:0x%llx fd:%lld virtAddr:%px\n", index,
+		   task->addrlist->addrDesc[index].devBuf.offset,
+		   task->addrlist->addrDesc[index].devBuf.memFd,
+		   task->addrlist->addrDesc[index].virtAddr);
+
+	return 0;
+}
+
+int32_t dla_get_dma_address(void *driver_context, void *task_data,
+			    int16_t index, void *dst_ptr, u32 *is_io_tensor)
+{
+	int32_t ret = 0;
+	addrDesc_t *address;
+	dma_addr_t *phys_addr = (dma_addr_t *)dst_ptr;
+	struct nvdla_task *task = (struct nvdla_task *)task_data;
+	if (index == -1 || index > task->addrlist->numAddress) {
+		dla_error("dma address index is invalid, %d\n", index);
+		return -EINVAL;
+	}
+
+	address = (addrDesc_t *)task->addrlist->addrDesc;
+
+	if (address[index].memoryType != 0) {
+		dla_error(
+			"memory handle type is error:index=%d,memory_type=%d\n",
+			index, address[index].memoryType);
+		return -1;
+	}
+
+	if (io_tensor_record(task->executor, &address[index], is_io_tensor) >
+	    0) {
+		dla_info(
+			"io tensor detected index=%d,memory_type=%d flag=%d bind_id=%d\n",
+			index, address[index].memoryType, address[index].flag,
+			address[index].bindId);
+		*phys_addr = -1ull;
+		return 1;
+	}
+
+	*phys_addr = task->bobjs[index].dma_addr;
+	*phys_addr = *phys_addr + address[index].devBuf.offset;
+
+	return ret;
+}
+
+int32_t dla_get_sram_address(void *driver_context, void *task_data,
+			     int16_t index, uint64_t *dst_ptr,
+			     u32 *is_io_tensor)
+{
+	int32_t ret = 0;
+	addrDesc_t *address;
+	struct nvdla_device *nvdla_dev = (struct nvdla_device *)driver_context;
+	struct nvdla_task *task = (struct nvdla_task *)task_data;
+
+	if (index == -1 || index > task->addrlist->numAddress) {
+		dla_error("dma address index is invalid, %d\n", index);
+		return -EINVAL;
+	}
+
+	address = (addrDesc_t *)task->addrlist->addrDesc;
+	if (address[index].memoryType != 1) {
+		dla_error(
+			"memory handle type is error:index=%d,memory_type=%d\n",
+			index, address[index].memoryType);
+		return -1;
+	}
+
+	if (io_tensor_record(task->executor, &address[index], is_io_tensor) >
+	    0) {
+		dla_debug(
+			"io tensor detected index=%d,memory_type=%d flag=%d bind_id=%d\n",
+			index, address[index].memoryType, address[index].flag,
+			address[index].bindId);
+		*dst_ptr = -1ull;
+		return 1;
+	}
+	*dst_ptr = nvdla_dev->spram_base_addr + address[index].devBuf.offset;
+
+	return ret;
+}
+
+static const struct of_device_id edla_of_match[] = {
+	{
+		.compatible = "eswin,npu0",
+	},
+	{},
+};
+
+void *npu_get_win_engine(void *arg_nvdla_dev)
+{
+	struct nvdla_device *nvdla_dev = arg_nvdla_dev;
+
+	return nvdla_dev->win_engine;
+}
+
+irqreturn_t npu_mbox_irq(int irq, void *dev_id)
+{
+	struct nvdla_device *nvdla_dev = (struct nvdla_device *)dev_id;
+	msg_payload_t payload;
+	u32 tiktok;
+	u16 op_index;
+	u32 stat;
+	u32 data1;
+
+	while (true) {
+		*(u32 *)&payload = readl(nvdla_dev->mbox_rx_base +
+					 MBOX_NPU_RD_DATA0_OFFSET);
+		data1 = readl(nvdla_dev->mbox_rx_base +
+			      MBOX_NPU_RD_DATA1_OFFSET);
+		if (!data1) {
+			break;
+		}
+		tiktok = payload.param & 0x1;
+		op_index = payload.lparam;
+		// notify data is retrieved by bit clear of data[63].
+		writel(0x0, nvdla_dev->mbox_rx_base + MBOX_NPU_RD_DATA1_OFFSET);
+
+		switch (payload.type) {
+		case FRAME_DONE:
+			stat = payload.param >> 1 & 0x1;
+			mbx_irq_frame_done(nvdla_dev->win_engine, tiktok, stat);
+			break;
+		case NOTIFY_OP_DONE:
+			mbx_irq_op_done(nvdla_dev->win_engine, tiktok,
+					op_index);
+			break;
+		case NOTIFY_EVENT_SINK_DONE:
+			mbx_irq_event_sink_done(nvdla_dev->win_engine, tiktok,
+						op_index);
+			break;
+		default:
+			dla_error("invalid payload.type= %hhu\n", payload.type);
+			ASSERT(false);
+		}
+	}
+	return IRQ_HANDLED;
+}
+
+static struct nvdla_device *static_nvdla_dev[2];
+
+struct nvdla_device *get_nvdla_dev(int i)
+{
+	if (i < 0 || i > 2) {
+		return NULL;
+	}
+	return static_nvdla_dev[i];
+}
+
+static int32_t edla_probe(struct platform_device *pdev)
+{
+	int32_t err = 0;
+	struct resource *res;
+	struct nvdla_device *nvdla_dev;
+	struct device *dev = &pdev->dev;
+	uint32_t version;
+
+	dla_debug("%s enter.\n", __FUNCTION__);
+#if SMALL_PEC_MAT
+	dla_debug("load npu driver with PEC2x2.\n");
+#else
+	dla_debug("load npu driver with PEC4x8.\n");
+#endif
+
+	pr_err("Probe Eswin NPU.\n");
+
+	nvdla_dev = devm_kzalloc(dev, sizeof(*nvdla_dev), GFP_KERNEL);
+	if (!nvdla_dev)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, nvdla_dev);
+	nvdla_dev->pdev = pdev;
+	spin_lock_init(&nvdla_dev->nvdla_lock);
+	mutex_init(&nvdla_dev->task_mutex);
+	init_waitqueue_head(&nvdla_dev->event_wq);
+	err = npu_dt_node_resources(nvdla_dev);
+	if (err) {
+		dla_error("error, get hw resource, ret=%d\n", err);
+		platform_set_drvdata(pdev, NULL);
+		return -EINVAL;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "no io resource\n");
+		err = PTR_ERR(res);
+		goto err_mem0;
+	}
+
+	//npu configuration space, start from 0x51c00000
+	nvdla_dev->base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(nvdla_dev->base)) {
+		err = PTR_ERR(nvdla_dev->base);
+		goto err_mem0;
+	}
+	if (request_mem_region(E31_EMISSION_DTIM_BASE, E31_EMISSION_DTIM_SIZE,
+			       "EMISSION_BASE") == NULL) {
+		dev_err(&pdev->dev, "request_mem_region error\n");
+		err = -EBUSY;
+		goto err_mem0;
+	}
+	nvdla_dev->emission_base = devm_ioremap(
+		&pdev->dev, E31_EMISSION_DTIM_BASE, E31_EMISSION_DTIM_SIZE);
+	if (!nvdla_dev->emission_base) {
+		dev_err(&pdev->dev, "ioremap error\n");
+		err = -ENOMEM;
+		goto err_iomap_emission;
+	}
+
+	if (request_mem_region(E31_PROGRAM_DTIM_BASE, E31_PROGRAM_DTIM_SIZE,
+			       "PROGRAM_BASE") == NULL) {
+		dev_err(&pdev->dev, "request_mem_region error\n");
+		err = -EBUSY;
+		goto err_iomap_emission;
+	}
+	nvdla_dev->program_base = devm_ioremap(
+		&pdev->dev, E31_PROGRAM_DTIM_BASE, E31_PROGRAM_DTIM_SIZE);
+	if (!nvdla_dev->program_base) {
+		dev_err(&pdev->dev, "ioremap error\n");
+		err = -ENOMEM;
+		goto err_iomap_program;
+	}
+
+	nvdla_dev->uart_mutex_base = devm_ioremap(
+		&pdev->dev, UART_MUTEX_BASE_ADDR, UART_MUTEX_ADDR_SIZE);
+	if (!nvdla_dev->uart_mutex_base) {
+		dev_err(&pdev->dev, "ioremap error\n");
+		err = -ENOMEM;
+		goto err_iomap_program;
+	}
+
+	err = npu_enable_clock(nvdla_dev);
+	if (err < 0) {
+		dev_err(&pdev->dev, "%s, %d, npu enable clock err, ret = %d.\n",
+			__func__, __LINE__, err);
+		goto err_iomap_program;
+	}
+
+	pm_runtime_set_autosuspend_delay(dev, 5000);
+	pm_runtime_use_autosuspend(dev);
+	pm_runtime_set_active(dev);
+	pm_runtime_enable(dev);
+	pm_runtime_get_noresume(dev);
+
+	err = npu_init_reset(nvdla_dev);
+	if (err)
+		goto err_init_reset;
+
+	err = npu_init_mbox(nvdla_dev);
+	if (err) {
+		dev_err(&pdev->dev, "npu init mailbox error, ret = %d.\n", err);
+		goto err_init_mbox;
+	}
+	npu_tbu_power(dev, true);
+
+	switch (nvdla_dev->numa_id) {
+	case 0:
+		nvdla_dev->e31_mmio_base = devm_ioremap(dev, NPU_CFG_BASE_ADDR,
+							NPU_CFG_ADDR_RANGE);
+		break;
+	case 1:
+		nvdla_dev->e31_mmio_base =
+			devm_ioremap(dev, NPU_CFG_BASE_ADDR + 0x20000000,
+				     NPU_CFG_ADDR_RANGE);
+		break;
+	default:
+		dla_error(
+			"parameter numaid=%d is not correct, please use 0 or 1.\n",
+			nvdla_dev->numa_id);
+		goto err_iomap_e31;
+	}
+	if (!nvdla_dev->e31_mmio_base) {
+		dla_error("Eswin e31 ioremap fail.\n");
+		goto err_iomap_e31;
+	}
+
+	err = npu_e31_load_fw(pdev, nvdla_dev->e31_mmio_base);
+	if (err) {
+		dev_err(&pdev->dev, "load e31 fw error.\n");
+		goto err_load_firm;
+	}
+
+	err = npu_spram_get(nvdla_dev);
+	if (err) {
+		dla_error("error get  spram.\n");
+		goto err_spram;
+	}
+	version = dla_reg_read(nvdla_dev, 0x150000);
+	dla_info("edla version: 0x%x\n", version);
+
+	/* config streamID of NPU_DMA */
+	npu_dma_sid_cfg(nvdla_dev->base, WIN2030_SID_NPU_DMA);
+
+	err = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(41));
+	if (err)
+		dev_warn(dev, "Unable to set coherent mask\n");
+
+	npu_hw_init(nvdla_dev);
+	err = edma_init(nvdla_dev);
+	if (err) {
+		dev_warn(dev, "edma_init fail\n");
+		goto err_edma_init;
+	}
+	err = npu_create_sysfs(pdev);
+	if (err) {
+		dev_err(&pdev->dev, "unable to create sysfs files\n");
+	}
+
+	err = win_engine_init(nvdla_dev, &nvdla_dev->win_engine);
+	if (err) {
+		dev_err(&pdev->dev, "failed to init win_engine\n");
+		goto err_engine_init;
+	}
+
+	dev_info(&pdev->dev, "win_engine 0x%px\n", nvdla_dev->win_engine);
+
+	nvdla_dev->pause_op_list = vmalloc(MAX_OP_NUM * sizeof(u16));
+	static_nvdla_dev[nvdla_dev->numa_id] = nvdla_dev;
+
+	err = create_npu_dev(0, nvdla_dev);
+	if (err) {
+		dev_err(&pdev->dev, "failed to register npu device\n");
+		goto err_create_dev;
+	}
+	pm_runtime_mark_last_busy(dev);
+	pm_runtime_put_autosuspend(dev);
+	return err;
+err_create_dev:
+	vfree(nvdla_dev->pause_op_list);
+	win_engine_destroy(nvdla_dev);
+err_engine_init:
+	edma_free(nvdla_dev);
+err_edma_init:
+	npu_spram_release(nvdla_dev);
+err_spram:
+err_load_firm:
+err_iomap_e31:
+	npu_tbu_power(dev, false);
+err_init_mbox:
+err_init_reset:
+	pm_runtime_put_noidle(dev);
+	pm_runtime_disable(dev);
+	pm_runtime_set_suspended(dev);
+	pm_runtime_dont_use_autosuspend(dev);
+	npu_disable_clock(nvdla_dev);
+err_iomap_program:
+	release_mem_region(E31_PROGRAM_DTIM_BASE, E31_PROGRAM_DTIM_SIZE);
+err_iomap_emission:
+	release_mem_region(E31_EMISSION_DTIM_BASE, E31_EMISSION_DTIM_SIZE);
+err_mem0:
+	npu_put_dt_resources(nvdla_dev);
+	return err;
+}
+
+static int32_t __exit edla_remove(struct platform_device *pdev)
+{
+	struct nvdla_device *nvdla_dev = dev_get_drvdata(&pdev->dev);
+	int ret;
+
+	if (nvdla_dev == NULL) {
+		return 0;
+	}
+
+	ret = npu_hardware_reset(nvdla_dev);
+	if (ret) {
+		dla_error("hardware reset error, ret=%d.\n", ret);
+		return -EIO;
+	}
+
+	destory_npu_dev(0);
+	npu_uninit_mbox(nvdla_dev);
+	npu_dev_reset(nvdla_dev);
+	pm_runtime_disable(&nvdla_dev->pdev->dev);
+	pm_runtime_set_suspended(&nvdla_dev->pdev->dev);
+	pm_runtime_dont_use_autosuspend(&nvdla_dev->pdev->dev);
+
+	/* reset the uart1 mutex lock */
+	reset_uart_mutex(nvdla_dev);
+
+	if (nvdla_dev->mbx_chan) {
+		mbox_free_channel(nvdla_dev->mbx_chan);
+	}
+	win_engine_destroy(nvdla_dev);
+	edma_free(nvdla_dev);
+	release_mem_region(E31_EMISSION_DTIM_BASE, E31_EMISSION_DTIM_SIZE);
+	release_mem_region(E31_PROGRAM_DTIM_BASE, E31_PROGRAM_DTIM_SIZE);
+	npu_spram_release(nvdla_dev);
+
+	npu_tbu_power(&pdev->dev, false);
+	ret = npu_disable_clock(nvdla_dev);
+	npu_put_dt_resources(nvdla_dev);
+	npu_remove_sysfs(pdev);
+	if (nvdla_dev->pause_op_list) {
+		vfree(nvdla_dev->pause_op_list);
+		nvdla_dev->pause_op_list = NULL;
+	}
+	return 0;
+}
+
+int npu_runtime_suspend(struct device *dev)
+{
+	struct nvdla_device *ndev = dev_get_drvdata(dev);
+	int ret;
+
+	if (!ndev) {
+		dla_error("%s, %d, ndev is null.\n", __func__, __LINE__);
+		return -EIO;
+	}
+	ret = npu_disable_clock(ndev);
+	dla_debug("%s, %d, ret=%d.\n", __func__, __LINE__, ret);
+	return ret;
+}
+
+int npu_runtime_resume(struct device *dev)
+{
+	struct nvdla_device *ndev = dev_get_drvdata(dev);
+	int ret;
+
+	if (!ndev) {
+		dla_error("%s, %d, ndev is null.\n", __func__, __LINE__);
+		return -EIO;
+	}
+	ret = npu_enable_clock(ndev);
+	dla_debug("%s, %d, ret=%d.\n", __func__, __LINE__, ret);
+	return ret;
+}
+
+int npu_suspend(struct device *dev)
+{
+	int ret;
+	struct nvdla_device *nvdla_dev = dev_get_drvdata(dev);
+	struct win_engine *engine = (struct win_engine *)nvdla_dev->win_engine;
+
+	dla_debug("%s, %d, into..\n", __func__, __LINE__);
+	ret = npu_pm_get(nvdla_dev);
+	if (ret < 0) {
+		dla_error("%s, %d, npu pm get err.\n", __func__, __LINE__);
+		return ret;
+	}
+	memset(engine->host_node, 0, sizeof(host_node_t));
+	memset(nvdla_dev->emission_base, 0, E31_EMISSION_DTIM_SIZE);
+	memset(nvdla_dev->program_base, 0, E31_PROGRAM_DTIM_SIZE);
+
+	engine->tiktok = 0;
+
+	npu_uninit_mbox(nvdla_dev);
+	npu_dev_reset(nvdla_dev);
+	npu_uninit_ipc(nvdla_dev);
+	reset_uart_mutex(nvdla_dev);
+	pm_runtime_mark_last_busy(dev);
+	pm_runtime_put_noidle(dev);
+
+	npu_tbu_power(dev, false);
+	npu_disable_clock(nvdla_dev);
+	return 0;
+}
+
+int npu_resume(struct device *dev)
+{
+	int ret;
+	struct nvdla_device *ndev = dev_get_drvdata(dev);
+
+	ret = npu_enable_clock(ndev);
+	if (ret < 0) {
+		return ret;
+	}
+	ret = npu_hardware_reset(ndev);
+	if (ret) {
+		dla_error("hardware reset error, ret=%d.\n", ret);
+		return -EIO;
+	}
+
+	pm_runtime_get_noresume(dev);
+
+	ret = npu_init_reset(ndev);
+	if (ret < 0) {
+		goto err_reset;
+	}
+	ret = npu_init_mbox(ndev);
+	if (ret) {
+		dev_err(dev, "npu init mailbox error, ret = %d.\n", ret);
+		goto err_reset;
+	}
+	npu_tbu_power(dev, true);
+	/* config streamID of NPU_DMA */
+
+	ret = npu_e31_load_fw(ndev->pdev, ndev->e31_mmio_base);
+	if (ret) {
+		dev_err(dev, "load e31 fw error.\n");
+		goto err_load_firm;
+	}
+	npu_dma_sid_cfg(ndev->base, WIN2030_SID_NPU_DMA);
+	npu_hw_init(ndev);
+	ret = npu_init_ipc(ndev);
+	if (ret) {
+		dev_err(dev, "npu init ipc error.\n");
+		goto err_ipc;
+	}
+
+	pm_runtime_mark_last_busy(dev);
+	pm_runtime_put_autosuspend(dev);
+	return 0;
+
+err_ipc:
+	npu_init_reset(ndev);
+err_load_firm:
+	npu_tbu_power(dev, false);
+err_reset:
+	npu_disable_clock(ndev);
+	return ret;
+}
+
+static const struct dev_pm_ops npu_hw_pm_ops = { SYSTEM_SLEEP_PM_OPS(
+	npu_suspend, npu_resume) SET_RUNTIME_PM_OPS(npu_runtime_suspend,
+						    npu_runtime_resume, NULL) };
+
+static struct platform_driver edla_driver =
+{
+	.probe = edla_probe,
+	.remove = edla_remove,
+	.driver =
+	{
+		.name = DRIVER_NAME,
+		.of_match_table = of_match_ptr(edla_of_match),
+		.pm = &npu_hw_pm_ops,
+	},
+};
+
+static int __init npu_modules_init(void)
+{
+	int err;
+
+	err = platform_driver_register(&edla_driver);
+	if (err < 0) {
+		dla_error("NPU:platform_register_drivers failed!err=%d\n", err);
+		return err;
+	}
+	err = npu_platform_init();
+	if (err) {
+		dla_error("npu platform init err, err=%d.\n", err);
+		platform_driver_unregister(&edla_driver);
+		return err;
+	}
+	npu_create_procfs();
+	return 0;
+}
+module_init(npu_modules_init);
+
+static void __exit npu_modules_exit(void)
+{
+	npu_remove_procfs();
+
+	npu_platform_uninit();
+
+	platform_driver_unregister(&edla_driver);
+
+	dla_loop_buf_exit();
+}
+module_exit(npu_modules_exit);
+
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_AUTHOR("EDLA");
+MODULE_DESCRIPTION("Eswin Deep Learning Accelerator driver");
diff --git a/drivers/soc/eswin/ai_driver/npu/npu_spram.c b/drivers/soc/eswin/ai_driver/npu/npu_spram.c
new file mode 100644
index 000000000000..2592597fabc5
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/npu/npu_spram.c
@@ -0,0 +1,220 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/delay.h>
+#include <linux/uaccess.h>
+#include "npu_spram.h"
+
+// At least one way must be reserved for cache
+#define MAX_CACHE_SIZE (2 * 0x100000)  //2MB
+#define MAX_NUM_OF_WAY_SET_ASSOCIATIVE \
+	16  //16-way set associative, i.e. 16 lines per set
+#define SIZE_OF_PER_WAY (MAX_CACHE_SIZE / MAX_NUM_OF_WAY_SET_ASSOCIATIVE)
+#define NPU_CACHE_LINE_SIZE 128
+
+// 8MB/16way/256 = 2048 sets
+// 4MB/16way/128 = 2048 sets
+#define MAX_SETS \
+	(MAX_CACHE_SIZE / MAX_NUM_OF_WAY_SET_ASSOCIATIVE / NPU_CACHE_LINE_SIZE)
+
+//At least one way must be reserved for cache
+#define SPRAM_WAYS (MAX_NUM_OF_WAY_SET_ASSOCIATIVE - 1)
+#define SPRAM_SIZE                     \
+	(SPRAM_WAYS * MAX_CACHE_SIZE / \
+	 MAX_NUM_OF_WAY_SET_ASSOCIATIVE)  //4MB of MAX_CACHE_SIZE is used as spram
+
+#define LLC_INTERLEAVE_ENABLE_BIT 0
+const static uint32_t npu_llc_offset[2] = { 0x188000, 0x189000 };
+
+enum coda_cache_reg {
+	CODA_CACHE_REG_CCUTCR = 0x0000,
+	CODA_CACHE_REG_CCUTAR = 0x0004,
+	CODA_CACHE_REG_CCUCTCR = 0x0010,
+	CODA_CACHE_REG_CCUCTAR = 0x0014,
+	CODA_CACHE_REG_CCUCAOR = 0x0018,
+	CODA_CACHE_REG_CCUSPCR0 = 0x0020,
+	CODA_CACHE_REG_CCUSPCR1 = 0x0024,
+	CODA_CACHE_REG_CCUSPBR0 = 0x0028,
+	CODA_CACHE_REG_CCUSPBR1 = 0x002C,
+	CODA_CACHE_REG_CCUWPCR00 = 0x0040,
+	CODA_CACHE_REG_CCUWPCR10 = 0x0044,
+	CODA_CACHE_REG_CCUWPCR01 = 0x0048,
+	CODA_CACHE_REG_CCUWPCR11 = 0x004c,
+	CODA_CACHE_REG_CCUCMCR = 0x0100,
+	CODA_CACHE_REG_CCUCMAR = 0x0104,
+	CODA_CACHE_REG_CCUCMLR0 = 0x0108,
+	CODA_CACHE_REG_CCUCMLR1 = 0x010c,
+	CODA_CACHE_REG_CCUCMLR2 = 0x0110,
+	CODA_CACHE_REG_CCUCMDR = 0x0114,
+	CODA_CACHE_REG_CCUCMWVR = 0x0118,
+	CODA_CACHE_REG_CCUCECR = 0x0140,
+	CODA_CACHE_REG_CCUCESR = 0x0144,
+	CODA_CACHE_REG_CCUCESAR = 0x0148,
+	CODA_CACHE_REG_CCUCELR0 = 0x014c,
+	CODA_CACHE_REG_CCUCELR1 = 0x0150,
+	CODA_CACHE_REG_CCUUEDR = 0x0154,
+	CODA_CACHE_REG_CCUUEIR = 0x0158,
+	CODA_CACHE_REG_CCUUESR = 0x015c,
+	CODA_CACHE_REG_CCUUESAR = 0x0160,
+	CODA_CACHE_REG_CCUUELR0 = 0x0164,
+	CODA_CACHE_REG_CCUUELR1 = 0x0168,
+	CODA_CACHE_REG_CCUIDR = 0x01c0,
+	CODA_CACHE_REG_CCUCRTR = 0x01c4,
+	CODA_CACHE_REG_CCUESR = 0x01c8,
+	CODA_CACHE_REG_CCUEMR = 0x01cc,
+	CODA_CACHE_REG_CCUEAR = 0x01d0,
+};
+
+void *spram_start = NULL;
+
+void npu_llc_write(struct nvdla_device *dev, uint32_t device, uint32_t addr,
+		   uint32_t value)
+{
+	dla_reg_write(dev, npu_llc_offset[device] + addr, value);
+}
+
+uint32_t npu_llc_read(struct nvdla_device *dev, uint32_t device, uint32_t addr)
+{
+	return dla_reg_read(dev, npu_llc_offset[device] + addr);
+}
+
+static int npu_llc_init(struct nvdla_device *dev, uint32_t spram_size,
+			uint32_t device)
+{
+	uint32_t val = 0;
+	uint32_t spram_num_of_ways;
+
+	//At least one way must be reserved for cache,  and spramSzie must be intergral multiple of SIZE_OF_PER_WAY
+	if ((spram_size > MAX_CACHE_SIZE) || (spram_size < SIZE_OF_PER_WAY) ||
+	    (spram_size % SIZE_OF_PER_WAY)) {
+		dev_err(&dev->pdev->dev, "Invalid spramSize\n");
+		return -1;
+	}
+
+	spram_num_of_ways = spram_size / SIZE_OF_PER_WAY;
+	npu_llc_write(dev, device, CODA_CACHE_REG_CCUCMWVR,
+		      GENMASK_ULL(spram_num_of_ways - 1, 0));
+	npu_llc_write(dev, device, CODA_CACHE_REG_CCUCMCR, 0x0);
+	do {
+		val = npu_llc_read(dev, device, CODA_CACHE_REG_CCUCMAR);
+		msleep(1);
+	} while (val & 0x1);
+
+	npu_llc_write(dev, device, CODA_CACHE_REG_CCUCMCR, 0x10000);
+	do {
+		val = npu_llc_read(dev, device, CODA_CACHE_REG_CCUCMAR);
+		msleep(1);
+	} while (val & 0x1);
+
+	npu_llc_write(dev, device, CODA_CACHE_REG_CCUSPBR0, 0);
+	npu_llc_write(dev, device, CODA_CACHE_REG_CCUSPBR1, 0);
+
+	npu_llc_write(dev, device, CODA_CACHE_REG_CCUSPCR0,
+		      (spram_num_of_ways - 1)
+			      << 16);  // num of  ways are used as spram
+	/*number of cachelines, taking 2048 sets as an example*/
+	npu_llc_write(dev, device, CODA_CACHE_REG_CCUSPCR1,
+		      MAX_SETS * spram_num_of_ways - 1);
+	val = npu_llc_read(dev, device, CODA_CACHE_REG_CCUSPCR0);
+	val |= 0x1;  //enable Spram
+	npu_llc_write(dev, device, CODA_CACHE_REG_CCUSPCR0, val);
+	npu_llc_write(dev, device, CODA_CACHE_REG_CCUCTCR,
+		      0x3);  // enable codacache ip lookups and fill
+	npu_llc_write(dev, device, CODA_CACHE_REG_CCUUEDR,
+		      0x3);  // enable codacache ip error detection
+	npu_llc_write(dev, device, CODA_CACHE_REG_CCUCAOR,
+		      0x4);  // enable codacache ip write allocation partial
+
+	return 0;
+}
+
+static int npu_llc_interleave_enable(struct nvdla_device *nvdla_dev)
+{
+	uint32_t value;
+	void *base_addr;
+	struct device *dev = &nvdla_dev->pdev->dev;
+
+	base_addr = ioremap(0x51810000, 0x500);
+	if (!base_addr) {
+		dev_err(dev, "ioremap error\n");
+		return -1;
+	}
+
+	value = readl(base_addr + 0x324);
+	value |= (1 << 0);
+
+	writel(value, base_addr + 0x324);
+
+	iounmap(base_addr);
+
+	return 0;
+}
+
+int npu_spram_init(struct nvdla_device *nvdla_dev)
+{
+	struct resource res_spram;
+	struct device_node *node;
+	struct device *dev;
+
+	dev = &nvdla_dev->pdev->dev;
+	node = of_parse_phandle(dev->of_node, "spram-region", 0);
+	if (IS_ERR(node)) {
+		dev_err(dev, "Get phandle npu-spram error\n");
+		return -ENODEV;
+	}
+
+	of_address_to_resource(node, 0, &res_spram);
+	dev_info(dev, "spram start addr: 0x%llx, len: 0x%llx\n",
+		 res_spram.start, resource_size(&res_spram));
+	nvdla_dev->spram_base_addr = res_spram.start;
+
+	if (npu_llc_interleave_enable(nvdla_dev) < 0) {
+		dev_err(dev, "npu_llc_interleave_enable error\n");
+		return -1;
+	}
+
+	if (npu_llc_init(nvdla_dev, MAX_CACHE_SIZE, 0) < 0) {
+		dev_err(dev, "npu_llc_init0 error\n");
+		return -1;
+	}
+
+	if (npu_llc_init(nvdla_dev, MAX_CACHE_SIZE, 1) < 0) {
+		dev_err(dev, "npu_llc_init1 error\n");
+		return -1;
+	}
+
+	spram_start =
+		ioremap(nvdla_dev->spram_base_addr, resource_size(&res_spram));
+	if (IS_ERR(spram_start)) {
+		dev_err(dev, "npu spram ioremap error\n");
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+void npu_spram_read(uint32_t addr, uint32_t len, uint8_t *buffer)
+{
+	uint32_t i;
+
+	for (i = 0; i < len; i++) {
+		buffer[i] = readb(spram_start + addr + i);
+	}
+}
+
+void npu_spram_write(uint32_t addr, uint32_t len, uint8_t *buffer)
+{
+	uint32_t i;
+
+	for (i = 0; i < len; i++) {
+		writeb(buffer[i], spram_start + addr + i);
+	}
+}
diff --git a/drivers/soc/eswin/ai_driver/npu/npu_spram.h b/drivers/soc/eswin/ai_driver/npu/npu_spram.h
new file mode 100644
index 000000000000..6bf9e2c369c4
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/npu/npu_spram.h
@@ -0,0 +1,17 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#ifndef NPU_SPRAM_H
+#define NPU_SPRAM_H
+
+#include "dla_driver.h"
+
+int npu_spram_init(struct nvdla_device *nvdla_dev);
+void npu_spram_read(uint32_t addr, uint32_t len, uint8_t *buffer);
+void npu_spram_write(uint32_t addr, uint32_t len, uint8_t *buffer);
+
+#endif
diff --git a/drivers/soc/eswin/ai_driver/npu/nvdla_hw.c b/drivers/soc/eswin/ai_driver/npu/nvdla_hw.c
new file mode 100644
index 000000000000..3ccaec7130fd
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/npu/nvdla_hw.c
@@ -0,0 +1,1022 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#include <linux/kernel.h>
+#include <linux/clk.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/ctype.h>
+#include <drm/drm_prime.h>
+#include <linux/mailbox_client.h>
+#include <linux/bitfield.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <nvdla_interface.h>
+#include <nvdla_linux.h>
+#include <linux/reset.h>
+#include <linux/pm_runtime.h>
+#include <dt-bindings/memory/eswin-win2030-sid.h>
+#include <dt-bindings/interconnect/eswin,win2030.h>
+#include <linux/eswin-win2030-sid-cfg.h>
+#include <linux/win2030_noc.h>
+#include <linux/version.h>
+#include <asm/cacheflush.h>
+#include <linux/iommu.h>
+#include <linux/es_iommu_rsv.h>
+#include "dla_interface.h"
+// TODO(yuzaiqiang) The header files dla_interface.h and llc_spram.h both define the same
+// macro CACHE_LINE_SIZE, resulting in a riscv compilation error.
+// To resolve the compilation issue, we are temporarily using '#undef
+#undef CACHE_LINE_SIZE
+#include <llc_spram.h>
+#include "dla_log.h"
+#include "dla_engine.h"
+#include "dla_engine_internal.h"
+#include "npu_spram.h"
+#include "dla_driver.h"
+#include "npu_top_csr.h"
+#include "edma.h"
+#include "debug.h"
+#include "internal_interface.h"
+#include "conv_regs.h"
+#include "hetero_host.h"
+#include "dla_buffer.h"
+#include "nvdla_lowlevel.h"
+#include "mailbox_regs.h"
+
+struct reg_desc_t {
+	unsigned long addr;
+	unsigned long len_or_val;
+};
+
+typedef union {
+	struct {
+		u32 cvif_noc_arqos : 4;
+		u32 cvif_noc_awqos : 4;
+		u32 e31_noc_arqos : 4;
+		u32 e31_noc_awqos : 4;
+		u32 edma_noc_arqos : 4;
+		u32 edma_noc_awqos : 4;
+		u32 mclf_noc_arqos : 4;
+		u32 mclf_noc_awqos : 4;
+	};
+	u32 dw;
+} npu_qos_0;
+
+typedef union {
+	struct {
+		u32 edma_qos_sel : 1;
+		u32 llc0_qos_sel : 1;
+		u32 llc1_qos_sel : 1;
+		u32 Reserved0 : 5;
+		u32 npu_lnoc_llc1_reg_arqos : 4;
+		u32 npu_lnoc_llc1_reg_awqos : 4;
+		u32 Reserved1 : 16;
+	};
+	u32 dw;
+} npu_qos_sel;
+
+static struct reg_desc_t reg_desc_hd;
+
+void npu_hw_init(struct nvdla_device *nvdla_dev);
+#define NPU_TOP_NPU_CSR_OFFSET 0x198000UL
+
+void npu_dma_sid_cfg(void __iomem *npu_subsys_base, u32 sid)
+{
+	u32 rdwr_sid_ssid = 0;
+	u32 rsidval = 0;
+	u32 wsidval = 0;
+	/* make the reading sid the same as writing sid, and ssid is fixed to zero */
+	rdwr_sid_ssid |= FIELD_PREP(NPU_DMA_SID, sid);
+	rdwr_sid_ssid |= FIELD_PREP(NPU_DMA_SSID, 0);
+	writel(rdwr_sid_ssid, npu_subsys_base + NPU_TOP_NPU_CSR_OFFSET +
+				      NPU_DMA_MMU_RID_REG_OFFSET);
+	writel(rdwr_sid_ssid, npu_subsys_base + NPU_TOP_NPU_CSR_OFFSET +
+				      NPU_DMA_MMU_WID_REG_OFFSET);
+
+	rsidval = readl(npu_subsys_base + NPU_TOP_NPU_CSR_OFFSET +
+			NPU_DMA_MMU_RID_REG_OFFSET);
+	wsidval = readl(npu_subsys_base + NPU_TOP_NPU_CSR_OFFSET +
+			NPU_DMA_MMU_WID_REG_OFFSET);
+
+	dla_info(
+		"%s, NPU_TOP_CSR_OFFSET=0x%lx, npu_dma: rsid=0x%x, wsid=0x%x\n",
+		__FUNCTION__, NPU_TOP_NPU_CSR_OFFSET, rsidval, wsidval);
+}
+
+void npu_tbu_power(struct device *dev, bool flag)
+{
+	win2030_tbu_power(dev, flag);
+}
+
+void *npu_alloc_dma_addr(struct win_executor *executor, size_t size,
+			 dma_addr_t *dma_handle, int i, gfp_t gfp)
+{
+	struct nvdla_device *nvdla_dev = executor->engine->nvdla_dev;
+	struct device *dev = &nvdla_dev->pdev->dev;
+
+	return dma_alloc_coherent(dev, size, dma_handle, gfp);
+}
+
+void npu_free_dma_addr(struct win_executor *executor, int i)
+{
+	struct nvdla_device *nvdla_dev = executor->engine->nvdla_dev;
+	struct device *dev = &nvdla_dev->pdev->dev;
+
+	dma_free_coherent(dev, executor->prog_data_size[i],
+			  executor->prog_data_buf_bobj[i],
+			  executor->dma_addr[i]);
+}
+
+static void npu_e31_hw_lock_reset(void)
+{
+#define MUTEX_BASE_ADDR 0x51820000
+#define MUTEX_UNIT_SIZE 4
+
+	uint32_t ret_token_id = 0;
+	unsigned long hw_lock_addr = MUTEX_BASE_ADDR + 1 * MUTEX_UNIT_SIZE;
+	void *hw_lock_virt_addr = NULL;
+
+	hw_lock_virt_addr = ioremap(hw_lock_addr, 8);
+
+	ret_token_id = readl(hw_lock_virt_addr);
+
+	if (ret_token_id != 0) {
+		writel(0, hw_lock_virt_addr);
+	}
+
+	iounmap(hw_lock_virt_addr);
+
+	return;
+}
+
+/*/sys/devices/platform/soc/51c00000.nvdla-controller/reg*/
+
+int npu_clk_reset_print(struct platform_device *pdev)
+{
+	void *reset_base_addr;
+	uint32_t reg_val1, reg_val2, reg_val3, reg_val5;
+
+	reset_base_addr = ioremap(NPU_CFG_BASE_ADDR, 0x500);
+	if (IS_ERR(reset_base_addr)) {
+		dev_err(&pdev->dev, "reset base addr ioremap error\n");
+		return -ENODEV;
+	}
+
+	reg_val1 = readl(reset_base_addr + NPU_ACLK_CTRL);
+
+	//npu_llc_clken
+	reg_val2 = readl(reset_base_addr + NPU_LLC_CTRL);
+
+	//npu_core_clken
+	reg_val3 = readl(reset_base_addr + NPU_CORE_CTRL);
+
+	//npu_xxx_rstn
+	reg_val5 = readl(reset_base_addr + NPU_RST_CTRL);
+
+	dla_debug(
+		"[0x178]=0x%08x [0x17c]=0x%08x [0x180]=0x%08x [0x418]=0x%08x\n",
+		reg_val1, reg_val2, reg_val3, reg_val5);
+
+	iounmap(reset_base_addr);
+
+	return 0;
+}
+
+static int npu_e31_dev_reset(struct nvdla_device *nvdla_dev)
+{
+	int ret = 0;
+
+	/*reset e31 core*/
+	ret = reset_control_assert(nvdla_dev->rstc_e31_core);
+	WARN_ON(0 != ret);
+
+	/*reset e31 uart hw mutext*/
+	npu_e31_hw_lock_reset();
+	return 0;
+}
+
+int npu_dev_reset(struct nvdla_device *nvdla_dev)
+{
+	int ret = 0;
+
+	/*reset npu e31*/
+	npu_e31_dev_reset(nvdla_dev);
+
+	msleep(10);
+	/*reset npu core*/
+	ret = npu_core_rst(0, false);
+	if (ret) {
+		dev_err(&nvdla_dev->pdev->dev, "npu_core_rst fail,error: %d.\n",
+			ret);
+		return ret;
+	}
+
+	/*reset npu cfg*/
+	ret = npu_cfg_rst(0, false);
+	if (ret) {
+		dev_err(&nvdla_dev->pdev->dev, "npu_core_rst fail,error: %d.\n",
+			ret);
+		return ret;
+	}
+	msleep(10);
+
+	ret = npu_cfg_rst(0, true);
+	if (ret) {
+		dev_err(&nvdla_dev->pdev->dev, "npu_cfg_rst fail,error: %d\n",
+			ret);
+		return ret;
+	}
+
+	ret = npu_core_rst(0, true);
+	if (ret) {
+		dev_err(&nvdla_dev->pdev->dev, "npu_core_rst fail,error: %d\n",
+			ret);
+		return ret;
+	}
+
+	reset_control_deassert(nvdla_dev->rstc_e31_core);
+
+	return 0;
+}
+
+int npu_init_reset(struct nvdla_device *nvdla_dev)
+{
+	struct platform_device *pdev = nvdla_dev->pdev;
+
+	npu_dev_reset(nvdla_dev);
+	npu_clk_reset_print(pdev);
+
+	return 0;
+}
+
+static ssize_t show_reg_val(struct device *d, struct device_attribute *attr,
+			    char *buf)
+{
+	void *base_addr;
+	uint32_t reg_val;
+
+	if (reg_desc_hd.addr == 0) {
+		sprintf(buf, "err:addr not telled!\n");
+		goto out;
+	}
+
+	base_addr = ioremap(reg_desc_hd.addr, 4);
+	if (IS_ERR(base_addr)) {
+		sprintf(buf, "err:base addr ioremap error!\n");
+		goto out;
+	}
+
+	reg_val = readl(base_addr);
+
+	printk("[0x%lx]=0x%08x\n", reg_desc_hd.addr, reg_val);
+
+	sprintf(buf, "[0x%lx]=0x%08x\n", reg_desc_hd.addr, reg_val);
+
+	iounmap(base_addr);
+
+out:
+	return strlen(buf);
+}
+
+static ssize_t store_reg_val(struct device *d, struct device_attribute *attr,
+			     const char *buf, size_t count)
+{
+	char *p_addr, *p_len;
+	void *v_addr;
+	int ret = 0;
+	int i = 0;
+	char buf_in[128] = { 0 };
+	uint32_t reg_val;
+
+	if (count == 0 || count > 128) {
+		printk("err:count=%ld\n", count);
+		return count;
+	}
+
+	memcpy(buf_in, buf, count);
+	if (buf_in[count - 1] == '\n') {
+		buf_in[count - 1] = 0;
+	}
+
+	p_addr = strstr(buf_in, "0x");
+	if (p_addr == NULL) {
+		p_addr = strstr(buf_in, "0X");
+	}
+	if (p_addr == NULL) {
+		dla_error("can not find addr_val!\n");
+		return count;
+	}
+
+	p_len = strstr(p_addr, " ");
+	if (p_len == NULL) {
+		dla_error("can not find len!\n");
+		return count;
+	}
+	*p_len = 0;
+	p_len++;
+
+	printk("p_addr=%s!\n", p_addr);
+	printk("p_len=%s!\n", p_len);
+
+	ret = kstrtoul(p_addr, 0, &reg_desc_hd.addr);
+	if (ret) {
+		printk("%s is not in hex or decimal form.\n", p_addr);
+		return count;
+	}
+
+	ret = kstrtoul(p_len, 0, &reg_desc_hd.len_or_val);
+	if (ret) {
+		printk("%s is not in hex or decimal form.\n", p_len);
+		return count;
+	}
+	printk("input 0x%0lx--0x%lx\n", reg_desc_hd.addr,
+	       reg_desc_hd.len_or_val);
+
+	if (buf_in[0] == 'w') {
+		v_addr = ioremap(reg_desc_hd.addr, 4);
+		if (IS_ERR(v_addr)) {
+			dla_error("ioremap error\n");
+		}
+		writel(reg_desc_hd.len_or_val, v_addr);
+		msleep(5);
+		reg_val = readl(v_addr);
+		printk("read: 0x%0lx--0x%0x\n", reg_desc_hd.addr, reg_val);
+
+		iounmap(v_addr);
+	} else if (buf_in[0] == 'r') {
+		v_addr = ioremap(reg_desc_hd.addr, reg_desc_hd.len_or_val);
+		if (IS_ERR(v_addr)) {
+			printk("ioremap error\n");
+		}
+		for (i = 0; i < reg_desc_hd.len_or_val; i++) {
+			reg_val = readl(v_addr + i * 4);
+			printk("read: 0x%0lx--0x%0x\n",
+			       reg_desc_hd.addr + i * 4, reg_val);
+		}
+		iounmap(v_addr);
+	} else {
+		printk("format err.\n");
+		memset(&reg_desc_hd, 0, sizeof(reg_desc_hd));
+	}
+
+	return count;
+}
+
+int npu_clk_reset_print(struct platform_device *pdev);
+
+int dla_noc_sideband_query(void)
+{
+	int ret = 0;
+	int noc_falut = 0;
+
+	ret = win2030_noc_sideband_mgr_query(SBM_NPU_SNOC_SP0);
+	if (ret != 1) {
+		dla_error("warning:SBM_NPU_SNOC_SP0 state:%d\n", ret);
+		noc_falut = -1;
+	}
+
+	ret = win2030_noc_sideband_mgr_query(SBM_NPU_SNOC_SP1);
+	if (ret != 1) {
+		dla_error("warning:SBM_NPU_SNOC_SP1 state:%d\n", ret);
+		noc_falut = -1;
+	}
+
+	ret = win2030_noc_sideband_mgr_query(SBM_SNOC_NPU);
+	if (ret != 1) {
+		dla_error("warning:SBM_SNOC_NPU state:%d\n", ret);
+		noc_falut = -1;
+	}
+
+	ret = win2030_noc_sideband_mgr_query(SBM_CNOC_NPU);
+	if (ret != 1) {
+		dla_error("warning:SBM_CNOC_NPU state:%d\n", ret);
+		noc_falut = -1;
+	}
+	return noc_falut;
+}
+
+static int npu_restart_init(struct nvdla_device *nvdla_dev)
+{
+	struct platform_device *pdev = nvdla_dev->pdev;
+	int ret;
+
+	npu_dma_sid_cfg(nvdla_dev->base, WIN2030_SID_NPU_DMA);
+	npu_hw_init(nvdla_dev);
+	ret = npu_e31_load_fw(pdev, nvdla_dev->e31_mmio_base);
+
+	return ret;
+}
+
+int npu_hardware_reset(struct nvdla_device *nvdla_dev)
+{
+	int try_cnt = 10;
+	int ret = 0;
+
+	while (--try_cnt) {
+		ret = dla_noc_sideband_query();
+		if (ret) {
+			msleep(200);
+			continue;
+		} else {
+			break;
+		}
+	}
+
+	if ((try_cnt == 0) && (ret != 0)) {
+		dla_error("err:npu noc is busy,reset failed.\n");
+		return -1;
+	}
+	npu_dev_reset(nvdla_dev);
+	return 0;
+}
+
+static ssize_t store_reset_hand(struct device *d, struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	char buf_in[128] = { 0 };
+	char *ptr = NULL;
+	int is_reset = 0;
+	struct nvdla_device *nvdla_dev = dev_get_drvdata(d);
+	struct win_engine *engine = npu_get_win_engine(nvdla_dev);
+
+	int ret, i;
+
+	if (count == 0 || count > 128) {
+		dla_error("err:count=%ld\n", count);
+		return count;
+	}
+
+	memcpy(buf_in, buf, count);
+
+	ptr = strstr(buf_in, "reset");
+	if (ptr != NULL) {
+		is_reset = 1;
+	}
+
+	ptr = strstr(buf_in, "npu");
+	mutex_lock(&engine->reset_mutex);
+	if (ptr != NULL) {
+		if (is_reset == 1) {
+			engine->engine_is_alive = false;
+			npu_drop_all_frame(nvdla_dev, false);
+			memset(engine->host_node, 0, sizeof(host_node_t));
+			memset(nvdla_dev->emission_base, 0,
+			       E31_EMISSION_DTIM_SIZE);
+			memset(nvdla_dev->program_base, 0,
+			       E31_PROGRAM_DTIM_SIZE);
+
+			engine->tiktok = 0;
+
+			ret = npu_hardware_reset(nvdla_dev);
+			if (ret) {
+				dla_error("hardware reset err, ret=%d.\n", ret);
+				goto exit;
+			}
+
+			npu_tbu_power(&nvdla_dev->pdev->dev, true);
+
+			clk_prepare_enable(nvdla_dev->mbox_pclk);
+			clk_prepare_enable(nvdla_dev->mbox_pclk_device);
+			reset_control_reset(nvdla_dev->mbox_rst_device);
+			reset_control_reset(nvdla_dev->mbox_rst);
+			writel(0x1,
+			       nvdla_dev->mbox_rx_base + MBOX_NPU_INT_OFFSET);
+			writel(ESWIN_MAILBOX_NPU_LOCK_BIT,
+			       nvdla_dev->mbox_rx_base + MBOX_NPU_WR_LOCK);
+			npu_restart_init(nvdla_dev);
+
+			host_ipc_initialize(
+				(u64)((struct win_engine
+					       *)(nvdla_dev->win_engine))
+					->host_node,
+				(u32)((struct win_engine
+					       *)(nvdla_dev->win_engine))
+					->host_node_iova,
+				(u64)nvdla_dev->emission_base,
+				(u64)nvdla_dev->program_base);
+
+			reset_uart_mutex(nvdla_dev);
+			for (i = 0; i < NUM_NPU_CORES; i++) {
+				/* initialize the node id for all e31 */
+				io_write((u8 *)nvdla_dev->e31_mmio_base +
+						 NPU_CPU_OFFSET +
+						 NPU_CPU_SIZE * i +
+						 NPU_DTIM_OFFSET +
+						 ADDR_OFFSET(cpu_node_t,
+							     node_id),
+					 i);
+				activate_system(nvdla_dev->e31_mmio_base, i);
+				if (i == 0) {
+					msleep(3);
+				}
+			}
+
+			ret = check_system_activated(nvdla_dev->e31_mmio_base);
+			if (ret == false) {
+				ret = check_system_activated(
+					nvdla_dev->e31_mmio_base);
+			}
+			if (nvdla_dev->e31_fw_virt_base) {
+				iommu_unmap_rsv_iova(
+					d, nvdla_dev->e31_fw_virt_base,
+					nvdla_dev->e31_nim_iova,
+					nvdla_dev->e31_fw_size);
+			}
+			if (ret == false) {
+				dla_error("e31 not bootup, error.\n");
+				goto exit;
+			}
+			engine->engine_is_alive = true;
+		} else {
+			dla_error("err:input err.\n");
+		}
+		goto exit;
+	}
+
+exit:
+	npu_clk_reset_print(nvdla_dev->pdev);
+	mutex_unlock(&engine->reset_mutex);
+	return count;
+}
+
+static ssize_t npu_drop_frame(struct device *d, struct device_attribute *attr,
+			      const char *buf, size_t count)
+{
+	struct nvdla_device *nvdla_dev = dev_get_drvdata(d);
+
+	if (!nvdla_dev) {
+		return -ENODEV;
+	}
+	npu_drop_all_frame(nvdla_dev, true);
+	return count;
+}
+
+static ssize_t npu_dump_dtim(struct device *d, struct device_attribute *attr,
+			     const char *buf, size_t count)
+{
+	struct nvdla_device *nvdla_dev = dev_get_drvdata(d);
+	struct win_engine *engine;
+	int i;
+
+	if (!nvdla_dev) {
+		return -ENODEV;
+	}
+	engine = npu_get_win_engine(nvdla_dev);
+	if (engine == NULL) {
+		return -ENODEV;
+	}
+
+	if (engine->master_mem) {
+		memcpy(engine->master_mem, engine->master_shm,
+		       E31_EMISSION_DTIM_SIZE);
+	}
+
+	if (engine->aux_mem) {
+		memcpy(engine->aux_mem, engine->aux_shm, E31_PROGRAM_DTIM_SIZE);
+	}
+	for (i = 0; i < NUM_MAJOR_CORES; i++) {
+		if (engine->major_mem[i]) {
+			memcpy(engine->major_mem[i], engine->major_shm[i],
+			       E31_MAJOR_DTIM_SIZE);
+		}
+	}
+	dump_dtim_to_file(engine, 3);
+	return count;
+}
+
+static DEVICE_ATTR(reg, 0644, show_reg_val, store_reg_val);
+static DEVICE_ATTR(reset, 0644, NULL, store_reset_hand);
+static DEVICE_ATTR(drop_frame, 0644, NULL, npu_drop_frame);
+static DEVICE_ATTR(dump_dtim, 0644, NULL, npu_dump_dtim);
+
+static const struct attribute *npu_attributes[] = {
+	&dev_attr_reg.attr, &dev_attr_reset.attr, &dev_attr_drop_frame.attr,
+	&dev_attr_dump_dtim.attr, NULL
+};
+
+int npu_create_sysfs(struct platform_device *pdev)
+{
+	int ret;
+
+	ret = sysfs_create_files(&pdev->dev.kobj, npu_attributes);
+	return ret;
+}
+
+int npu_remove_sysfs(struct platform_device *pdev)
+{
+	sysfs_remove_files(&pdev->dev.kobj, npu_attributes);
+	return 0;
+}
+
+int npu_spram_get(struct nvdla_device *nvdla_dev)
+{
+	struct dla_buffer_object *spram_bobj = NULL;
+	uint32_t drv_spram_size;
+	int err = 0;
+
+	err = llc_user_register(&nvdla_dev->pdev->dev);
+	if (err) {
+		dla_error("%s %d llc_user_register failed!,err=%d\n", __func__,
+			  __LINE__, err);
+		return -1;
+	}
+
+	err = llc_spram_avail_size(nvdla_dev->numa_id, &drv_spram_size);
+	if (err) {
+		dla_error("%s %d llc_spram_avail_size failed!,err=%d\n",
+			  __func__, __LINE__, err);
+		return -1;
+	}
+
+	if (of_property_read_u32(nvdla_dev->pdev->dev.of_node, "spram-size",
+				 &nvdla_dev->spram_size)) {
+		dla_error("%s %d get spram_size failed!\n", __func__, __LINE__);
+		return -1;
+	}
+
+	if (drv_spram_size < nvdla_dev->spram_size) {
+		dla_error(
+			"%s %d spram size(0x%x) from spram driver is smaller than size(0x%x) in dts\n",
+			__func__, __LINE__, drv_spram_size,
+			nvdla_dev->spram_size);
+		return -1;
+	}
+	dla_info("spram_size=0x%x\n", nvdla_dev->spram_size);
+
+	spram_bobj = dla_alloc_dmabuf(nvdla_dev->spram_size,
+				      ES_MEM_ALLOC_SPRAM_DIE0);
+	if (spram_bobj < 0) {
+		dla_error(
+			"spram_dma_fd dev_mem_alloc failed!,spram_size=0x%x\n",
+			nvdla_dev->spram_size);
+		return -1;
+	}
+
+	err = dla_attach_dmabuf(spram_bobj, &nvdla_dev->pdev->dev);
+	if (err) {
+		dla_error("dla_attach_dmabuf failed!,err=%d\n", err);
+		dla_release_bobj(spram_bobj);
+		return err;
+	}
+	dla_debug("%s, %d, spram file count=%ld.\n", __func__, __LINE__,
+		  file_count(spram_bobj->dmabuf->file));
+	nvdla_dev->spram_base_addr = sg_phys(spram_bobj->attach->sgt->sgl);
+	dla_debug("spram phy_addr=0x%llx\n", nvdla_dev->spram_base_addr);
+
+	nvdla_dev->spram_bobj = spram_bobj;
+
+	return 0;
+}
+
+int npu_spram_release(struct nvdla_device *nvdla_dev)
+{
+	dla_debug("%s, %d, spram file count=%ld.\n", __func__, __LINE__,
+		  file_count(nvdla_dev->spram_bobj->dmabuf->file));
+	dla_release_bobj(nvdla_dev->spram_bobj);
+
+	return 0;
+}
+
+int send_mbx_msg_to_e31(struct win_engine *engine, msg_payload_t payload)
+{
+	unsigned long flags;
+	struct nvdla_device *ndev = (struct nvdla_device *)engine->nvdla_dev;
+	int count = 0;
+	u32 tmp_data;
+
+	spin_lock_irqsave(&ndev->mbox_lock, flags);
+	while (true) {
+		if (count > 3) {
+			spin_unlock_irqrestore(&ndev->mbox_lock, flags);
+			return -EBUSY;
+		}
+		writel(ndev->mbox_tx_lock_bit,
+		       ndev->mbox_tx_base + MBOX_NPU_WR_LOCK);
+		if (!(readl(ndev->mbox_tx_base + MBOX_NPU_WR_LOCK) &
+		      ndev->mbox_tx_lock_bit) ||
+		    (readl(ndev->mbox_tx_base + MBOX_NPU_FIFO_OFFSET) &
+		     BIT_ULL(0))) {
+			udelay(10);
+			count++;
+			continue;
+		}
+		break;
+	}
+
+	tmp_data = ((u32)payload.type | (u32)payload.param << 8 |
+		    (u32)payload.lparam << 16);
+	writel(tmp_data, ndev->mbox_tx_base + MBOX_NPU_WR_DATA0_OFFSET);
+
+	tmp_data = (u32)BIT(31);
+	writel(tmp_data, ndev->mbox_tx_base + MBOX_NPU_WR_DATA1_OFFSET);
+
+	writel(ndev->mbox_tx_irq_bit, ndev->mbox_tx_base + MBOX_NPU_INT_OFFSET);
+
+	writel(0x0, ndev->mbox_tx_base + MBOX_NPU_WR_LOCK);
+	spin_unlock_irqrestore(&ndev->mbox_lock, flags);
+
+	return 0;
+}
+
+static int npu_enable_mbox_clock(struct nvdla_device *ndev)
+{
+	int ret;
+	ret = clk_prepare_enable(ndev->mbox_pclk);
+	if (ret) {
+		dev_err(&ndev->pdev->dev,
+			"failed to enable host mailbox pclk: %d\n", ret);
+		return ret;
+	}
+
+	ret = clk_prepare_enable(ndev->mbox_pclk_device);
+	if (ret) {
+		dev_err(&ndev->pdev->dev,
+			"failed to enable device mailbox pclk: %d\n", ret);
+		clk_disable_unprepare(ndev->mbox_pclk);
+	}
+	return ret;
+}
+
+static int npu_disable_mbox_clock(struct nvdla_device *ndev)
+{
+	clk_disable_unprepare(ndev->mbox_pclk_device);
+	clk_disable_unprepare(ndev->mbox_pclk);
+	return 0;
+}
+
+int npu_init_mbox(struct nvdla_device *nvdla_dev)
+{
+	reset_control_reset(nvdla_dev->mbox_rst);
+	reset_control_reset(nvdla_dev->mbox_rst_device);
+
+	writel(0x1, nvdla_dev->mbox_rx_base + MBOX_NPU_INT_OFFSET);
+	writel(ESWIN_MAILBOX_NPU_LOCK_BIT,
+	       nvdla_dev->mbox_rx_base + MBOX_NPU_WR_LOCK);
+
+	spin_lock_init(&nvdla_dev->mbox_lock);
+	dla_debug("%s, done\n", __func__);
+	return 0;
+}
+
+int npu_uninit_mbox(struct nvdla_device *ndev)
+{
+	int ret;
+	ret = reset_control_assert(ndev->mbox_rst);
+	WARN_ON(ret != 0);
+	ret = reset_control_assert(ndev->mbox_rst_device);
+	dla_info("npu_uninit_mbox done.\n");
+	return 0;
+}
+
+int npu_put_dt_resources(struct nvdla_device *ndev)
+{
+	struct platform_device *mbox_pdev = ndev->mbox_pdev;
+
+	free_irq(ndev->mbox_irq, ndev);
+
+	clk_put(ndev->mbox_pclk);
+	clk_put(ndev->mbox_pclk_device);
+
+	reset_control_put(ndev->mbox_rst_device);
+	reset_control_put(ndev->mbox_rst);
+
+	dev_set_drvdata(&mbox_pdev->dev, NULL);
+	ndev->mbox_pdev = NULL;
+	return 0;
+}
+
+int npu_dt_node_resources(struct nvdla_device *nvdla_dev)
+{
+	struct platform_device *pdev = nvdla_dev->pdev;
+	struct device_node *mbox_node = NULL;
+	struct platform_device *mbox_pdev = NULL;
+	int ret;
+	struct resource *res;
+
+	if (of_property_read_u32(pdev->dev.of_node, "numa-node-id",
+				 &nvdla_dev->numa_id)) {
+		nvdla_dev->numa_id = 0;
+	}
+
+	nvdla_dev->e31_core_clk = devm_clk_get(&pdev->dev, "e31_core_clk");
+	if (IS_ERR(nvdla_dev->e31_core_clk)) {
+		ret = PTR_ERR(nvdla_dev->e31_core_clk);
+		nvdla_dev->e31_core_clk = NULL;
+		dev_err(&pdev->dev, "failed to get core_clk: %d\n", ret);
+		return ret;
+	}
+	nvdla_dev->rstc_e31_core = devm_reset_control_get_optional_exclusive(
+		&pdev->dev, "e31_core");
+	if (IS_ERR_OR_NULL(nvdla_dev->rstc_e31_core)) {
+		dev_err(&nvdla_dev->pdev->dev,
+			"Failed to e31_core reset handle\n");
+		return -EFAULT;
+	}
+	mbox_node = of_parse_phandle(pdev->dev.of_node, "npu_mbox", 0);
+	if (mbox_node == NULL) {
+		dev_err(&pdev->dev, "npu node have not mailbox node, err.\n");
+		return -EINVAL;
+	}
+
+	mbox_pdev = of_find_device_by_node(mbox_node);
+	if (mbox_pdev == NULL) {
+		dev_err(&pdev->dev, "cannot find npu mbox platform dev, err\n");
+		return -EINVAL;
+	}
+	of_node_put(mbox_node);
+	nvdla_dev->mbox_pdev = mbox_pdev;
+
+	//platform_set_drvdata(mbox_pdev, nvdla_dev);
+	/* use eswin mailbox to send msg and receive msg */
+	if (of_property_read_u32(mbox_node, "lock-bit",
+				 &nvdla_dev->mbox_tx_lock_bit)) {
+		dev_err(&pdev->dev, "failed to get lock_bit: %d\n", ret);
+		return -ENXIO;
+	}
+
+	if (of_property_read_u32(mbox_node, "irq-bit",
+				 &nvdla_dev->mbox_tx_irq_bit)) {
+		dev_err(&mbox_pdev->dev, "failed to get irq_bit: %d\n", ret);
+		return -ENXIO;
+	}
+
+	res = platform_get_resource(mbox_pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		return -ENODEV;
+	}
+	nvdla_dev->mbox_tx_base =
+		devm_ioremap(&mbox_pdev->dev, res->start, resource_size(res));
+	if (IS_ERR(nvdla_dev->mbox_tx_base)) {
+		return PTR_ERR(nvdla_dev->mbox_tx_base);
+	}
+
+	res = platform_get_resource(mbox_pdev, IORESOURCE_MEM, 1);
+	if (!res)
+		return -ENODEV;
+
+	nvdla_dev->mbox_rx_base =
+		devm_ioremap(&mbox_pdev->dev, res->start, resource_size(res));
+	if (IS_ERR(nvdla_dev->mbox_rx_base))
+		return PTR_ERR(nvdla_dev->mbox_rx_base);
+	nvdla_dev->mbox_pclk =
+		devm_clk_get(&mbox_pdev->dev, "pclk_mailbox_host");
+	if (IS_ERR(nvdla_dev->mbox_pclk)) {
+		ret = PTR_ERR(nvdla_dev->mbox_pclk);
+		dev_err(&mbox_pdev->dev,
+			"failed to get host mailbox clock: %d\n", ret);
+		return ret;
+	}
+	nvdla_dev->mbox_pclk_device =
+		devm_clk_get(&mbox_pdev->dev, "pclk_mailbox_device");
+	if (IS_ERR(nvdla_dev->mbox_pclk_device)) {
+		ret = PTR_ERR(nvdla_dev->mbox_pclk_device);
+		dev_err(&mbox_pdev->dev,
+			"failed to get device mailbox clock: %d\n", ret);
+		return ret;
+	}
+	nvdla_dev->mbox_rst = devm_reset_control_get_optional_exclusive(
+		&mbox_pdev->dev, "rst");
+	if (IS_ERR(nvdla_dev->mbox_rst)) {
+		ret = -ENODEV;
+		dev_err(&mbox_pdev->dev, "failed to get rst controller.\n");
+		return ret;
+	}
+	nvdla_dev->mbox_rst_device = devm_reset_control_get_optional_exclusive(
+		&mbox_pdev->dev, "rst_device");
+	if (IS_ERR(nvdla_dev->mbox_rst_device)) {
+		ret = PTR_ERR(nvdla_dev->mbox_rst_device);
+		return ret;
+	}
+	nvdla_dev->mbox_irq = platform_get_irq(mbox_pdev, 0);
+	if (nvdla_dev->mbox_irq < 0) {
+		ret = nvdla_dev->mbox_irq;
+		return ret;
+	}
+	ret = devm_request_threaded_irq(&mbox_pdev->dev, nvdla_dev->mbox_irq,
+					npu_mbox_irq, NULL, IRQF_ONESHOT,
+					dev_name(&mbox_pdev->dev), nvdla_dev);
+	if (ret < 0) {
+		return ret;
+	}
+
+	return 0;
+}
+#define NPU_TOP_S_BASE_ADDR_1 0x198000UL
+#define NPU_MAC_S_BASE_ADDR_1 0x190000UL
+#define NPU_RMDA_WRAPPER_S_BASE_ADDR_1 0x128000UL
+
+void npu_hw_init(struct nvdla_device *nvdla_dev)
+{
+	pp_status_t pp_status;
+	npu_qos_0 qos_0;
+	npu_qos_sel qos_sel;
+	/* reset the uart mutex lock */
+	reset_uart_mutex(nvdla_dev);
+
+	dla_reg_write(nvdla_dev, NPU_TOP_S_BASE_ADDR_1 + NPU_TOP_CTRL, 0);
+	dla_reg_write(nvdla_dev, NPU_TOP_S_BASE_ADDR_1 + NPU_TOP_INT_ENABLE, 0);
+
+	dla_disable_intr(nvdla_dev, -1u);
+
+	pp_status.value = dla_reg_read(nvdla_dev,
+				       NPU_MAC_S_BASE_ADDR_1 + MAC_S_PP_STATUS);
+	dla_reg_write(nvdla_dev, NPU_MAC_S_BASE_ADDR_1 + MAC_S_POINTER_FLAG, 0);
+
+	pp_status.value =
+		dla_reg_read(nvdla_dev, NPU_RMDA_WRAPPER_S_BASE_ADDR_1 +
+						RDMA_WRAPPER_S_PP_STATUS);
+	dla_reg_write(nvdla_dev,
+		      NPU_RMDA_WRAPPER_S_BASE_ADDR_1 +
+			      RDMA_WRAPPER_S_POINTER_FLAG,
+		      0);
+
+	//config qos for edma
+	qos_0.dw = dla_reg_read(nvdla_dev, NPU_TOP_S_BASE_ADDR_1 + NPU_QOS_0);
+	qos_0.edma_noc_arqos = 2;
+	qos_0.edma_noc_awqos = 0;
+	dla_reg_write(nvdla_dev, NPU_TOP_S_BASE_ADDR_1 + NPU_QOS_0, qos_0.dw);
+
+	qos_sel.dw =
+		dla_reg_read(nvdla_dev, NPU_TOP_S_BASE_ADDR_1 + NPU_QOS_SEL);
+	qos_sel.edma_qos_sel = 1;
+	dla_reg_write(nvdla_dev, NPU_TOP_S_BASE_ADDR_1 + NPU_QOS_SEL,
+		      qos_sel.dw);
+}
+
+int npu_disable_clock(struct nvdla_device *ndev)
+{
+	npu_disable_mbox_clock(ndev);
+	clk_disable_unprepare(ndev->e31_core_clk);
+	return npu_clk_gate_set(ndev->numa_id, false);
+}
+
+int npu_enable_clock(struct nvdla_device *ndev)
+{
+	int ret;
+	ret = npu_clk_gate_set(ndev->numa_id, true);
+	if (ret < 0) {
+		dla_error("npu_clk_gate_set failed.\n");
+		return ret;
+	}
+	ret = clk_prepare_enable(ndev->e31_core_clk);
+	if (ret < 0) {
+		dla_error("npu enable e31 core clk err.\n");
+		goto err_e31_clk;
+	}
+	ret = npu_enable_mbox_clock(ndev);
+	if (ret < 0) {
+		dla_error("npu enable mbox clock failed.\n");
+		goto err_mbox_clk;
+	}
+	return 0;
+err_mbox_clk:
+	clk_disable_unprepare(ndev->e31_core_clk);
+err_e31_clk:
+	npu_clk_gate_set(ndev->numa_id, false);
+	return ret;
+}
+
+int npu_platform_init(void)
+{
+	return 0;
+}
+
+int npu_pm_get(struct nvdla_device *ndev)
+{
+	int ret;
+
+	if (ndev == NULL) {
+		return -EINVAL;
+	}
+	ret = pm_runtime_resume_and_get(&ndev->pdev->dev);
+	if (ret < 0) {
+		return ret;
+	}
+	return 0;
+}
+
+int npu_pm_put(struct nvdla_device *ndev)
+{
+	if (ndev == NULL) {
+		return -EINVAL;
+	}
+	pm_runtime_mark_last_busy(&ndev->pdev->dev);
+	pm_runtime_put_autosuspend(&ndev->pdev->dev);
+	return 0;
+}
+
+int npu_platform_uninit(void)
+{
+	return 0;
+}
+
+int npu_hetero_cmd(struct nvdla_device *nvdla_dev, struct win_ioctl_args *args)
+{
+	return -EINVAL;
+}
diff --git a/drivers/soc/eswin/ai_driver/npu/nvdla_lowlevel.h b/drivers/soc/eswin/ai_driver/npu/nvdla_lowlevel.h
new file mode 100644
index 000000000000..08bd5f77fe5b
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/npu/nvdla_lowlevel.h
@@ -0,0 +1,40 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#ifndef __NVDLA_LOWLEVEL_H__
+#define __NVDLA_LOWLEVEL_H__
+#include <linux/platform_device.h>
+#include "dla_driver.h"
+
+irqreturn_t npu_mbox_irq(int irq, void *dev_id);
+void npu_tbu_power(struct device *dev, bool flag);
+void npu_hw_init(struct nvdla_device *ndev);
+int npu_platform_init(void);
+int npu_platform_uninit(void);
+int npu_dt_node_resources(struct nvdla_device *nvdla);
+int npu_put_dt_resources(struct nvdla_device *ndev);
+
+int npu_init_mbox(struct nvdla_device *nvdla_dev);
+
+int npu_uninit_mbox(struct nvdla_device *nvdla_dev);
+int npu_remove_sysfs(struct platform_device *pdev);
+int npu_create_sysfs(struct platform_device *pdev);
+
+int npu_hardware_reset(struct nvdla_device *nvdla_dev);
+
+int npu_dev_reset(struct nvdla_device *nvdla_dev);
+int npu_init_reset(struct nvdla_device *nvdla_dev);
+void npu_dma_sid_cfg(void __iomem *npu_subsys_base, u32 sid);
+
+int npu_e31_load_fw(struct platform_device *, void __iomem *e31_mmio_base);
+int npu_pm_get(struct nvdla_device *ndev);
+int npu_pm_put(struct nvdla_device *ndev);
+
+int npu_enable_clock(struct nvdla_device *ndev);
+
+int npu_disable_clock(struct nvdla_device *ndev);
+#endif
diff --git a/drivers/soc/eswin/ai_driver/npu/nvdla_proc.c b/drivers/soc/eswin/ai_driver/npu/nvdla_proc.c
new file mode 100644
index 000000000000..91d47bae97d2
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/npu/nvdla_proc.c
@@ -0,0 +1,369 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#include <linux/fs.h>
+#include <linux/proc_fs.h>
+#include <linux/kernel.h>
+#include <linux/seq_file.h>
+#include "hetero_ioctl.h"
+#include "internal_interface.h"
+#include "hetero_perf.h"
+
+static struct proc_dir_entry *proc_esnpu;
+static int g_perf = 0;
+static s16 *g_cfg_seq[2][NUM_OP_TYPE];
+static u16 total_op_num[2];
+static u16 op_num[2][NUM_OP_TYPE];
+static spinlock_t proc_lock[2];
+static host_node_t *g_host_node[2] = { NULL };
+static wait_queue_head_t g_perf_wait_list[2];
+static u32 g_stat_titok[2] = { -1 };
+static u32 g_die_perf[2] = { 0 };
+
+void handle_perf_switch(struct nvdla_device *ndev, bool enable)
+{
+	struct win_engine *engine;
+	unsigned long flags;
+
+	spin_lock_irqsave(&proc_lock[ndev->numa_id], flags);
+
+	engine = (struct win_engine *)ndev->win_engine;
+	engine->perf_switch = enable ? 1 : 0;
+	g_perf = engine->perf_switch;
+	if (g_perf == 0) {
+		memset(g_cfg_seq[ndev->numa_id][IDX_START], 0,
+		       sizeof(s16) * MAX_OP_NUM);
+		memset(op_num[ndev->numa_id], 0, sizeof(u16) * NUM_OP_TYPE);
+		g_host_node[ndev->numa_id] = NULL;
+		g_stat_titok[ndev->numa_id] = -1;
+		dla_debug("perf switch to off.\n");
+	}
+	spin_unlock_irqrestore(&proc_lock[ndev->numa_id], flags);
+}
+
+int get_perf_data(struct nvdla_device *ndev)
+{
+#if NPU_PERF_STATS > 1
+	int j, k;
+	int tiktok = -1;
+	npu_e31_perf_t *op_stats;
+	s16 op_idx;
+	struct win_engine *engine;
+	int numa_id = ndev->numa_id;
+	unsigned long flags;
+
+	engine = (struct win_engine *)ndev->win_engine;
+	if (!engine->perf_switch) {
+		dla_error("%s, %d, perf not turn on.\n", __func__, __LINE__);
+		return -EFAULT;
+	}
+
+	if (g_stat_titok[numa_id] == -1) {
+		wait_event_interruptible(g_perf_wait_list[numa_id],
+					 g_stat_titok[numa_id] != -1);
+	}
+
+	spin_lock_irqsave(&proc_lock[numa_id], flags);
+	tiktok = g_stat_titok[numa_id];
+	op_stats = g_host_node[numa_id]->model_stat[tiktok].op_stats;
+	for (j = 0; j < NUM_OP_TYPE; j++) {
+		for (k = 0; k < op_num[numa_id][j]; k++) {
+			op_idx = g_cfg_seq[numa_id][j][k];
+			op_stats[op_idx].Die = numa_id;
+		}
+	}
+	dla_debug("get tiktok=%u perf data.\n", tiktok);
+	memcpy((npu_e31_perf_t *)engine->perf_data_buf, op_stats,
+	       sizeof(npu_e31_perf_t) * MAX_OP_NUM);
+	g_stat_titok[numa_id] = -1;
+	memset(g_host_node[numa_id]->model_stat[tiktok].op_stats, 0,
+	       sizeof(npu_e31_perf_t) * MAX_OP_NUM);
+	spin_unlock_irqrestore(&proc_lock[numa_id], flags);
+#endif
+	return 0;
+}
+
+void refresh_op_statistic(struct win_executor *executor,
+			  struct win_engine *engine, u32 tiktok)
+{
+	int numa_id;
+	struct nvdla_device *ndev;
+	int i;
+	unsigned long flags;
+
+	ndev = engine->nvdla_dev;
+	numa_id = ndev->numa_id;
+	dla_debug("%s, %d, numa_id=%d, tiktok=%d.\n", __func__, __LINE__,
+		  numa_id, tiktok);
+	spin_lock_irqsave(&proc_lock[numa_id], flags);
+	g_cfg_seq[numa_id][IDX_EDMA] = g_cfg_seq[numa_id][IDX_START];
+	g_cfg_seq[numa_id][IDX_CONV] =
+		g_cfg_seq[numa_id][IDX_EDMA] + executor->op_num[IDX_EDMA];
+	g_cfg_seq[numa_id][IDX_SDP] =
+		g_cfg_seq[numa_id][IDX_CONV] + executor->op_num[IDX_CONV];
+	g_cfg_seq[numa_id][IDX_PDP] =
+		g_cfg_seq[numa_id][IDX_SDP] + executor->op_num[IDX_SDP];
+	g_cfg_seq[numa_id][IDX_RUBIK] =
+		g_cfg_seq[numa_id][IDX_PDP] + executor->op_num[IDX_PDP];
+	g_cfg_seq[numa_id][IDX_KMD_DSP0] =
+		g_cfg_seq[numa_id][IDX_RUBIK] + executor->op_num[IDX_RUBIK];
+	g_cfg_seq[numa_id][IDX_KMD_DSP1] = g_cfg_seq[numa_id][IDX_KMD_DSP0] +
+					   executor->op_num[IDX_KMD_DSP0];
+	g_cfg_seq[numa_id][IDX_KMD_DSP2] = g_cfg_seq[numa_id][IDX_KMD_DSP1] +
+					   executor->op_num[IDX_KMD_DSP1];
+	g_cfg_seq[numa_id][IDX_KMD_DSP3] = g_cfg_seq[numa_id][IDX_KMD_DSP2] +
+					   executor->op_num[IDX_KMD_DSP2];
+	g_cfg_seq[numa_id][IDX_EVENT_SINK] = g_cfg_seq[numa_id][IDX_KMD_DSP3] +
+					     executor->op_num[IDX_KMD_DSP3];
+	g_cfg_seq[numa_id][IDX_EVENT_SOURCE] =
+		g_cfg_seq[numa_id][IDX_EVENT_SINK] +
+		executor->op_num[IDX_EVENT_SINK];
+
+	for (i = 0; i < NUM_OP_TYPE; i++) {
+		op_num[numa_id][i] = executor->op_num[i];
+		if (executor->op_num[i] != 0) {
+			memcpy(g_cfg_seq[numa_id][i], executor->cfg_seq[i],
+			       sizeof(s16) * executor->op_num[i]);
+		}
+	}
+	total_op_num[numa_id] = executor->total_op_num;
+	g_host_node[numa_id] = engine->host_node;
+	g_stat_titok[numa_id] = tiktok;
+	g_die_perf[numa_id] = 1;
+	dla_debug("refresh tiktok=%u perf data done.\n", tiktok);
+	spin_unlock_irqrestore(&proc_lock[numa_id], flags);
+	wake_up_interruptible(&g_perf_wait_list[numa_id]);
+}
+
+static char *pcer_str(u8 pcer)
+{
+	switch (pcer) {
+	case IDX_NONE:
+		return "none";
+	case IDX_EDMA:
+		return "EDMA";
+	case IDX_CONV:
+		return "CONV";
+	case IDX_SDP:
+		return "SDP";
+	case IDX_PDP:
+		return "PDP";
+	case IDX_RUBIK:
+		return "RUBIK";
+	case IDX_EVENT_SINK:
+		return "EVENT_SINK";
+	case IDX_KMD_DSP0:
+		return "IDX_KMD_DSP0";
+	case IDX_KMD_DSP1:
+		return "IDX_KMD_DSP1";
+	case IDX_KMD_DSP2:
+		return "IDX_KMD_DSP2";
+	case IDX_KMD_DSP3:
+		return "IDX_KMD_DSP3";
+	case IDX_EVENT_SOURCE:
+		return "EVENT_SOURCE";
+	default:
+		return "FAIL";
+	}
+	return "FAIL";
+}
+
+static int npu_info_show(struct seq_file *m, void *p)
+{
+#if NPU_PERF_STATS > 1
+	int i, j, k;
+	int tiktok;
+	npu_e31_perf_t *op_stat;
+	s16 op_idx;
+
+	if (g_perf == 0) {
+		seq_printf(
+			m,
+			"The perf is not turned on, pls first turn on the perf.\n");
+		return 0;
+	}
+
+	seq_printf(
+		m,
+		"--------------------NPU PERF STATISTIC BEGIN--------------------\n");
+	seq_printf(m, "\n");
+	seq_printf(m, "\t%-4s\t %-4s\t %-4s\t %-8s\t %-10s\t %-10s\t %-10s\n",
+		   "Die", "OpNum", "OpIndex", "OpType", "StartCycle",
+		   "EndCycle", "Elapsed(ns)");
+	for (i = 0; i < 2; i++) {
+		u32 start = 0xffffffff, end = 0;
+
+		if (!g_die_perf[i]) {
+			continue;
+		}
+
+		spin_lock(&proc_lock[i]);
+		tiktok = g_stat_titok[i];
+		op_stat = g_host_node[i]->model_stat[tiktok].op_stats;
+		for (j = 0; j < NUM_OP_TYPE; j++) {
+			for (k = 0; k < op_num[i][j]; k++) {
+				op_idx = g_cfg_seq[i][j][k];
+
+				if (start > op_stat[op_idx].OpEvalStartCycle) {
+					start = op_stat[op_idx].OpEvalStartCycle;
+				}
+				if (end < op_stat[op_idx].OpEvalEndCycle) {
+					end = op_stat[op_idx].OpEvalEndCycle;
+				}
+				seq_printf(
+					m,
+					"\t%-4d\t %-4d\t %-4d\t %-8s\t %10u\t %10u\t %10u\n",
+					i, k, op_idx, pcer_str(j),
+					op_stat[op_idx].OpEvalStartCycle,
+					op_stat[op_idx].OpEvalEndCycle,
+					op_stat[op_idx].OpEvalEndCycle -
+						op_stat[op_idx]
+							.OpEvalStartCycle);
+			}
+		}
+		spin_unlock(&proc_lock[i]);
+		seq_printf(m, "\n");
+	}
+	seq_printf(
+		m,
+		"--------------------NPU PERF STATISTIC END--------------------\n");
+#endif
+	return 0;
+}
+
+static int info_open(struct inode *inode, struct file *flip)
+{
+	return single_open(flip, npu_info_show, NULL);
+}
+
+static int perf_show(struct seq_file *m, void *p)
+{
+	struct nvdla_device *ndev;
+	struct win_engine *engine;
+	int i;
+
+	seq_printf(m,
+		   "--------------------NPU Perf Info--------------------\n");
+	seq_printf(m, "\n");
+	seq_printf(m, "    DieId    Status    Value\n");
+	for (i = 0; i < 2; i++) {
+		ndev = get_nvdla_dev(i);
+		if (!ndev) {
+			seq_printf(m, "    %d       %s     %d\n", i, "No DIE",
+				   0);
+		} else {
+			engine = (struct win_engine *)ndev->win_engine;
+			seq_printf(m, "    %d       %s     %d\n", i, "ONLINE",
+				   engine->perf_switch);
+		}
+	}
+	seq_printf(m, "\n");
+	return 0;
+}
+
+static int perf_open(struct inode *inode, struct file *flip)
+{
+	return single_open(flip, perf_show, NULL);
+}
+
+static ssize_t perf_write(struct file *flip, const char __user *buf,
+			  size_t size, loff_t *pos)
+{
+	u16 data;
+	struct nvdla_device *ndev;
+	int i;
+	u8 value;
+	bool enable;
+
+	if (size > 2) {
+		return -EINVAL;
+	}
+	if (copy_from_user(&data, buf, size)) {
+		return -EFAULT;
+	}
+	value = data & 0xff;
+
+	value -= '0';
+	if (!(value == 1 || value == 0)) {
+		dla_error("%s, %d, data=%d is not correct, pls use 1 or 0.\n",
+			  __func__, __LINE__, value);
+		return -EINVAL;
+	}
+	enable = value ? 1 : 0;
+
+	for (i = 0; i < 2; i++) {
+		ndev = get_nvdla_dev(i);
+		if (ndev) {
+			handle_perf_switch(ndev, enable);
+		}
+	}
+	return size;
+}
+
+static struct proc_ops proc_info_fops = {
+	.proc_open = info_open,
+	.proc_read = seq_read,
+	.proc_release = single_release,
+};
+
+static struct proc_ops proc_perf_fops = {
+	.proc_open = perf_open,
+	.proc_read = seq_read,
+	.proc_release = single_release,
+	.proc_write = perf_write,
+};
+
+static void *tmp = NULL;
+
+int npu_create_procfs(void)
+{
+	proc_esnpu = proc_mkdir("esnpu", NULL);
+	if (proc_esnpu == NULL) {
+		dla_error("create proc esnpu dir err.\n");
+		return -ENOMEM;
+	}
+
+	if (!proc_create("info", 0644, proc_esnpu, &proc_info_fops)) {
+		dla_error("error create proc npu info file.\n");
+		goto err_info;
+	}
+
+	if (!proc_create("perf", 0644, proc_esnpu, &proc_perf_fops)) {
+		dla_error("error create proc npu perf file.\n");
+		goto err_perf;
+	}
+	spin_lock_init(&proc_lock[0]);
+	spin_lock_init(&proc_lock[1]);
+	init_waitqueue_head(&g_perf_wait_list[0]);
+	init_waitqueue_head(&g_perf_wait_list[1]);
+
+	tmp = kzalloc(sizeof(s16) * MAX_OP_NUM * 2, GFP_KERNEL);
+	if (!tmp) {
+		goto err_mem;
+	}
+	g_cfg_seq[0][IDX_START] = tmp;
+	g_cfg_seq[1][IDX_START] = tmp + sizeof(s16) * MAX_OP_NUM;
+	return 0;
+
+err_mem:
+	remove_proc_entry("perf", proc_esnpu);
+err_perf:
+	remove_proc_entry("info", proc_esnpu);
+err_info:
+	remove_proc_entry("esnpu", NULL);
+	return -1;
+}
+
+void npu_remove_procfs(void)
+{
+	if (tmp != NULL) {
+		kfree(tmp);
+	}
+	remove_proc_entry("info", proc_esnpu);
+	remove_proc_entry("perf", proc_esnpu);
+	remove_proc_entry("esnpu", NULL);
+}
diff --git a/drivers/soc/eswin/ai_driver/npu/nvdla_proc.h b/drivers/soc/eswin/ai_driver/npu/nvdla_proc.h
new file mode 100644
index 000000000000..be2e45cee663
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/npu/nvdla_proc.h
@@ -0,0 +1,16 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#ifndef __NVDLA_PROC_H_
+#define __NVDLA_PROC_H_
+struct win_executor;
+struct win_engine;
+int npu_create_procfs(void);
+void npu_remove_procfs(void);
+void refresh_op_statistic(struct win_executor *executor,
+			  struct win_engine *engine, u32 tiktok);
+#endif
diff --git a/drivers/soc/eswin/ai_driver/npu/nvdla_sim.c b/drivers/soc/eswin/ai_driver/npu/nvdla_sim.c
new file mode 100644
index 000000000000..eaf6de2c74fb
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/npu/nvdla_sim.c
@@ -0,0 +1,590 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/dma-buf.h>
+#include <linux/dma-mapping.h>
+#include <linux/elf.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/irqdomain.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include <linux/ctype.h>
+#include <drm/drm_prime.h>
+#include <linux/mailbox_client.h>
+#include <linux/mailbox/eswin-mailbox.h>
+#include <linux/delay.h>
+#include <linux/bitfield.h>
+#include <nvdla_interface.h>
+#include <nvdla_linux.h>
+#include "hetero_ioctl.h"
+#include <opendla.h>
+#include <linux/reset.h>
+#include <linux/clk.h>
+#include <dt-bindings/memory/eswin-win2030-sid.h>
+#include <dt-bindings/interconnect/eswin,win2030.h>
+#include <linux/eswin-win2030-sid-cfg.h>
+#include <linux/win2030_noc.h>
+#include <linux/dma-map-ops.h>
+#include <linux/cma.h>
+
+#include "dla_log.h"
+#include "dla_engine.h"
+#include "dla_engine_internal.h"
+#include "dla_interface.h"
+#include "npu_spram.h"
+#include "dla_driver.h"
+#include "npu_top_csr.h"
+#include "edma.h"
+#include "debug.h"
+#include "hetero_common.h"
+#include "internal_interface.h"
+
+#define MAX_NPU_CORE 1
+static frame_info_t g_frame_info[NUM_TIKTOK];
+struct win_executor *g_executor[NUM_TIKTOK];
+struct npu_op_done_info {
+	msg_payload_t payload;
+	bool op_resume_flag;
+};
+
+extern void handle_event_sink_from_e31(struct win_engine *engine, u32 tiktok,
+				       u16 op_index);
+
+static struct npu_op_done_info op_done_info[NUM_OP_TYPE];
+
+static u16 event_source_idx[NUM_TIKTOK] = { invalid_op_index,
+					    invalid_op_index };
+
+struct npu_hw_info {
+	int numa_id;
+};
+
+int npu_disable_clock(struct nvdla_device *ndev)
+{
+	return 0;
+}
+
+int npu_enable_clock(struct nvdla_device *ndev)
+{
+	return 0;
+}
+
+void npu_dma_sid_cfg(void __iomem *npu_subsys_base, u32 sid)
+{
+}
+int npu_init_mbox(struct nvdla_device *ndev)
+{
+	return 0;
+}
+int npu_uninit_mbox(struct nvdla_device *ndev)
+{
+	return 0;
+}
+
+int npu_create_sysfs(struct platform_device *pdev)
+{
+	return 0;
+}
+
+int npu_remove_sysfs(struct platform_device *pdev)
+{
+	return 0;
+}
+int npu_dt_node_resources(struct nvdla_device *ndev)
+{
+	return 0;
+}
+
+void npu_tbu_power(struct device *dev, bool flag)
+{
+}
+
+void npu_hw_init(struct nvdla_device *ndev)
+{
+}
+
+int npu_hardware_reset(struct nvdla_device *ndev)
+{
+	return 0;
+}
+
+int npu_dev_reset(struct nvdla_device *ndev)
+{
+	return 0;
+}
+
+int npu_e31_load_fw(struct platform_device *pdev, void __iomem *e31_mmio_base)
+{
+	return 0;
+}
+
+int npu_init_reset_and_clk(struct nvdla_device *ndev)
+{
+	return 0;
+}
+
+int npu_spram_get(struct nvdla_device *nvdla_dev)
+{
+	struct dla_buffer_object *spram_bobj = NULL;
+	int err = 0;
+
+	//TODO(zhangyizhong): jira 13174: on simulator, SRAM size should be got from DTS.
+	nvdla_dev->spram_size = 4 * 1024 * 1024;
+	dla_info("set spram_size to %u KB for simulation.\n",
+		 nvdla_dev->spram_size / 1024);
+
+	spram_bobj = dla_alloc_dmabuf(nvdla_dev->spram_size, ES_MEM_ALLOC_RSV);
+	if (spram_bobj < 0) {
+		dla_error(
+			"spram_dma_fd dev_mem_alloc failed!,spram_size=0x%x\n",
+			nvdla_dev->spram_size);
+		return -1;
+	}
+
+	err = dla_attach_dmabuf(spram_bobj, &nvdla_dev->pdev->dev);
+	if (err) {
+		dla_error("dla_attach_dmabuf failed!,err=%d\n", err);
+		dla_release_bobj(spram_bobj);
+		return err;
+	}
+
+	nvdla_dev->spram_base_addr = sg_phys(spram_bobj->attach->sgt->sgl);
+	dla_debug("spram phy_addr=0x%llx\n", nvdla_dev->spram_base_addr);
+	dla_debug("nvdla_dev->spram_base_addr=0x%llx\n",
+		  nvdla_dev->spram_base_addr);
+
+	nvdla_dev->spram_bobj = spram_bobj;
+
+	return 0;
+}
+
+int npu_spram_release(struct nvdla_device *nvdla_dev)
+{
+	if (nvdla_dev->spram_bobj) {
+		dla_release_bobj(nvdla_dev->spram_bobj);
+	}
+	return 0;
+}
+
+int npu_cmd_check(struct cma *cma, void *data)
+{
+	struct npu_cma_info *tmp;
+
+	if (data == NULL) {
+		dla_error("data is null.\n");
+		return 0;
+	}
+	tmp = (struct npu_cma_info *)data;
+
+	if (cma != NULL) {
+		if (strcmp(cma_get_name(cma), "reserved") != 0) {
+			return 0;
+		}
+
+		tmp->base = cma_get_base(cma);
+		tmp->size = (uint32_t)cma_get_size(cma);
+		return 1;
+	}
+
+	return 0;
+}
+
+static int npu_get_cma_info(void *arg)
+{
+	struct npu_cma_info info;
+	int ret;
+
+	ret = cma_for_each_area(npu_cmd_check, &info);
+	if (!ret) {
+		dla_error("cannot find cma info.\n");
+		return -ENODEV;
+	}
+
+	if (copy_to_user((void __user *)arg, &info, sizeof(info))) {
+		dla_error("copy to user err.\n");
+		return -EFAULT;
+	}
+	return 0;
+}
+
+void *npu_alloc_dma_addr(struct win_executor *executor, size_t size,
+			 dma_addr_t *dma_handle, int i, gfp_t gfp)
+{
+	struct nvdla_device *nvdla_dev =
+		(struct nvdla_device *)(executor->engine->nvdla_dev);
+	struct device *dev = &nvdla_dev->pdev->dev;
+	void *cpu_addr = NULL;
+	int ret = 0;
+
+	executor->tmp_for_simu[i] = dla_alloc_dmabuf(size, ES_MEM_ALLOC_RSV);
+	if (executor->tmp_for_simu[i] == NULL) {
+		printk("%s,%d, i=%d.\n", __func__, __LINE__, i);
+		return NULL;
+	}
+
+	ret = dla_attach_dmabuf(executor->tmp_for_simu[i], dev);
+	if (ret) {
+		printk("%s,%d, i=%d.\n", __func__, __LINE__, i);
+		goto err;
+	}
+
+	cpu_addr = dla_dmabuf_vmap(executor->tmp_for_simu[i]);
+	if (cpu_addr == NULL) {
+		printk("%s,%d, i=%d.\n", __func__, __LINE__, i);
+		goto err;
+	}
+	*dma_handle = executor->tmp_for_simu[i]->dma_addr;
+
+	return cpu_addr;
+err:
+	return NULL;
+}
+
+void npu_free_dma_addr(struct win_executor *executor, int i)
+{
+	if (executor->tmp_for_simu[i] != NULL) {
+		dla_release_bobj(executor->tmp_for_simu[i]);
+	}
+}
+
+void hetero_send_frame_to_npu(u8 tiktok, struct host_frame_desc *f)
+{
+	struct user_model *model = (struct user_model *)f->model;
+	hetero_ipc_frame_t *frame_desc =
+		(hetero_ipc_frame_t *)&model->e31_frame_info;
+	npu_io_tensor_t *io_tensor = &f->io_tensor;
+
+	if (g_frame_info[tiktok].is_ready) {
+		dla_error("%s, tiktok:%d is ready and not processed\n",
+			  __func__, tiktok);
+		return;
+	}
+
+	g_frame_info[tiktok].tiktok = tiktok;
+	memcpy(&g_frame_info[tiktok].frame, frame_desc,
+	       sizeof(hetero_ipc_frame_t));
+	memcpy(&g_frame_info[tiktok].io_tensor, io_tensor,
+	       sizeof(npu_io_tensor_t));
+	g_frame_info[tiktok].is_ready = true;
+	g_executor[tiktok] = f->executor;
+}
+
+static long npu_ioctl_query_frame_status(void *arg)
+{
+	int idx;
+
+	for (idx = 0; idx < NUM_TIKTOK; idx++) {
+		if (g_frame_info[idx].is_ready) {
+			break;
+		}
+	}
+
+	if (idx == NUM_TIKTOK) {
+		if (copy_to_user((void __user *)arg, &g_frame_info[0],
+				 sizeof(frame_info_t))) {
+			dla_error("copy to user err.\n");
+			return -EFAULT;
+		}
+	} else {
+		if (copy_to_user((void __user *)arg, &g_frame_info[idx],
+				 sizeof(frame_info_t))) {
+			dla_error("copy to user err.\n");
+			return -EFAULT;
+		}
+		dla_debug("send frame to e31:idx:%d\n", idx);
+		g_frame_info[idx].is_ready = false;
+	}
+
+	return 0;
+}
+
+static long npu_ioctl_send_frame_done(void *arg)
+{
+	u32 tiktok;
+	bool stat;
+	host_frame_done_t frame_done;
+	model_stat_t *stat_data;
+
+	if (copy_from_user(&frame_done, arg, sizeof(host_frame_done_t))) {
+		printk("copy from user err.\n");
+		return -EFAULT;
+	}
+	tiktok = frame_done.param & 0x1;
+	stat = frame_done.param >> 1 & 0x1;
+	if (stat) {
+		stat_data = &(g_executor[tiktok]
+				      ->engine->host_node->model_stat[tiktok]);
+		if (copy_from_user(stat_data, (void *)frame_done.stat_addr,
+				   sizeof(model_stat_t))) {
+			printk("copy from user stat info err.\n");
+			return -EFAULT;
+		}
+	}
+
+	mbx_irq_frame_done(g_executor[tiktok]->engine, tiktok, stat);
+
+	return 0;
+}
+
+static long npu_ioctl_send_op_done(void *arg)
+{
+	int i;
+	struct host_frame_desc *f;
+	struct npu_op_done_info *info = NULL;
+	msg_payload_t payload;
+	if (copy_from_user(&payload, (u32 __user *)arg,
+			   sizeof(msg_payload_t))) {
+		dla_error("copy from user err.\n");
+		return -EFAULT;
+	}
+
+	// dump output data
+	f = g_executor[payload.param]->engine->tiktok_frame[payload.param];
+	dla_dump_src_data(g_executor[payload.param], f, payload.lparam);
+	dla_dump_dst_data(g_executor[payload.param], f, payload.lparam);
+
+	// update op_done info list
+	for (i = 0; i < NUM_OP_TYPE; i++) {
+		if (!op_done_info[i].op_resume_flag) {
+			info = &op_done_info[i];
+			break;
+		}
+	}
+
+	if (info != NULL) {
+		info->payload = payload;
+		info->op_resume_flag = true;
+	} else {
+		dla_error("%s(), send op_done failed\n", __func__);
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+static long npu_ioctl_event_sink_done(struct nvdla_device *nvdla_dev, void *arg)
+{
+	// int i;
+	// struct npu_op_done_info *info = NULL;
+	msg_payload_t payload;
+	u16 op_index;
+	u32 tiktok;
+
+	if (copy_from_user(&payload, (u32 __user *)arg,
+			   sizeof(msg_payload_t))) {
+		dla_error("copy from user err.\n");
+		return -EFAULT;
+	}
+#if 0
+	// update op_done info list
+	for (i = 0; i < NUM_OP_TYPE; i++) {
+		if (!op_done_info[i].op_resume_flag) {
+			info = &op_done_info[i];
+			break;
+		}
+	}
+
+	if (info != NULL) {
+		info->payload = payload;
+		info->op_resume_flag = true;
+	} else {
+		dla_error("%s(), send op_done failed\n", __func__);
+		return -EFAULT;
+	}
+#endif
+	op_index = payload.lparam;
+	tiktok = payload.param;
+	dla_detail("get event sink tiktok:%d, op_index:%d\n", tiktok, op_index);
+
+	handle_event_sink_from_e31(npu_get_win_engine(nvdla_dev), tiktok,
+				   op_index);
+
+	return 0;
+}
+
+static long npu_ioctl_query_op_resume(void *arg)
+{
+	int i;
+	struct npu_op_done_info *info = NULL;
+
+	for (i = 0; i < NUM_OP_TYPE; i++) {
+		if (op_done_info[i].op_resume_flag) {
+			info = &op_done_info[i];
+			break;
+		}
+	}
+
+	if (info != NULL) {
+		resume_info_t resume_info;
+		resume_info.op_index = info->payload.lparam;
+		resume_info.tiktok = info->payload.param;
+		resume_info.resume_flag = 1;
+		if (copy_to_user((u32 __user *)arg, &resume_info,
+				 sizeof(msg_payload_t))) {
+			dla_error("%s,%d, copy from user err.\n", __func__,
+				  __LINE__);
+			return -EFAULT;
+		}
+
+		info->op_resume_flag = false;
+	}
+
+	return 0;
+}
+
+void hetero_send_event_source_req(u8 tiktok, u16 op_index)
+{
+	dla_info("%s(%d) tiktok=%d op_index=%u\n", __func__, __LINE__, tiktok,
+		 op_index);
+	event_source_idx[tiktok] = op_index;
+}
+
+static long npu_ioctl_query_event_source(void *arg)
+{
+	event_op_info_t event_info;
+	int i;
+	for (i = 0; i < NUM_TIKTOK; i++) {
+		if (event_source_idx[i] != invalid_op_index) {
+			event_info.tiktok = i;
+			event_info.op_index = event_source_idx[i];
+			event_source_idx[i] = invalid_op_index;
+			if (copy_to_user((u32 __user *)arg, &event_info,
+					 sizeof(msg_payload_t))) {
+				dla_error("%s,%d, copy from user err.\n",
+					  __func__, __LINE__);
+				return -EFAULT;
+			}
+		}
+	}
+
+	return 0;
+}
+
+int npu_hetero_cmd(struct nvdla_device *nvdla_dev, struct win_ioctl_args *args)
+{
+	int ret;
+
+	switch (args->hetero_cmd) {
+	case NPU_HETERO_GET_CMA_INFO:
+		ret = npu_get_cma_info((void *)args->data);
+		break;
+	case NPU_HETERO_QUERY_FRAME_READY:
+		ret = npu_ioctl_query_frame_status((void *)args->data);
+		break;
+	case NPU_HETERO_QUERY_EVENT_SOURCE:
+		ret = npu_ioctl_query_event_source((void *)args->data);
+		break;
+	case NPU_HETERO_SEND_FRAME_DONE:
+		ret = npu_ioctl_send_frame_done((void *)args->data);
+		break;
+	case NPU_HETERO_SEND_OP_DONE:
+		ret = npu_ioctl_send_op_done((void *)args->data);
+		break;
+	case NPU_HETERO_QUERY_OP_RESUME:
+		ret = npu_ioctl_query_op_resume((void *)args->data);
+		break;
+	case NPU_HETERO_SEND_EVENT_SINK_DONE:
+		ret = npu_ioctl_event_sink_done(nvdla_dev, (void *)args->data);
+		break;
+	default:
+		dla_error("error hetero_cmd: 0x%x.\n", args->hetero_cmd);
+		return -EINVAL;
+	}
+	return ret;
+}
+
+static struct resource npu_res[]= {
+	[0] = {
+		.flags = IORESOURCE_MEM,
+		.name = "npu_base",
+		.start = 0x51c00000,
+		.end = 0x51c00000 + 0x400000 - 1,
+	},
+	[1] = {
+		.flags = IORESOURCE_IRQ,
+		.start = 256,
+		.name = "npu_irq",
+	},
+};
+
+static struct platform_device *npu_plat_dev[MAX_NPU_CORE];
+int npu_platform_init(void)
+{
+	int i;
+	int ret;
+	struct npu_hw_info info;
+
+	for (i = 0; i < MAX_NPU_CORE; i++) {
+		npu_plat_dev[i] = platform_device_alloc("eswin_npu", i);
+		if (!npu_plat_dev[i]) {
+			i--;
+			while (i >= 0) {
+				platform_device_put(npu_plat_dev[i--]);
+			}
+			ret = -EIO;
+			goto err_dev_alloc;
+		}
+		npu_plat_dev[i]->dev.coherent_dma_mask = DMA_BIT_MASK(32);
+	}
+
+	for (i = 0; i < MAX_NPU_CORE; i++) {
+		info.numa_id = i;
+		ret = platform_device_add_resources(npu_plat_dev[i], npu_res,
+						    ARRAY_SIZE(npu_res));
+		if (ret) {
+			goto release_pdev;
+		}
+		ret = platform_device_add_data(npu_plat_dev[i], (void *)&info,
+					       sizeof(info));
+		if (ret) {
+			goto err_add_pdata;
+		}
+	}
+
+	for (i = 0; i < MAX_NPU_CORE; i++) {
+		ret = platform_device_add(npu_plat_dev[i]);
+		if (ret < 0) {
+			i--;
+			while (i >= 0) {
+				platform_device_del(npu_plat_dev[i--]);
+			}
+			goto err_add_dev;
+		}
+	}
+
+	dla_debug("%s, plat init done.\n", __func__);
+	return 0;
+err_add_dev:
+err_add_pdata:
+release_pdev:
+	for (i = 0; i < MAX_NPU_CORE; i++) {
+		platform_device_put(npu_plat_dev[i]);
+	}
+err_dev_alloc:
+	return ret;
+}
+
+int npu_platform_uninit(void)
+{
+	int i;
+
+	for (i = 0; i < MAX_NPU_CORE; i++) {
+		if (npu_plat_dev[i]) {
+			platform_device_unregister(npu_plat_dev[i]);
+			npu_plat_dev[i] = NULL;
+		}
+	}
+	dla_debug("%s, ok\n", __func__);
+	return 0;
+}
diff --git a/drivers/soc/eswin/ai_driver/npu/parse_dep.c b/drivers/soc/eswin/ai_driver/npu/parse_dep.c
new file mode 100644
index 000000000000..36b48dd376b0
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/npu/parse_dep.c
@@ -0,0 +1,461 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <dla_interface.h>
+#include <dla_sched.h>
+#include <dla_log.h>
+#include "internal_interface.h"
+#include "dla_buffer.h"
+#include "debug.h"
+
+static int config_sequence_setup(struct win_executor *executor, int op_num,
+				 s16 *cfg_seq[])
+{
+	s16 i, j, pcer, op_type, op_idx;
+	struct dla_task *task = executor->task;
+	struct processors_interface *pcer_interface;
+	int ret, total = 0;
+	int rdma;
+	u16 op_type_pos[NUM_OP_TYPE] = { 0 };
+
+	for (i = IDX_START; i < NUM_OP_TYPE; i++) {
+		executor->head_op_idx[i] = INVALID_OP_IDX;
+	}
+	memset(executor->op_num, 0, sizeof(executor->op_num));
+	/* head_op setup */
+	for (i = 0; i < op_num; i++) {
+		op_type = executor->task->common_desc[i].op_type;
+		op_idx = executor->task->common_desc[i].index;
+		pcer = processor_dla_convert[op_type];
+		executor->op_num[pcer]++;
+		if (executor->head_op_idx[pcer] == INVALID_OP_IDX) {
+			executor->head_op_idx[pcer] = op_idx;
+		}
+	}
+	for (i = IDX_START; i < NUM_OP_TYPE; i++) {
+		total += executor->op_num[i];
+		dla_debug(
+			"%s %d executor->op_num[%d] %d executor->head_op_idx[%d] %d\n",
+			__func__, __LINE__, i, executor->op_num[i], i,
+			executor->head_op_idx[i]);
+	}
+	if (total != op_num) {
+		dla_error("%s %d BUG op sum %d != op_num %d\n", __func__,
+			  __LINE__, total, op_num);
+		return -1;
+	}
+
+	/* cfg_seq pointer offset */
+	cfg_seq[IDX_EDMA] = cfg_seq[IDX_START];
+	cfg_seq[IDX_CONV] = cfg_seq[IDX_EDMA] + executor->op_num[IDX_EDMA];
+	cfg_seq[IDX_SDP] = cfg_seq[IDX_CONV] + executor->op_num[IDX_CONV];
+	cfg_seq[IDX_PDP] = cfg_seq[IDX_SDP] + executor->op_num[IDX_SDP];
+	cfg_seq[IDX_RUBIK] = cfg_seq[IDX_PDP] + executor->op_num[IDX_PDP];
+	cfg_seq[IDX_KMD_DSP0] =
+		cfg_seq[IDX_RUBIK] + executor->op_num[IDX_RUBIK];
+	cfg_seq[IDX_KMD_DSP1] =
+		cfg_seq[IDX_KMD_DSP0] + executor->op_num[IDX_KMD_DSP0];
+	cfg_seq[IDX_KMD_DSP2] =
+		cfg_seq[IDX_KMD_DSP1] + executor->op_num[IDX_KMD_DSP1];
+	cfg_seq[IDX_KMD_DSP3] =
+		cfg_seq[IDX_KMD_DSP2] + executor->op_num[IDX_KMD_DSP2];
+	cfg_seq[IDX_EVENT_SINK] =
+		cfg_seq[IDX_KMD_DSP3] + executor->op_num[IDX_KMD_DSP3];
+	cfg_seq[IDX_EVENT_SOURCE] =
+		cfg_seq[IDX_EVENT_SINK] + executor->op_num[IDX_EVENT_SINK];
+
+	for (i = 0; i < op_num; i++) {
+		op_type = executor->task->common_desc[i].op_type;
+		op_idx = executor->task->common_desc[i].index;
+		ASSERT(op_idx != INVALID_OP_IDX && op_type < HW_OP_NUM);
+		pcer = processor_dla_convert[op_type];
+		j = op_type_pos[pcer];
+		cfg_seq[pcer][j] = op_idx;
+		pcer_interface = executor->engine->processors[pcer];
+		ret = pcer_interface->tensor_unfold(executor, op_idx,
+						    &task->op_desc[op_idx],
+						    &task->surface_desc[op_idx],
+						    executor->tensor_set[pcer],
+						    j);
+		if (pcer_interface->rdma_check != NULL) {
+			rdma = pcer_interface->rdma_check(
+				NULL, &task->op_desc[op_idx],
+				&task->surface_desc[op_idx]);
+		}
+
+		ret = pcer_interface->prepare_prog_data(
+			executor, rdma, j, op_idx, &task->op_desc[op_idx],
+			&task->surface_desc[op_idx]);
+		op_type_pos[pcer]++;
+	}
+
+	dla_debug("%s, %d, done.\n", __func__, __LINE__);
+	return 0;
+}
+
+static void npu_set_enable_consumer(npu_dep_info_t *npu_info, u16 cons)
+{
+	npu_info->enable_op_idx = cons;
+}
+
+static void npu_set_completion_consumer(npu_dep_info_t *npu_info, u32 type,
+					u16 consumer_idx, u16 pos)
+{
+	npu_info->completion_event_bitmap |= 1U << type;
+	npu_info->completion_op_idx[pos] = consumer_idx;
+}
+
+#define get_npu_info(pcer_t, PCER_T, k)                                   \
+	({                                                                \
+		pcer_t##_dev_t *tmp;                                      \
+		tmp = (pcer_t##_dev_t *)                                  \
+			      executor->prog_data_buf_bobj[IDX_##PCER_T]; \
+		npu_info = (npu_dep_info_t *)&tmp[k];                     \
+	})
+
+static npu_dep_info_t *npu_get_dep_info(struct win_executor *executor, u8 pcer,
+					int k)
+{
+	npu_dep_info_t *npu_info;
+	switch (pcer) {
+	case IDX_EDMA:
+		get_npu_info(edma, EDMA, k);
+		break;
+	case IDX_CONV:
+		npu_info = (npu_dep_info_t
+				    *)((char *)executor
+					       ->prog_data_buf_bobj[IDX_CONV] +
+				       MAX_CONV_PROG_DATA_SIZE * k +
+				       sizeof(rdma_dev_com_inf_t));
+		break;
+	case IDX_SDP:
+		get_npu_info(sdp, SDP, k);
+		break;
+	case IDX_PDP:
+		get_npu_info(pdp, PDP, k);
+		break;
+	case IDX_RUBIK:
+		get_npu_info(rubik, RUBIK, k);
+		break;
+	case IDX_EVENT_SINK:
+		get_npu_info(event_sink, EVENT_SINK, k);
+		break;
+	case IDX_EVENT_SOURCE:
+		get_npu_info(event_source, EVENT_SOURCE, k);
+		break;
+	case IDX_KMD_DSP0:
+		get_npu_info(dsp, KMD_DSP0, k);
+		break;
+	case IDX_KMD_DSP1:
+		get_npu_info(dsp, KMD_DSP1, k);
+		break;
+	case IDX_KMD_DSP2:
+		get_npu_info(dsp, KMD_DSP2, k);
+		break;
+	case IDX_KMD_DSP3:
+		get_npu_info(dsp, KMD_DSP3, k);
+		break;
+	default:
+		dla_error("get npu info err, pcer = %d, k = %d.\n", pcer, k);
+		return NULL;
+	}
+	return npu_info;
+}
+
+static inline void init_npu_info(npu_dep_info_t *npu_info)
+{
+	int i;
+
+	npu_info->enable_op_idx = invalid_op_index;
+	for (i = 0; i < MAX_KMD_DEPCNT; i++) {
+		npu_info->completion_op_idx[i] = invalid_op_index;
+	}
+}
+
+static void dependency_consumer2producer(struct win_executor *executor,
+					 struct dla_task *task, int op_num)
+{
+	u16 pcer_cnt[NUM_OP_TYPE];
+	u8 pcer, op_type, event;
+	u16 i, j, consumer;
+	int k = 0;
+	u16 pos = 0;
+	u16 event_cnt[NUM_OP_TYPE];
+	u8 *dependency_count = executor->dependency_count;
+	npu_dep_info_t *npu_info;
+
+	memset(pcer_cnt, 0, sizeof(pcer_cnt));
+	memset(event_cnt, 0, sizeof(event_cnt));
+
+	for (i = 0; i < op_num; i++) {
+		pcer = processor_dla_convert[task->common_desc[i].op_type];
+		dla_detail("i:%d op_type:%d\n", i,
+			   task->common_desc[i].op_type);
+		k = pcer_cnt[pcer];
+		npu_info = npu_get_dep_info(executor, pcer, k);
+		if (npu_info == NULL) {
+			dla_error(
+				"get processor %d, op_idx=%d, npu_info is null.\n",
+				pcer, k);
+			continue;
+		}
+		if (pcer != IDX_CONV)
+			init_npu_info(npu_info);
+
+		if (pcer == IDX_EVENT_SOURCE)
+			dependency_count[i]++;
+
+		for (j = IDX_SDP; j <= IDX_PDP; j++) {
+			consumer = task->common_desc[i].fused_parent.index;
+			event = task->common_desc[i].fused_parent.event;
+			if (consumer != invalid_op_index &&
+			    event == DLA_EVENT_OP_ENABLED) {
+				npu_set_enable_consumer(npu_info, consumer);
+			}
+		}
+		pos = 0;
+		for (j = IDX_START; j < NUM_OP_TYPE; j++) {
+			op_type = processor_idx_convert[j];
+			consumer =
+				task->common_desc[i].consumers[op_type].index;
+			event = task->common_desc[i].consumers[op_type].event;
+			if (consumer == 0xffff) {
+				continue;
+			}
+
+			if (event == DLA_EVENT_OP_PROGRAMMED) {
+				dla_detail(
+					"i:%d j:%d consumer:%d dependency_count:%d\n",
+					i, j, consumer,
+					dependency_count[consumer]);
+				dependency_count[consumer]--;
+			}
+			if (pcer == IDX_CONV) {
+				continue;
+			}
+
+			if (event == DLA_EVENT_OP_COMPLETED) {
+				if (unlikely(pos >= MAX_KMD_DEPCNT)) {
+					dla_error(
+						"op index:%d dependency cnt over max\n",
+						i);
+					BUG_ON(false);
+					return;
+				}
+				npu_set_completion_consumer(npu_info, op_type,
+							    consumer, pos);
+				pos++;
+			}
+
+			/* Notice: fused_parent not cause dep bit
+			 * sequence of op in op_list will ensure fly op likes
+			 * sdp-conv trigger sequence.
+			 */
+		}
+		dependency_count[i]++;
+		dla_detail("i:%d dependency_count:%d\n", i,
+			   dependency_count[i]);
+		npu_info->depcnt = dependency_count[i];
+		pcer_cnt[pcer]++;
+	}
+	return;
+}
+
+int generate_small_program(struct win_executor *executor)
+{
+	int ret = 0, op_num;
+
+	op_num = executor->network->num_operations;
+	executor->total_op_num = op_num;
+
+	executor->cfg_seq[IDX_START] =
+		kzalloc(op_num * sizeof(u16), GFP_KERNEL);
+	if (executor->cfg_seq[IDX_START] == NULL) {
+		ret = -ENOMEM;
+		return ret;
+	}
+	dla_debug("%s, %d, op_num=%d.\n", __func__, __LINE__, op_num);
+	ret = config_sequence_setup(executor, op_num, executor->cfg_seq);
+	if (ret < 0) {
+		dla_error("%s %d config_sequence_setup fail\n", __func__,
+			  __LINE__);
+		goto err_free1;
+	}
+	dependency_consumer2producer(executor, executor->task, op_num);
+
+	return 0;
+err_free1:
+	memset(executor->cfg_seq[IDX_START], -1, op_num * sizeof(u16));
+	kfree(executor->cfg_seq[IDX_START]);
+	executor->cfg_seq[IDX_START] = NULL;
+	return ret;
+}
+
+int generate_event_map(struct win_executor *executor)
+{
+	s16 i, op_type, op_idx;
+	int op_num, event_idx;
+	int ret;
+
+	op_num = executor->network->num_operations;
+
+	executor->total_event_sink_num = 0;
+	executor->total_event_source_num = 0;
+
+	for (i = 0; i < op_num; i++) {
+		op_type = executor->task->common_desc[i].op_type;
+
+		switch (op_type) {
+		case IDX_EVENT_SINK:
+			executor->total_event_sink_num++;
+			break;
+		case IDX_EVENT_SOURCE:
+			executor->total_event_source_num++;
+			break;
+		default:
+			continue;
+		}
+	}
+	dla_detail("total_event_sink_num:%d total_event_source_num:%d\n",
+		   executor->total_event_sink_num,
+		   executor->total_event_source_num);
+	executor->event_sink_map = kzalloc(
+		executor->total_event_sink_num * sizeof(s16), GFP_KERNEL);
+	executor->event_source_map = kzalloc(
+		executor->total_event_source_num * sizeof(s16), GFP_KERNEL);
+
+	if (executor->event_sink_map == NULL ||
+	    executor->event_source_map == NULL) {
+		ret = -ENOMEM;
+		return ret;
+	}
+
+	for (i = 0; i < op_num; i++) {
+		op_type = executor->task->common_desc[i].op_type;
+		op_idx = executor->task->common_desc[i].index;
+
+		switch (op_type) {
+		case IDX_EVENT_SINK:
+			event_idx = executor->task->op_desc[i].event_op.index;
+			if (event_idx >= executor->total_event_sink_num) {
+				dla_error(
+					"Event Sink, event_idx(%d) is wrong in model.\n",
+					event_idx);
+				ret = -EINVAL;
+				goto err_free;
+			}
+			executor->event_sink_map[event_idx] = op_idx;
+			break;
+		case IDX_EVENT_SOURCE:
+			event_idx = executor->task->op_desc[i].event_op.index;
+			if (event_idx >= executor->total_event_source_num) {
+				dla_error(
+					"Event Source, event_idx(%d) is wrong in model.\n",
+					event_idx);
+				ret = -EINVAL;
+				goto err_free;
+			}
+			executor->event_source_map[event_idx] = op_idx;
+			break;
+		default:
+			continue;
+		}
+	}
+
+	return 0;
+err_free:
+	kfree(executor->event_sink_map);
+	kfree(executor->event_source_map);
+	executor->event_sink_map = NULL;
+	executor->event_source_map = NULL;
+
+	return ret;
+}
+
+int set_pause_op_done(struct win_executor *executor, kmd_dump_info_t *dump_info)
+{
+	int ret = 0, op_num;
+	u16 pcer_cnt[NUM_OP_TYPE];
+	u8 pcer;
+	u16 op_index, i, j;
+	int k = 0;
+	npu_dep_info_t *npu_info;
+	struct dla_task *task = executor->task;
+
+	op_num = executor->network->num_operations;
+
+	memset(pcer_cnt, 0, sizeof(pcer_cnt));
+	for (i = 0; i < op_num; i++) {
+		pcer = processor_dla_convert[task->common_desc[i].op_type];
+		k = pcer_cnt[pcer];
+		npu_info = npu_get_dep_info(executor, pcer, k);
+		if (npu_info == NULL) {
+			dla_error(
+				"get processor %d, op_idx=%d, npu_info is null.\n",
+				pcer, k);
+			continue;
+		}
+
+		npu_info->notify_op_done = 0;
+		npu_info->pause_op_done = 0;
+
+		for (j = 0; j < dump_info->list_size; j++) {
+			op_index = dump_info->op_idx_list[j];
+			if (op_index > op_num) {
+				continue;
+			}
+
+			if (op_index == task->common_desc[i].index) {
+				npu_info->notify_op_done = 1;
+				npu_info->pause_op_done = 1;
+				dla_debug("%s, %d, dump op_index:%d\n",
+					  __func__, __LINE__, op_index);
+				break;
+			}
+		}
+
+		pcer_cnt[pcer]++;
+	}
+	dla_debug("%s, %d, ret=%d.\n\n", __func__, __LINE__, ret);
+
+	return ret;
+}
+
+int reset_pause_op_done(struct win_executor *executor)
+{
+	int ret = 0, op_num;
+	u16 pcer_cnt[NUM_OP_TYPE];
+	u8 pcer;
+	u16 i;
+	int k = 0;
+	npu_dep_info_t *npu_info;
+	struct dla_task *task = executor->task;
+
+	op_num = executor->network->num_operations;
+
+	memset(pcer_cnt, 0, sizeof(pcer_cnt));
+	for (i = 0; i < op_num; i++) {
+		pcer = processor_dla_convert[task->common_desc[i].op_type];
+		k = pcer_cnt[pcer];
+		npu_info = npu_get_dep_info(executor, pcer, k);
+		if (npu_info == NULL) {
+			dla_error(
+				"get processor %d, op_idx=%d, npu_info is null.\n",
+				pcer, k);
+			continue;
+		}
+
+		npu_info->notify_op_done = 0;
+		npu_info->pause_op_done = 0;
+
+		pcer_cnt[pcer]++;
+	}
+
+	return ret;
+}
diff --git a/drivers/soc/eswin/ai_driver/npu/pdp.c b/drivers/soc/eswin/ai_driver/npu/pdp.c
new file mode 100644
index 000000000000..e32a4dfb27ee
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/npu/pdp.c
@@ -0,0 +1,583 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#include <linux/slab.h>
+#include <opendla.h>
+#include <dla_err.h>
+#include <dla_interface.h>
+#include "common.h"
+#include "dla_engine_internal.h"
+#include "dla_log.h"
+#include "post_drp.h"
+#include "dla_driver.h"
+#include "internal_interface.h"
+#include "dla_buffer.h"
+
+#define MAX_SPLIT_NUM 64
+#ifndef ARRAY_SIZE
+#define ARRAY_SIZE(a) (sizeof(a) / sizeof((a[0])))
+#endif
+
+static const uint8_t map_ram[] = {
+	FIELD_ENUM(PDP_RDMA_D_SRC_RAM_CFG_0, SRC_RAM_TYPE, MC),
+	FIELD_ENUM(PDP_RDMA_D_SRC_RAM_CFG_0, SRC_RAM_TYPE, CV),
+};
+
+static const uint8_t map_pool[] = {
+	FIELD_ENUM(PDP_D_OPERATION_MODE_CFG_0, POOLING_METHOD,
+		   POOLING_METHOD_AVERAGE),
+	FIELD_ENUM(PDP_D_OPERATION_MODE_CFG_0, POOLING_METHOD,
+		   POOLING_METHOD_MAX),
+	FIELD_ENUM(PDP_D_OPERATION_MODE_CFG_0, POOLING_METHOD,
+		   POOLING_METHOD_MIN),
+};
+
+static const uint8_t map_precision[] = {
+	FIELD_ENUM(PDP_D_DATA_FORMAT_0, INPUT_DATA, INT8),
+	FIELD_ENUM(PDP_D_DATA_FORMAT_0, INPUT_DATA, INT16),
+	FIELD_ENUM(PDP_D_DATA_FORMAT_0, INPUT_DATA, FP16),
+};
+
+static const uint8_t map_pool_kernel[] = {
+	FIELD_ENUM(PDP_D_POOLING_KERNEL_CFG_0, KERNEL_WIDTH, KERNEL_WIDTH_1),
+	FIELD_ENUM(PDP_D_POOLING_KERNEL_CFG_0, KERNEL_WIDTH, KERNEL_WIDTH_2),
+	FIELD_ENUM(PDP_D_POOLING_KERNEL_CFG_0, KERNEL_WIDTH, KERNEL_WIDTH_3),
+	FIELD_ENUM(PDP_D_POOLING_KERNEL_CFG_0, KERNEL_WIDTH, KERNEL_WIDTH_4),
+	FIELD_ENUM(PDP_D_POOLING_KERNEL_CFG_0, KERNEL_WIDTH, KERNEL_WIDTH_5),
+	FIELD_ENUM(PDP_D_POOLING_KERNEL_CFG_0, KERNEL_WIDTH, KERNEL_WIDTH_6),
+	FIELD_ENUM(PDP_D_POOLING_KERNEL_CFG_0, KERNEL_WIDTH, KERNEL_WIDTH_7),
+	FIELD_ENUM(PDP_D_POOLING_KERNEL_CFG_0, KERNEL_WIDTH, KERNEL_WIDTH_8),
+};
+
+/* The reciprocal of kernel width: 1/1, 1/2, 1/3, ... */
+static const uint32_t recip_kernel_size[2][8] = {
+	/*
+	 * INT8/16
+	 * 1      1/2     1/3     1/4     1/5     1/6     1/7     1/8
+	 */
+	{ 0x10000, 0x8000, 0x5555, 0x4000, 0x3333, 0x2aaa, 0x2492, 0x2000 },
+	{ 0x7c00, 0x7800, 0x7555, 0x7400, 0x7266, 0x7155, 0x7092, 0x7000 },
+};
+
+static uint32_t get_fly_mode(uint8_t type)
+{
+	uint32_t val;
+
+	val = type == DLA_MEM_HW ? FIELD_ENUM(PDP_D_OPERATION_MODE_CFG_0,
+					      FLYING_MODE, ON_FLYING) :
+				   FIELD_ENUM(PDP_D_OPERATION_MODE_CFG_0,
+					      FLYING_MODE, OFF_FLYING);
+
+	return val;
+}
+
+int dla_pdp_rdma_check(struct dla_processor_group *group,
+		       union dla_operation_container *op,
+		       union dla_surface_container *surface)
+{
+	struct dla_pdp_surface_desc *pdp_surface;
+	int ret;
+
+	if (group) {
+		pdp_surface = &group->surface_desc->pdp_surface;
+		group->is_rdma_needed = 0;
+	} else {
+		pdp_surface = &surface->pdp_surface;
+	}
+
+	ret = pdp_surface->src_data.type != DLA_MEM_HW;
+	if (group) {
+		group->is_rdma_needed = ret;
+	}
+	return ret;
+}
+static int validate_strides(uint8_t stride_x, uint8_t stride_y)
+{
+	int32_t ret = 0;
+
+	if (stride_x < 1 || stride_y < 1 || stride_x > 8 || stride_y > 8) {
+		dla_error("Invalid Stride (x[%d], y[%d])\n", stride_x,
+			  stride_y);
+		ret = ERR(INVALID_INPUT);
+	}
+
+	return ret;
+}
+
+static int vaildate_pdp_configs(struct dla_pdp_op_desc *pdp_op,
+				struct dla_pdp_surface_desc *pdp_surface)
+{
+	int32_t ret = 0;
+
+	if (pdp_surface->dst_data.type == DLA_MEM_HW) {
+		dla_error(
+			"Destination buffer for PDP has to be either MC or CV");
+		ret = ERR(INVALID_INPUT);
+		goto exit;
+	}
+
+	ret = validate_data_cube(&pdp_surface->src_data, &pdp_surface->dst_data,
+				 DLA_MEM_HW);
+	if (ret)
+		goto exit;
+
+	ret = validate_precision(pdp_op->precision, ARRAY_SIZE(map_precision));
+	if (ret)
+		goto exit;
+
+	ret = validate_strides(pdp_op->stride_x, pdp_op->stride_y);
+	if (ret)
+		goto exit;
+
+	if (pdp_op->split_num > MAX_SPLIT_NUM) {
+		dla_error("Invalid split_num: %u\n", pdp_op->split_num);
+		ret = ERR(INVALID_INPUT);
+		goto exit;
+	}
+
+	if (pdp_op->pool_mode >= ARRAY_SIZE(map_pool)) {
+		dla_error("Invalid pool_mode: %u\n", pdp_op->pool_mode);
+		ret = ERR(INVALID_INPUT);
+		goto exit;
+	}
+
+	if (!(pdp_op->pool_height <= 8 && pdp_op->pool_width <= 8)) {
+		dla_error(
+			"pdp param check error: pool_height <= 8 && pool_width <= 8\n");
+		ret = ERR(INVALID_INPUT);
+		goto exit;
+	}
+
+	if (!(pdp_op->stride_y <= 16 && pdp_op->stride_x <= 16)) {
+		dla_error(
+			"pdp param check error: stride_y <= 16 && stride_x <= 16\n");
+		ret = ERR(INVALID_INPUT);
+		goto exit;
+	}
+
+	if (!(pdp_surface->dst_data.height > 0 &&
+	      pdp_surface->dst_data.width > 0)) {
+		dla_error(
+			"pdp param check error: dst_data.height > 0 && dst_data.width > 0\n");
+		ret = ERR(INVALID_INPUT);
+		goto exit;
+	}
+
+	if (!(pdp_surface->dst_data.height <= 8192 &&
+	      pdp_surface->dst_data.width <= 8192)) {
+		dla_error(
+			"pdp param check error: dst_data.height <= 8192 && dst_data.width <= 8192\n");
+		ret = ERR(INVALID_INPUT);
+		goto exit;
+	}
+
+exit:
+	return ret;
+}
+
+int pdp_tensor_unfold(struct win_executor *executor, int op_idx,
+		      union dla_operation_container *operation_desc,
+		      union dla_surface_container *surface_desc, void *tensor,
+		      int idx)
+{
+	struct dla_pdp_surface_desc *pdp_surface = &surface_desc->pdp_surface;
+	pdp_tensor_t *pdp_tensor = (pdp_tensor_t *)tensor;
+	int ret;
+	pdp_dev_t *pdp =
+		(pdp_dev_t *)executor->prog_data_buf_bobj[IDX_PDP];
+	pdp_dev_t *pdp_data = (pdp_dev_t *)&pdp[idx];
+
+	pdp_data->npu_info.current_op_idx = op_idx;
+	ret = read_input_address(executor, &pdp_surface->dst_data,
+				 &pdp_tensor[idx].output_address,
+				 &pdp_tensor[idx].output_is_io_tensor);
+	if (ret) {
+		dla_error("pdp read output address error\n");
+		return -1;
+	}
+
+	if (pdp_surface->src_data.type == DLA_MEM_HW) {
+		return 0;
+	}
+	ret = read_input_address(executor, &pdp_surface->src_data,
+				 &pdp_tensor[idx].input_address,
+				 &pdp_tensor[idx].input_is_io_tensor);
+	if (ret) {
+		dla_error("pdp read input address error\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+static void pdp_post_drp_set_dst_addr(pdp_program_t *data, u64 addr)
+{
+	data->pdp_drp_reg[R_PDP_POST_BASE_ADDR_H] =
+		(u32)(addr >> NUM_BIT_IN_DWORD);
+	data->pdp_drp_reg[R_PDP_POST_BASE_ADDR_L] = (u32)addr;
+	npu_set_u64_bit(R_PDP_POST_BASE_ADDR_H, &data->u84_drp_bitmap);
+	npu_set_u64_bit(R_PDP_POST_BASE_ADDR_L, &data->u84_drp_bitmap);
+}
+
+static void pdp_post_drp_handle(pdp_program_t *data,
+				struct post_drp_op_desc *desc)
+{
+	data->pdp_drp_reg[R_PDP_DRP_G_STRIDE_SRAM] = desc->g_stride_lsram - 1;
+	npu_set_u64_bit(R_PDP_DRP_G_STRIDE_SRAM, &data->u84_drp_bitmap);
+
+	data->pdp_drp_reg[R_PDP_DRP_N_STRIDE_SRAM] = desc->n_stride_lsram - 1;
+	data->pdp_drp_reg[R_PDP_DRP_H_STRIDE_SRAM] = desc->h_stride - 1;
+	data->pdp_drp_reg[R_PDP_DRP_C_STRIDE_SRAM] = desc->c_stride - 1;
+	data->pdp_drp_reg[R_PDP_DRP_W_EXT_STRIDE] = desc->w_stride - 1;
+	data->pdp_drp_reg[R_PDP_DRP_LAYER_PARA_L] = (desc->n - 1) << 16 |
+						    (desc->e - 1);
+	data->pdp_drp_reg[R_PDP_DRP_LAYER_PARA_H] = (desc->m - 1) << 16 |
+						    (desc->f - 1);
+	data->pdp_drp_reg[R_PDP_DRP_OMAP_PARA_L] = desc->c0 - 1;
+	data->pdp_drp_reg[R_PDP_DRP_CTRL] = (desc->surface_double << 1) |
+					    desc->type_16;
+	data->pdp_drp_reg[R_PDP_DRP_SPLIT] = desc->split_num - 1;
+
+	data->pdp_drp_reg[R_PDP_DRP_PARTIAL_WIDTH] = ((desc->f_lst - 1) << 20) |
+						     ((desc->f_mid - 1) << 10) |
+						     (desc->f_fst - 1);
+	data->pdp_drp_reg[R_PDP_DRP_SRAM_LOOP_PARA_H] =
+		((desc->e4_all - 1) << 16) | (desc->m3_all - 1);
+	data->pdp_drp_reg[R_PDP_DRP_SRAM_LOOP_PARA_L] =
+		((desc->n3_all - 1) << 16) | (desc->g3_all - 1);
+	npu_set_u64_bit(R_PDP_DRP_N_STRIDE_SRAM, &data->u84_drp_bitmap);
+	npu_set_u64_bit(R_PDP_DRP_H_STRIDE_SRAM, &data->u84_drp_bitmap);
+	npu_set_u64_bit(R_PDP_DRP_C_STRIDE_SRAM, &data->u84_drp_bitmap);
+	npu_set_u64_bit(R_PDP_DRP_W_EXT_STRIDE, &data->u84_drp_bitmap);
+	npu_set_u64_bit(R_PDP_DRP_LAYER_PARA_L, &data->u84_drp_bitmap);
+	npu_set_u64_bit(R_PDP_DRP_LAYER_PARA_H, &data->u84_drp_bitmap);
+	npu_set_u64_bit(R_PDP_DRP_OMAP_PARA_L, &data->u84_drp_bitmap);
+	npu_set_u64_bit(R_PDP_DRP_CTRL, &data->u84_drp_bitmap);
+	npu_set_u64_bit(R_PDP_DRP_SPLIT, &data->u84_drp_bitmap);
+	npu_set_u64_bit(R_PDP_DRP_PARTIAL_WIDTH, &data->u84_drp_bitmap);
+	npu_set_u64_bit(R_PDP_DRP_SRAM_LOOP_PARA_H, &data->u84_drp_bitmap);
+	npu_set_u64_bit(R_PDP_DRP_SRAM_LOOP_PARA_L, &data->u84_drp_bitmap);
+}
+
+static int processor_pdp_program(struct win_executor *executor, int rdma,
+				 int tensor_idx,
+				 union dla_operation_container *operation_desc,
+				 union dla_surface_container *surface_desc)
+{
+	int32_t ret = 0;
+	uint32_t reg, high, low;
+	uint64_t input_address = 0;
+	uint64_t output_address = 0;
+	struct dla_pdp_op_desc *pdp_op;
+	struct dla_pdp_surface_desc *pdp_surface;
+	pdp_tensor_t *tensor = NULL;
+	pdp_tensor_t *pdp_tensor = NULL;
+	pdp_program_t *data = NULL;
+	pdp_dev_t *pdp =
+		(pdp_dev_t *)executor->prog_data_buf_bobj[IDX_PDP];
+	pdp_dev_t *pdp_data = (pdp_dev_t *)&pdp[tensor_idx];
+
+	tensor = (pdp_tensor_t *)executor->tensor_set[IDX_PDP];
+	pdp_tensor = &tensor[tensor_idx];
+
+	data = &pdp_data->prog_data;
+	pdp_data->prog_data.input_tensor_idx = invalid_tensor_idx;
+	pdp_data->prog_data.output_tensor_idx = invalid_tensor_idx;
+
+	pdp_op = &operation_desc->pdp_op;
+	pdp_surface = &surface_desc->pdp_surface;
+
+	if (pdp_surface->src_data.type != DLA_MEM_HW) {
+		if (pdp_tensor->input_is_io_tensor == invalid_tensor_idx) {
+			if (unlikely(pdp_tensor->input_address == -1ull)) {
+				dla_error("pdp read input address error\n");
+				goto exit;
+			} else {
+				input_address = pdp_tensor->input_address;
+			}
+		} else {
+			input_address = pdp_surface->src_data.offset;
+			pdp_data->prog_data.input_tensor_idx =
+				pdp_tensor->input_is_io_tensor;
+		}
+	}
+
+	ret = vaildate_pdp_configs(pdp_op, pdp_surface);
+	data->is_rdma = (pdp_surface->src_data.type != DLA_MEM_HW);
+
+	if (ret) {
+		dla_error("pdp params check error\n");
+		goto exit;
+	}
+
+	pdp_post_drp_handle(data, &pdp_op->post_drp_op);
+
+	if (pdp_tensor->output_is_io_tensor == invalid_tensor_idx) {
+		if (pdp_surface->dst_data.address != -1) {
+			if (unlikely(pdp_tensor->output_address == -1ull)) {
+				dla_error("pdp output_address error\n");
+				goto exit;
+			} else {
+				output_address = pdp_tensor->output_address;
+			}
+		}
+	} else {
+		output_address = pdp_surface->dst_data.offset;
+		pdp_data->prog_data.output_tensor_idx =
+			pdp_tensor->output_is_io_tensor;
+	}
+
+	pdp_post_drp_set_dst_addr(data, output_address);
+
+	if (pdp_surface->src_data.type != DLA_MEM_HW) {
+		data->pdp_rdma_reg[R_DATA_CUBE_IN_WIDTH] =
+			pdp_surface->src_data.width - 1;
+		data->pdp_rdma_reg[R_DATA_CUBE_IN_HEIGHT] =
+			pdp_surface->src_data.height - 1;
+		data->pdp_rdma_reg[R_DATA_CUBE_IN_CHANNEL] =
+			pdp_surface->src_data.channel - 1;
+		npu_set_u64_bit(R_DATA_CUBE_IN_WIDTH, &data->u84_rdma_bitmap);
+		npu_set_u64_bit(R_DATA_CUBE_IN_HEIGHT, &data->u84_rdma_bitmap);
+		npu_set_u64_bit(R_DATA_CUBE_IN_CHANNEL, &data->u84_rdma_bitmap);
+
+		high = HIGH32BITS(input_address);
+		low = LOW32BITS(input_address);
+		data->pdp_rdma_reg[R_SRC_BASE_ADDR_HIGH] = high;
+		data->pdp_rdma_reg[R_SRC_BASE_ADDR_LOW] = low;
+		npu_set_u64_bit(R_SRC_BASE_ADDR_HIGH, &data->u84_rdma_bitmap);
+		npu_set_u64_bit(R_SRC_BASE_ADDR_LOW, &data->u84_rdma_bitmap);
+
+		data->pdp_rdma_reg[R_SRC_LINE_STRIDE] =
+			pdp_surface->src_data.line_stride;
+		data->pdp_rdma_reg[R_SRC_SURFACE_STRIDE] =
+			pdp_surface->src_data.surf_stride;
+		npu_set_u64_bit(R_SRC_LINE_STRIDE, &data->u84_rdma_bitmap);
+		npu_set_u64_bit(R_SRC_SURFACE_STRIDE, &data->u84_rdma_bitmap);
+
+		reg = (map_precision[pdp_op->precision]
+		       << SHIFT(PDP_RDMA_D_DATA_FORMAT_0, INPUT_DATA));
+		data->pdp_rdma_reg[R_DATA_FORMAT] = reg;
+		npu_set_u64_bit(R_DATA_FORMAT, &data->u84_rdma_bitmap);
+
+		reg = map_ram[pdp_surface->src_data.type]
+		      << SHIFT(PDP_RDMA_D_SRC_RAM_CFG_0, SRC_RAM_TYPE);
+		data->pdp_rdma_reg[R_SRC_RAM_CFG] = reg;
+		npu_set_u64_bit(R_SRC_RAM_CFG, &data->u84_rdma_bitmap);
+
+		reg = ((pdp_op->split_num - 1)
+		       << SHIFT(PDP_RDMA_D_OPERATION_MODE_CFG_0, SPLIT_NUM));
+		data->pdp_rdma_reg[R_OPERATION_MODE_CFG] = reg;
+		npu_set_u64_bit(R_OPERATION_MODE_CFG, &data->u84_rdma_bitmap);
+
+		reg = (map_pool_kernel[pdp_op->pool_width - 1] << SHIFT(
+			       PDP_RDMA_D_POOLING_KERNEL_CFG_0, KERNEL_WIDTH)) |
+		      ((pdp_op->stride_x - 1)
+		       << SHIFT(PDP_RDMA_D_POOLING_KERNEL_CFG_0,
+				KERNEL_STRIDE_WIDTH));
+		data->pdp_rdma_reg[R_POOLING_KERNEL_CFG] = reg;
+		npu_set_u64_bit(R_POOLING_KERNEL_CFG, &data->u84_rdma_bitmap);
+
+		reg = (pdp_op->pad_left
+		       << SHIFT(PDP_RDMA_D_POOLING_PADDING_CFG_0, PAD_WIDTH));
+		data->pdp_rdma_reg[R_POOLING_PADDING_CFG] = reg;
+		npu_set_u64_bit(R_POOLING_PADDING_CFG, &data->u84_rdma_bitmap);
+		reg = ((pdp_op->partial_in_width_first == 0 ?
+				0 :
+				pdp_op->partial_in_width_first - 1)
+		       << SHIFT(PDP_RDMA_D_PARTIAL_WIDTH_IN_0,
+				PARTIAL_WIDTH_IN_FIRST)) |
+		      ((pdp_op->partial_in_width_mid == 0 ?
+				0 :
+				pdp_op->partial_in_width_mid - 1)
+		       << SHIFT(PDP_RDMA_D_PARTIAL_WIDTH_IN_0,
+				PARTIAL_WIDTH_IN_MID)) |
+		      ((pdp_op->partial_in_width_last == 0 ?
+				0 :
+				pdp_op->partial_in_width_last - 1)
+		       << SHIFT(PDP_RDMA_D_PARTIAL_WIDTH_IN_0,
+				PARTIAL_WIDTH_IN_LAST));
+		data->pdp_rdma_reg[R_PARTIAL_WIDTH_IN] = reg;
+		npu_set_u64_bit(R_PARTIAL_WIDTH_IN, &data->u84_rdma_bitmap);
+
+	} else {
+		if (pdp_op->split_num != 1) {
+			dla_error("pdp split num invalid, %d\n",
+				  pdp_op->split_num);
+			ret = ERR(INVALID_INPUT);
+			goto exit;
+		}
+	}
+
+	reg = ((pdp_surface->src_data.width - 1)
+	       << SHIFT(PDP_D_DATA_CUBE_IN_WIDTH_0, CUBE_IN_WIDTH));
+	data->reg[D_DATA_CUBE_IN_WIDTH] = reg;
+	npu_set_u64_bit(D_DATA_CUBE_IN_WIDTH, &data->u84_bitmap);
+
+	reg = ((pdp_surface->src_data.height - 1)
+	       << SHIFT(PDP_D_DATA_CUBE_IN_HEIGHT_0, CUBE_IN_HEIGHT));
+	data->reg[D_DATA_CUBE_IN_HEIGHT] = reg;
+	npu_set_u64_bit(D_DATA_CUBE_IN_HEIGHT, &data->u84_bitmap);
+
+	reg = ((pdp_surface->src_data.channel - 1)
+	       << SHIFT(PDP_D_DATA_CUBE_IN_CHANNEL_0, CUBE_IN_CHANNEL));
+	data->reg[D_DATA_CUBE_IN_CHANNEL] = reg;
+	npu_set_u64_bit(D_DATA_CUBE_IN_CHANNEL, &data->u84_bitmap);
+
+	reg = ((pdp_surface->dst_data.width - 1)
+	       << SHIFT(PDP_D_DATA_CUBE_OUT_WIDTH_0, CUBE_OUT_WIDTH));
+	data->reg[D_DATA_CUBE_OUT_WIDTH] = reg;
+	npu_set_u64_bit(D_DATA_CUBE_OUT_WIDTH, &data->u84_bitmap);
+
+	reg = ((pdp_surface->dst_data.height - 1)
+	       << SHIFT(PDP_D_DATA_CUBE_OUT_HEIGHT_0, CUBE_OUT_HEIGHT));
+	data->reg[D_DATA_CUBE_OUT_HEIGHT] = reg;
+	npu_set_u64_bit(D_DATA_CUBE_OUT_HEIGHT, &data->u84_bitmap);
+
+	reg = ((pdp_surface->dst_data.channel - 1)
+	       << SHIFT(PDP_D_DATA_CUBE_OUT_CHANNEL_0, CUBE_OUT_CHANNEL));
+	data->reg[D_DATA_CUBE_OUT_CHANNEL] = reg;
+	npu_set_u64_bit(D_DATA_CUBE_OUT_CHANNEL, &data->u84_bitmap);
+
+	reg = (map_pool[pdp_op->pool_mode]
+	       << SHIFT(PDP_D_OPERATION_MODE_CFG_0, POOLING_METHOD)) |
+	      (get_fly_mode(pdp_surface->src_data.type)
+	       << SHIFT(PDP_D_OPERATION_MODE_CFG_0, FLYING_MODE)) |
+	      ((pdp_op->split_num - 1)
+	       << SHIFT(PDP_D_OPERATION_MODE_CFG_0, SPLIT_NUM));
+	data->reg[D_OPERATION_MODE_CFG] = reg;
+	npu_set_u64_bit(D_OPERATION_MODE_CFG, &data->u84_bitmap);
+
+	reg = ((pdp_op->partial_in_width_first == 0 ?
+			0 :
+			pdp_op->partial_in_width_first - 1)
+	       << SHIFT(PDP_D_PARTIAL_WIDTH_IN_0, PARTIAL_WIDTH_IN_FIRST)) |
+	      ((pdp_op->partial_in_width_mid == 0 ?
+			0 :
+			pdp_op->partial_in_width_mid - 1)
+	       << SHIFT(PDP_D_PARTIAL_WIDTH_IN_0, PARTIAL_WIDTH_IN_MID)) |
+	      ((pdp_op->partial_in_width_last == 0 ?
+			0 :
+			pdp_op->partial_in_width_last - 1)
+	       << SHIFT(PDP_D_PARTIAL_WIDTH_IN_0, PARTIAL_WIDTH_IN_LAST));
+	data->reg[D_PARTIAL_WIDTH_IN] = reg;
+	npu_set_u64_bit(D_PARTIAL_WIDTH_IN, &data->u84_bitmap);
+
+	reg = ((pdp_op->partial_width_first == 0 ?
+			0 :
+			pdp_op->partial_width_first - 1)
+	       << SHIFT(PDP_D_PARTIAL_WIDTH_OUT_0, PARTIAL_WIDTH_OUT_FIRST)) |
+	      ((pdp_op->partial_width_mid == 0 ? 0 :
+						 pdp_op->partial_width_mid - 1)
+	       << SHIFT(PDP_D_PARTIAL_WIDTH_OUT_0, PARTIAL_WIDTH_OUT_MID)) |
+	      ((pdp_op->partial_width_last == 0 ?
+			0 :
+			pdp_op->partial_width_last - 1)
+	       << SHIFT(PDP_D_PARTIAL_WIDTH_OUT_0, PARTIAL_WIDTH_OUT_LAST));
+	data->reg[D_PARTIAL_WIDTH_OUT] = reg;
+	npu_set_u64_bit(D_PARTIAL_WIDTH_OUT, &data->u84_bitmap);
+
+	reg = (map_pool_kernel[pdp_op->pool_width - 1]
+	       << SHIFT(PDP_D_POOLING_KERNEL_CFG_0, KERNEL_WIDTH)) |
+	      (map_pool_kernel[pdp_op->pool_height - 1]
+	       << SHIFT(PDP_D_POOLING_KERNEL_CFG_0, KERNEL_HEIGHT)) |
+	      ((pdp_op->stride_x - 1)
+	       << SHIFT(PDP_D_POOLING_KERNEL_CFG_0, KERNEL_STRIDE_WIDTH)) |
+	      ((pdp_op->stride_y - 1)
+	       << SHIFT(PDP_D_POOLING_KERNEL_CFG_0, KERNEL_STRIDE_HEIGHT));
+	data->reg[D_POOLING_KERNEL_CFG] = reg;
+	npu_set_u64_bit(D_POOLING_KERNEL_CFG, &data->u84_bitmap);
+
+	data->reg[D_RECIP_KERNEL_WIDTH] =
+		(recip_kernel_size[pdp_op->precision == PRECISION_FP16]
+				  [pdp_op->pool_width - 1]);
+
+	npu_set_u64_bit(D_RECIP_KERNEL_WIDTH, &data->u84_bitmap);
+
+	data->reg[D_RECIP_KERNEL_HEIGHT] =
+		(recip_kernel_size[pdp_op->precision == PRECISION_FP16]
+				  [pdp_op->pool_height - 1]);
+	npu_set_u64_bit(D_RECIP_KERNEL_HEIGHT, &data->u84_bitmap);
+
+	reg = (pdp_op->pad_left
+	       << SHIFT(PDP_D_POOLING_PADDING_CFG_0, PAD_LEFT)) |
+	      (pdp_op->pad_right
+	       << SHIFT(PDP_D_POOLING_PADDING_CFG_0, PAD_RIGHT)) |
+	      (pdp_op->pad_top << SHIFT(PDP_D_POOLING_PADDING_CFG_0, PAD_TOP)) |
+	      (pdp_op->pad_bottom
+	       << SHIFT(PDP_D_POOLING_PADDING_CFG_0, PAD_BOTTOM));
+	if (pdp_op->precision == PRECISION_FP16) {
+		int32_t i;
+
+		for (i = 0; i < PDP_PAD_VAL_NUM; i++) {
+			if (pdp_op->padding_value[i] != 0) {
+				dla_error("pdp padding value is invalid\n");
+				ret = ERR(INVALID_INPUT);
+				goto exit;
+			}
+		}
+	}
+
+	data->reg[D_POOLING_PADDING_CFG] = reg;
+	npu_set_u64_bit(D_POOLING_PADDING_CFG, &data->u84_bitmap);
+
+	data->reg[D_POOLING_PADDING_VALUE_1_CFG] = pdp_op->padding_value[0];
+	npu_set_u64_bit(D_POOLING_PADDING_VALUE_1_CFG, &data->u84_bitmap);
+	data->reg[D_POOLING_PADDING_VALUE_2_CFG] = pdp_op->padding_value[1];
+	npu_set_u64_bit(D_POOLING_PADDING_VALUE_2_CFG, &data->u84_bitmap);
+	data->reg[D_POOLING_PADDING_VALUE_3_CFG] = pdp_op->padding_value[2];
+	npu_set_u64_bit(D_POOLING_PADDING_VALUE_3_CFG, &data->u84_bitmap);
+	data->reg[D_POOLING_PADDING_VALUE_4_CFG] = pdp_op->padding_value[3];
+	npu_set_u64_bit(D_POOLING_PADDING_VALUE_4_CFG, &data->u84_bitmap);
+	data->reg[D_POOLING_PADDING_VALUE_5_CFG] = pdp_op->padding_value[4];
+	npu_set_u64_bit(D_POOLING_PADDING_VALUE_5_CFG, &data->u84_bitmap);
+	data->reg[D_POOLING_PADDING_VALUE_6_CFG] = pdp_op->padding_value[5];
+	npu_set_u64_bit(D_POOLING_PADDING_VALUE_6_CFG, &data->u84_bitmap);
+	data->reg[D_POOLING_PADDING_VALUE_7_CFG] = pdp_op->padding_value[6];
+	npu_set_u64_bit(D_POOLING_PADDING_VALUE_7_CFG, &data->u84_bitmap);
+
+	if (pdp_surface->src_data.type != DLA_MEM_HW) {
+		data->reg[D_SRC_LINE_STRIDE] =
+			pdp_surface->src_data.line_stride;
+		npu_set_u64_bit(D_SRC_LINE_STRIDE, &data->u84_bitmap);
+		data->reg[D_SRC_SURFACE_STRIDE] =
+			pdp_surface->src_data.surf_stride;
+		npu_set_u64_bit(D_SRC_SURFACE_STRIDE, &data->u84_bitmap);
+	}
+	data->reg[D_PDP_DST_LINE_STRIDE] = pdp_surface->dst_data.line_stride;
+	npu_set_u64_bit(D_PDP_DST_LINE_STRIDE, &data->u84_bitmap);
+
+	data->reg[D_PDP_DST_SURFACE_STRIDE] = pdp_surface->dst_data.surf_stride;
+	npu_set_u64_bit(D_PDP_DST_SURFACE_STRIDE, &data->u84_bitmap);
+
+	reg = (map_precision[pdp_op->precision]
+	       << SHIFT(PDP_D_DATA_FORMAT_0, INPUT_DATA));
+	data->reg[D_PDP_DATA_FORMAT] = reg;
+	npu_set_u64_bit(D_PDP_DATA_FORMAT, &data->u84_bitmap);
+
+	data->pdp_drp_reg[D_PDP_POST_DRP_ENABLE] = 1;
+	npu_set_u64_bit(D_PDP_POST_DRP_ENABLE, &data->u84_drp_bitmap);
+exit:
+	return ret;
+}
+
+int dla_pdp_prepare_prog_data(struct win_executor *executor, int rdma,
+			      int tensor_idx, u16 op_idx,
+			      union dla_operation_container *operation_desc,
+			      union dla_surface_container *surface_desc)
+
+{
+	int32_t ret;
+	dla_debug("%s %d\n", __func__, __LINE__);
+
+	ret = processor_pdp_program(executor, rdma, tensor_idx, operation_desc,
+				    surface_desc);
+	if (ret)
+		goto exit;
+
+exit:
+	return ret;
+}
diff --git a/drivers/soc/eswin/ai_driver/npu/post_drp.h b/drivers/soc/eswin/ai_driver/npu/post_drp.h
new file mode 100644
index 000000000000..51d11e560fe5
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/npu/post_drp.h
@@ -0,0 +1,58 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#ifndef POST_DRP_H
+#define POST_DRP_H
+
+#include "dla_interface.h"
+
+#define SDP_POST_DRP_S_BASE_ADDR 0x13a000
+#define SDP_POST_DRP_D_BASE_ADDR 0x13b000
+
+#define PDP_POST_DRP_S_BASE_ADDR 0x13c000
+#define PDP_POST_DRP_D_BASE_ADDR 0x13d000
+
+#define POST_DRP_CLK_GATING_BIT_OFFSET 24
+
+typedef enum { POST_DRP_TYPE_PDP = 1, POST_DRP_TYPE_SDP } POST_DRP_TYPE;
+
+typedef enum {
+	POST_DRP_S_REG_SOFT_RESET = 0x0,
+	POST_DRP_S_REG_POINTER_FLAG = 0x4,
+	POST_DRP_S_REG_PP_STATUS = 0x8,
+	POST_DRP_S_REG_POST_NOC_AW_CNT = 0x100,
+	POST_DRP_S_REG_POST_NOC_AW_BLOCK_CNT = 0x104,
+	POST_DRP_S_REG_POST_NOC_W_CNT = 0x108,
+	POST_DRP_S_REG_POST_NOC_W_BLOCK_CNT = 0x10c,
+	POST_DRP_S_REG_POST_NOC_W_BUBBE_CNT = 0x110,
+} POST_DRP_S_REG_E;
+
+typedef enum {
+	POST_DRP_D_REG_OP_EN_TRIG = 0x00,
+	POST_DRP_D_REG_OP_STATUS = 0x04,
+	POST_DRP_D_REG_G_STRIDE_SRAM = 0x08,
+	POST_DRP_D_REG_N_STRIDE_SRAM = 0x0c,
+	POST_DRP_D_REG_H_STRIDE_SRAM = 0x10,
+	POST_DRP_D_REG_C_STRIDE_SRAM = 0x14,
+	POST_DRP_D_REG_H_EXT_STRIDE = 0x18,
+	POST_DRP_D_REG_W_EXT_STRIDE = 0x1c,
+	POST_DRP_D_REG_OMAP_PARA_RSP_H = 0x20,
+	POST_DRP_D_REG_OMAP_PARA_RSP_L = 0x24,
+	POST_DRP_D_REG_LAYER_PARA_L = 0x28,
+	POST_DRP_D_REG_LAYER_PARA_M = 0x2c,
+	POST_DRP_D_REG_LAYER_PARA_H = 0x30,
+	POST_DRP_D_REG_OMAP_PARA_L = 0x34,
+	POST_DRP_D_REG_BASE_ADDR_H = 0x38,
+	POST_DRP_D_REG_BASE_ADDR_L = 0x3c,
+	POST_DRP_D_REG_CTRL = 0x40,
+	POST_DRP_D_REG_SPLIT = 0x44,
+	POST_DRP_D_REG_PARTIAL_WIDTH = 0x48,
+	POST_DRP_D_REG_SRAM_LOOP_PARA_H = 0x4c,
+	POST_DRP_D_REG_SRAM_LOOP_PARA_L = 0x50,
+} POST_DRP_D_REG_E;
+
+#endif
diff --git a/drivers/soc/eswin/ai_driver/npu/rubik.c b/drivers/soc/eswin/ai_driver/npu/rubik.c
new file mode 100644
index 000000000000..1e08b06480ad
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/npu/rubik.c
@@ -0,0 +1,301 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#include <linux/slab.h>
+#include <opendla.h>
+#include <dla_err.h>
+#include <dla_interface.h>
+#include "common.h"
+#include "dla_engine_internal.h"
+#include "dla_log.h"
+#include "internal_interface.h"
+#include "dla_buffer.h"
+
+static uint8_t map_rubik_mode[] = {
+	FIELD_ENUM(RBK_D_MISC_CFG_0, RUBIK_MODE, CONTRACT),
+	FIELD_ENUM(RBK_D_MISC_CFG_0, RUBIK_MODE, SPLIT),
+	FIELD_ENUM(RBK_D_MISC_CFG_0, RUBIK_MODE, MERGE),
+};
+
+static uint8_t map_ram_type[] = {
+	FIELD_ENUM(RBK_D_DAIN_RAM_TYPE_0, DATAIN_RAM_TYPE, MCIF),
+	FIELD_ENUM(RBK_D_DAIN_RAM_TYPE_0, DATAIN_RAM_TYPE, CVIF),
+};
+
+static uint8_t map_precision[] = {
+	FIELD_ENUM(RBK_D_MISC_CFG_0, IN_PRECISION, INT8),
+	FIELD_ENUM(RBK_D_MISC_CFG_0, IN_PRECISION, INT16),
+	FIELD_ENUM(RBK_D_MISC_CFG_0, IN_PRECISION, FP16),
+};
+
+static uint8_t map_bpe[] = {
+	BPE_PRECISION_INT8,
+	BPE_PRECISION_INT16,
+	BPE_PRECISION_FP16,
+};
+
+int dla_rubik_rdma_check(struct dla_processor_group *group,
+			 union dla_operation_container *op,
+			 union dla_surface_container *surface)
+{
+	if (group) {
+		group->is_rdma_needed = 0;
+	}
+	return 0;
+}
+
+int rubik_tensor_unfold(struct win_executor *executor, int op_idx,
+			union dla_operation_container *operation_desc,
+			union dla_surface_container *surface_desc, void *tensor,
+			int idx)
+{
+	struct dla_rubik_surface_desc *rubik_surface =
+		&surface_desc->rubik_surface;
+	rubik_tensor_t *rubik_tensor = (rubik_tensor_t *)tensor;
+	int ret;
+	rubik_dev_t *rubik_data = NULL;
+	rubik_dev_t *rubik =
+		(rubik_dev_t *)executor->prog_data_buf_bobj[IDX_RUBIK];
+
+	rubik_data = (rubik_dev_t *)&rubik[idx];
+
+	dla_debug("%s, %d, idx=%d, op_idx=%d.\n", __func__, __LINE__, idx,
+		  op_idx);
+
+	/* get the addresses from task descriptor */
+	ret = read_input_address(executor, &rubik_surface->src_data,
+				 &rubik_tensor[idx].input_address,
+				 &rubik_tensor[idx].input_is_io_tensor);
+	if (ret)
+		return -1;
+
+	rubik_data->npu_info.current_op_idx = op_idx;
+	dla_get_dma_cube_address(executor->driver_context,
+				 executor->mem_handles,
+				 rubik_surface->dst_data.address,
+				 rubik_surface->dst_data.offset,
+				 (void *)&rubik_tensor[idx].output_address,
+				 &rubik_tensor[idx].output_is_io_tensor);
+	return 0;
+}
+
+static int32_t
+processor_rubik_program(struct win_executor *executor, int rdma, int tensor_idx,
+			union dla_operation_container *operation_desc,
+			union dla_surface_container *surface_desc)
+{
+	int32_t ret = 0;
+	uint32_t reg, high, low;
+	uint64_t input_address = 0;
+	uint64_t output_address = 0;
+	struct dla_rubik_op_desc *rubik_op;
+	struct dla_rubik_surface_desc *rubik_surface;
+	rubik_tensor_t *tensor = executor->tensor_set[IDX_RUBIK];
+	rubik_tensor_t *rubik_tensor = &tensor[tensor_idx];
+	rubik_dev_t *rubik =
+		(rubik_dev_t *)executor->prog_data_buf_bobj[IDX_RUBIK];
+	rubik_dev_t *rubik_data = (rubik_dev_t *)&rubik[tensor_idx];
+	rubik_program_t *data = &rubik_data->prog_data;
+
+	rubik_op = &operation_desc->rubik_op;
+	rubik_surface = &surface_desc->rubik_surface;
+	data->input_tensor_idx = invalid_tensor_idx;
+	data->output_tensor_idx = invalid_tensor_idx;
+	/* Argument check */
+	if (rubik_surface->src_data.type == DLA_MEM_HW ||
+	    rubik_surface->dst_data.type == DLA_MEM_HW) {
+		ret = ERR(INVALID_INPUT);
+		goto exit;
+	}
+	if (rubik_tensor->input_is_io_tensor == invalid_tensor_idx) {
+		if (unlikely(rubik_tensor->input_address == -1ull)) {
+			dla_error("rubik input_address fail\n");
+			goto exit;
+		} else {
+			input_address = rubik_tensor->input_address;
+		}
+	} else {
+		input_address = rubik_surface->src_data.offset;
+		data->input_tensor_idx = rubik_tensor->input_is_io_tensor;
+	}
+
+	if (rubik_tensor->output_is_io_tensor == invalid_tensor_idx) {
+		if (unlikely(rubik_tensor->output_address == -1ull)) {
+			dla_error("rubik ouput_address fail\n");
+			goto exit;
+		} else {
+			output_address = rubik_tensor->output_address;
+		}
+	} else {
+		output_address = rubik_surface->dst_data.offset;
+		data->output_tensor_idx = rubik_tensor->output_is_io_tensor;
+	}
+	/* config rubik */
+	reg = (((uint32_t)map_rubik_mode[rubik_op->mode])
+	       << SHIFT(RBK_D_MISC_CFG_0, RUBIK_MODE)) |
+	      (((uint32_t)map_precision[rubik_op->precision])
+	       << SHIFT(RBK_D_MISC_CFG_0, IN_PRECISION));
+	data->reg[D_MISC_CFG] = reg;
+	npu_set_u64_bit(D_MISC_CFG, &data->u84_bitmap);
+
+	reg = (((uint32_t)map_ram_type[rubik_surface->src_data.type])
+	       << SHIFT(RBK_D_DAIN_RAM_TYPE_0, DATAIN_RAM_TYPE));
+	data->reg[D_DAIN_RAM_TYPE] = reg;
+	npu_set_u64_bit(D_DAIN_RAM_TYPE, &data->u84_bitmap);
+
+	reg = ((rubik_surface->src_data.width - 1)
+	       << SHIFT(RBK_D_DATAIN_SIZE_0_0, DATAIN_WIDTH)) |
+	      ((rubik_surface->src_data.height - 1)
+	       << SHIFT(RBK_D_DATAIN_SIZE_0_0, DATAIN_HEIGHT));
+	data->reg[D_DATAIN_SIZE_0] = reg;
+	npu_set_u64_bit(D_DATAIN_SIZE_0, &data->u84_bitmap);
+
+	reg = ((rubik_surface->src_data.channel - 1)
+	       << SHIFT(RBK_D_DATAIN_SIZE_1_0, DATAIN_CHANNEL));
+	data->reg[D_DATAIN_SIZE_1] = reg;
+	npu_set_u64_bit(D_DATAIN_SIZE_1, &data->u84_bitmap);
+
+	high = HIGH32BITS(input_address);
+	low = LOW32BITS(input_address);
+	data->reg[D_DAIN_ADDR_LOW] = low;
+	data->reg[D_DAIN_ADDR_HIGH] = high;
+	npu_set_u64_bit(D_DAIN_ADDR_LOW, &data->u84_bitmap);
+	npu_set_u64_bit(D_DAIN_ADDR_HIGH, &data->u84_bitmap);
+
+	if (rubik_op->mode == RUBIK_MODE_MERGE) {
+		if (rubik_surface->src_data.plane_stride == 0 ||
+		    (rubik_surface->src_data.plane_stride & 0x1f) != 0) {
+			ret = ERR(INVALID_INPUT);
+			goto exit;
+		}
+		data->reg[D_DAIN_PLANAR_STRIDE] =
+			rubik_surface->src_data.plane_stride;
+		npu_set_u64_bit(D_DAIN_PLANAR_STRIDE, &data->u84_bitmap);
+	} else {
+		data->reg[D_DAIN_SURF_STRIDE] =
+			rubik_surface->src_data.surf_stride,
+		npu_set_u64_bit(D_DAIN_SURF_STRIDE, &data->u84_bitmap);
+	}
+	data->reg[D_DAIN_LINE_STRIDE] = rubik_surface->src_data.line_stride;
+	npu_set_u64_bit(D_DAIN_LINE_STRIDE, &data->u84_bitmap);
+
+	reg = (((uint32_t)map_ram_type[rubik_surface->dst_data.type])
+	       << SHIFT(RBK_D_DAOUT_RAM_TYPE_0, DATAOUT_RAM_TYPE));
+	data->reg[D_DAOUT_RAM_TYPE] = reg;
+	npu_set_u64_bit(D_DAOUT_RAM_TYPE, &data->u84_bitmap);
+
+	reg = ((rubik_surface->dst_data.channel - 1)
+	       << SHIFT(RBK_D_DATAOUT_SIZE_1_0, DATAOUT_CHANNEL));
+	data->reg[D_DATAOUT_SIZE_1] = reg;
+	npu_set_u64_bit(D_DATAOUT_SIZE_1, &data->u84_bitmap);
+
+	high = HIGH32BITS(output_address);
+	low = LOW32BITS(output_address);
+
+	data->reg[D_DAOUT_ADDR_LOW] = low;
+	data->reg[D_DAOUT_ADDR_HIGH] = high;
+	npu_set_u64_bit(D_DAOUT_ADDR_LOW, &data->u84_bitmap);
+	npu_set_u64_bit(D_DAOUT_ADDR_HIGH, &data->u84_bitmap);
+
+	data->reg[D_DAOUT_LINE_STRIDE] = rubik_surface->dst_data.line_stride;
+	npu_set_u64_bit(D_DAOUT_LINE_STRIDE, &data->u84_bitmap);
+
+	if (rubik_op->mode != RUBIK_MODE_SPLIT) {
+		data->reg[D_DAOUT_SURF_STRIDE] =
+			rubik_surface->dst_data.surf_stride;
+		npu_set_u64_bit(D_DAOUT_SURF_STRIDE, &data->u84_bitmap);
+
+		if (rubik_op->mode == RUBIK_MODE_CONTRACT) {
+			reg = ((rubik_surface->dst_data.channel *
+					map_bpe[rubik_op->precision] +
+				31) >>
+			       5) *
+			      rubik_surface->src_data.surf_stride;
+			data->reg[D_CONTRACT_STRIDE_0] = reg;
+			npu_set_u64_bit(D_CONTRACT_STRIDE_0, &data->u84_bitmap);
+
+			reg = rubik_op->stride_y *
+			      rubik_surface->dst_data.line_stride;
+			data->reg[D_CONTRACT_STRIDE_1] = reg;
+			npu_set_u64_bit(D_CONTRACT_STRIDE_1, &data->u84_bitmap);
+
+			reg = (((uint32_t)(rubik_op->stride_x - 1))
+			       << SHIFT(RBK_D_DECONV_STRIDE_0,
+					DECONV_X_STRIDE)) |
+			      (((uint32_t)(rubik_op->stride_y - 1)) << SHIFT(
+				       RBK_D_DECONV_STRIDE_0, DECONV_Y_STRIDE));
+			data->reg[D_DECONV_STRIDE] = reg;
+			npu_set_u64_bit(D_DECONV_STRIDE, &data->u84_bitmap);
+		}
+	} else {
+		data->reg[D_DAOUT_PLANAR_STRIDE] =
+			rubik_surface->dst_data.plane_stride;
+		npu_set_u64_bit(D_DAOUT_PLANAR_STRIDE, &data->u84_bitmap);
+	}
+
+exit:
+	return ret;
+}
+
+void dla_rubik_dump_config(struct dla_processor_group *group)
+{
+	struct dla_rubik_op_desc *rubik_op;
+	struct dla_rubik_surface_desc *rubik_surface;
+
+	rubik_op = &group->operation_desc->rubik_op;
+	rubik_surface = &group->surface_desc->rubik_surface;
+
+	dla_debug("op_desc mode: %d\n", rubik_op->mode);
+	dla_debug("op_desc precision: %d\n", rubik_op->precision);
+	dla_debug("op_desc stride_x: %d\n", rubik_op->stride_x);
+	dla_debug("op_desc stride_y: %d\n", rubik_op->stride_y);
+
+	dla_debug("surface src type:%d\n", rubik_surface->src_data.type);
+	dla_debug("surface src address:%d\n", rubik_surface->src_data.address);
+	dla_debug("surface src offset:%d\n", rubik_surface->src_data.offset);
+	dla_debug("surface src size:%d\n", rubik_surface->src_data.size);
+	dla_debug("surface src batch:%d\n", rubik_surface->src_data.batch);
+	dla_debug("surface src width:%d\n", rubik_surface->src_data.width);
+	dla_debug("surface src height:%d\n", rubik_surface->src_data.height);
+	dla_debug("surface src channel:%d\n", rubik_surface->src_data.channel);
+	dla_debug("surface src line_stride:%d\n",
+		  rubik_surface->src_data.line_stride);
+	dla_debug("surface src surf_stride:%d\n",
+		  rubik_surface->src_data.surf_stride);
+	dla_debug("surface src plane_stride:%d\n",
+		  rubik_surface->src_data.plane_stride);
+
+	dla_debug("surface dst type:%d\n", rubik_surface->dst_data.type);
+	dla_debug("surface dst address:%d\n", rubik_surface->dst_data.address);
+	dla_debug("surface dst offset:%d\n", rubik_surface->dst_data.offset);
+	dla_debug("surface dst size:%d\n", rubik_surface->dst_data.size);
+	dla_debug("surface dst batch:%d\n", rubik_surface->dst_data.batch);
+	dla_debug("surface dst width:%d\n", rubik_surface->dst_data.width);
+	dla_debug("surface dst height:%d\n", rubik_surface->dst_data.height);
+	dla_debug("surface dst channel:%d\n", rubik_surface->dst_data.channel);
+	dla_debug("surface dst line_stride:%d\n",
+		  rubik_surface->dst_data.line_stride);
+	dla_debug("surface dst surf_stride:%d\n",
+		  rubik_surface->dst_data.surf_stride);
+	dla_debug("surface dst plane_stride:%d\n",
+		  rubik_surface->dst_data.plane_stride);
+}
+
+int dla_rubik_prepare_prog_data(struct win_executor *executor, int rdma,
+				int tensor_idx, u16 op_idx,
+				union dla_operation_container *operation_desc,
+				union dla_surface_container *surface_desc)
+{
+	int32_t ret = 0;
+	ret = processor_rubik_program(executor, rdma, tensor_idx,
+				      operation_desc, surface_desc);
+	if (ret)
+		goto exit;
+
+exit:
+	return ret;
+}
diff --git a/drivers/soc/eswin/ai_driver/npu/scheduler.c b/drivers/soc/eswin/ai_driver/npu/scheduler.c
new file mode 100644
index 000000000000..0f23eb00b11f
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/npu/scheduler.c
@@ -0,0 +1,301 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/workqueue.h>
+#include "dla_log.h"
+#include "dla_driver.h"
+#include "dla_engine.h"
+#include "hetero_ioctl.h"
+#include "internal_interface.h"
+#include "npu_spram.h"
+#include "conv.h"
+#include "hetero_host.h"
+#include "dla_buffer.h"
+#include "debug.h"
+#include "nvdla_proc.h"
+
+static int frame_timeout = 1000000;
+module_param(frame_timeout, int, 0644);
+MODULE_PARM_DESC(frame_timeout, "frame timeout in ms, default 1000s");
+
+extern void handle_event_sink_from_e31(struct win_engine *engine, u32 tiktok,
+				       u16 op_index);
+
+static inline void pick_next_frame(struct win_engine *engine,
+				   struct host_frame_desc **f)
+{
+	*f = list_first_entry_or_null(&engine->sched_frame_list,
+				      struct host_frame_desc, sched_node);
+	if (unlikely(*f == NULL)) {
+		/* No more frame */
+		dla_debug("%s %d no more frame\n", __func__, __LINE__);
+		return;
+	}
+	list_del(&((*f)->sched_node));
+	return;
+}
+
+static int send_frame_to_hw(struct win_engine *engine, u8 tiktok,
+			    hetero_ipc_frame_t *frame_desc,
+			    npu_io_tensor_t *io_tensor, host_node_t *host_node)
+{
+	int ret;
+	emission_node_t *pemission_node =
+		(emission_node_t *)host_node->emission_base_addr;
+	program_node_t *program_node =
+		(program_node_t *)host_node->program_base_addr;
+	u8 param = tiktok | ((engine->perf_switch) ? 0x02 : 0x0);
+	msg_payload_t payload = { FRAME_READY, param };
+	memcpy(&pemission_node->frame_desc[tiktok], frame_desc,
+	       sizeof(hetero_ipc_frame_t));
+	memcpy(program_node->io_addr_list[tiktok].tensor_addr,
+	       io_tensor->tensor_addr, sizeof(io_tensor->tensor_addr));
+
+	ret = send_mbx_msg_to_e31(engine, payload);
+	if (ret) {
+		dla_error("%s, %d, send mailbox to npu error=%d.\n", __func__,
+			  __LINE__, ret);
+	}
+	return ret;
+}
+
+int send_frame_to_npu(struct host_frame_desc *f, int tiktok)
+{
+#if (NPU_DEV_SIM != NPU_MCU_HOST)
+	struct win_engine *engine = f->executor->engine;
+#endif
+#if (NPU_DEV_SIM == NPU_REAL_ENV)
+	struct user_model *model = (struct user_model *)f->model;
+#endif
+
+	ASSERT(tiktok < NUM_TIKTOK);
+#if (NPU_DEV_SIM == NPU_REAL_ENV)
+	send_frame_to_hw(engine, tiktok,
+			 (hetero_ipc_frame_t *)&model->e31_frame_info,
+			 &f->io_tensor, engine->host_node);
+#if 0
+	send_frame_ready(tiktok, engine->perf_switch,
+			 (hetero_ipc_frame_t *)&model->e31_frame_info,
+			 &f->io_tensor,
+			 (void *)((struct nvdla_device *)engine->nvdla_dev)
+				 ->e31_mmio_base,
+			 engine->host_node);
+	ret = send_mbx_msg_to_e31(engine);
+	if (ret) {
+		dla_error("%s, %d, send mailbox to npu error=%d.\n", __func__,
+			  __LINE__, ret);
+		return ret;
+	}
+#endif
+#elif (NPU_DEV_SIM == NPU_MCU_ALONE)
+	if (!work_pending(&engine->dump_file_work[tiktok].work)) {
+		engine->dump_file_work[tiktok].f = f;
+		queue_work(engine->work_queue,
+			   &engine->dump_file_work[tiktok].work);
+	} else {
+		dla_error("%s, %d, dump_file_work error\n", __func__, __LINE__);
+		return -1;
+	}
+#elif (NPU_DEV_SIM == NPU_MCU_HOST)
+	dla_debug("hetero_send_frame_to_npu\n");
+	hetero_send_frame_to_npu(tiktok, f);
+#else
+	dla_error("%s, %d, Wrong NPU_DEV_SIM = %d.\n", __func__, __LINE__,
+		  NPU_DEV_SIM);
+	return -1;
+#endif
+
+	return 0;
+}
+
+static bool is_frame_model_alive(struct host_frame_desc *f)
+{
+	struct user_model *model = f->model;
+	struct user_context *uctx = model->uctx;
+	struct win_engine *engine = (struct win_engine *)model->engine;
+
+	return uctx->uctx_is_alive && engine->engine_is_alive;
+}
+
+void npu_frame_schedule(struct win_engine *engine)
+{
+	struct host_frame_desc *f = NULL;
+	unsigned long flags;
+	bool ret;
+
+	while (true) {
+		spin_lock_irqsave(&engine->executor_lock, flags);
+		if (atomic_read(&engine->is_sending) ||
+		    engine->tiktok_frame[engine->tiktok] != NULL) {
+			spin_unlock_irqrestore(&engine->executor_lock, flags);
+			break;
+		}
+
+		pick_next_frame(engine, &f);
+		if (f == NULL) {
+			spin_unlock_irqrestore(&engine->executor_lock, flags);
+			break;
+		}
+		atomic_set(&engine->is_sending, 1);
+		spin_unlock_irqrestore(&engine->executor_lock, flags);
+
+		ret = is_frame_model_alive(f);
+		if (!ret) {
+			spin_lock_irqsave(&engine->complete_lock, flags);
+			list_add_tail(&f->complete_entry,
+				      &engine->frame_complete_list);
+			spin_unlock_irqrestore(&engine->complete_lock, flags);
+
+			if (!work_pending(&engine->complete_work)) {
+				queue_work(system_highpri_wq,
+					   &engine->complete_work);
+			}
+
+		} else {
+			engine->tiktok_frame[engine->tiktok] = f;
+			f->tiktok = engine->tiktok;
+			f->is_event_source_done =
+				engine->is_event_source_done[engine->tiktok];
+			memset(f->is_event_source_done, 0,
+			       COMPLETE_EVENT_ID / 8);
+
+			set_current(engine, f->executor, f->tiktok);
+			engine->timer[f->tiktok].expires =
+				jiffies + msecs_to_jiffies(frame_timeout);
+			engine->tiktok = (engine->tiktok + 1) % NUM_TIKTOK;
+			smp_mb();
+
+			preempt_disable();
+			add_timer(&engine->timer[f->tiktok]);
+			send_frame_to_npu(f, f->tiktok);
+			preempt_enable();
+
+			dla_debug("%s, %d, done.\n", __func__, __LINE__);
+		}
+		atomic_set(&engine->is_sending, 0);
+	}
+}
+
+bool send_new_frame(struct win_engine *engine, struct win_executor *executor,
+		    struct host_frame_desc *f)
+{
+	unsigned long flags;
+
+	INIT_LIST_HEAD(&f->sched_node);
+	spin_lock_irqsave(&engine->executor_lock, flags);
+	if (is_frame_model_alive(f) == false) {
+		dla_error("queue frame on executor state dead\n");
+		spin_unlock_irqrestore(&engine->executor_lock, flags);
+		return false;
+	}
+	dla_debug("add frame to sched_frame_list.\n");
+	list_add_tail(&f->sched_node, &engine->sched_frame_list);
+	spin_unlock_irqrestore(&engine->executor_lock, flags);
+	npu_frame_schedule(engine);
+
+	return true;
+}
+
+void mbx_irq_event_sink_done(struct win_engine *priv, u32 tiktok, u16 op_index)
+{
+	struct win_engine *engine = priv;
+	dla_debug("receive event sink op done: tiktok %u op_index %u.\n",
+		  tiktok, op_index);
+	handle_event_sink_from_e31(engine, tiktok, op_index);
+}
+
+void mbx_irq_op_done(struct win_engine *priv, u32 tiktok, u16 op_index)
+{
+	struct win_engine *engine = priv;
+	struct host_frame_desc *f;
+	u16 op_type = NUM_OP_TYPE;
+	unsigned long flags;
+
+	spin_lock_irqsave(&engine->executor_lock, flags);
+	f = engine->tiktok_frame[tiktok];
+	if (f == NULL) {
+		dla_debug("irq get %d, frame is null, err.\n", tiktok);
+		spin_unlock_irqrestore(&engine->executor_lock, flags);
+		return;
+	}
+
+	if (f->executor->network->num_operations > op_index) {
+		op_type = f->executor->task->common_desc[op_index].op_type;
+	}
+
+	if (op_type == NUM_OP_TYPE) {
+		dla_error("cannot find op_type by idx:%d\n", op_index);
+		spin_unlock_irqrestore(&engine->executor_lock, flags);
+		return;
+	}
+
+	spin_unlock_irqrestore(&engine->executor_lock, flags);
+
+	if (!work_pending(&engine->dump_op_work[op_type].work)) {
+		engine->dump_op_work[op_type].tiktok = tiktok;
+		engine->dump_op_work[op_type].f = f;
+		engine->dump_op_work[op_type].op_index = op_index;
+		queue_work(engine->dump_op_work_queue,
+			   &engine->dump_op_work[op_type].work);
+		return;
+	}
+}
+
+void mbx_irq_frame_done(struct win_engine *priv, u32 tiktok, u32 stat)
+{
+	struct win_engine *engine = priv;
+	struct win_executor *executor;
+	struct host_frame_desc *f;
+	struct user_model *model;
+	int ret = 1;
+	unsigned long last_state;
+	unsigned long flags;
+
+	ret = del_timer(&engine->timer[tiktok]);
+	if (!ret) {
+		dla_debug("%s, %d, task is now processing in timer.\n",
+			  __func__, __LINE__);
+		return;
+	}
+
+	f = engine->tiktok_frame[tiktok];
+	if (f == NULL) {
+		dla_debug("irq get %d, frame is null, err.\n", tiktok);
+		return;
+	}
+
+	executor = f->executor;
+	model = f->model;
+	engine = executor->engine;
+	if (unlikely(stat && engine->perf_switch)) {
+		refresh_op_statistic(executor, engine, tiktok);
+	}
+
+	if (!is_frame_model_alive(f)) {
+		model->uctx->event_desc.len = 0;
+		memset(&model->uctx->event_desc.event_sinks[0], -1,
+		       MAX_EVENT_SINK_SAVE_NUM * sizeof(s16));
+	}
+	spin_lock_irqsave(&engine->executor_lock, flags);
+	engine->tiktok_frame[f->tiktok] = NULL;
+	unset_current(engine, executor, f->tiktok);
+	spin_unlock_irqrestore(&engine->executor_lock, flags);
+
+	npu_frame_done_process(f);
+	last_state = atomic_fetch_and(~NPU_RT_MUTX_FRAME_DONE,
+				      &model->uctx->lock_status);
+	if (last_state == NPU_RT_MUTX_FRAME_DONE) {
+		up(&engine->runtime_sem);
+		dla_debug("%s, %d unlocked, last_state:0x%lx\n", __func__,
+			  __LINE__, last_state);
+	}
+
+	dla_debug("%s, %d.\n", __func__, __LINE__);
+}
diff --git a/drivers/soc/eswin/ai_driver/npu/sdp.c b/drivers/soc/eswin/ai_driver/npu/sdp.c
new file mode 100644
index 000000000000..fcb4dcfaffa8
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/npu/sdp.c
@@ -0,0 +1,1058 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#include <linux/slab.h>
+
+#include <opendla.h>
+#include <dla_interface.h>
+#include "common.h"
+#include "dla_engine_internal.h"
+#include "dla_log.h"
+#include "post_drp.h"
+#include "dla_driver.h"
+#include "internal_interface.h"
+#include "sdp_regs.h"
+#include "dla_buffer.h"
+
+static const uint8_t map_ena[] = {
+	FIELD_ENUM(SDP_RDMA_D_BRDMA_CFG_0, BRDMA_DISABLE, YES),
+	FIELD_ENUM(SDP_RDMA_D_BRDMA_CFG_0, BRDMA_DISABLE, NO),
+};
+
+static const uint8_t map_prelu[] = {
+	FIELD_ENUM(SDP_D_DP_BS_CFG_0, BS_MUL_PRELU, NO),
+	FIELD_ENUM(SDP_D_DP_BS_CFG_0, BS_MUL_PRELU, YES),
+};
+
+static const uint8_t map_bypass[] = {
+	FIELD_ENUM(SDP_D_DP_BS_CFG_0, BS_BYPASS, YES),
+	FIELD_ENUM(SDP_D_DP_BS_CFG_0, BS_BYPASS, NO),
+};
+
+static const uint8_t map_alu_op[] = {
+	FIELD_ENUM(SDP_D_DP_EW_CFG_0, EW_ALU_ALGO, MAX),
+	FIELD_ENUM(SDP_D_DP_EW_CFG_0, EW_ALU_ALGO, MIN),
+	FIELD_ENUM(SDP_D_DP_EW_CFG_0, EW_ALU_ALGO, SUM),
+	FIELD_ENUM(SDP_D_DP_EW_CFG_0, EW_ALU_ALGO, EQL),
+};
+
+static const uint8_t map_alu_src[] = {
+	FIELD_ENUM(SDP_D_DP_BS_ALU_CFG_0, BS_ALU_SRC, MEM),
+	FIELD_ENUM(SDP_D_DP_BS_ALU_CFG_0, BS_ALU_SRC, REG),
+};
+
+static const uint8_t map_fly[] = {
+	FIELD_ENUM(SDP_D_FEATURE_MODE_CFG_0, FLYING_MODE, OFF),
+	FIELD_ENUM(SDP_D_FEATURE_MODE_CFG_0, FLYING_MODE, ON),
+};
+
+static const uint8_t map_dst[] = {
+	FIELD_ENUM(SDP_D_FEATURE_MODE_CFG_0, OUTPUT_DST, MEM),
+	FIELD_ENUM(SDP_D_FEATURE_MODE_CFG_0, OUTPUT_DST, PDP),
+};
+
+static const uint8_t map_wg[] = {
+	FIELD_ENUM(SDP_D_FEATURE_MODE_CFG_0, WINOGRAD, OFF),
+	FIELD_ENUM(SDP_D_FEATURE_MODE_CFG_0, WINOGRAD, ON),
+};
+
+static const uint8_t map_precision[] = {
+	FIELD_ENUM(SDP_RDMA_D_FEATURE_MODE_CFG_0, IN_PRECISION, INT8),
+	FIELD_ENUM(SDP_RDMA_D_FEATURE_MODE_CFG_0, IN_PRECISION, INT16),
+	FIELD_ENUM(SDP_RDMA_D_FEATURE_MODE_CFG_0, IN_PRECISION, FP16),
+};
+
+static const uint32_t map_proc_precision[3][3] = {
+	{
+		FIELD_ENUM(SDP_RDMA_D_FEATURE_MODE_CFG_0, IN_PRECISION, INT8),
+		FIELD_ENUM(SDP_RDMA_D_FEATURE_MODE_CFG_0, IN_PRECISION, INT8),
+		FIELD_ENUM(SDP_RDMA_D_FEATURE_MODE_CFG_0, IN_PRECISION, FP16),
+	},
+	{
+		FIELD_ENUM(SDP_RDMA_D_FEATURE_MODE_CFG_0, IN_PRECISION, INT8),
+		FIELD_ENUM(SDP_RDMA_D_FEATURE_MODE_CFG_0, IN_PRECISION, INT16),
+		FIELD_ENUM(SDP_RDMA_D_FEATURE_MODE_CFG_0, IN_PRECISION, FP16),
+	},
+	{
+		FIELD_ENUM(SDP_RDMA_D_FEATURE_MODE_CFG_0, IN_PRECISION, INT8),
+		FIELD_ENUM(SDP_RDMA_D_FEATURE_MODE_CFG_0, IN_PRECISION, INT16),
+		FIELD_ENUM(SDP_RDMA_D_FEATURE_MODE_CFG_0, IN_PRECISION, FP16),
+	},
+};
+
+static const uint8_t map_op_type[] = {
+	FIELD_ENUM(SDP_RDMA_D_BRDMA_CFG_0, BRDMA_DATA_USE, MUL),
+	FIELD_ENUM(SDP_RDMA_D_BRDMA_CFG_0, BRDMA_DATA_USE, MUL),
+	FIELD_ENUM(SDP_RDMA_D_BRDMA_CFG_0, BRDMA_DATA_USE, ALU),
+	FIELD_ENUM(SDP_RDMA_D_BRDMA_CFG_0, BRDMA_DATA_USE, BOTH),
+};
+
+static const uint8_t map_element_size[] = {
+	FIELD_ENUM(SDP_RDMA_D_BRDMA_CFG_0, BRDMA_DATA_SIZE, ONE_BYTE),
+	FIELD_ENUM(SDP_RDMA_D_BRDMA_CFG_0, BRDMA_DATA_SIZE, TWO_BYTE),
+	FIELD_ENUM(SDP_RDMA_D_BRDMA_CFG_0, BRDMA_DATA_SIZE, TWO_BYTE),
+};
+
+static const uint8_t map_op_mode[] = {
+	FIELD_ENUM(SDP_RDMA_D_BRDMA_CFG_0, BRDMA_DATA_MODE, PER_ELEMENT),
+	FIELD_ENUM(SDP_RDMA_D_BRDMA_CFG_0, BRDMA_DATA_MODE, PER_KERNEL),
+	FIELD_ENUM(SDP_RDMA_D_BRDMA_CFG_0, BRDMA_DATA_MODE, PER_ELEMENT),
+};
+
+static const uint8_t map_ram_type[] = {
+	FIELD_ENUM(SDP_RDMA_D_BRDMA_CFG_0, BRDMA_RAM_TYPE, MC),
+	FIELD_ENUM(SDP_RDMA_D_BRDMA_CFG_0, BRDMA_RAM_TYPE, CV),
+};
+
+static const uint8_t map_perf_dma[] = {
+	FIELD_ENUM(SDP_D_PERF_ENABLE_0, PERF_DMA_EN, NO),
+	FIELD_ENUM(SDP_D_PERF_ENABLE_0, PERF_DMA_EN, YES),
+};
+
+static const uint8_t map_perf_lut[] = {
+	FIELD_ENUM(SDP_D_PERF_ENABLE_0, PERF_LUT_EN, NO),
+	FIELD_ENUM(SDP_D_PERF_ENABLE_0, PERF_LUT_EN, YES),
+};
+
+static const uint8_t map_perf_sat[] = {
+	FIELD_ENUM(SDP_D_PERF_ENABLE_0, PERF_SAT_EN, NO),
+	FIELD_ENUM(SDP_D_PERF_ENABLE_0, PERF_SAT_EN, YES),
+};
+
+static const uint8_t map_perf_nan_inf[] = {
+	FIELD_ENUM(SDP_D_PERF_ENABLE_0, PERF_NAN_INF_COUNT_EN, NO),
+	FIELD_ENUM(SDP_D_PERF_ENABLE_0, PERF_NAN_INF_COUNT_EN, YES),
+};
+
+int dla_sdp_rdma_check(struct dla_processor_group *group,
+		       union dla_operation_container *op,
+		       union dla_surface_container *surface)
+{
+	uint8_t x1_rdma_ena;
+	uint8_t x2_rdma_ena;
+	uint8_t y_rdma_ena;
+	uint8_t fly;
+	int ret;
+	struct dla_sdp_op_desc *sdp_op;
+	struct dla_sdp_surface_desc *sdp_surface;
+
+	if (group) {
+		sdp_op = &group->operation_desc->sdp_op;
+		sdp_surface = &group->surface_desc->sdp_surface;
+	} else {
+		sdp_op = &op->sdp_op;
+		sdp_surface = &surface->sdp_surface;
+	}
+
+	x1_rdma_ena = sdp_op->x1_op.enable;
+	x2_rdma_ena = sdp_op->x2_op.enable;
+	y_rdma_ena = sdp_op->y_op.enable;
+
+	x1_rdma_ena &= (sdp_op->x1_op.mode != SDP_OP_PER_LAYER);
+	x2_rdma_ena &= (sdp_op->x2_op.mode != SDP_OP_PER_LAYER);
+	y_rdma_ena &= (sdp_op->y_op.mode != SDP_OP_PER_LAYER);
+
+	fly = sdp_surface->src_data.type == DLA_MEM_HW;
+	ret = (!fly) || (x1_rdma_ena || x2_rdma_ena || y_rdma_ena);
+
+	if (group) {
+		group->is_rdma_needed = ret;
+	}
+	return ret;
+}
+
+int sdp_tensor_unfold(struct win_executor *executor, int op_idx,
+		      union dla_operation_container *operation_desc,
+		      union dla_surface_container *surface_desc, void *tensor,
+		      int idx)
+{
+	struct dla_sdp_op_desc *sdp_op = &operation_desc->sdp_op;
+	struct dla_sdp_surface_desc *sdp_surface = &surface_desc->sdp_surface;
+	struct dla_sdp_op *x1_op;
+	struct dla_sdp_op *x2_op;
+	struct dla_sdp_op *y_op;
+	uint8_t x1_rdma_ena;
+	uint8_t x2_rdma_ena;
+	uint8_t y_rdma_ena;
+	uint8_t out_dma_ena;
+	uint8_t fly;
+	sdp_tensor_t *sdp_tensor = (sdp_tensor_t *)tensor;
+	int ret;
+	void *vaddr = executor->prog_data_buf_bobj[IDX_SDP];
+	sdp_dev_t *sdp = &(((sdp_dev_t *)vaddr)[idx]);
+
+	fly = sdp_surface->src_data.type == DLA_MEM_HW;
+	out_dma_ena = sdp_surface->dst_data.type != DLA_MEM_HW;
+	x1_op = &sdp_op->x1_op;
+	x2_op = &sdp_op->x2_op;
+	y_op = &sdp_op->y_op;
+	x1_rdma_ena = x1_op->enable && x1_op->type != SDP_OP_NONE;
+	x2_rdma_ena = x2_op->enable && x2_op->type != SDP_OP_NONE;
+	y_rdma_ena = y_op->enable && y_op->type != SDP_OP_NONE;
+
+	sdp->npu_info.current_op_idx = op_idx;
+	/* load address */
+	if (!fly) {
+		ret = read_input_address(executor, &sdp_surface->src_data,
+					 &sdp_tensor[idx].no_fly_src_addr,
+					 &sdp_tensor[idx].src_is_io_tensor);
+		if (ret < 0) {
+			dla_error("%s %d sdp src addr read fail\n", __func__,
+				  __LINE__);
+			goto exit;
+		}
+		CHECK_ALIGN(sdp_tensor[idx].no_fly_src_addr, atom_size);
+	}
+	if (out_dma_ena) {
+		ret = read_input_address(executor, &sdp_surface->dst_data,
+					 &sdp_tensor[idx].out_dma_dst_addr,
+					 &sdp_tensor[idx].dst_is_io_tensor);
+		if (ret < 0) {
+			dla_error("%s %d sdp dst addr read fail", __func__,
+				  __LINE__);
+			goto exit;
+		}
+		CHECK_ALIGN(sdp_tensor[idx].out_dma_dst_addr, atom_size);
+	}
+
+	x1_rdma_ena &= (x1_op->mode != SDP_OP_PER_LAYER);
+	x2_rdma_ena &= (x2_op->mode != SDP_OP_PER_LAYER);
+	y_rdma_ena &= (y_op->mode != SDP_OP_PER_LAYER);
+
+	if (x1_rdma_ena) {
+		ret = read_input_address(executor, &sdp_surface->x1_data,
+					 &sdp_tensor[idx].x1_addr,
+					 &sdp_tensor[idx].x1_is_io_tensor);
+		if (ret) {
+			dla_error("%s %d sdp x1_addr read fail\n", __func__,
+				  __LINE__);
+			goto exit;
+		}
+		CHECK_ALIGN(sdp_tensor->x1_addr, atom_size);
+	}
+	if (x2_rdma_ena) {
+		ret = read_input_address(executor, &sdp_surface->x2_data,
+					 &sdp_tensor[idx].x2_addr,
+					 &sdp_tensor[idx].x2_is_io_tensor);
+		if (ret) {
+			dla_error("%s %d sdp x2_addr read fail\n", __func__,
+				  __LINE__);
+			goto exit;
+		}
+		CHECK_ALIGN(sdp_tensor[idx].x2_addr, atom_size);
+	}
+	if (y_rdma_ena) {
+		ret = read_input_address(executor, &sdp_surface->y_data,
+					 &sdp_tensor[idx].y_addr,
+					 &sdp_tensor[idx].y_is_io_tensor);
+		if (ret) {
+			dla_error("%s %d sdp y_addr read fail\n", __func__,
+				  __LINE__);
+			goto exit;
+		}
+		CHECK_ALIGN(sdp_tensor[idx].y_addr, atom_size);
+	}
+exit:
+	return ret;
+}
+
+static int sdp_post_drp_handle(sdp_program_t *data,
+			       struct post_drp_op_desc *desc)
+{
+	data->sdp_drp_reg[DRP_D_REG_G_STRIDE_SRAM] = desc->g_stride_lsram - 1;
+	npu_set_u64_bit(DRP_D_REG_G_STRIDE_SRAM, &data->u84_drp_bitmap);
+	data->sdp_drp_reg[DRP_D_REG_N_STRIDE_SRAM] = desc->n_stride_lsram - 1;
+	npu_set_u64_bit(DRP_D_REG_N_STRIDE_SRAM, &data->u84_drp_bitmap);
+
+	data->sdp_drp_reg[DRP_D_REG_H_STRIDE_SRAM] = desc->h_stride - 1;
+	npu_set_u64_bit(DRP_D_REG_H_STRIDE_SRAM, &data->u84_drp_bitmap);
+
+	data->sdp_drp_reg[DRP_D_REG_C_STRIDE_SRAM] = desc->c_stride - 1;
+	npu_set_u64_bit(DRP_D_REG_C_STRIDE_SRAM, &data->u84_drp_bitmap);
+
+	data->sdp_drp_reg[DRP_D_REG_W_EXT_STRIDE] = desc->w_stride - 1;
+	npu_set_u64_bit(DRP_D_REG_W_EXT_STRIDE, &data->u84_drp_bitmap);
+
+	data->sdp_drp_reg[DRP_D_REG_LAYER_PARA_L] = (desc->n - 1) << 16 |
+						    (desc->e - 1);
+	npu_set_u64_bit(DRP_D_REG_LAYER_PARA_L, &data->u84_drp_bitmap);
+
+	data->sdp_drp_reg[DRP_D_REG_LAYER_PARA_H] = (desc->m - 1) << 16 |
+						    (desc->f - 1);
+	npu_set_u64_bit(DRP_D_REG_LAYER_PARA_H, &data->u84_drp_bitmap);
+
+	data->sdp_drp_reg[DRP_D_REG_OMAP_PARA_L] = desc->c0 - 1;
+	npu_set_u64_bit(DRP_D_REG_OMAP_PARA_L, &data->u84_drp_bitmap);
+
+	data->sdp_drp_reg[DRP_D_REG_CTRL] = (desc->surface_double << 1) |
+					    desc->type_16;
+	npu_set_u64_bit(DRP_D_REG_CTRL, &data->u84_drp_bitmap);
+	data->sdp_drp_reg[DRP_D_REG_SPLIT] = desc->split_num - 1;
+	npu_set_u64_bit(DRP_D_REG_SPLIT, &data->u84_drp_bitmap);
+
+	data->sdp_drp_reg[DRP_D_REG_PARTIAL_WIDTH] = ((desc->f_lst - 1) << 20) |
+						     ((desc->f_mid - 1) << 10) |
+						     (desc->f_fst - 1);
+	npu_set_u64_bit(DRP_D_REG_PARTIAL_WIDTH, &data->u84_drp_bitmap);
+
+	data->sdp_drp_reg[DRP_D_REG_SRAM_LOOP_PARA_H] =
+		((desc->e4_all - 1) << 16) | (desc->m3_all - 1);
+	npu_set_u64_bit(DRP_D_REG_SRAM_LOOP_PARA_H, &data->u84_drp_bitmap);
+
+	data->sdp_drp_reg[DRP_D_REG_SRAM_LOOP_PARA_L] =
+		((desc->n3_all - 1) << 16) | (desc->g3_all - 1);
+	npu_set_u64_bit(DRP_D_REG_SRAM_LOOP_PARA_L, &data->u84_drp_bitmap);
+	return 0;
+}
+
+static void sdp_post_drp_set_dst_addr(sdp_program_t *data, u64 addr)
+{
+	data->sdp_drp_reg[DRP_D_REG_BASE_ADDR_H] = (u32)(addr >> 32);
+	data->sdp_drp_reg[DRP_D_REG_BASE_ADDR_L] = (u32)addr;
+
+	npu_set_u64_bit(DRP_D_REG_BASE_ADDR_H, &data->u84_drp_bitmap);
+	npu_set_u64_bit(DRP_D_REG_BASE_ADDR_L, &data->u84_drp_bitmap);
+}
+
+static int32_t
+processor_sdp_program(struct win_executor *executor, int rdma, int idx,
+		      union dla_operation_container *operation_desc,
+		      union dla_surface_container *surface_desc)
+{
+	int32_t ret = 0;
+	uint32_t not_used;
+	uint64_t src_addr = -1, x1_addr = -1, x2_addr = -1;
+	uint64_t y_addr = -1, dst_addr = -1;
+	uint32_t reg, high, low;
+	uint8_t fly;
+	struct dla_sdp_op *x1_op;
+	struct dla_sdp_op *x2_op;
+	struct dla_sdp_op *y_op;
+	uint8_t x1_rdma_ena;
+	uint8_t x2_rdma_ena;
+	uint8_t y_rdma_ena;
+	uint8_t out_dma_ena;
+	struct dla_sdp_op_desc *sdp_op;
+	struct dla_sdp_surface_desc *sdp_surface;
+	sdp_tensor_t *tensor = executor->tensor_set[IDX_SDP];
+	sdp_tensor_t *sdp_tensor = NULL;
+	void *vaddr = executor->prog_data_buf_bobj[IDX_SDP];
+	sdp_dev_t *sdp = &(((sdp_dev_t *)vaddr)[idx]);
+	sdp_program_t *sdp_prog = &sdp->prog_data;
+	sdp_tensor = &tensor[idx];
+
+	sdp_op = &operation_desc->sdp_op;
+	sdp_surface = &surface_desc->sdp_surface;
+
+	sdp_prog->input_tensor_idx = invalid_tensor_idx;
+	sdp_prog->output_tensor_idx = invalid_tensor_idx;
+	sdp_prog->x1_tensor_idx = invalid_tensor_idx;
+	sdp_prog->x2_tensor_idx = invalid_tensor_idx;
+	sdp_prog->y_tensor_idx = invalid_tensor_idx;
+	dla_debug(
+		"sdp_tensor_set no_fly_src_addr 0x%llx out_dma_dst_addr 0x%llx x1_addr 0x%llx x2_addr 0x%llx y_addr 0x%llx\n",
+		sdp_tensor->no_fly_src_addr, sdp_tensor->out_dma_dst_addr,
+		sdp_tensor->x1_addr, sdp_tensor->x2_addr, sdp_tensor->y_addr);
+
+	fly = sdp_surface->src_data.type == DLA_MEM_HW;
+	out_dma_ena = sdp_surface->dst_data.type != DLA_MEM_HW;
+	x1_op = &sdp_op->x1_op;
+	x2_op = &sdp_op->x2_op;
+	y_op = &sdp_op->y_op;
+
+	x1_rdma_ena = x1_op->enable && x1_op->type != SDP_OP_NONE;
+	x2_rdma_ena = x2_op->enable && x2_op->type != SDP_OP_NONE;
+	y_rdma_ena = y_op->enable && y_op->type != SDP_OP_NONE;
+
+	x1_rdma_ena &= (x1_op->mode != SDP_OP_PER_LAYER);
+	x2_rdma_ena &= (x2_op->mode != SDP_OP_PER_LAYER);
+	y_rdma_ena &= (y_op->mode != SDP_OP_PER_LAYER);
+
+	sdp_prog->is_rdma = (!fly) || (x1_rdma_ena || x2_rdma_ena || y_rdma_ena);
+#ifdef CONV_DUMP
+	dla_debug(
+		"--fly: %d, x1_rdma_ena: %d, x2_rdma_ena: %d, y_rdma_ena: %x\n",
+		fly, x1_rdma_ena, x2_rdma_ena, y_rdma_ena);
+
+	dla_debug("--src_precision: %d\n", sdp_op->src_precision);
+	dla_debug("--dst_precision: %d\n", sdp_op->dst_precision);
+	dla_debug("--lut_index: %d\n", sdp_op->lut_index);
+	dla_debug("--out_cvt.scale: %d\n", sdp_op->out_cvt.scale);
+	dla_debug("--out_cvt.truncate: %d\n", sdp_op->out_cvt.truncate);
+	dla_debug("--out_cvt.enable: %d\n", sdp_op->out_cvt.enable);
+	dla_debug("--sdp_op->out_cvt.offset: %d\n", sdp_op->out_cvt.offset);
+	dla_debug("--conv_mode: %d\n", sdp_op->conv_mode);
+	dla_debug("--batch_num: %d\n", sdp_op->batch_num);
+	dla_debug("--batch_stride: %d\n", sdp_op->batch_stride);
+
+	dla_debug("--src_data.type: %d\n", sdp_surface->src_data.type);
+	dla_debug("--src_data.address: %d\n", sdp_surface->src_data.address);
+	dla_debug("--src_data.offset: %d\n", sdp_surface->src_data.offset);
+	dla_debug("--src_data.size: %d\n", sdp_surface->src_data.size);
+	dla_debug("--src_data.batch: %d\n", sdp_surface->src_data.batch);
+	dla_debug("--src_data.width: %d\n", sdp_surface->src_data.width);
+	dla_debug("--src_data.height: %d\n", sdp_surface->src_data.height);
+	dla_debug("--src_data.channel: %d\n", sdp_surface->src_data.channel);
+	dla_debug("--src_data.line_stride: %d\n",
+		  sdp_surface->src_data.line_stride);
+	dla_debug("--src_data.sur_stride: %d\n",
+		  sdp_surface->src_data.surf_stride);
+	dla_debug("--src_data.plan_stride: %d\n",
+		  sdp_surface->src_data.plane_stride);
+
+	dla_debug("--x1_data.type: %d\n", sdp_surface->x1_data.type);
+	dla_debug("--x1_data.address: %d\n", sdp_surface->x1_data.address);
+	dla_debug("--x1_data.offset: %d\n", sdp_surface->x1_data.offset);
+	dla_debug("--x1_data.size: %d\n", sdp_surface->x1_data.size);
+	dla_debug("--x1_data.batch: %d\n", sdp_surface->x1_data.batch);
+	dla_debug("--x1_data.width: %d\n", sdp_surface->x1_data.width);
+	dla_debug("--x1_data.height: %d\n", sdp_surface->x1_data.height);
+	dla_debug("--x1_data.channel: %d\n", sdp_surface->x1_data.channel);
+	dla_debug("--x1_data.line_stride: %d\n",
+		  sdp_surface->x1_data.line_stride);
+	dla_debug("--x1_data.sur_stride: %d\n",
+		  sdp_surface->x1_data.surf_stride);
+	dla_debug("--x1_data.plan_stride: %d\n",
+		  sdp_surface->x1_data.plane_stride);
+
+	dla_debug("--x2_data.type: %d\n", sdp_surface->x2_data.type);
+	dla_debug("--x2_data.address: %d\n", sdp_surface->x2_data.address);
+	dla_debug("--x2_data.offset: %d\n", sdp_surface->x2_data.offset);
+	dla_debug("--x2_data.size: %d\n", sdp_surface->x2_data.size);
+	dla_debug("--x2_data.batch: %d\n", sdp_surface->x2_data.batch);
+	dla_debug("--x2_data.width: %d\n", sdp_surface->x2_data.width);
+	dla_debug("--x2_data.height: %d\n", sdp_surface->x2_data.height);
+	dla_debug("--x2_data.channel: %d\n", sdp_surface->x2_data.channel);
+	dla_debug("--x2_data.line_stride: %d\n",
+		  sdp_surface->x2_data.line_stride);
+	dla_debug("--x2_data.sur_stride: %d\n",
+		  sdp_surface->x2_data.surf_stride);
+	dla_debug("--x2_data.plan_stride: %d\n",
+		  sdp_surface->x2_data.plane_stride);
+
+	dla_debug("--y_data.type: %d\n", sdp_surface->y_data.type);
+	dla_debug("--y_data.address: %d\n", sdp_surface->y_data.address);
+	dla_debug("--y_data.offset: %d\n", sdp_surface->y_data.offset);
+	dla_debug("--y_data.size: %d\n", sdp_surface->y_data.size);
+	dla_debug("--y_data.batch: %d\n", sdp_surface->y_data.batch);
+	dla_debug("--y_data.width: %d\n", sdp_surface->y_data.width);
+	dla_debug("--y_data.height: %d\n", sdp_surface->y_data.height);
+	dla_debug("--y_data.channel: %d\n", sdp_surface->y_data.channel);
+	dla_debug("--y_data.line_stride: %d\n",
+		  sdp_surface->y_data.line_stride);
+	dla_debug("--y_data.sur_stride: %d\n", sdp_surface->y_data.surf_stride);
+	dla_debug("--y_data.plan_stride: %d\n",
+		  sdp_surface->y_data.plane_stride);
+
+	dla_debug("--dst_data.type: %d\n", sdp_surface->dst_data.type);
+	dla_debug("--dst_data.address: %d\n", sdp_surface->dst_data.address);
+	dla_debug("--dst_data.offset: %d\n", sdp_surface->dst_data.offset);
+	dla_debug("--dst_data.size: %d\n", sdp_surface->dst_data.size);
+	dla_debug("--dst_data.batch: %d\n", sdp_surface->dst_data.batch);
+	dla_debug("--dst_data.width: %d\n", sdp_surface->dst_data.width);
+	dla_debug("--dst_data.height: %d\n", sdp_surface->dst_data.height);
+	dla_debug("--dst_data.channel: %d\n", sdp_surface->dst_data.channel);
+	dla_debug("--dst_data.line_stride: %d\n",
+		  sdp_surface->dst_data.line_stride);
+	dla_debug("--dst_data.sur_stride: %d\n",
+		  sdp_surface->dst_data.surf_stride);
+	dla_debug("--dst_data.plan_stride: %d\n",
+		  sdp_surface->dst_data.plane_stride);
+#endif
+	if (sdp_surface->dst_data.type != DLA_MEM_HW) {
+		sdp_post_drp_handle(sdp_prog, &sdp_op->post_drp_op);
+	}
+
+	sdp_tensor->fly = fly;
+	sdp_tensor->out_dma_ena = out_dma_ena;
+	if (!fly) {
+		if (sdp_tensor->src_is_io_tensor == invalid_tensor_idx) {
+			if (unlikely(sdp_tensor->no_fly_src_addr == -1ull)) {
+				dla_error("%s %d no_fly_src_addr -1\n",
+					  __func__, __LINE__);
+				goto exit;
+			} else {
+				src_addr = sdp_tensor->no_fly_src_addr;
+			}
+		} else {
+			//store offset to register when io_tensor_idx is effective.
+			src_addr = sdp_surface->src_data.offset;
+			sdp_prog->input_tensor_idx =
+				sdp_tensor->src_is_io_tensor;
+		}
+	}
+
+	if (out_dma_ena) {
+		if (sdp_tensor->dst_is_io_tensor == invalid_tensor_idx) {
+			if (unlikely(sdp_tensor->out_dma_dst_addr == -1ull)) {
+				dla_error(
+					"%s %d out_dma_dst_addr -1, try read again\n",
+					__func__, __LINE__);
+				goto exit;
+			} else {
+				dst_addr = sdp_tensor->out_dma_dst_addr;
+			}
+			if (sdp_surface->dst_data.type != DLA_MEM_HW) {
+				sdp_post_drp_set_dst_addr(sdp_prog, dst_addr);
+			}
+
+		} else {
+			dst_addr = sdp_surface->dst_data.offset;
+			sdp_prog->output_tensor_idx =
+				sdp_tensor->dst_is_io_tensor;
+		}
+	}
+
+	x1_rdma_ena &= (x1_op->mode != SDP_OP_PER_LAYER);
+	x2_rdma_ena &= (x2_op->mode != SDP_OP_PER_LAYER);
+	y_rdma_ena &= (y_op->mode != SDP_OP_PER_LAYER);
+
+	sdp_tensor->x1_rdma_ena = x1_rdma_ena;
+	sdp_tensor->x2_rdma_ena = x2_rdma_ena;
+	sdp_tensor->y_rdma_ena = y_rdma_ena;
+
+	if (x1_rdma_ena) {
+		if (sdp_tensor->x1_is_io_tensor == invalid_tensor_idx) {
+			if (unlikely(sdp_tensor->x1_addr == -1ull)) {
+				dla_error("%s %d x1_addr -1\n", __func__,
+					  __LINE__);
+				goto exit;
+			} else {
+				x1_addr = sdp_tensor->x1_addr;
+			}
+		} else {
+			x1_addr = sdp_surface->x1_data.offset;
+			sdp_prog->x1_tensor_idx = sdp_tensor->x1_is_io_tensor;
+		}
+	}
+
+	if (x2_rdma_ena) {
+		if (sdp_tensor->x2_is_io_tensor == invalid_tensor_idx) {
+			if (unlikely(sdp_tensor->x2_addr == -1ull)) {
+				dla_error("%s %d x2_addr -1\n", __func__,
+					  __LINE__);
+				goto exit;
+			} else {
+				x2_addr = sdp_tensor->x2_addr;
+			}
+		} else {
+			x2_addr = sdp_surface->x2_data.offset;
+			sdp_prog->x2_tensor_idx = sdp_tensor->x2_is_io_tensor;
+		}
+	}
+
+	if (y_rdma_ena) {
+		if (sdp_tensor->y_is_io_tensor == invalid_tensor_idx) {
+			if (unlikely(sdp_tensor->y_addr == -1ull)) {
+				dla_error("%s %d y_addr -1\n", __func__,
+					  __LINE__);
+				goto exit;
+			} else {
+				y_addr = sdp_tensor->y_addr;
+			}
+		} else {
+			y_addr = sdp_surface->y_data.offset;
+			sdp_prog->y_tensor_idx = sdp_tensor->y_is_io_tensor;
+		}
+	}
+
+	reg = (map_fly[0] << SHIFT(SDP_RDMA_D_FEATURE_MODE_CFG_0, FLYING_MODE));
+	sdp_prog->sdp_rdma_reg[SDP_RDMA_D_FEATURE_MODE_CFG] = reg;
+	npu_set_u64_bit(SDP_RDMA_D_FEATURE_MODE_CFG,
+			&sdp_prog->u84_rdma_bitmap);
+
+	reg = (map_ena[1] << SHIFT(SDP_RDMA_D_BRDMA_CFG_0, BRDMA_DISABLE));
+	sdp_prog->sdp_rdma_reg[SDP_RDMA_D_BRDMA_CFG] = reg;
+	npu_set_u64_bit(SDP_RDMA_D_BRDMA_CFG, &sdp_prog->u84_rdma_bitmap);
+
+	reg = (map_ena[1] << SHIFT(SDP_RDMA_D_NRDMA_CFG_0, NRDMA_DISABLE));
+	sdp_prog->sdp_rdma_reg[SDP_RDMA_D_NRDMA_CFG] = reg;
+	npu_set_u64_bit(SDP_RDMA_D_NRDMA_CFG, &sdp_prog->u84_rdma_bitmap);
+
+	reg = (map_ena[1] << SHIFT(SDP_RDMA_D_ERDMA_CFG_0, ERDMA_DISABLE));
+	sdp_prog->sdp_rdma_reg[SDP_RDMA_D_ERDMA_CFG] = reg;
+	npu_set_u64_bit(SDP_RDMA_D_ERDMA_CFG, &sdp_prog->u84_rdma_bitmap);
+
+	reg = (map_fly[fly]
+	       << SHIFT(SDP_RDMA_D_FEATURE_MODE_CFG_0, FLYING_MODE)) |
+	      (map_wg[sdp_op->conv_mode == CONV_MODE_WINOGRAD]
+	       << SHIFT(SDP_RDMA_D_FEATURE_MODE_CFG_0, WINOGRAD)) |
+	      (map_precision[sdp_op->src_precision]
+	       << SHIFT(SDP_RDMA_D_FEATURE_MODE_CFG_0, IN_PRECISION)) |
+	      (map_precision[sdp_op->dst_precision]
+	       << SHIFT(SDP_RDMA_D_FEATURE_MODE_CFG_0, OUT_PRECISION)) |
+	      (map_proc_precision[sdp_op->dst_precision][sdp_op->src_precision]
+	       << SHIFT(SDP_RDMA_D_FEATURE_MODE_CFG_0, PROC_PRECISION)) |
+	      ((sdp_op->batch_num - 1)
+	       << SHIFT(SDP_RDMA_D_FEATURE_MODE_CFG_0, BATCH_NUMBER));
+
+	sdp_prog->sdp_rdma_reg[SDP_RDMA_D_FEATURE_MODE_CFG] = reg;
+	npu_set_u64_bit(SDP_RDMA_D_FEATURE_MODE_CFG,
+			&sdp_prog->u84_rdma_bitmap);
+	if (rdma) {
+		sdp_prog->sdp_rdma_reg[SDP_RDMA_D_DATA_CUBE_WIDTH] =
+			sdp_surface->src_data.width - 1;
+		npu_set_u64_bit(SDP_RDMA_D_DATA_CUBE_WIDTH,
+				&sdp_prog->u84_rdma_bitmap);
+		sdp_prog->sdp_rdma_reg[SDP_RDMA_D_DATA_CUBE_HEIGHT] =
+			sdp_surface->src_data.height - 1;
+		npu_set_u64_bit(SDP_RDMA_D_DATA_CUBE_HEIGHT,
+				&sdp_prog->u84_rdma_bitmap);
+
+		sdp_prog->sdp_rdma_reg[SDP_RDMA_D_DATA_CUBE_CHANNEL] =
+			sdp_surface->src_data.channel - 1;
+		npu_set_u64_bit(SDP_RDMA_D_DATA_CUBE_CHANNEL,
+				&sdp_prog->u84_rdma_bitmap);
+
+		/* config SDP source info */
+		if (!fly) {
+			high = HIGH32BITS(src_addr);
+			low = LOW32BITS(src_addr);
+			sdp_prog->sdp_rdma_reg[SDP_RDMA_D_SRC_BASE_ADDR_LOW] =
+				low;
+			npu_set_u64_bit(SDP_RDMA_D_SRC_BASE_ADDR_LOW,
+					&sdp_prog->u84_rdma_bitmap);
+
+			sdp_prog->sdp_rdma_reg[SDP_RDMA_D_SRC_BASE_ADDR_HIGH] =
+				high;
+			npu_set_u64_bit(SDP_RDMA_D_SRC_BASE_ADDR_HIGH,
+					&sdp_prog->u84_rdma_bitmap);
+			sdp_prog->sdp_rdma_reg[SDP_RDMA_D_SRC_LINE_STRIDE] =
+				sdp_surface->src_data.line_stride;
+			npu_set_u64_bit(SDP_RDMA_D_SRC_LINE_STRIDE,
+					&sdp_prog->u84_rdma_bitmap);
+
+			sdp_prog->sdp_rdma_reg[SDP_RDMA_D_SRC_SURFACE_STRIDE] =
+				sdp_surface->src_data.surf_stride;
+			npu_set_u64_bit(SDP_RDMA_D_SRC_SURFACE_STRIDE,
+					&sdp_prog->u84_rdma_bitmap);
+			sdp_prog->sdp_rdma_reg[SDP_RDMA_D_SRC_DMA_CFG] =
+				map_ram_type[sdp_surface->src_data.type];
+
+			npu_set_u64_bit(SDP_RDMA_D_SRC_DMA_CFG,
+					&sdp_prog->u84_rdma_bitmap);
+		}
+
+		/* config x1 source info */
+		reg = (map_ena[x1_rdma_ena]
+		       << SHIFT(SDP_RDMA_D_BRDMA_CFG_0, BRDMA_DISABLE)) |
+		      (map_op_type[x1_op->type]
+		       << SHIFT(SDP_RDMA_D_BRDMA_CFG_0, BRDMA_DATA_USE)) |
+		      (map_element_size[x1_op->precision]
+		       << SHIFT(SDP_RDMA_D_BRDMA_CFG_0, BRDMA_DATA_SIZE)) |
+		      (map_op_mode[x1_op->mode]
+		       << SHIFT(SDP_RDMA_D_BRDMA_CFG_0, BRDMA_DATA_MODE)) |
+		      (map_ram_type[sdp_surface->x1_data.type]
+		       << SHIFT(SDP_RDMA_D_BRDMA_CFG_0, BRDMA_RAM_TYPE));
+		sdp_prog->sdp_rdma_reg[SDP_RDMA_D_BRDMA_CFG] = reg;
+		npu_set_u64_bit(SDP_RDMA_D_BRDMA_CFG,
+				&sdp_prog->u84_rdma_bitmap);
+		if (x1_rdma_ena) {
+			high = HIGH32BITS(x1_addr);
+			low = LOW32BITS(x1_addr);
+			dla_debug("sdp set x1 addr: 0x%x, 0x%x\n", high, low);
+
+			sdp_prog->sdp_rdma_reg[SDP_RDMA_D_BS_BASE_ADDR_LOW] =
+				low;
+
+			sdp_prog->sdp_rdma_reg[SDP_RDMA_D_BS_BASE_ADDR_HIGH] =
+				high;
+
+			npu_set_u64_bit(SDP_RDMA_D_BS_BASE_ADDR_LOW,
+					&sdp_prog->u84_rdma_bitmap);
+			npu_set_u64_bit(SDP_RDMA_D_BS_BASE_ADDR_HIGH,
+					&sdp_prog->u84_rdma_bitmap);
+
+			sdp_prog->sdp_rdma_reg[SDP_RDMA_D_BS_LINE_STRIDE] =
+				sdp_surface->x1_data.line_stride;
+
+			npu_set_u64_bit(SDP_RDMA_D_BS_LINE_STRIDE,
+					&sdp_prog->u84_rdma_bitmap);
+
+			sdp_prog->sdp_rdma_reg[SDP_RDMA_D_BS_SURFACE_STRIDE] =
+				sdp_surface->x1_data.surf_stride;
+			npu_set_u64_bit(SDP_RDMA_D_BS_SURFACE_STRIDE,
+					&sdp_prog->u84_rdma_bitmap);
+		}
+
+		/* config x2 source info */
+		reg = (map_ena[x2_rdma_ena]
+		       << SHIFT(SDP_RDMA_D_NRDMA_CFG_0, NRDMA_DISABLE)) |
+		      (map_op_type[x2_op->type]
+		       << SHIFT(SDP_RDMA_D_NRDMA_CFG_0, NRDMA_DATA_USE)) |
+		      (map_element_size[x2_op->precision]
+		       << SHIFT(SDP_RDMA_D_NRDMA_CFG_0, NRDMA_DATA_SIZE)) |
+		      (map_op_mode[x2_op->mode]
+		       << SHIFT(SDP_RDMA_D_NRDMA_CFG_0, NRDMA_DATA_MODE)) |
+		      (map_ram_type[sdp_surface->x2_data.type]
+		       << SHIFT(SDP_RDMA_D_NRDMA_CFG_0, NRDMA_RAM_TYPE));
+
+		sdp_prog->sdp_rdma_reg[SDP_RDMA_D_NRDMA_CFG] = reg;
+		npu_set_u64_bit(SDP_RDMA_D_NRDMA_CFG,
+				&sdp_prog->u84_rdma_bitmap);
+		if (x2_rdma_ena) {
+			high = HIGH32BITS(x2_addr);
+			low = LOW32BITS(x2_addr);
+			dla_debug("sdp set x2 addr: 0x%x, 0x%x\n", high, low);
+
+			sdp_prog->sdp_rdma_reg[SDP_RDMA_D_BN_BASE_ADDR_LOW] =
+				low;
+
+			sdp_prog->sdp_rdma_reg[SDP_RDMA_D_BN_BASE_ADDR_HIGH] =
+				high;
+
+			npu_set_u64_bit(SDP_RDMA_D_BN_BASE_ADDR_LOW,
+					&sdp_prog->u84_rdma_bitmap);
+			npu_set_u64_bit(SDP_RDMA_D_BN_BASE_ADDR_HIGH,
+					&sdp_prog->u84_rdma_bitmap);
+
+			sdp_prog->sdp_rdma_reg[SDP_RDMA_D_BN_LINE_STRIDE] =
+				sdp_surface->x2_data.line_stride;
+			npu_set_u64_bit(SDP_RDMA_D_BN_LINE_STRIDE,
+					&sdp_prog->u84_rdma_bitmap);
+
+			sdp_prog->sdp_rdma_reg[SDP_RDMA_D_BN_SURFACE_STRIDE] =
+				sdp_surface->x2_data.surf_stride;
+
+			npu_set_u64_bit(SDP_RDMA_D_BN_SURFACE_STRIDE,
+					&sdp_prog->u84_rdma_bitmap);
+		}
+
+		/* config y source info */
+		reg = (map_ena[y_rdma_ena]
+		       << SHIFT(SDP_RDMA_D_ERDMA_CFG_0, ERDMA_DISABLE)) |
+		      (map_op_type[y_op->type]
+		       << SHIFT(SDP_RDMA_D_ERDMA_CFG_0, ERDMA_DATA_USE)) |
+		      (map_element_size[y_op->precision]
+		       << SHIFT(SDP_RDMA_D_ERDMA_CFG_0, ERDMA_DATA_SIZE)) |
+		      (map_op_mode[y_op->mode]
+		       << SHIFT(SDP_RDMA_D_ERDMA_CFG_0, ERDMA_DATA_MODE)) |
+		      (map_ram_type[sdp_surface->y_data.type]
+		       << SHIFT(SDP_RDMA_D_ERDMA_CFG_0, ERDMA_RAM_TYPE));
+
+		sdp_prog->sdp_rdma_reg[SDP_RDMA_D_ERDMA_CFG] = reg;
+		npu_set_u64_bit(SDP_RDMA_D_ERDMA_CFG,
+				&sdp_prog->u84_rdma_bitmap);
+
+		if (y_rdma_ena) {
+			high = HIGH32BITS(y_addr);
+			low = LOW32BITS(y_addr);
+			dla_debug("sdp set y addr: 0x%x, 0x%x\n", high, low);
+			sdp_prog->sdp_rdma_reg[SDP_RDMA_D_EW_BASE_ADDR_LOW] =
+				low;
+			npu_set_u64_bit(SDP_RDMA_D_EW_BASE_ADDR_LOW,
+					&sdp_prog->u84_rdma_bitmap);
+
+			sdp_prog->sdp_rdma_reg[SDP_RDMA_D_EW_BASE_ADDR_HIGH] =
+				high;
+
+			npu_set_u64_bit(SDP_RDMA_D_EW_BASE_ADDR_HIGH,
+					&sdp_prog->u84_rdma_bitmap);
+			sdp_prog->sdp_rdma_reg[SDP_RDMA_D_EW_LINE_STRIDE] =
+				sdp_surface->y_data.line_stride;
+			npu_set_u64_bit(SDP_RDMA_D_EW_LINE_STRIDE,
+					&sdp_prog->u84_rdma_bitmap);
+
+			sdp_prog->sdp_rdma_reg[SDP_RDMA_D_EW_SURFACE_STRIDE] =
+				sdp_surface->y_data.surf_stride;
+			npu_set_u64_bit(SDP_RDMA_D_EW_SURFACE_STRIDE,
+					&sdp_prog->u84_rdma_bitmap);
+		}
+	}
+
+	if (sdp_op->lut_index >= 0) {
+		ret = dla_get_dma_cube_address(
+			executor->driver_context, executor->mem_handles,
+			executor->network->lut_data_index,
+			sdp_op->lut_index * sizeof(lut_dev_t),
+			&sdp->npu_info.lut_address, &not_used);
+		if (ret) {
+			dla_error("Failed to read lut_address, ret=%d\n", ret);
+			return -1;
+		}
+
+		if (sdp_op->lut_index == 0) {
+			executor->lut_base_iova = sdp->npu_info.lut_address;
+		}
+
+		BUG_ON(sdp->npu_info.lut_address == 0);
+		dla_debug("sdp->npu_info.lut_address=0x%llx, not_used=%u\n",
+			  sdp->npu_info.lut_address, not_used);
+		if (executor->recent_lut_iova == sdp->npu_info.lut_address) {
+			/* inform E31 to reuse recent lut */
+			sdp->npu_info.lut_address = 0;
+		} else {
+			executor->recent_lut_iova = sdp->npu_info.lut_address;
+		}
+	}
+
+	sdp_prog->reg[D_DATA_CUBE_WIDTH] = sdp_surface->src_data.width - 1;
+	sdp_prog->reg[D_DATA_CUBE_HEIGHT] = sdp_surface->src_data.height - 1;
+	sdp_prog->reg[D_DATA_CUBE_CHANNEL] = sdp_surface->src_data.channel - 1;
+	npu_set_u64_bit(D_DATA_CUBE_WIDTH, &sdp_prog->u84_bitmap);
+	npu_set_u64_bit(D_DATA_CUBE_HEIGHT, &sdp_prog->u84_bitmap);
+	npu_set_u64_bit(D_DATA_CUBE_CHANNEL, &sdp_prog->u84_bitmap);
+	if (out_dma_ena) {
+		high = HIGH32BITS(dst_addr);
+		low = LOW32BITS(dst_addr);
+		sdp_prog->reg[D_DST_BASE_ADDR_HIGH] = high;
+		sdp_prog->reg[D_DST_BASE_ADDR_LOW] = low;
+		npu_set_u64_bit(D_DST_BASE_ADDR_HIGH, &sdp_prog->u84_bitmap);
+		npu_set_u64_bit(D_DST_BASE_ADDR_LOW, &sdp_prog->u84_bitmap);
+
+		sdp_prog->reg[D_DST_LINE_STRIDE] =
+			sdp_surface->dst_data.line_stride;
+		npu_set_u64_bit(D_DST_LINE_STRIDE, &sdp_prog->u84_bitmap);
+		sdp_prog->reg[D_DST_SURFACE_STRIDE] =
+			sdp_surface->dst_data.surf_stride;
+
+		npu_set_u64_bit(D_DST_SURFACE_STRIDE, &sdp_prog->u84_bitmap);
+	}
+
+	/* Config BS module */
+	reg = (map_bypass[x1_op->enable]
+	       << SHIFT(SDP_D_DP_BS_CFG_0, BS_BYPASS)) |
+	      (map_bypass[x1_op->type != SDP_OP_MUL &&
+			  x1_op->type != SDP_OP_NONE]
+	       << SHIFT(SDP_D_DP_BS_CFG_0, BS_ALU_BYPASS)) |
+	      (map_alu_op[x1_op->alu_type]
+	       << SHIFT(SDP_D_DP_BS_CFG_0, BS_ALU_ALGO)) |
+	      (map_bypass[x1_op->type != SDP_OP_ADD &&
+			  x1_op->type != SDP_OP_NONE]
+	       << SHIFT(SDP_D_DP_BS_CFG_0, BS_MUL_BYPASS)) |
+	      (map_prelu[x1_op->act == ACTIVATION_PRELU]
+	       << SHIFT(SDP_D_DP_BS_CFG_0, BS_MUL_PRELU)) |
+	      (map_bypass[x1_op->act == ACTIVATION_RELU]
+	       << SHIFT(SDP_D_DP_BS_CFG_0, BS_RELU_BYPASS));
+	sdp_prog->reg[D_DP_BS_CFG] = reg;
+	npu_set_u64_bit(D_DP_BS_CFG, &sdp_prog->u84_bitmap);
+
+	if (x1_op->enable) {
+		if (x1_op->type == SDP_OP_ADD || x1_op->type == SDP_OP_BOTH) {
+			reg = (map_alu_src[x1_op->mode == SDP_OP_PER_LAYER]
+			       << SHIFT(SDP_D_DP_BS_ALU_CFG_0, BS_ALU_SRC)) |
+			      (x1_op->shift_value
+			       << SHIFT(SDP_D_DP_BS_ALU_CFG_0,
+					BS_ALU_SHIFT_VALUE));
+
+			sdp_prog->reg[D_DP_BS_ALU_CFG] = reg;
+			npu_set_u64_bit(D_DP_BS_ALU_CFG, &sdp_prog->u84_bitmap);
+		}
+
+		if (x1_op->mode == SDP_OP_PER_LAYER) {
+			sdp_prog->reg[D_DP_BS_ALU_SRC_VALUE] =
+				x1_op->alu_operand;
+			npu_set_u64_bit(D_DP_BS_ALU_SRC_VALUE,
+					&sdp_prog->u84_bitmap);
+			sdp_prog->reg[D_DP_BS_MUL_SRC_VALUE] =
+				x1_op->mul_operand;
+			npu_set_u64_bit(D_DP_BS_MUL_SRC_VALUE,
+					&sdp_prog->u84_bitmap);
+		}
+
+		/**
+		 * MUL truncate will take effect no matter
+		 * MUL is bypassed or not
+		 */
+		reg = (map_alu_src[x1_op->mode == SDP_OP_PER_LAYER]
+		       << SHIFT(SDP_D_DP_BS_MUL_CFG_0, BS_MUL_SRC)) |
+		      (x1_op->truncate
+		       << SHIFT(SDP_D_DP_BS_MUL_CFG_0, BS_MUL_SHIFT_VALUE));
+		sdp_prog->reg[D_DP_BS_MUL_CFG] = reg;
+		npu_set_u64_bit(D_DP_BS_MUL_CFG, &sdp_prog->u84_bitmap);
+	}
+
+	/* Config BN module */
+	reg = (map_bypass[x2_op->enable]
+	       << SHIFT(SDP_D_DP_BN_CFG_0, BN_BYPASS)) |
+	      (map_bypass[x2_op->type != SDP_OP_MUL &&
+			  x2_op->type != SDP_OP_NONE]
+	       << SHIFT(SDP_D_DP_BN_CFG_0, BN_ALU_BYPASS)) |
+	      (map_alu_op[x2_op->alu_type]
+	       << SHIFT(SDP_D_DP_BN_CFG_0, BN_ALU_ALGO)) |
+	      (map_bypass[x2_op->type != SDP_OP_ADD &&
+			  x2_op->type != SDP_OP_NONE]
+	       << SHIFT(SDP_D_DP_BN_CFG_0, BN_MUL_BYPASS)) |
+	      (map_prelu[x2_op->act == ACTIVATION_PRELU]
+	       << SHIFT(SDP_D_DP_BN_CFG_0, BN_MUL_PRELU)) |
+	      (map_bypass[x2_op->act == ACTIVATION_RELU]
+	       << SHIFT(SDP_D_DP_BN_CFG_0, BN_RELU_BYPASS));
+	sdp_prog->reg[D_DP_BN_CFG] = reg;
+	npu_set_u64_bit(D_DP_BN_CFG, &sdp_prog->u84_bitmap);
+
+	if (x2_op->enable) {
+		if (x2_op->type == SDP_OP_ADD || x2_op->type == SDP_OP_BOTH) {
+			reg = (map_alu_src[x2_op->mode == SDP_OP_PER_LAYER]
+			       << SHIFT(SDP_D_DP_BN_ALU_CFG_0, BN_ALU_SRC)) |
+			      (x2_op->shift_value
+			       << SHIFT(SDP_D_DP_BN_ALU_CFG_0,
+					BN_ALU_SHIFT_VALUE));
+			sdp_prog->reg[D_DP_BN_ALU_CFG] = reg;
+			npu_set_u64_bit(D_DP_BN_ALU_CFG, &sdp_prog->u84_bitmap);
+		}
+
+		if (x2_op->mode == SDP_OP_PER_LAYER) {
+			sdp_prog->reg[D_DP_BN_ALU_SRC_VALUE] =
+				x2_op->alu_operand;
+			npu_set_u64_bit(D_DP_BN_ALU_SRC_VALUE,
+					&sdp_prog->u84_bitmap);
+
+			sdp_prog->reg[D_DP_BN_MUL_SRC_VALUE] =
+				x2_op->mul_operand;
+			npu_set_u64_bit(D_DP_BN_MUL_SRC_VALUE,
+					&sdp_prog->u84_bitmap);
+		}
+
+		reg = (map_alu_src[x2_op->mode == SDP_OP_PER_LAYER]
+		       << SHIFT(SDP_D_DP_BN_MUL_CFG_0, BN_MUL_SRC)) |
+		      (x2_op->truncate
+		       << SHIFT(SDP_D_DP_BN_MUL_CFG_0, BN_MUL_SHIFT_VALUE));
+		sdp_prog->reg[D_DP_BN_MUL_CFG] = reg;
+		npu_set_u64_bit(D_DP_BN_MUL_CFG, &sdp_prog->u84_bitmap);
+	}
+
+	/* Config EW module */
+	reg = (map_bypass[y_op->enable]
+	       << SHIFT(SDP_D_DP_EW_CFG_0, EW_BYPASS)) |
+	      (map_bypass[y_op->type != SDP_OP_MUL && y_op->type != SDP_OP_NONE]
+	       << SHIFT(SDP_D_DP_EW_CFG_0, EW_ALU_BYPASS)) |
+	      (map_alu_op[y_op->alu_type]
+	       << SHIFT(SDP_D_DP_EW_CFG_0, EW_ALU_ALGO)) |
+	      (map_bypass[y_op->type != SDP_OP_ADD && y_op->type != SDP_OP_NONE]
+	       << SHIFT(SDP_D_DP_EW_CFG_0, EW_MUL_BYPASS)) |
+	      ((map_prelu[y_op->act == ACTIVATION_PRELU])
+	       << SHIFT(SDP_D_DP_EW_CFG_0, EW_MUL_PRELU)) |
+	      (map_bypass[y_op->act == ACTIVATION_LUT]
+	       << SHIFT(SDP_D_DP_EW_CFG_0, EW_LUT_BYPASS));
+	sdp_prog->reg[D_DP_EW_CFG] = reg;
+	npu_set_u64_bit(D_DP_EW_CFG, &sdp_prog->u84_bitmap);
+
+	if (y_op->enable) {
+		if (y_op->type == SDP_OP_ADD || y_op->type == SDP_OP_BOTH) {
+			reg = (map_alu_src[y_op->mode == SDP_OP_PER_LAYER]
+			       << SHIFT(SDP_D_DP_EW_ALU_CFG_0, EW_ALU_SRC)) |
+			      (map_bypass[y_op->cvt.alu_cvt.enable]
+			       << SHIFT(SDP_D_DP_EW_ALU_CFG_0,
+					EW_ALU_CVT_BYPASS));
+			sdp_prog->reg[D_DP_EW_ALU_CFG] = reg;
+			npu_set_u64_bit(D_DP_EW_ALU_CFG, &sdp_prog->u84_bitmap);
+
+			if (y_op->mode == SDP_OP_PER_LAYER) {
+				sdp_prog->reg[D_DP_EW_ALU_SRC_VALUE] =
+					y_op->alu_operand;
+				npu_set_u64_bit(D_DP_EW_ALU_SRC_VALUE,
+						&sdp_prog->u84_bitmap);
+
+			} else {
+				sdp_prog->reg[D_DP_EW_ALU_CVT_OFFSET_VALUE] =
+					y_op->cvt.alu_cvt.offset;
+				npu_set_u64_bit(D_DP_EW_ALU_CVT_OFFSET_VALUE,
+						&sdp_prog->u84_bitmap);
+
+				sdp_prog->reg[D_DP_EW_ALU_CVT_SCALE_VALUE] =
+					y_op->cvt.alu_cvt.scale;
+				npu_set_u64_bit(D_DP_EW_ALU_CVT_SCALE_VALUE,
+						&sdp_prog->u84_bitmap);
+
+				sdp_prog->reg[D_DP_EW_ALU_CVT_TRUNCATE_VALUE] =
+					y_op->cvt.alu_cvt.truncate;
+				npu_set_u64_bit(D_DP_EW_ALU_CVT_TRUNCATE_VALUE,
+						&sdp_prog->u84_bitmap);
+			}
+		}
+
+		if (y_op->type == SDP_OP_MUL || y_op->type == SDP_OP_BOTH) {
+			reg = (map_alu_src[y_op->mode == SDP_OP_PER_LAYER]
+			       << SHIFT(SDP_D_DP_EW_MUL_CFG_0, EW_MUL_SRC)) |
+			      (map_bypass[y_op->cvt.mul_cvt.enable]
+			       << SHIFT(SDP_D_DP_EW_MUL_CFG_0,
+					EW_MUL_CVT_BYPASS));
+			sdp_prog->reg[D_DP_EW_MUL_CFG] = reg;
+			npu_set_u64_bit(D_DP_EW_MUL_CFG, &sdp_prog->u84_bitmap);
+
+			if (y_op->mode == SDP_OP_PER_LAYER) {
+				sdp_prog->reg[D_DP_EW_MUL_SRC_VALUE] =
+					y_op->mul_operand;
+				npu_set_u64_bit(D_DP_EW_MUL_SRC_VALUE,
+						&sdp_prog->u84_bitmap);
+
+			} else {
+				sdp_prog->reg[D_DP_EW_MUL_CVT_OFFSET_VALUE] =
+					y_op->cvt.mul_cvt.offset;
+				npu_set_u64_bit(D_DP_EW_MUL_CVT_OFFSET_VALUE,
+						&sdp_prog->u84_bitmap);
+
+				sdp_prog->reg[D_DP_EW_MUL_CVT_SCALE_VALUE] =
+					y_op->cvt.mul_cvt.scale;
+				npu_set_u64_bit(D_DP_EW_MUL_CVT_SCALE_VALUE,
+						&sdp_prog->u84_bitmap);
+
+				sdp_prog->reg[D_DP_EW_MUL_CVT_TRUNCATE_VALUE] =
+					y_op->cvt.mul_cvt.truncate;
+				npu_set_u64_bit(D_DP_EW_MUL_CVT_TRUNCATE_VALUE,
+						&sdp_prog->u84_bitmap);
+			}
+		}
+
+		sdp_prog->reg[D_DP_EW_TRUNCATE_VALUE] = y_op->truncate;
+		npu_set_u64_bit(D_DP_EW_TRUNCATE_VALUE, &sdp_prog->u84_bitmap);
+	}
+
+	reg = (map_fly[sdp_surface->src_data.type == DLA_MEM_HW]
+	       << SHIFT(SDP_D_FEATURE_MODE_CFG_0, FLYING_MODE)) |
+	      (map_dst[sdp_surface->dst_data.type == DLA_MEM_HW]
+	       << SHIFT(SDP_D_FEATURE_MODE_CFG_0, OUTPUT_DST)) |
+	      (map_wg[sdp_op->conv_mode == CONV_MODE_WINOGRAD]
+	       << SHIFT(SDP_D_FEATURE_MODE_CFG_0, WINOGRAD)) |
+	      ((sdp_op->batch_num - 1)
+	       << SHIFT(SDP_D_FEATURE_MODE_CFG_0, BATCH_NUMBER));
+	sdp_prog->reg[D_FEATURE_MODE_CFG] = reg;
+	npu_set_u64_bit(D_FEATURE_MODE_CFG, &sdp_prog->u84_bitmap);
+
+	if (sdp_op->batch_num > 1) {
+		sdp_prog->reg[D_DST_BATCH_STRIDE] = sdp_op->batch_stride;
+		npu_set_u64_bit(D_DST_BATCH_STRIDE, &sdp_prog->u84_bitmap);
+	}
+
+	reg = (map_proc_precision[sdp_op->dst_precision][sdp_op->src_precision]
+	       << SHIFT(SDP_D_DATA_FORMAT_0, PROC_PRECISION)) |
+	      (map_precision[sdp_op->dst_precision]
+	       << SHIFT(SDP_D_DATA_FORMAT_0, OUT_PRECISION));
+	sdp_prog->reg[D_DATA_FORMAT] = reg;
+	sdp_prog->reg[D_CVT_OFFSET] = sdp_op->out_cvt.offset;
+	sdp_prog->reg[D_CVT_SCALE] = sdp_op->out_cvt.scale;
+	sdp_prog->reg[D_CVT_SHIFT] = sdp_op->out_cvt.truncate;
+	npu_set_u64_bit(D_DATA_FORMAT, &sdp_prog->u84_bitmap);
+	npu_set_u64_bit(D_CVT_OFFSET, &sdp_prog->u84_bitmap);
+	npu_set_u64_bit(D_CVT_SCALE, &sdp_prog->u84_bitmap);
+	npu_set_u64_bit(D_CVT_SHIFT, &sdp_prog->u84_bitmap);
+
+	if (sdp_surface->dst_data.type != DLA_MEM_HW) {
+		sdp_prog->sdp_drp_reg[DRP_D_REG_OP_EN_TRIG] = 1;
+		npu_set_u64_bit(DRP_D_REG_OP_EN_TRIG,
+				&sdp_prog->u84_drp_bitmap);
+	}
+
+exit:
+	return ret;
+}
+
+int dla_sdp_prepare_prog_data(struct win_executor *executor, int rdma, int idx,
+			      u16 op_idx,
+			      union dla_operation_container *operation_desc,
+			      union dla_surface_container *surface_desc)
+{
+	int32_t ret;
+
+	ret = processor_sdp_program(executor, rdma, idx, operation_desc,
+				    surface_desc);
+	if (ret)
+		goto exit;
+
+exit:
+	return ret;
+}
diff --git a/drivers/soc/eswin/ai_driver/npu/sdp.h b/drivers/soc/eswin/ai_driver/npu/sdp.h
new file mode 100644
index 000000000000..ee013c2fb7e3
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/npu/sdp.h
@@ -0,0 +1,98 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#ifndef __SDP_H_
+#define __SDP_H_
+#include "opendla_initial.h"
+#include "post_drp.h"
+#include "reg_index.h"
+
+u32 sdp_bit_to_reg[SDP_REG_MAX] = {
+	[D_DATA_CUBE_WIDTH] = SDP_D_DATA_CUBE_WIDTH_0,
+	[D_DATA_CUBE_HEIGHT] = SDP_D_DATA_CUBE_HEIGHT_0,
+	[D_DATA_CUBE_CHANNEL] = SDP_D_DATA_CUBE_CHANNEL_0,
+	[D_DST_BASE_ADDR_HIGH] = SDP_D_DST_BASE_ADDR_HIGH_0,
+	[D_DST_BASE_ADDR_LOW] = SDP_D_DST_BASE_ADDR_LOW_0,
+	[D_DST_LINE_STRIDE] = SDP_D_DST_LINE_STRIDE_0,
+	[D_DST_SURFACE_STRIDE] = SDP_D_DST_SURFACE_STRIDE_0,
+	[D_DP_BS_CFG] = SDP_D_DP_BS_CFG_0,
+	[D_DP_BS_ALU_CFG] = SDP_D_DP_BS_ALU_CFG_0,
+	[D_DP_BS_ALU_SRC_VALUE] = SDP_D_DP_BS_ALU_SRC_VALUE_0,
+	[D_DP_BS_MUL_SRC_VALUE] = SDP_D_DP_BS_MUL_SRC_VALUE_0,
+	[D_DP_BS_MUL_CFG] = SDP_D_DP_BS_MUL_CFG_0,
+	[D_DP_BN_CFG] = SDP_D_DP_BN_CFG_0,
+	[D_DP_BN_ALU_CFG] = SDP_D_DP_BN_ALU_CFG_0,
+	[D_DP_BN_ALU_SRC_VALUE] = SDP_D_DP_BN_ALU_SRC_VALUE_0,
+	[D_DP_BN_MUL_SRC_VALUE] = SDP_D_DP_BN_MUL_SRC_VALUE_0,
+	[D_DP_BN_MUL_CFG] = SDP_D_DP_BN_MUL_CFG_0,
+	[D_DP_EW_CFG] = SDP_D_DP_EW_CFG_0,
+	[D_DP_EW_ALU_CFG] = SDP_D_DP_EW_ALU_CFG_0,
+	[D_DP_EW_ALU_SRC_VALUE] = SDP_D_DP_EW_ALU_SRC_VALUE_0,
+	[D_DP_EW_ALU_CVT_OFFSET_VALUE] = SDP_D_DP_EW_ALU_CVT_OFFSET_VALUE_0,
+	[D_DP_EW_ALU_CVT_SCALE_VALUE] = SDP_D_DP_EW_ALU_CVT_SCALE_VALUE_0,
+	[D_DP_EW_ALU_CVT_TRUNCATE_VALUE] = SDP_D_DP_EW_ALU_CVT_TRUNCATE_VALUE_0,
+	[D_DP_EW_MUL_CFG] = SDP_D_DP_EW_MUL_CFG_0,
+	[D_DP_EW_MUL_SRC_VALUE] = SDP_D_DP_EW_MUL_SRC_VALUE_0,
+	[D_DP_EW_MUL_CVT_OFFSET_VALUE] = SDP_D_DP_EW_MUL_CVT_OFFSET_VALUE_0,
+	[D_DP_EW_MUL_CVT_SCALE_VALUE] = SDP_D_DP_EW_MUL_CVT_SCALE_VALUE_0,
+	[D_DP_EW_MUL_CVT_TRUNCATE_VALUE] = SDP_D_DP_EW_MUL_CVT_TRUNCATE_VALUE_0,
+	[D_DP_EW_TRUNCATE_VALUE] = SDP_D_DP_EW_TRUNCATE_VALUE_0,
+	[D_FEATURE_MODE_CFG] = SDP_D_FEATURE_MODE_CFG_0,
+	[D_DST_BATCH_STRIDE] = SDP_D_DST_BATCH_STRIDE_0,
+	[D_DATA_FORMAT] = SDP_D_DATA_FORMAT_0,
+	[D_CVT_OFFSET] = SDP_D_CVT_OFFSET_0,
+	[D_CVT_SCALE] = SDP_D_CVT_SCALE_0,
+	[D_CVT_SHIFT] = SDP_D_CVT_SHIFT_0,
+
+	//15 regs for sdp_post_drp
+	[DRP_D_REG_G_STRIDE_SRAM] = POST_DRP_D_REG_G_STRIDE_SRAM,
+	[DRP_D_REG_N_STRIDE_SRAM] = POST_DRP_D_REG_N_STRIDE_SRAM,
+	[DRP_D_REG_H_STRIDE_SRAM] = POST_DRP_D_REG_H_STRIDE_SRAM,
+	[DRP_D_REG_C_STRIDE_SRAM] = POST_DRP_D_REG_C_STRIDE_SRAM,
+	[DRP_D_REG_W_EXT_STRIDE] = POST_DRP_D_REG_H_EXT_STRIDE,
+	[DRP_D_REG_LAYER_PARA_L] = POST_DRP_D_REG_LAYER_PARA_L,
+	[DRP_D_REG_LAYER_PARA_H] = POST_DRP_D_REG_LAYER_PARA_H,
+	[DRP_D_REG_OMAP_PARA_L] = POST_DRP_D_REG_OMAP_PARA_L,
+	[DRP_D_REG_CTRL] = POST_DRP_D_REG_CTRL,
+	[DRP_D_REG_SPLIT] = POST_DRP_D_REG_SPLIT,
+	[DRP_D_REG_PARTIAL_WIDTH] = POST_DRP_D_REG_PARTIAL_WIDTH,
+	[DRP_D_REG_SRAM_LOOP_PARA_H] = POST_DRP_D_REG_SRAM_LOOP_PARA_H,
+	[DRP_D_REG_SRAM_LOOP_PARA_L] = POST_DRP_D_REG_SRAM_LOOP_PARA_L,
+	[DRP_D_REG_BASE_ADDR_H] = POST_DRP_D_REG_BASE_ADDR_H,
+	[DRP_D_REG_BASE_ADDR_L] = POST_DRP_D_REG_BASE_ADDR_L,
+};
+
+u32 sdp_rdma_bit_to_reg[SDP_RDMA_REG_MAX] = {
+	[SDP_RDMA_D_DATA_CUBE_WIDTH] = SDP_RDMA_D_DATA_CUBE_WIDTH_0,
+	[SDP_RDMA_D_DATA_CUBE_HEIGH] = SDP_RDMA_D_DATA_CUBE_HEIGHT_0,
+	[SDP_RDMA_D_DATA_CUBE_CHANNEL] = SDP_RDMA_D_DATA_CUBE_CHANNEL_0,
+	[SDP_RDMA_D_SRC_BASE_ADDR_LOW] = SDP_RDMA_D_SRC_BASE_ADDR_LOW_0,
+	[SDP_RDMA_D_SRC_BASE_ADDR_HIGH] = SDP_RDMA_D_SRC_BASE_ADDR_HIGH_0,
+	[SDP_RDMA_D_SRC_LINE_STRIDE] = SDP_RDMA_D_SRC_LINE_STRIDE_0,
+	[SDP_RDMA_D_SRC_SURFACE_STRIDE] = SDP_RDMA_D_SRC_SURFACE_STRIDE_0,
+	[SDP_RDMA_D_BRDMA_CFG] = SDP_RDMA_D_BRDMA_CFG_0,
+	[SDP_RDMA_D_BS_BASE_ADDR_LOW] = SDP_RDMA_D_BS_BASE_ADDR_LOW_0,
+	[SDP_RDMA_D_BS_BASE_ADDR_HIGH] = SDP_RDMA_D_BS_BASE_ADDR_HIGH_0,
+	[SDP_RDMA_D_BS_LINE_STRIDE] = SDP_RDMA_D_BS_LINE_STRIDE_0,
+	[SDP_RDMA_D_BS_SURFACE_STRIDE] = SDP_RDMA_D_BS_SURFACE_STRIDE_0,
+	[SDP_RDMA_D_BS_BATCH_STRIDE] = SDP_RDMA_D_BS_BATCH_STRIDE_0,
+	[SDP_RDMA_D_BN_BASE_ADDR_LOW] = SDP_RDMA_D_BN_BASE_ADDR_LOW_0,
+	[SDP_RDMA_D_BN_BASE_ADDR_HIGH] = SDP_RDMA_D_BN_BASE_ADDR_HIGH_0,
+	[SDP_RDMA_D_BN_LINE_STRIDE] = SDP_RDMA_D_BN_LINE_STRIDE_0,
+	[SDP_RDMA_D_BN_SURFACE_STRIDE] = SDP_RDMA_D_BN_SURFACE_STRIDE_0,
+	[SDP_RDMA_D_BN_BATCH_STRIDE] = SDP_RDMA_D_BN_BATCH_STRIDE_0,
+	[SDP_RDMA_D_ERDMA_CFG] = SDP_RDMA_D_ERDMA_CFG_0,
+	[SDP_RDMA_D_EW_BASE_ADDR_LOW] = SDP_RDMA_D_EW_BASE_ADDR_LOW_0,
+	[SDP_RDMA_D_EW_BASE_ADDR_HIGH] = SDP_RDMA_D_EW_BASE_ADDR_HIGH_0,
+	[SDP_RDMA_D_EW_LINE_STRIDE] = SDP_RDMA_D_EW_LINE_STRIDE_0,
+	[SDP_RDMA_D_EW_SURFACE_STRIDE] = SDP_RDMA_D_EW_SURFACE_STRIDE_0,
+	[SDP_RDMA_D_EW_BATCH_STRIDE] = SDP_RDMA_D_EW_BATCH_STRIDE_0,
+	[SDP_RDMA_D_FEATURE_MODE_CFG] = SDP_RDMA_D_FEATURE_MODE_CFG_0,
+	[SDP_RDMA_D_SRC_DMA_CFG] = SDP_RDMA_D_SRC_DMA_CFG_0,
+};
+
+#endif
diff --git a/drivers/soc/eswin/ai_driver/npu/user_context.c b/drivers/soc/eswin/ai_driver/npu/user_context.c
new file mode 100644
index 000000000000..1d58f190a7a7
--- /dev/null
+++ b/drivers/soc/eswin/ai_driver/npu/user_context.c
@@ -0,0 +1,1203 @@
+// Copyright © 2023 ESWIN. All rights reserved.
+//
+// Beijing ESWIN Computing Technology Co., Ltd and its affiliated companies ("ESWIN") retain
+// all intellectual property and proprietary rights in and to this software. Except as expressly
+// authorized by ESWIN, no part of the software may be released, copied, distributed, reproduced,
+// modified, adapted, translated, or created derivative work of, in whole or in part.
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <nvdla_linux.h>
+#include <opendla.h>
+#include <linux/cdev.h>
+#include <linux/compat.h>
+#include <linux/poll.h>
+#include "hetero_ioctl.h"
+#include "npu_spram.h"
+#include "dla_driver.h"
+#include "nvdla_lowlevel.h"
+#include "dla_engine.h"
+#include "dla_log.h"
+#include "debug.h"
+#include "internal_interface.h"
+#include "dla_buffer.h"
+#include "hetero_arch.h"
+#include "hetero_host.h"
+extern void handle_perf_switch(struct nvdla_device *ndev, bool enable);
+extern int get_perf_data(struct nvdla_device *ndev);
+
+static int setup_model_task(struct user_model *model)
+{
+	int ret = -1;
+	struct dla_network_desc *network;
+	struct dla_task *task;
+
+	network = model->network;
+	task = &model->task;
+	ret = dla_data_get_vaddr(&model->mem_handles,
+				 network->dependency_graph_index,
+				 (void **)&task->common_desc);
+	if (ret < 0) {
+		dla_error("err:get network vaddr failed!\n");
+		return ret;
+	}
+
+	ret = dla_data_get_vaddr(&model->mem_handles,
+				 network->operation_desc_index,
+				 (void **)&task->op_desc);
+	if (ret < 0) {
+		dla_error("err:get op_desc vaddr failed!\n");
+		return ret;
+	}
+
+	ret = dla_data_get_vaddr(&model->mem_handles,
+				 network->surface_desc_index,
+				 (void **)&task->surface_desc);
+	if (ret < 0) {
+		dla_error("err: surface_desc read failed\n");
+		return ret;
+	}
+	return 0;
+}
+
+static void npu_put_dmabuf_from_model(struct user_model *model)
+{
+	dla_dmabuf_vunmap_for_model(model);
+	dla_detach_dmabuf_from_model(model);
+}
+
+static void npu_put_model_bobj(struct user_model *model)
+{
+	dla_release_bobj(model->model_bobj);
+}
+
+static void npu_model_release(struct khandle *handle)
+{
+	struct user_model *model =
+		container_of(handle, struct user_model, handle);
+	struct user_context *uctx;
+	uctx = model->uctx;
+
+	executor_clearup(model->executor);
+	npu_put_dmabuf_from_model(model);
+	npu_put_model_bobj(model);
+	kfree(model);
+	dla_debug("npu_release_model ok.\n");
+}
+
+static int npu_get_model_bobj(int shm_fd, struct user_model *model)
+{
+	struct nvdla_device *nvdla_dev = model->nvdla_dev;
+	int ret;
+
+	dla_debug("shm_fd=%d\n", shm_fd);
+	model->model_bobj =
+		dla_import_fd_to_device(shm_fd, &nvdla_dev->pdev->dev);
+	if (IS_ERR(model->model_bobj)) {
+		dla_error("err:import shm fd failed!\n");
+		return -EFAULT;
+	}
+
+	model->model_shm = dla_dmabuf_vmap(model->model_bobj);
+	if (model->model_shm == NULL) {
+		dla_error("err:model_bobj vamp failed!\n");
+		ret = -EFAULT;
+		goto err_release_shm;
+	}
+	model->mem_handles.addrlist = &model->model_shm->addrList;
+	return 0;
+
+err_release_shm:
+	dla_release_bobj(model->model_bobj);
+	return ret;
+}
+
+static int npu_get_dmabuf_from_model(struct user_model *model)
+{
+	int ret;
+	ret = dla_import_dmabuf_from_model(model);
+	if (ret < 0) {
+		dla_error("err:import dma buf from model failed!\n");
+		return ret;
+	}
+
+	ret = dla_dmabuf_vmap_for_model(model);
+	if (ret < 0) {
+		dla_error("err:vmap dma buf for model failed!\n");
+		goto err_dmabuf_bobj;
+	}
+	return 0;
+err_dmabuf_bobj:
+	dla_detach_dmabuf_from_model(model);
+	return ret;
+}
+
+static int npu_check_model_version(struct user_model *model)
+{
+	if (model->network->version.major_version !=
+		    NPU_INTERFACE_MAJOR_VERSION ||
+	    model->network->version.minor_version !=
+		    NPU_INTERFACE_MINOR_VERSION ||
+	    model->network->version.subminor_version !=
+		    NPU_INTERFACE_SUBMINOR_VERSION) {
+		dla_error(
+			"error:model's version(%d.%d.%d) not equal npu interface version(%d.%d.%d)\n",
+			model->network->version.major_version,
+			model->network->version.minor_version,
+			model->network->version.subminor_version,
+			NPU_INTERFACE_MAJOR_VERSION,
+			NPU_INTERFACE_MINOR_VERSION,
+			NPU_INTERFACE_SUBMINOR_VERSION);
+		return -EFAULT;
+	}
+	return 0;
+}
+
+static int submit_model(struct nvdla_device *nvdla_dev,
+			struct user_context *uctx, void *arg)
+{
+	int ret;
+	struct user_model *model;
+	struct win_ioctl_args *win_arg = arg;
+	int shm_fd = win_arg->shm_fd;
+	int idx;
+
+	model = kzalloc(sizeof(struct user_model), GFP_KERNEL);
+	if (model == NULL) {
+		dla_error("%s %d nomem\n", __func__, __LINE__);
+		return -ENOMEM;
+	}
+	model->uctx = uctx;
+	model->nvdla_dev = nvdla_dev;
+	model->engine = npu_get_win_engine(nvdla_dev);
+
+	dla_detail("model=0x%px model_size=%ld\n", model,
+		   sizeof(struct user_model));
+
+	ret = npu_get_model_bobj(shm_fd, model);
+	if (ret < 0) {
+		goto err_model_bobj;
+	}
+
+	ret = npu_get_dmabuf_from_model(model);
+	if (ret < 0) {
+		goto err_dmabuf_model;
+	}
+
+	ret = dla_data_get_vaddr(&model->mem_handles,
+				 model->model_shm->kmdNetworkAddrId,
+				 (void **)&model->network);
+
+	if (ret < 0) {
+		dla_error("err:get network vaddr failed!\n");
+		goto err_netowrk;
+	}
+
+	ret = npu_check_model_version(model);
+	if (ret < 0) {
+		goto err_netowrk;
+	}
+
+	ret = setup_model_task(model);
+	if (ret < 0) {
+		dla_error("Failed setup model task\n");
+		goto err_netowrk;
+	}
+
+	ret = create_executor(&model->task, model->network, &model->executor,
+			      &model->mem_handles, model->engine, nvdla_dev,
+			      model);
+	if (ret < 0) {
+		dla_error("Failed to extract executor\n");
+		goto err_netowrk;
+	}
+	prepare_e31_frame_info(model->executor, model);
+
+	ret = init_kernel_handle(&model->handle, npu_model_release,
+				 NPU_MODEL_KHANDLE_MAGIC, &uctx->handle);
+	if (ret < 0) {
+		dla_error("init kernel handle for model ,error.\n");
+		goto err_init_handle;
+	}
+	idx = model->handle.fd;
+	dla_debug("%s, %d, model id=%d, done.\n", __func__, __LINE__, idx);
+	kernel_handle_decref(&model->handle);
+	return idx;
+
+err_init_handle:
+	executor_clearup(model->executor);
+err_netowrk:
+	npu_put_dmabuf_from_model(model);
+err_dmabuf_model:
+	npu_put_model_bobj(model);
+err_model_bobj:
+	kfree(model);
+	return ret;
+}
+
+static struct user_model *npu_get_model_by_id(struct user_context *uctx, int id)
+{
+	struct khandle *m_handle;
+	struct user_model *model;
+
+	spin_lock(&uctx->model_lock);
+	dla_debug("%s, %d, id=%d.\n", __func__, __LINE__, id);
+	m_handle =
+		find_kernel_handle(&uctx->handle, id, NPU_MODEL_KHANDLE_MAGIC);
+	if (m_handle == NULL) {
+		spin_unlock(&uctx->model_lock);
+		dla_error("%s, %d, invalid model id = 0x%x.\n", __func__,
+			  __LINE__, id);
+		return NULL;
+	}
+	model = container_of(m_handle, struct user_model, handle);
+	spin_unlock(&uctx->model_lock);
+	return model;
+}
+static void npu_put_model(struct user_model *model)
+{
+	kernel_handle_decref(&model->handle);
+}
+static int release_model(struct user_context *uctx, void *arg)
+{
+	struct win_ioctl_args *win_arg = arg;
+	struct user_model *model;
+	uint64_t idx = win_arg->model_idx;
+
+	model = npu_get_model_by_id(uctx, idx);
+	if (model == NULL) {
+		dla_error("cannot get model.\n");
+		return -EINVAL;
+	}
+
+	kernel_handle_release_family(&model->handle);
+	npu_put_model(model);
+	dla_debug("%s, %d, done.\n", __func__, __LINE__);
+	return 0;
+}
+
+static DECLARE_WAIT_QUEUE_HEAD(npu_waitq);
+
+int get_event_idx(struct win_executor *executor, int op_index)
+{
+	if (op_index >= executor->network->num_operations) {
+		dla_error("error:bad op_index(%d).\n", op_index);
+		return -EFAULT;
+	}
+	return executor->task->op_desc[op_index].event_op.index;
+}
+
+static int save_event_to_cache(struct user_context *uctx, int16_t event_idx)
+{
+	if (uctx->event_desc.len == MAX_EVENT_SINK_SAVE_NUM) {
+		dla_error("err:no memory for new event.\n");
+		return -1;
+	}
+
+	uctx->event_desc.event_sinks[(uctx->event_desc.produce_idx++) %
+				     MAX_EVENT_SINK_SAVE_NUM] = event_idx;
+	uctx->event_desc.len++;
+	dla_detail("save event cache. after++ len=%d\n", uctx->event_desc.len);
+
+	return 0;
+}
+
+static int get_event_from_cache(struct user_context *uctx)
+{
+	int16_t event_idx;
+
+	dla_detail("get cache len=%d\n", uctx->event_desc.len);
+	if (uctx->event_desc.len == 0) {
+		return -1;
+	}
+
+	event_idx =
+		uctx->event_desc.event_sinks[(uctx->event_desc.consumer_idx++) %
+					     MAX_EVENT_SINK_SAVE_NUM];
+	uctx->event_desc.len--;
+
+	return event_idx;
+}
+
+void handle_event_sink_from_e31(struct win_engine *engine, u32 tiktok,
+				u16 op_index)
+{
+	struct host_frame_desc *f;
+	struct user_model *model;
+	struct win_executor *executor;
+	int16_t event_idx = 0;
+	unsigned long flags;
+
+	if (engine == NULL) {
+		dla_error("err:engine is NULL.\n");
+		return;
+	}
+
+	f = engine->tiktok_frame[tiktok];
+	if (f == NULL) {
+		dla_debug("err:frame is null.\n");
+		return;
+	}
+
+	model = f->model;
+	executor = engine->cur[tiktok];
+	if (executor == NULL) {
+		dla_error("err:executor is NULL.\n");
+		return;
+	}
+	event_idx = get_event_idx(executor, op_index);
+	if (event_idx < 0) {
+		return;
+	}
+	if (!executor) {
+		dla_error("%s, %d, executor is null.\n", __func__, __LINE__);
+		return;
+	}
+	dla_detail("op_index:%d event_idx:%d.\n", op_index, event_idx);
+
+	spin_lock_irqsave(&model->uctx->event_desc.spinlock, flags);
+
+	if (save_event_to_cache(model->uctx, event_idx)) {
+		dla_error("err:save event failed.\n");
+		spin_unlock_irqrestore(&model->uctx->event_desc.spinlock,
+				       flags);
+		return;
+	}
+	spin_unlock_irqrestore(&model->uctx->event_desc.spinlock, flags);
+
+	//wakeup poll
+	wake_up_interruptible(&npu_waitq);
+}
+
+static int get_event_sink_val(struct user_context *uctx,
+			      struct win_ioctl_args *win_arg)
+{
+	unsigned long flags;
+	union event_union event;
+	int i;
+
+	event.event_data = -1ULL;
+	spin_lock_irqsave(&uctx->event_desc.spinlock, flags);
+	for (i = 0; i < sizeof(union event_union) / sizeof(u16); i++) {
+		event.event_sinks[i] = get_event_from_cache(uctx);
+		if (event.event_sinks[i] < 0) {
+			break;
+		}
+	}
+	spin_unlock_irqrestore(&uctx->event_desc.spinlock, flags);
+
+	if (event.event_data == -1ULL) {
+		dla_error("err:bad event val.\n");
+		return -EFAULT;
+	}
+
+	dla_detail("get event sink:0x%llx\n", event.event_data);
+
+	if (copy_to_user((void __user *)(win_arg->data), &event.event_data,
+			 sizeof(u64))) {
+		dla_error("err:bad user data address.\n");
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+static void send_event_source_req_to_hw(struct win_engine *engine, u8 tiktok,
+					u16 op_index)
+{
+	msg_payload_t payload;
+	payload.type = DEC_OP_REF;
+	payload.param = tiktok;
+	payload.param |= IDX_EVENT_SOURCE << 4;
+	payload.lparam = op_index;
+	send_mbx_msg_to_e31(engine, payload);
+}
+
+#define NPU_SET_BIT(bitmap, pos) (bitmap[pos / 8] |= (1 << (pos % 8)))
+int send_event_source_to_e31(struct user_context *ctx, int model_id,
+			     u16 event_val)
+{
+	struct user_model *model;
+	struct win_engine *engine;
+	struct win_executor *executor;
+	u16 op_index = 0;
+	u32 tiktok;
+	struct host_frame_desc *frame;
+
+	model = npu_get_model_by_id(ctx, model_id);
+	if (model == NULL) {
+		dla_error("model id = %d, is error.\n", model_id);
+		return -EINVAL;
+	}
+
+	engine = model->engine;
+	executor = model->executor;
+	tiktok = (engine->tiktok + 1) % NUM_TIKTOK;  // get current tiktok
+
+	if (event_val >= executor->total_event_source_num) {
+		dla_error("err:bad event_val:%d.\n", event_val);
+		return -EFAULT;
+	}
+
+	op_index = executor->event_source_map[event_val];
+	if (op_index == INVALID_OP_IDX) {
+		dla_error("err:bad event_val:%d.\n", event_val);
+		return -EFAULT;
+	}
+
+	frame = engine->tiktok_frame[tiktok];
+	NPU_SET_BIT(frame->is_event_source_done, event_val);
+	dla_detail("%s, %d, event_id=%hu.\n", __func__, __LINE__, event_val);
+
+#if (NPU_DEV_SIM == NPU_REAL_ENV)
+	send_event_source_req_to_hw(engine, tiktok, op_index);
+	// send_event_source_req(tiktok, op_index,
+	// 		(void *)((struct nvdla_device *)engine->nvdla_dev)
+	// 				->e31_mmio_base,
+	// 			engine->host_node);
+#elif (NPU_DEV_SIM == NPU_MCU_HOST)
+	hetero_send_event_source_req(tiktok, op_index);
+#else
+	dla_error("%s, %d, Wrong NPU_DEV_SIM = %d.\n", __func__, __LINE__,
+		  NPU_DEV_SIM);
+	npu_put_model(model);
+	return -1;
+#endif
+
+	npu_put_model(model);
+	return 0;
+}
+
+static int set_dump_info(struct win_executor *executor, void *arg)
+{
+	struct win_ioctl_args *win_arg = arg;
+	kmd_dump_info_t dump_info;
+
+	if (win_arg->dump_enable) {
+		if (copy_from_user(&dump_info,
+				   (void __user *)win_arg->dump_info,
+				   sizeof(kmd_dump_info_t))) {
+			dla_error("%s %d bad user data address\n", __func__,
+				  __LINE__);
+			return -EFAULT;
+		}
+
+		if (copy_from_user(executor->dump_info.op_idx_list,
+				   (void __user *)dump_info.op_idx_list,
+				   sizeof(u16) * dump_info.list_size)) {
+			dla_error("%s %d bad user data address\n", __func__,
+				  __LINE__);
+			return -EFAULT;
+		}
+		executor->dump_info.process_id = dump_info.process_id;
+		executor->dump_info.model_id = dump_info.model_id;
+		executor->dump_info.is_dump_enable = kmd_dump_enable;
+		executor->dump_info.list_size = dump_info.list_size;
+		memset(executor->dump_info.path, 0, DUMP_PATH_LEN);
+		memcpy(executor->dump_info.path, dump_info.path, DUMP_PATH_LEN);
+		set_pause_op_done(executor, &executor->dump_info);
+	} else {
+		if (executor->dump_info.is_dump_enable == kmd_dump_enable) {
+			executor->dump_info.is_dump_enable = kmd_dump_disable;
+			reset_pause_op_done(executor);
+		}
+	}
+
+	return 0;
+}
+static int commit_new_io_tensor(struct user_context *uctx, void *arg)
+{
+	struct user_model *model;
+	struct win_ioctl_args *win_arg = arg;
+	u16 idx = win_arg->model_idx;
+	struct host_frame_desc *f;
+	struct win_executor *executor;
+	int ret;
+	bool result;
+	int new_state;
+
+	new_state = (NPU_RT_MUTX_LOCKED | NPU_RT_MUTX_FRAME_DONE);
+	if (atomic_cmpxchg(&uctx->lock_status, NPU_RT_MUTX_LOCKED, new_state) !=
+	    NPU_RT_MUTX_LOCKED) {
+		dla_error("%s, %d, invalid status\n", __func__, __LINE__);
+		return -EINVAL;
+	}
+
+	model = npu_get_model_by_id(uctx, idx);
+	if (model == NULL) {
+		dla_error("%s, %d, invalid model id = 0x%x.\n", __func__,
+			  __LINE__, idx);
+		ret = -EINVAL;
+		goto err_model_id;
+	}
+
+	ret = create_new_frame(model->executor, &f, model);
+	if (unlikely(ret != win_arg->tensor_size)) {
+		dla_error(
+			"%s %d model %d io_tensor_size %d != win_arg->tensor_size %d\n",
+			__func__, __LINE__, idx, ret, win_arg->tensor_size);
+		npu_put_model(model);
+		goto err_model_id;
+	}
+	kernel_handle_release_family(&f->handle);
+	if (copy_from_user(f->io_tensor_list, (void __user *)win_arg->data,
+			   ret)) {
+		dla_error("%s %d bad user data address\n", __func__, __LINE__);
+		ret = -EFAULT;
+		goto clean_out;
+	}
+	ret = io_tensor_to_io_addr(model->executor, f);
+	if (unlikely(ret < 0)) {
+		goto clean_out;
+	}
+
+	ret = set_dump_info(model->executor, arg);
+	if (ret) {
+		goto clean_out;
+	}
+
+	f->model = model;
+	f->frame_idx = win_arg->frame_idx;
+	f->executor = model->executor;
+	f->state = frame_state_queued;
+	init_waitqueue_head(&f->frame_done);
+
+	executor = (struct win_executor *)f->executor;
+	memcpy(f->io_tensor.tensor_addr, f->io_tensors_addr_list,
+	       (executor->input_num + executor->output_num) * sizeof(u64));
+
+	result = send_new_frame(model->engine, model->executor, f);
+	if (!result) {
+		dla_error("schedule new frame err.\n");
+		ret = result;
+		goto clean_out;
+	}
+	dla_debug("%s, %d, done.\n", __func__, __LINE__);
+	return 0;
+
+clean_out:
+	kernel_handle_decref(&f->handle);
+err_model_id:
+	atomic_set(&uctx->lock_status, NPU_RT_MUTX_LOCKED);
+
+	return ret;
+}
+
+static struct win_engine *get_engine_from_file(struct file *file);
+
+static int runtime_lock_request(struct user_context *uctx, struct file *file,
+				unsigned int cmd)
+{
+	unsigned long last_state;
+	struct win_engine *engine;
+
+	engine = get_engine_from_file(file);
+	if (cmd == ES_NPU_IOCTL_MUTEX_LOCK) {
+		if (down_interruptible(&engine->runtime_sem)) {
+			return -EINTR;
+		}
+
+		BUG_ON(atomic_read(&uctx->lock_status) != NPU_RT_MUTX_IDLE);
+		atomic_set(&uctx->lock_status, NPU_RT_MUTX_LOCKED);
+		dla_debug("%s, %d locked\n", __func__, __LINE__);
+	} else {
+		last_state = atomic_fetch_and(~NPU_RT_MUTX_LOCKED,
+					      &uctx->lock_status);
+		if (last_state == NPU_RT_MUTX_LOCKED) {
+			up(&engine->runtime_sem);
+			dla_debug("%s, %d unlocked\n", __func__, __LINE__);
+		}
+	}
+
+	return 0;
+}
+
+static int get_sram_fd(struct nvdla_device *nvdla_dev,
+		       struct win_ioctl_args *win_arg)
+{
+	int dmabuf_fd;
+	struct dma_buf *sram_dmabuf;
+	sram_info_t sram_info;
+
+	sram_dmabuf = nvdla_dev->spram_bobj->dmabuf;
+	get_dma_buf(sram_dmabuf);
+
+	/* allocate a new dmabuf_fd linked to this dmabuf, the refcount of the dmabuf
+	 * will NOT be increased by dma_buf_fd */
+	dmabuf_fd = dma_buf_fd(sram_dmabuf, sram_dmabuf->file->f_flags);
+	if (dmabuf_fd < 0) {
+		dma_buf_put(sram_dmabuf);  // put the dmabuf back
+		return dmabuf_fd;
+	}
+
+	dla_detail("sram_dmabuf fd:%d size:0x%x.\n", dmabuf_fd,
+		   nvdla_dev->spram_bobj->size);
+	sram_info.fd = dmabuf_fd;
+	sram_info.size = nvdla_dev->spram_bobj->size;
+
+	if (copy_to_user((void __user *)(win_arg->data), &sram_info,
+			 sizeof(sram_info_t))) {
+		dla_error("err:bad user data address.\n");
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+static int handle_perf(struct nvdla_device *nvdla_dev,
+		       struct win_ioctl_args *win_arg)
+{
+	bool enable;
+
+	enable = win_arg->data ? 1 : 0;
+	handle_perf_switch(nvdla_dev, enable);
+
+	return 0;
+}
+
+static int send_perf_data_to_usr(struct nvdla_device *nvdla_dev,
+				 struct win_ioctl_args *win_arg)
+{
+	struct win_engine *engine;
+	int ret;
+
+	engine = (struct win_engine *)nvdla_dev->win_engine;
+
+	ret = get_perf_data(nvdla_dev);
+	if (ret)
+		goto fail;
+
+	if (copy_to_user((void __user *)(win_arg->data), engine->perf_data_buf,
+			 sizeof(npu_e31_perf_t) * MAX_OP_NUM)) {
+		dla_error("err:bad user data address.\n");
+		ret = -EFAULT;
+		goto fail;
+	}
+
+fail:
+
+	return ret;
+}
+
+#define NPU_DEV_NAME "npu"
+
+struct npu_cdev_t {
+	struct class *class;
+	struct device *device;
+	struct cdev dev;
+	dev_t devid;
+	char *name;
+	int major;
+	int minor;
+	struct nvdla_device *nvdla_dev;
+};
+static struct npu_cdev_t npu_cdev[2];
+
+struct npu_cdev_t *get_npu_dev_by_devid(int major, int minor)
+{
+	int i = 0;
+
+	for (i = 0; i < 2; i++) {
+		if ((npu_cdev[i].major == major) &&
+		    (npu_cdev[i].minor == minor)) {
+			return &npu_cdev[i];
+		}
+	}
+
+	return NULL;
+}
+
+static void npu_dma_buf_release(struct khandle *h)
+{
+	struct npu_dma_buf_ex *entry =
+		container_of(h, struct npu_dma_buf_ex, handle);
+	dla_unmapdma_buf_to_dev(&entry->obj);
+	kfree(entry);
+}
+
+int npu_prepare_dma_buf(struct nvdla_device *ndev, struct user_context *uctx,
+			void *arg)
+{
+	int ret;
+	ES_DEV_BUF_S buf;
+	struct npu_dma_buf_ex *entry;
+	struct khandle *khandle;
+
+	if (copy_from_user(&buf, (void *)arg, sizeof(buf))) {
+		dla_error("%s, %d, copy_from_user err.\n", __func__,
+			  __LINE__) return -EINVAL;
+	}
+	mutex_lock(&uctx->dma_lock);
+	entry = xa_load(&uctx->buf_xrray, (int)buf.memFd);
+	if (entry) {
+		khandle = find_kernel_handle(&uctx->handle, entry->handle.fd,
+					     NPU_DMABUF_HANDLE_MAGIC);
+		if (khandle) {
+			dla_debug("find 0x%x entry, handle fd=%d.\n",
+				  (int)entry->buf_info.memFd, entry->handle.fd);
+			kernel_handle_addref(&entry->handle);
+			mutex_unlock(&uctx->dma_lock);
+			return 0;
+		} else {
+			xa_erase(&uctx->buf_xrray, (int)entry->buf_info.memFd);
+		}
+	}
+	entry = kzalloc(sizeof(struct npu_dma_buf_ex), GFP_KERNEL);
+	if (!entry) {
+		dla_error("%s, %d, alloc npu dma buf ex err.\n", __func__,
+			  __LINE__);
+		mutex_unlock(&uctx->dma_lock);
+		return -ENOMEM;
+	}
+	ret = init_kernel_handle(&entry->handle, npu_dma_buf_release,
+				 NPU_DMABUF_HANDLE_MAGIC, &uctx->handle);
+	if (ret) {
+		dla_error(
+			"%s, %d, init kernel handle for npu dma buf ex err.\n",
+			__func__, __LINE__);
+		kfree(entry);
+		mutex_unlock(&uctx->dma_lock);
+		return ret;
+	}
+	xa_store(&uctx->buf_xrray, (int)buf.memFd, entry, GFP_KERNEL);
+	dla_debug("%s, %d, entry handle_fd=%d.\n", __func__, __LINE__,
+		  entry->handle.fd);
+	ret = dla_mapdma_buf_to_dev((int)buf.memFd, &entry->obj,
+				    &ndev->pdev->dev);
+	if (ret) {
+		ret = -ENODEV;
+		goto err;
+	}
+	entry->buf_info = buf;
+	kernel_handle_decref(&entry->handle);
+	mutex_unlock(&uctx->dma_lock);
+	dla_debug("%s, %d, entry fd=0x%x.\n", __func__, __LINE__,
+		  (int)entry->buf_info.memFd);
+	return 0;
+err:
+	mutex_unlock(&uctx->dma_lock);
+	kernel_handle_release_family(&entry->handle);
+	kernel_handle_decref(&entry->handle);
+	return ret;
+}
+
+int npu_unprepare_dma_buf(struct user_context *uctx, void *arg)
+{
+	u32 fd;
+	struct khandle *khandle;
+	struct npu_dma_buf_ex *entry;
+
+	if (copy_from_user(&fd, arg, sizeof(u32))) {
+		dla_error("%s, %d, copy_from_user err.\n", __func__, __LINE__);
+		return -EINVAL;
+	}
+	mutex_lock(&uctx->dma_lock);
+	entry = xa_load(&uctx->buf_xrray, fd);
+	if (!entry) {
+		dla_error("%s, %d, ,cannot find %d dma buf entry.\n", __func__,
+			  __LINE__, fd);
+		mutex_unlock(&uctx->dma_lock);
+		return -EINVAL;
+	}
+	xa_erase(&uctx->buf_xrray, fd);
+	mutex_unlock(&uctx->dma_lock);
+
+	khandle = find_kernel_handle(&uctx->handle, entry->handle.fd,
+				     NPU_DMABUF_HANDLE_MAGIC);
+	if (!khandle) {
+		dla_error("%s, %d, cannot find dmabuf=%d handle.\n", __func__,
+			  __LINE__, (int)entry->buf_info.memFd);
+		return 0;
+	}
+	kernel_handle_release_family(khandle);
+	kernel_handle_decref(khandle);
+	return 0;
+}
+
+static long npu_dev_ioctl(struct file *file, unsigned int cmd,
+			  unsigned long arg)
+{
+	int ret = 0;
+	int major = 0;
+	int minor = 0;
+	struct npu_cdev_t *npu_cdev;
+	struct user_context *uctx;
+	struct win_ioctl_args win_arg;
+	uint64_t data = 0;
+
+	major = imajor(file->f_inode);
+	minor = iminor(file->f_inode);
+
+	npu_cdev = get_npu_dev_by_devid(major, minor);
+	if (npu_cdev == NULL) {
+		dla_error("%s %d nodev\n", __func__, __LINE__);
+		return -EFAULT;
+	}
+	uctx = file->private_data;
+	if (uctx == NULL) {
+		dla_error("error:uctx is NULL!\n");
+		return -EFAULT;
+	}
+
+	if (copy_from_user(&win_arg, (void *)arg,
+			   sizeof(struct win_ioctl_args))) {
+		dla_error("bad user data address\n");
+		return -EFAULT;
+	}
+
+	switch (cmd) {
+	case ES_NPU_IOCTL_MODEL_LOAD:
+		ret = submit_model(npu_cdev->nvdla_dev, uctx, &win_arg);
+		data = ret;
+		if (copy_to_user((void __user *)(win_arg.pret), &data, 8)) {
+			dla_error("bad user data address\n");
+			return -EFAULT;
+		}
+
+		break;
+	case ES_NPU_IOCTL_MODEL_UNLOAD:
+		ret = release_model(uctx, &win_arg);
+		break;
+	case ES_NPU_IOCTL_SET_EVENT:
+		dla_debug("model_idx=%d event_source_val=%d\n",
+			  win_arg.model_idx, win_arg.event_source_val);
+		ret = send_event_source_to_e31(uctx, win_arg.model_idx,
+					       win_arg.event_source_val);
+		break;
+	case ES_NPU_IOCTL_GET_EVENT:
+		ret = get_event_sink_val(uctx, &win_arg);
+		break;
+	case ES_NPU_IOCTL_TASK_SUBMIT:
+		ret = commit_new_io_tensor(uctx, &win_arg);
+		break;
+	case ES_NPU_IOCTL_MUTEX_LOCK:
+	case ES_NPU_IOCTL_MUTEX_UNLOCK:
+		ret = runtime_lock_request(uctx, file, cmd);
+		break;
+	case ES_NPU_IOCTL_HETERO_CMD:
+		ret = npu_hetero_cmd(npu_cdev->nvdla_dev, &win_arg);
+		break;
+	case ES_NPU_IOCTL_GET_SRAM_FD:
+		ret = get_sram_fd(npu_cdev->nvdla_dev, &win_arg);
+		break;
+	case ES_NPU_IOCTL_HANDLE_PERF:
+		ret = handle_perf(npu_cdev->nvdla_dev, &win_arg);
+		break;
+	case ES_NPU_IOCTL_GET_PERF_DATA:
+		ret = send_perf_data_to_usr(npu_cdev->nvdla_dev, &win_arg);
+		break;
+	case ES_NPU_IOCTL_PREPARE_DMA_BUF:
+		ret = npu_prepare_dma_buf(npu_cdev->nvdla_dev, uctx,
+					  (void *)arg);
+		break;
+	case ES_NPU_IOCTL_UNPREPARE_DMA_BUF:
+		ret = npu_unprepare_dma_buf(uctx, (void *)arg);
+		break;
+	default:
+		dla_error("err:ioctl cmd err!cmd=0x%x\n", cmd);
+		ret = -EFAULT;
+		break;
+	}
+	if (ret < 0) {
+		dla_error("cmd 0x%x fail, ret:%d\n", cmd, ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static void npu_uctx_release(struct khandle *h)
+{
+	struct user_context *uctx =
+		container_of(h, struct user_context, handle);
+	struct nvdla_device *ndev;
+
+	if (uctx == NULL) {
+		return;
+	}
+	ndev = uctx->ndev;
+	dla_debug("npu_uctx_release ok. pid=%d, uctx=0x%px.\n", current->pid,
+		  uctx);
+	kfree(uctx);
+	module_put(THIS_MODULE);
+	npu_pm_put(ndev);
+}
+
+int npu_dev_open(struct inode *inode, struct file *file)
+{
+	struct user_context *uctx;
+	struct npu_cdev_t *npu_cdev;
+	struct nvdla_device *ndev;
+	struct win_engine *engine;
+	int major = 0;
+	int minor = 0;
+	int ret;
+	unsigned long flags;
+
+	dla_debug("%s, %d, current pid=%d.\n\n", __func__, __LINE__,
+		  current->pid);
+
+	major = imajor(file->f_inode);
+	minor = iminor(file->f_inode);
+
+	npu_cdev = get_npu_dev_by_devid(major, minor);
+	if (npu_cdev == NULL) {
+		dla_error("cannot find npu device. \n");
+		return -ENODEV;
+	}
+
+	ndev = npu_cdev->nvdla_dev;
+	engine = ndev->win_engine;
+	ret = npu_pm_get(ndev);
+	if (ret < 0) {
+		dla_error("%s, %d, npu_pm_get failed, ret = %d.\n", __func__, __LINE__, ret);
+		return ret;
+	}
+	spin_lock_irqsave(&engine->executor_lock, flags);
+	if (engine->engine_is_alive == false) {
+		dla_error("npu engine is not ok, please restart.\n");
+		npu_pm_put(ndev);
+		spin_unlock_irqrestore(&engine->executor_lock, flags);
+		return -ENODEV;
+	}
+	spin_unlock_irqrestore(&engine->executor_lock, flags);
+
+	if (!try_module_get(THIS_MODULE)) {
+		dla_error("%s, %d, cannot get module.\n", __func__, __LINE__);
+		npu_pm_put(ndev);
+		return -ENODEV;
+	}
+
+	uctx = kzalloc(sizeof(struct user_context), GFP_KERNEL);
+	if (uctx == NULL) {
+		module_put(THIS_MODULE);
+		npu_pm_put(ndev);
+		dla_error("%s %d nomem\n", __func__, __LINE__);
+		return -ENOMEM;
+	}
+	spin_lock_init(&uctx->model_lock);
+	ret = init_kernel_handle(&uctx->handle, npu_uctx_release,
+				 NPU_UCTX_KHANDLE_MAGIC, NULL);
+	if (ret != 0) {
+		dla_error("init kernel handle for user context error.\n");
+		module_put(THIS_MODULE);
+		npu_pm_put(ndev);
+		kfree(uctx);
+		return ret;
+	}
+	atomic_set(&uctx->lock_status, NPU_RT_MUTX_IDLE);
+	spin_lock_init(&uctx->event_desc.spinlock);
+	mutex_init(&uctx->dma_lock);
+	xa_init(&uctx->buf_xrray);
+	uctx->uctx_is_alive = true;
+	file->private_data = uctx;
+	uctx->ndev = ndev;
+	kernel_handle_decref(&uctx->handle);
+	dla_debug("npu_dev_open success!\n");
+	return 0;
+}
+
+static struct win_engine *get_engine_from_file(struct file *file)
+{
+	int major = 0;
+	int minor = 0;
+	struct npu_cdev_t *npu_cdev;
+	struct win_engine *engine;
+
+	major = imajor(file->f_inode);
+	minor = iminor(file->f_inode);
+
+	npu_cdev = get_npu_dev_by_devid(major, minor);
+	if (npu_cdev == NULL) {
+		dla_error("%s %d nodev\n", __func__, __LINE__);
+		return NULL;
+	}
+
+	engine = npu_get_win_engine(npu_cdev->nvdla_dev);
+	return engine;
+}
+
+#define NPU_CHECK_BIT(bitmap, pos) ((bitmap[pos / 8]) & (1 << (pos % 8)))
+int npu_dev_release(struct inode *inode, struct file *file)
+{
+	struct user_context *uctx = file->private_data;
+	struct win_engine *engine;
+	struct host_frame_desc *frame;
+	struct user_model *model;
+	struct win_executor *executor;
+	unsigned long last_state;
+	int model_id;
+	u32 tiktok = 0;
+	u16 eid = 0;
+	engine = get_engine_from_file(file);
+	uctx->uctx_is_alive = false;
+
+	for (tiktok = 0; tiktok < NUM_TIKTOK; tiktok++) {
+		frame = engine->tiktok_frame[tiktok];
+		if (frame) {
+			model = frame->model;
+			model_id = model->handle.fd;
+			if (model && model_id != -1 && uctx == model->uctx) {
+				executor = model->executor;
+				for (eid = 0;
+				     eid < executor->total_event_source_num;
+				     eid++) {
+					if (!NPU_CHECK_BIT(
+						    frame->is_event_source_done,
+						    eid)) {
+						dla_debug(
+							"%s %d addr of is_event_source_done=0x%px, src_done_val=0x%x\n",
+							__func__, __LINE__,
+							frame->is_event_source_done,
+							*(u32 *)frame
+								 ->is_event_source_done);
+						send_event_source_to_e31(
+							uctx, model_id, eid);
+						dla_info("%s %d: eid=%hu\n",
+							 __FUNCTION__, __LINE__,
+							 eid);
+					}
+				}
+			}
+		}
+	}
+
+	last_state = atomic_fetch_and(~NPU_RT_MUTX_LOCKED, &uctx->lock_status);
+	if (last_state == NPU_RT_MUTX_LOCKED) {
+		up(&engine->runtime_sem);
+		dla_debug("%s, %d unlocked\n", __func__, __LINE__);
+	}
+
+	kernel_handle_release_family(&uctx->handle);
+
+	file->private_data = NULL;
+	dla_debug("%s, %d, Done, pid=%d.\n", __func__, __LINE__, current->pid);
+	return 0;
+}
+
+static ssize_t npu_dev_write(struct file *file, const char __user *buf,
+			     size_t size, loff_t *ppos)
+{
+	return 0;
+}
+static ssize_t npu_dev_read(struct file *file, char __user *buf, size_t size,
+			    loff_t *ppos)
+{
+	return 0;
+}
+
+#ifdef CONFIG_COMPAT
+static long npu_dev_ioctl_compat(struct file *flip, unsigned int cmd,
+				 unsigned long arg)
+{
+	return npu_dev_ioctl(flip, cmd, (unsigned long)compat_ptr(arg));
+}
+#endif
+
+static __poll_t npu_dev_poll(struct file *file, poll_table *wait)
+{
+	__poll_t mask = 0;
+	struct user_context *uctx = file->private_data;
+	poll_wait(file, &npu_waitq, wait);
+
+	if (uctx->event_desc.len > 0) {
+		dla_detail("event sinks len:%d\n", uctx->event_desc.len);
+		mask = EPOLLIN | EPOLLRDNORM;
+	}
+
+	return mask;
+}
+
+static const struct file_operations npu_cdev_fops = {
+	.owner = THIS_MODULE,
+	.open = npu_dev_open,
+	.release = npu_dev_release,
+	.read = npu_dev_read,
+	.write = npu_dev_write,
+	.unlocked_ioctl = npu_dev_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl = npu_dev_ioctl_compat,
+#endif
+	.poll = npu_dev_poll,
+};
+
+int create_npu_dev(int node_id, struct nvdla_device *nvdla_dev)
+{
+	int ret = 0;
+	char *name;
+
+	npu_cdev[node_id].name = kzalloc(16, GFP_KERNEL);
+	if (!npu_cdev[node_id].name) {
+		dla_error("alloc memory for %d node err.\n", node_id);
+		return -ENOMEM;
+	}
+	name = npu_cdev[node_id].name;
+	snprintf(name, 16, "%s%d", NPU_DEV_NAME, node_id);
+
+	if (npu_cdev[node_id].major) {
+		npu_cdev[node_id].devid = MKDEV(npu_cdev[node_id].major, 0);
+		ret = register_chrdev_region(npu_cdev[node_id].devid, 1, name);
+	} else {
+		ret = alloc_chrdev_region(&npu_cdev[node_id].devid, 0, 1, name);
+		npu_cdev[node_id].major = MAJOR(npu_cdev[node_id].devid);
+		npu_cdev[node_id].minor = MINOR(npu_cdev[node_id].devid);
+
+		dla_debug("major=%d, minor=%d!\n", npu_cdev[node_id].major,
+			  npu_cdev[node_id].minor);
+	}
+
+	if (ret < 0) {
+		dla_error("alloc_chrdev_region failed for npu%d\n", node_id);
+		kfree(name);
+		npu_cdev[node_id].name = NULL;
+		return ret;
+	}
+
+	npu_cdev[node_id].dev.owner = THIS_MODULE;
+	cdev_init(&npu_cdev[node_id].dev, &npu_cdev_fops);
+	cdev_add(&npu_cdev[node_id].dev, npu_cdev[node_id].devid, 1);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 6, 0))
+	npu_cdev[node_id].class = class_create(name);
+#else
+	npu_cdev[node_id].class = class_create(THIS_MODULE, name);
+#endif
+	if (IS_ERR(npu_cdev[node_id].class)) {
+		dla_error("class_create failed for npu%d\n", node_id);
+		goto class_err;
+	}
+
+	npu_cdev[node_id].device = device_create(npu_cdev[node_id].class, NULL,
+						 npu_cdev[node_id].devid, NULL,
+						 name);
+	if (IS_ERR(npu_cdev[node_id].device)) {
+		dla_error("device_create failed for npu%d\n", node_id);
+		goto device_err;
+	}
+
+	npu_cdev[node_id].nvdla_dev = nvdla_dev;
+
+	dla_debug("dev %s create ok!\n", name);
+
+	return 0;
+device_err:
+	class_destroy(npu_cdev[node_id].class);
+class_err:
+	unregister_chrdev_region(npu_cdev[node_id].devid, 1);
+	kfree(name);
+	npu_cdev[node_id].name = NULL;
+
+	return -1;
+}
+
+void destory_npu_dev(int node_id)
+{
+	unregister_chrdev_region(npu_cdev[node_id].devid, 1);
+	cdev_del(&npu_cdev[node_id].dev);
+	device_destroy(npu_cdev[node_id].class, npu_cdev[node_id].devid);
+	class_destroy(npu_cdev[node_id].class);
+	if (npu_cdev[node_id].name) {
+		kfree(npu_cdev[node_id].name);
+		npu_cdev[node_id].name = NULL;
+	}
+	dla_debug("destory_npu_dev!\n");
+}
-- 
2.47.0

